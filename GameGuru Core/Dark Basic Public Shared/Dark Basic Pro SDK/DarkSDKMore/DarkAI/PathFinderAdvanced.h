#ifndef H_PATHFINDER
#define H_PATHFINDER

class Polygon2D;
class Path;
class Container;

//#include "DBPro Functions.h"

#include <vector>
#include <cctype>
#include <math.h>
#include <windows.h>
#include "Grid.h"

#define DARKAI_WAYPOINT_PEEK_LEFT	0x01
#define DARKAI_WAYPOINT_PEEK_RIGHT	0x02
#define DARKAI_WAYPOINT_BRIDGE		0x04

#define DARKAI_COVER_TAKEN			0x02

struct Blocker
{
	int id;
	float x,z,radius;
	Blocker *pNextBlocker;

	Blocker() { id = 0; x = 0; z = 0; radius = 0; pNextBlocker = NULL; }
	~Blocker() {}
};

class EdgeData
{
public:

	float fX, fY, fX2, fY2, fNormVX, fNormVY;
	bool bHalfHeight;
	EdgeData *pNextEdge;

	EdgeData( );
	~EdgeData( );

	bool Intersects ( float fSX, float fSY, float fEX, float fEY, int iHeight );
};

class CollisionNode
{
public:

	CollisionNode *left, *right;
	float fMinX, fMinY;
	float fMaxX, fMaxY;

	CollisionNode( int iNumEdges, int iEdgesPerNode, EdgeData *pEdgeList );
	~CollisionNode( );

	bool Intersects ( float fSX, float fSY, float fEX, float fEY, int iHeight );
	void CountEdges ( int *pCount );
};

class CollisionBox
{
public:

	CollisionBox *left, *right;
	float fMinX, fMinY;
	float fMaxX, fMaxY;

	CollisionBox( int iNumEdges, int iEdgesPerNode, EdgeData *pEdgeList );
	~CollisionBox( );

	int InPolygon ( float fX, float fY );
	void FindClosestOutsidePoint ( float *pX, float *pY );
	float FindClosestPolygon ( float fSX, float fSY, float fEX, float fEY );
};

struct sCoverPoint
{
	static int iLastID;
	int iID;
	float fX, fY;
	float fAngle;
	int iManualCoverPoint;
	float fDirX, fDirY;
	float fLeapDist;
	char bFlags;
	int iContainer;
	sCoverPoint *pNextPoint;

	sCoverPoint() { iID = 0; bFlags = 0; pNextPoint = 0; fLeapDist = -1; iManualCoverPoint = 0; }
	~sCoverPoint() {}

	void InUse() { bFlags |= DARKAI_COVER_TAKEN; }
	void Unused() { bFlags &= ~DARKAI_COVER_TAKEN; }
	bool IsInUse() { return (bFlags &= DARKAI_COVER_TAKEN) != 0; }
	float GetLeapDistance() { return fLeapDist; }
};

//contains all processes relating to working out the path
//can be replaced as long as CalculatePath() exists
class PathFinderAdvanced
{
  private:

	static HANDLE hPathFindingMutex;
	HANDLE hBlockerMutex;
    
    struct sColResults
    {
        float fDist;
        int iSide;
        int iPoly;
        int iEdge;
        
        //used for sorting
        bool operator<(sColResults c) const {
            return fDist < c.fDist;
        }
    };
    
    //data calculated locally from the polygon list
    //also puts everything into floating point form
    struct sVertexData
    {
        //position and normalised vector to next vertex
        float fX, fY, fNormVX, fNormVY, fLength;
    };
    
    struct sPolygonData
    {
		std::vector<sVertexData> sVertexData_list;

		bool bHalfHeight;
		bool bBlocksPath;
		bool bBlocksView;
		int id;
		bool bTerrain;
		bool bDiveOver;

		sPolygonData ( ) { bHalfHeight = false; bBlocksPath = true; bBlocksView = true; id = 0; bTerrain = false; bDiveOver = false; }
		~sPolygonData ( ) { }
    };
    
    std::vector<sPolygonData> sPolygonData_list;
    std::vector<sPolygonData> sPolygonOrigData_list;
	std::vector<sPolygonData> sViewBlockingData_list;

	CollisionNode *pOptimizedCol, *pOptimizedOrigCol;
	CollisionNode* pOptimizedColGrid[128][128];

	float fCurrRadius;
    
public:

    struct sWaypoint;

	struct sDoor
	{
		int id;
		sDoor *pNextDoor;
	};

	struct sDoorInfo
	{
		int id;
		float x1, y1;
		float x2, y2;
		sDoorInfo *pNextDoor;
	};
    
    struct sWaypointEdge
    {
        sWaypoint *pOtherWP;
        float fCost;
		sDoor *pDoors;

		sWaypointEdge *pNextEdge;

		sWaypointEdge() { pDoors = 0; pOtherWP = 0; fCost = 0; }
		~sWaypointEdge() 
		{
			sDoor *pDoor;
			while ( pDoors )
			{
				pDoor = pDoors;
				pDoors = pDoors->pNextDoor;
				delete pDoor;
			}
		}
    };

    struct sWaypoint
    {
        float fX;
        float fY;
        float fDistF;
        float fDistG;
        float fDistH;
		float fWPCost;
		bool bHalfHeight;
		bool bActive;
		int iNumEdges;

		float fVX, fVY; // direction pointing towards the obstacle this waypoint was generated by
		float fCAngle; // cos of the angle of the corner this waypoint represents
		bool bCanPeek; // can this waypoint be used for peeking around corners
		char bFlags;

		//float fCornerAngY;
		//int iObjID;

		Container* pContainer;
		bool bIsBridge;
        
        int iVisited;
        sWaypoint *pParent;
        
        sWaypointEdge *pEdgeList;
		sWaypoint *pNextWaypoint;

		void AddEdge ( sWaypoint *pWaypoint, float fCost );
		void RemoveLastEdge ( );
		void RemoveEdge ( sWaypoint *pWaypoint );
		void ClearEdges ( );
		
		sWaypoint ( ) { pEdgeList = 0; iNumEdges = 0; fWPCost = 0; pContainer = 0; bIsBridge = false; bCanPeek = false; fVX = 0; fVY = 0; fCAngle = 0; bFlags = 0; }
		~sWaypoint ( );

		bool operator ==(sWaypoint w) const {
			return ( fabs( fX - w.fX ) < 0.000001 ) && ( fabs( fY - w.fY ) < 0.000001 );
		}
    };
    
	sCoverPoint *pCoverPointList;

private:

    struct sWaypointInfo
    {
        sWaypoint *pThisWP;
        
        float fCost;
        
        bool operator<(sWaypointInfo w) const {
            return fCost > w.fCost;
        }
    };
    
public:
    sWaypoint *pWaypointList;
    std::vector<sWaypointInfo> sWaypointOpen_list;
	sDoorInfo *pAllDoors;
	int iNumWaypoints;

private:
	int iCoverPointObject;
	int iWaypointObject;
	int iWaypointEdgeObject;
	int iPolygonBoundsObject;
	int iHHPolygonBoundsObject;		//HalfHeight
	int iVBPolygonBoundsObject;		//View Blocking
	int iGridObject;
	int iGridObject2;
	float fFlashingTimer;

	Container *pOwner;

	void AddWaypoint ( sWaypoint *pWaypoint );
	void RemoveLastWaypoint ( );

	float fGridRadius;
	Grid cGrid;
	Grid cUndesirableGrid;

	bool bShowAvoidanceGrid;
	float fAvoidanceGridDebugTimer;
	float fAvoidanceGridHeight;

	Blocker *pBlockerList;
  
  public:  

    static int iUndesirableThreshold;
    
    PathFinderAdvanced ( Container *pContainer );
    ~PathFinderAdvanced ( );

	void Update( float fTimeDelta );

	const Blocker* GetBlockerList( );

	sCoverPoint* GetCoverPoint( int iID );

	void AddCoverPoint( float fx , float fz , float angle );
	void SetGridRadius( float radius );
	int GridFtoI( float value );
	float GridItoF( int value );
	bool GridSetEntityPosition( float x, float z, int id );
	void GridClearEntityPosition( float x, float z );
	int GridGetPosition( float x, float z );
	int GridGetUndesirablePosition( float x, float z );
	void GridSetUndesirablePosition( float x, float z );
	void GridClearUndesirablePosition( float x, float z );
	//bool GridReservePosition( float x, float z );
	//bool GridUnReservePosition( float x, float z );
	int GridCheckDirection( int id, float x, float z, float dirX, float dirZ, float destX, float destZ, int ignore, int &iReserved );
	bool GridCheckDestination( float *x, float *z );
	void GridMoveEntity( float x, float z, float newX, float newZ );

	void AddDynamicBlocker( int id, float x, float z, float radius );
	void RemoveDynamicBlocker( int id );

	void SaveObstacleData( char *pFilename );
	void LoadObstacleData( char *pFilename );
	int CountObstacles( );
	int CountEdges( );

	PathFinderAdvanced::sWaypoint* AddWaypoint ( float x, float z, bool bHalf, bool bIsBridge = false, float vx = 0, float vy = 0, float ca = 0, bool canpeek = false, char flags = 0 );
	int CountWaypoints ( );
	void RemoveWaypoint ( int iIndex );
	void MakeMemblockFromWaypoints ( int iMemblockID );
	void MakeWaypointsFromMemblock ( int iMemblockID );
	void UpdateVisibility ( float fLimit );
	void UpdateSingleVisibility ( PathFinderAdvanced::sWaypoint *pNewWP, float fLimit, bool duplex = true );
	void ClearWaypoints ( );
	void ClearCoverPoints ( );
	void SetWaypointCost ( int iIndex, float fCost );
	sWaypoint* GetWaypoint ( int iIndex );
	int GetWaypointIndex ( sWaypoint* pWaypoint );
	void RemoveEndWaypoint( sWaypoint *pWaypoint );

	void RemoveAllEdges ( );
	
	//int GetWaypointIndex ( std::vector < sWaypoint >::iterator wIter );
	//int GetClosestWaypoint ( float fSX, float fSY );
	sWaypoint* GetClosestWaypoint ( float fSX, float fSY );
	//void GetConnectedPoints ( sWaypoint* pWaypoint, Path *pPoints, int *pIndices );
	void GetConnectedPoints ( float fSX, float fSY, Path *pPoints );
	void GetClosestWaypoints ( float fSX, float fSY, float fRadius, Path *pPoints, bool halfheight = false );
	//float GetWaypointX ( int iIndex );
	//float GetWaypointY ( int iIndex );
    
    //pass the list of polygons to check so the pathfinder can do some pre-processing
    //allows multiple paths to be computed without having to repeat this step.
    //also set the collision radius here
    //void SetPolygons ( std::vector<Polygon2D>* pPolygon_list );

	sPolygonData ConvertPolygon ( Polygon2D *const pPolygon, bool* bSucceed );

	void AddPolygon ( Polygon2D *const pPolygon );
	void AddPolygon ( Polygon2D *const pPolygon, bool bUpdate );
	void AddViewBlocker ( Polygon2D *const pPolygon );
	void RemovePolygon ( int id );

	void AddDoor ( int id, float x1, float y1, float x2, float y2 );
	void RemoveDoor( int id );
	bool BlockedByDoor( float x1, float y1, float x2, float y2 );

	void SetRadius ( float fRadius );

	void OptimizeObstacles( );
	void CompleteObstacles( );
    
    void ClearPolygons ( );
    
    void BuildWaypoints( );
    
    //first 4 values define a vector to check against, last 4 define the ray vector
    //returns the relative distance along the ray to first collision
    // -> 0 = start of ray, 1 = end of ray
    //returns -1 if no collision occurs
    float CheckRay ( float fVx, float fVy, float fDiffVx, float fDiffVy,    //polygon vector
                     float fPx, float fPy, float fDiffPx, float fDiffPy );  //path ray

	float CheckInfRay ( float fVx, float fVy, float fDiffVx, float fDiffVy,    //polygon vector
						float fPx, float fPy, float fDiffPx, float fDiffPy,    //path ray
						int *iSide );
                     
    //same as above excpet also returns the direction of the incoming ray 
    //relative to the polygon vector (> 1 is going in, < 1 is going out)
    float CheckSidedRay ( float fVx, float fVy, float fDiffVx, float fDiffVy,    //polygon vector
                          float fPx, float fPy, float fDiffPx, float fDiffPy,    //path ray
                          int *iSide );
    
    //checks all polygons against the ray
    //simply returns true if something hit, false otherwise
	//iHeight = 0 - low hieght only, = 1 - high height only, = 2 - all heights
    bool QuickPolygonsCheck ( float fSX, float fSY, float fEX, float fEY, int iHeight );

	bool QuickPolygonsCheckVisible ( float fSX, float fSY, float fEX, float fEY, int iHeight );

	float FindClosestPolygon ( float fSX, float fSY, float fEX, float fEY );

	void FindClosestOutsidePoint ( float *pX, float *pY ); 
	
    //returns the number of times the ray crosses an edge
    int CountCrossings ( float fSX, float fSY, float fEX, float fEY );
	
	//returns non zero if start and end points are on different sides (inside, outside)
	int CountSidedness ( float fSX, float fSY, float fEX, float fEY );
	
	//returns the number of polygons the point is inside
	int InPolygons ( float fSX, float fSY );

	void ActivateAllWaypoints ( );
	void DeActivateWaypoint ( sWaypoint *pWaypoint );
    
    //uses A* on the waypoints to find the shortest path
    bool ShortestPath ( float fEX, float fEY, Path* pBuildPath, int iDestinationContainer );
    
    //The main function. Polygon list must have been passed sometime before  
    //paths pFinalPath must be defined, assumed clear.
    //if either path is not found, it will be cleared.
    void CalculatePath ( float fSX, float fSY, float fEX, float fEY,    //points to check between
                         Path* pFinalPath,								//place to store the final path
						 float fMaxEdgeCost,
						 int iDestinationContainer );

	void ClearDistanceData( );
	
	//use the waypoint network to return all points that can be seen from given point
	//can use this to search the local area
	void SearchPoints ( float fSX, float fSY, Path *pPoints, int iHeight );

	void SearchPeekingPoints ( float fSX, float fSY, float fTX, float fTY, Path *pPoints, Path *pDirections, Path *pPeekPoints );

	void SearchCoverPoints ( float fSX, float fSY, float fTX, float fTY, Path *pPoints );
    
	void DebugDrawCoverPoints ( float fHeight );
	void DebugHideCoverPoints ( );
    void DebugDrawWaypoints ( float fHeight );
	void DebugHideWaypoints ( );

	void DebugDrawWaypointEdges ( float fHeight );
	void DebugHideWaypointEdges ( );

    void DebugDrawPolygonBounds ( float fHeight );
	void DebugHidePolygonBounds ( );
	void DebugUpdatePolygonColour ( float fTimeDelta );

	void DebugDrawAvoidanceGrid( float fHeight );
	void DebugHideAvoidanceGrid( );
	void DebugUpdateAvoidanceGrid( float fTimeDelta );
};

#endif
