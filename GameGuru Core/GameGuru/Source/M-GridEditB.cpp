//
// VS2017 (32bit) having trouble with large GridEdit.cpp file, so split into two
//

// Includes 
#include "stdafx.h"
#include "gameguru.h"
#include "M-WelcomeSystem.h"
#include "M-Widget.h"
#include "GGVR.h"
#include "M-GridEditB.h"

#include <algorithm>
#include <string>
#include <time.h>
#include <wininet.h>
#include <mmsystem.h>
#include "ShlObj.h"
#include "sha1.h"
#include "sha2.h"
#include "miniz.h"
#include "Nlohmann JSON/json.hpp"

//#define PETESTING
#ifdef PETESTING
#include "..\Imgui\imgui_demo.cpp"
#endif

// Globals
#ifndef PRODUCTCLASSIC
extern int iGenralWindowsFlags ;
extern bool bBoostIconColors;
#endif

// Namespaces
#ifdef WICKEDENGINE
#include "shellapi.h"
#include ".\\..\..\\Guru-WickedMAX\\GPUParticles.h"
using namespace GPUParticles;
#include "GGTerrain/GGTerrain.h"
using namespace GGTerrain;
#include "GGTerrain/GGTrees.h"
using namespace GGTrees;
#include "GGTerrain/GGGrass.h"
using namespace GGGrass;
#endif

#ifdef RPG_GAMES
void ProcessRPGSetupWindow(void);
bool IsRPGActive(void);
bool save_rpg_system(char *name);
bool load_rpg_system(char *name);
void init_rpg_system(void);
extern bool bRPGSetup_Window;
#endif

#ifdef STORYBOARD
	#include "..\..\GameGuru\Imgui\imnodes.h"
	#include "..\..\GameGuru\Imgui\imnodes_internal.h"
	#include "..\..\GameGuru\Imgui\imgui_impl_win32.h"
	#include "..\..\GameGuru\Imgui\imgui_gg_extras.h"
	extern ImNodesContext* GImNodes;
#endif

// Externs
extern int grideleprof_uniqui_id;
#define MAXTEXTINPUT 1024
extern float g_Storyboard_header_height;
extern char cTmpInput[MAXTEXTINPUT + 1];
extern int g_Storyboard_First_Level_Node;
extern int g_Storyboard_Current_Level;
extern char g_Storyboard_First_fpm[256];
extern char g_Storyboard_Current_fpm[256];
extern char g_Storyboard_Current_lua[256];
extern std::vector<std::string> projectbank_list;
//extern std::vector<bool> projectbank_list_exist; 
extern std::vector<std::string> projectbank_image;
extern std::vector<int> projectbank_imageid;
extern StoryboardStruct Storyboard;
extern StoryboardStruct checkproject;
StoryboardStruct tempProjectData;
extern std::vector< std::pair<ImFont*, std::string>> StoryboardFonts;
extern bool bScreen_Editor_Window;
extern int iScreen_Editor_Node;
extern int iStoryboardExecuteKey;
extern bool bTriggerSaveAs;
extern bool bTriggerOpenProject;
extern int iDelayTriggerOpenProject;
extern bool bTriggerSaveAsAfterNewLevel;
extern char SaveProjectAsName[256];
extern char SaveProjectAsError[256];
extern bool bTriggerWhatsNewInStoryboard;
extern bool bAddWhatNewToMenu;
extern bool bOpenProjectsFromWelcome;
extern cstr TriggerLoadGameProject;
extern bool bStoryboardFirstRunSetInitPos;
extern bool bStoryboardInitNodes;
extern bool bJustRederedScreenEditor;
extern bool g_bUpdateAppAvailable;
extern bool g_bAdjustPlaneXZUsingSurfaceXZ;
extern bool g_bResetPlaneAfterXZAdjust;
extern bool g_bHoldGridEntityPosWhenManaged;
extern float g_fHoldGridEntityPosX;
extern float g_fHoldGridEntityPosY;
extern float g_fHoldGridEntityPosZ;
extern float g_fLocalTurnRotationForSmartMode ;
extern int g_iStackToSurfaceMode;
extern int g_iOrientToSurfaceMode;
extern sObject* g_selected_editor_object;
extern XMFLOAT4 g_selected_editor_color;
extern bool bEditorGridFitObjectSize;
extern int iEditorGridSizeX;
extern int iEditorGridSizeZ;
extern bool bRenderTabTab;
extern bool bRenderNextFrame;
extern bool bNeedImGuiInput;
extern bool bProfilerEnable;
extern int iExtractMode;
extern float fExtractYValue, fExtractFixedYValue;
extern bool bExtractFixPivot;
extern bool g_bStandaloneSinglePlayer;
extern bool g_bStandaloneMultiPlayer;
extern bool g_bStandaloneVRMode;
extern bool g_bPreviewLighting;
extern int iLastOpenHeader;
extern int iExecuteCTRLkey;
extern int iExecuteALTkey;
extern int iIncludeLeftIconSet;
extern uint64_t g_hovered_dot_entity;
extern sObject* g_hovered_dot_pobject;
extern sObject* g_destination_dot_pobject;
extern sObject* g_source_dot_pobject;
extern sObject* g_selected_middle_dot_pobject;
extern bool bDotMiddleWindow;
extern ImVec2 vDotMiddleWindowPos;
#define MAXDOTMIDDLE 1000
#define DOTOBJECTIDADD 40000
#define DOTCURSOROBJECTID (70001+40000+20000)
#define DOTMIDDLEOBJECTID (70001+40000+20001)
#define MAXDOTARCSOBJECTS 20000
#define DOTARCSOBJECTID (70001+40000+20001+MAXDOTMIDDLE+1000000)
#define RELATIONOBJECTID (70001+40000+20001+MAXDOTMIDDLE)
#define RELATIONOBJECTMAX 1000
extern int iLargestDotObjectID;
extern int iLargestDotCount;
extern bool bDotObjectDragging;
extern int iDotMiddleInfoSource[MAXDOTMIDDLE];
extern int iDotMiddleInfoDestination[MAXDOTMIDDLE];
extern int iDotMiddleColor[MAXDOTMIDDLE];
extern int iDotArceColor[MAXDOTARCSOBJECTS];
extern int iDotMiddleInfoSourceType[MAXDOTMIDDLE];
extern int iDotMiddleInfoDestinationType[MAXDOTMIDDLE];
extern float fLastHitPosition[4];
extern int iCursorDotObject;
extern bool bFactionWindow[16];
extern float fDrawDotCircleTimer;
extern bool bDrawDotCircle;
extern float fDrawDotCircleRadius;
extern int fDrawDotCircleFrom;
extern bool g_bDotsAreVisible;
#define BACKBUFFERIMAGE (g.perentitypromptimageoffset+9000)
extern int BackBufferObjectID;
extern bool BackBufferSnapShotMode;
extern bool BackBufferParticlesMode;
extern int iBackBufferParticlesTrigger;
extern int BackBufferParticleEmitter;
extern bool bFullScreenBackbuffer;
extern bool bSnapShotModeUseCamera;
extern bool bSnapShotModeUse2D;
extern float fSnapShotModeCameraX, fSnapShotModeCameraY, fSnapShotModeCameraZ;
extern float fSnapShotModeCameraAngX, fSnapShotModeCameraAngY, fSnapShotModeCameraAngZ;
extern cstr g_LastGroupSaved_s;
extern bool g_bBehaviorEditorActive;
extern bool library_createbehavior;
extern char library_newbehaviorname[256];
extern bool BackBufferIsGroup;
extern int BackBufferEntityID;
extern int BackBufferImageID;
extern int BackBufferSizeX;
extern int BackBufferSizeY;
extern float BackBufferRotateY, RestoreBackBufferRotateY;
extern float BackBufferRotateX, RestoreBackBufferRotateX;
extern float BackBufferRotateZ, RestoreBackBufferRotateZ;
extern float BackBufferZoom, RestoreBackBufferZoom;
extern float BackBufferCamMove;
extern float BackBufferCamLeft, RestoreBackBufferCamLeft;
extern float BackBufferCamUp, RestoreBackBufferCamUp;
extern bool bBackBufferAnimated;
extern bool bBackBufferRestoreCamera;
extern bool bEditorInFreeFlightMode;
extern bool bLoopBackBuffer;
extern bool bLoopFullFPS;
extern bool bRotateBackBuffer;
extern cstr BackBufferCacheName;
extern cstr ProjectCacheName;
extern cstr BackBufferSaveCacheName;
extern std::vector<sImageList> g_imageList;
static std::vector<sImageList> g_TempimageList;
extern int iRestoreEntidMaster;
extern int fpe_current_loaded_script;
extern int fpe_current_loaded_script_image;
extern int fpe_current_loaded_script_image_count;

extern bool bReadyToDropEntity;
extern bool bWaitOnMouseRelease;
extern bool bDraggingActive;
extern bool bDraggingActiveInitial;
extern int iDragDropActive;
#define HITPOINTYSTARTPOS GGORIGIN_Y
extern float fHitPointX, fHitPointY, fHitPointZ;
extern float fHitOffsetX, fHitOffsetY, fHitOffsetZ;
extern float fHitRayFrom, fLastHitY;
extern sObject* g_hovered_pobject;
extern bool bTriggerVisibleWidget;
extern bool bMouseInputSystemUsed;
extern int iLastHitObjectID;
extern int iStartMouseX, iStartMouseY;
extern int iObjectMoveMode;
extern int iObjectMoveModeDropSystem;
extern int iObjectMoveModeDropSystemUsing;
extern bool bObjectAllowOverlapping;
extern float fDebug, fDebug1, fDebug2, fDebug3;
extern int i_switch_group_tab;
extern int current_selected_group;
extern bool group_editing_on;
extern bool bCreateNewGroupOnNextDrop;
extern int iLastEntityOnCursor;
extern float fLastRubberBandX1;
extern float fLastRubberBandX2;
extern float fLastRubberBandY1;
extern float fLastRubberBandY2;
extern bool bDetectTerrainOnly;
extern bool bRubberBandCreated;
extern bool bDragCameraActive;
extern bool g_bThumbBankCopyMode;
extern bool g_bRefreshRotationValuesFromObjectOnce;
extern bool g_bLightProbeScaleChanged;
extern int iReusePickObjectID;
extern int iReusePickEntityID;
extern float fReusePickHitX, fReusePickHitY, fReusePickHitZ;
extern sObject* pReusePickObject;
extern std::vector<sLibraryList> g_LibraryFileList;
extern cStr cLastProjectList;
extern cstr cCurrentBackDropImageFile;
extern bool bUseBackDropImage;
extern cstr cUseBackbufferCubemap;
extern bool bBackbufferCubemapActive;
extern int iLastSelectedEntityGroup;
extern int iLastSelectedEntity;
extern int iSetSettingsFocusTab;
extern bool bStoryboardWindow;
extern bool bStoryboardWindowOpenLoad;
extern bool bMarketplace_Window;
extern bool bTriggerCloseEntityWindow;
extern bool bMarketplace_Init;
extern cstr sDefaultImportPath;
extern bool bResetObjectLibrarySize;
extern bool bWelcomeScreen_Window;
extern bool bWelcomeNoBackButton;
extern bool bWelcomeScreen_Init;
extern std::map<std::string, int> selected_library_fpe;
extern bool bProceduralLevel;
extern bool bProceduralLevelFromStoryboard;
extern int iBlackoutForFrames;
extern int iQuitProceduralLevel;
extern bool bProceduralLevelStartup;
extern int g_iUniqueGroupID;
extern cstr sGotoPreviewWithFile;
extern int iGotoPreviewType;
extern int init_Left_Categories_Column_Width;
extern int g_iDevToolsOpen;
extern bool bInvulnerableMode;
extern bool bStartInvulnerableMode;
extern int iWelcomeHeaderType;
extern int iAboutLogoType;
//#endif //WICKEDENGINE
extern bool bTrashcanIconActive, bTrashcanIconActive2;
extern int current_sort_order;
extern int iWidgetSelection;
extern bool bRotScaleAlreadyUpdated;
extern float fEditorGridOffsetX;
extern float fEditorGridOffsetY;
extern float fEditorGridOffsetZ;
extern float fEditorGridSizeX;
extern float fEditorGridSizeY;
extern float fEditorGridSizeZ;
extern int old_iMSAASampleCount;
extern int old_iMSAO;
extern float old_fMSAOPower;
extern int old_iShadowSpotCascadeResolution;
extern int old_iShadowSpotResolution;
extern int old_iShadowPointResolution;
extern bool bForceRefreshLightCount;
extern int iUpdateOcean;
extern bool bEditorLight;
extern cStr sNextLevelToLoad;
#ifdef WICKEDENGINE
extern float fMouseWheelZoomFactor;
extern bool g_bResetCameraToFreeFlightOnNewLevel;
extern float fLocalMax;
#else
extern float fMouseWheelZoomFactor;
#endif
extern bool g_occluderf9Mode;
extern bool g_bSkipTerrainRender;
extern bool g_bBlackListRemovedSomeEntities;
extern bool gbWelcomeSystemActive;
extern int g_iWelcomeLoopPage;
extern int g_trialStampDaysLeft;
extern int g_tstoreprojectmodifiedstatic;
extern preferences pref;
extern cFolderItem MainEntityList;
extern bool g_occluderf9Mode;
extern bool g_bSkipTerrainRender;
extern bool g_bBlackListRemovedSomeEntities;
extern bool gbWelcomeSystemActive;
extern int g_iWelcomeLoopPage;
extern int g_trialStampDaysLeft;
extern int g_tstoreprojectmodifiedstatic;
#ifdef VRTECH
extern bool g_bCharacterCreatorPlusActivated;
extern bool g_bDisableQuitFlag;
extern bool bEnableWeather;
extern char cImGuiDebug[2048];
extern bool bForceKey;
extern int iForceScancode;
extern cstr csForceKey;
extern bool bForceKey2;
extern cstr csForceKey2;
extern bool bForceUndo;
extern bool bForceRedo;
extern int iLaunchAfterSync;
extern int iLaunchAfterSyncAction;
extern bool bLaunchTestGameAfterLoad;
extern bool bLaunchSaveStandalonefterLoad;
extern bool bCloseStoryboardAfterLoad;
extern int iLevelEditorFromStoryboardID;
extern char pLaunchAfterSyncPreSelectModel[MAX_PATH];
extern char pLaunchAfterSyncLastImportedModel[MAX_PATH];
extern int iOldLaunchAfterSync;
extern int iSkibFramesBeforeLaunch;
extern DWORD gWindowSizeXOld;
extern DWORD gWindowSizeYOld;
extern DWORD gWindowSizeAddY;
extern DWORD gWindowSizeAddX;
extern DWORD gWindowVisibleOld;
extern DWORD gWindowPosXOld;
extern DWORD gWindowPosYOld;
extern DWORD gWindowMaximized;
extern int xmouseold, ymouseold;
#ifdef ENABLEIMGUI
extern bool bImGuiInTestGame;
extern bool bBlockImGuiUntilNewFrame;
extern bool bImGuiRenderWithNoCustomTextures;
extern bool bImGuiFrameState;
extern bool bImGuiReadyToRender;
extern bool bImGuiInitDone;
extern ImVec2 OldrenderTargetSize;
extern ImVec2 OldrenderTargetPos;
extern ImVec2 renderTargetAreaPos;
extern ImVec2 renderTargetAreaSize;
extern bool bImGuiRenderTargetFocus;
extern bool bImGuiGotFocus;
extern bool g_bCascadeQuitFlag;
extern int ImGuiStatusBar_Size;
extern char defaultWriteFolder[260];
extern bool bEntityGotFocus;
extern char cDirectOpen[260];
extern bool imgui_is_running;
extern int refresh_gui_docking;
extern ImGuiID dock_main_tabs, dock_tools_windows;
extern cstr RedockNextWindow;
extern ImGuiViewport* viewport;
extern int toolbar_size;
extern bool g_bInTutorialMode;
extern int g_iCountdownToAlphaBetaMessage;
extern ImVec4 drawCol_toogle;
extern int g_EntityClipboardAnchorEntityIndex;
extern std::vector<int> g_EntityClipboard;
extern preferences pref;
//extern cFolderItem MainEntityList;
extern bool bExport_Standalone_Window;
extern bool bExport_SaveToGameCloud_Window;
extern bool bExternal_Entities_Window;
extern int iDisplayLibraryType;
extern int iDisplayLibrarySubType;
extern int iLastDisplayLibraryType;
extern cstr sStartLibrarySearchString;
extern cstr sTriggerCategorySelect;
extern int iLibraryStingReturnToID;
extern int iSelectedLibraryStingReturnID;
extern cstr sMakeDefaultSelecting;
extern cstr sSelectedLibrarySting;
extern bool bSelectLibraryViewAll;
extern bool bExternal_Entities_Init;
extern bool bEntity_Properties_Window;
extern bool bProperties_Window_Block_Mouse;
extern bool bCheckForClosing;
extern bool bCheckForClosingForce;
extern bool bBuilder_Properties_Window;
extern bool bBuilder_Left_Window;
extern bool bTerrain_Tools_Window;
extern bool bWaypoint_Window;
extern bool bDownloadStore_Window;
extern bool bImporter_Window;
extern bool bHelpVideo_Window;
extern bool bHelp_Window;
extern char cForceTutorialName[1024];
extern bool bHelp_Menu_Image_Window;
extern bool bAbout_Window;
extern bool bCredits_Window;
extern bool bBug_Reporting_Window;
extern bool bBug_RefreshBugList;
extern bool bAbout_Window_First_Run;
extern bool bCredits_Window_First_Run;
extern bool bAbout_Init;
extern bool Entity_Tools_Window;
extern bool bInfo_Window;
extern bool bInfo_Reload;
extern bool bInfo_Window_First_Run;
extern cstr cInfoMessage;
extern cstr cInfoImage, cInfoImageLast;
extern int iInfoUniqueId;
extern int g_iActiveMonitors;

#ifdef WICKEDENGINE
extern bool Visuals_Tools_Window;
extern bool Weather_Tools_Window;
extern int iRestoreLastWindow;
extern std::vector<sRubberBandType> vEntityLockedList;
#define MAXGROUPSLISTS 100
extern cstr sEntityGroupListName[MAXGROUPSLISTS];
extern std::vector<sRubberBandType> vEntityGroupList[MAXGROUPSLISTS];
extern int iEntityGroupListImage[MAXGROUPSLISTS];
extern bool bPreferences_Window;
extern char cPreferencesMessage[MAX_PATH];
extern bool Shooter_Tools_Window; 
extern bool Puzzle_Tools_Window;
extern bool RPG_Tools_Window;
extern char cNextWindowFocus[256];
extern bool bEditGameSettings;
#endif
extern int media_icon_size_leftpanel;
extern int iColumnsWidth_leftpanel;
extern int iColumns_leftpanel;
extern bool bDisplayText_leftpanel;
extern float fFontSize_leftpanel;
extern cFolderItem::sFolderFiles *pDragDropFile;
extern int iOldgridentity;
extern float fPropertiesColoumWidth;
extern bool bTriggerMessage;
extern int iTriggerMessageDelay;
extern int iTriggerMessageY;
extern char cTriggerMessage[MAX_PATH];
extern int iMessageTimer;
extern ImVec4 drawCol_back;
extern ImVec4 drawCol_normal;
extern ImVec4 drawCol_hover;
extern ImVec4 drawCol_Down;
extern ImVec4 drawCol_black;
extern ISpObjectToken* CCP_SelectedToken;
extern LPSTR pCCPVoiceSet;
extern char CCP_SpeakText[1024];
extern wchar_t CCP_SpeakText_w[1024];
extern int CCP_Speak_Rate;
extern std::vector<cstr> tutorial_list;
extern std::map<std::string, std::string> tutorial_files;
extern std::map<std::string, std::string> tutorial_videos;
extern std::map<std::string, std::string> tutorial_description;
extern std::vector<cstr> about_text;
extern bool bTutorial_Init;
extern int current_tutorial;
extern int selected_tutorial;
extern bool bVideoPlayerMaximized;
extern bool bSmallVideoPlayerMaximized;
extern bool bLastSmallVideoPlayerMaximized;
extern bool bVideoResumePossible;
extern bool bVideoPerccentStart;
extern int iVideoFindFirstFrame;
extern int iVideoDelayExecute;
extern bool bTutorialCheckAction;
extern int bDelayedTutorialCheckAction;
extern int iDelayedCameraRestore;
#define TUTORIALMAXTEXT 1024
#define TUTORIALMAXSTEPS 20
extern char cForceTutorialName[1024];
extern char cTutorialName[TUTORIALMAXTEXT];
extern cstr cVideoDescription;
extern ActiveTutorial tut;
extern bool bTutorialRendered;
extern bool bSmallVideoFrameStart;
extern bool bSetTutorialSectionLeft;
extern int iLastTooltipSelection;
extern int iTooltipTimer;
extern int iTooltipHoveredTimer;
extern int iTooltipLastObjectId;
extern bool iTooltipAlreadyLoaded;
extern bool iTooltipObjectReady;
extern float lastKeyTime;
extern char cHelpMenuImage[MAX_PATH];
extern bool bLostFocus;
extern bool bRenderTargetModalMode;
extern int iStartupTime;
extern cstr CurrentWinTitle;
extern int speech_ids[5];
extern bool bWaypointDrawmode;
extern float custom_back_color[4];
extern bool bUpdateVeg;
extern int iLastUpdateVeg;
#endif
#endif
extern int iTriggerWelcomeSystemStuff;
extern int iCountDownToShowQuickStartDialog;
#ifdef WICKEDENGINE
extern ImVec2 back_renderTargetAreaPos;
extern ImVec2 back_renderTargetAreaSize;
#endif
extern int back_iLastResolutionWidth;
extern int back_iLastResolutionHeight;
extern bool bFakeStandaloneTest;
extern int iTriggerGrassTreeUpdate;
extern bool Shooter_Tools_Window_Active;

typedef std::map<std::string, ISpObjectToken *> VoiceMap_t;
extern VoiceMap_t VoiceMap;
extern std::vector <cstr> g_voiceList_s;
extern std::vector <ISpObjectToken *> g_voicetoken;

bool bDigAHoleToHWND = false;

#ifdef WICKEDENGINE
bool bSortProjects = true;
bool bResetProjectThumbnails = true;
#endif

#ifdef ENABLEIMGUI
void imgui_set_openproperty_flags(int iMasterID)
{
	//  Open property window
	t.editorinterfaceactive = t.e;

	//  Setup usage flags
	t.tsimplecharview = 0;
	t.tflaglives = 0; t.tflaglight = 0; t.tflagobjective = 0; t.tflagtdecal = 0; t.tflagdecalparticle = 0; t.tflagspawn = 0; t.tflagifused = 0;
	t.tflagnewparticle = 0;
	t.tflagvis = 0; t.tflagchar = 0; t.tflagweap = 0; t.tflagammo = 0; t.tflagai = 1; t.tflagsound = 0; t.tflagsoundset = 0; t.tflagnosecond = 0;
	t.tflagmobile = 0; t.tflaghurtfall = 0; t.tflaghasweapon = 0; t.tflagammoclip = 0; t.tflagstats = 0; t.tflagquantity = 0;
	t.tflagvideo = 0;
	t.tflagplayersettings = 0;
	t.tflagusekey = 0;
	t.tflagteamfield = 0;
	int tflagtext = 0;
	int tflagimage = 0;

	//  If its static and arena mode, only do optional visuals, ignore rest
	t.tstatic = 0;

	// 070510 - simplified character properties
	if (g.gsimplifiedcharacterediting == 1 && t.entityprofile[iMasterID].ischaracter == 1)
	{
		//  flag the simple character properties layout (FPGC)
		t.tsimplecharview = 1;
	}
	else
	{
		//  FPGC - 260310 - new entitylight indicated with new flag
		if (t.entityprofile[iMasterID].islightmarker == 1)
		{
			t.tflaglight = 1;
		}
		else
		{
			if (t.entityprofile[iMasterID].ismarker == 0)
			{
				t.tflagvis = 1; t.tflagmobile = 1; t.tflagobjective = 1; t.tflagsound = 1; t.tflagstats = 1; t.tflagspawn = 1;
				// 070115 - removed until UBER character (multiweapon) is ready for action
				// t.entityprofile[iMasterID].ischaracter>0 then t.tflagchar = 1  ) ; t.tflaghasweapon = 1 ; t.tflagsoundset = 1 ; t.tflagsound = 0
				if (t.entityprofile[iMasterID].ischaracter > 0) { t.tflagchar = 1; t.tflagsoundset = 1; t.tflagsound = 0; }
				if (Len(t.entityprofile[iMasterID].isweapon_s.Get()) > 2) { t.tflagweap = 1; t.tflagammoclip = 1; t.tflagsound = 0; }
				if (t.entityprofile[iMasterID].isammo > 0) { t.tflagammo = 1; t.tflagobjective = 0; t.tflagsound = 0; }
				t.tflagusekey = 1;
			}
			else
			{
				if (t.entityprofile[iMasterID].ismarker == 1)
				{
					t.tflagai = 0;
					//  FPGC - 160909 - filtered fpgcgenre=1 is shooter genre
					if (g.fpgcgenre == 1)
					{
						//  Shooter legacy properties for player start
						if (t.entityprofile[iMasterID].lives > 0)
						{
							t.tflagstats = 1; t.tflaglives = 1; t.tflagsoundset = 1; t.tflaghurtfall = 1; t.tflaghasweapon = 1; t.tflagquantity = 1;
							t.tflagplayersettings = 1;
							t.tflagnosecond = 1;
						}
						else
						{
							t.tflagsound = 1; t.tflagnosecond = 1;
						}
					}
					else
					{
						//  Other genre's have no ammo quantity and weapon is renamed as equipment
						if (t.entityprofile[iMasterID].lives == -1)
						{
							//  checkpint marker is type 1
							t.tflagsound = 1; t.tflagnosecond = 1;
						}
						else
						{
							t.tflagstats = 1; t.tflaglives = 1; t.tflagsoundset = 1; t.tflaghurtfall = 1; t.tflaghasweapon = 1;
						}
					}
				}
				if (t.entityprofile[iMasterID].ismarker == 3 || t.entityprofile[iMasterID].ismarker == 6 || t.entityprofile[iMasterID].ismarker == 8)
				{
					t.tflagnosecond = 1; t.tflagifused = 1;
				}
				if (t.entityprofile[iMasterID].ismarker == 4) { t.tflagtdecal = 1; t.tflagdecalparticle = 1; }
				#ifdef WICKEDENGINE
				// handled next to Behavior component for MAX
				#else
				if (t.entityprofile[iMasterID].ismarker == 10) { t.tflagnewparticle = 1; }
				#endif
				if (t.entityprofile[iMasterID].ismarker == 3)
				{
					if (t.entityprofile[iMasterID].markerindex <= 1)
					{
						if (t.entityprofile[iMasterID].markerindex == 1)
						{
							// video
							t.tflagvideo = 1;
						}
						else
						{
							// sound
							t.tflagsound = 1;
						}
					}
					else
					{
						if (t.entityprofile[iMasterID].markerindex == 2) tflagtext = 1;
						if (t.entityprofile[iMasterID].markerindex == 3) tflagimage = 1;
					}
				}
				if (t.entityprofile[iMasterID].ismarker == 7)
				{
					//  multiplayer start marker
					t.tflagstats = 1;
					t.tflaghurtfall = 1;
					t.tflagplayersettings = 1;
					t.tflagteamfield = 1;
				}
				if (t.entityprofile[iMasterID].ismarker == 8)
				{
					// floor zone marker
					t.tflagsound = 0;
				}
				if (t.entityprofile[iMasterID].ismarker == 9)
				{
					// cover zone marker
					t.tflagifused = 1;
				}
			}
		}
	}

	// parental control removes weapons and violence properties
	if (g.quickparentalcontrolmode == 2)
	{
		t.tflagweap = 0;
		t.tflagammo = 0;
	}

	//PE: New flags check.
	// special VR mode can remove even more
	t.tflagnotionofhealth = 1;
	t.tflagsimpler = 0;
	//if ( bVRQ2ZeroViolenceMode == true )
	//{
	//	t.tflaglives=0; 
	//	t.tflaghurtfall=0; 
	//	t.tflaghasweapon=0; 
	//	t.tflagammoclip=0;
	//	t.tflagnotionofhealth=0;
	//	t.tflagsimpler = 1;
	//}


}
#endif

// 
//  PROPERTIES
// 

void interface_openpropertywindow ( void )
{
	//  Open proprty window
	#ifdef FPSEXCHANGE
	OpenFileMap (  1, "FPSEXCHANGE" );
	SetFileMapDWORD (  1, 978, 1 );
	SetFileMapDWORD (  1, 458, 0 );
	SetEventAndWait (  1 );
	t.editorinterfaceactive=t.e;

	//  open the entity file map
	OpenFileMap (  2, "FPSENTITY" );
	SetEventAndWait (  2 );

	//  wait until the entity window is read
	if (  GetFileMapDWORD( 2, ENTITY_SETUP )  ==  1 ) 
	{
		#ifdef VRTECH
		// special VRQ2 mode also hides concepts of lives, health, blood, violence (substitute health for strength)
		bool bVRQ2ZeroViolenceMode = false;
		if ( g.vrqcontrolmode != 0 ) bVRQ2ZeroViolenceMode = true;//if ( g.gvrmode == 3 ) bVRQ2ZeroViolenceMode = true;
		#endif

		//  Setup usage flags
		t.tsimplecharview=0;
		t.tflaglives=0 ; t.tflaglight=0 ; t.tflagobjective=0 ; t.tflagtdecal=0 ; t.tflagdecalparticle=0 ; t.tflagspawn=0 ; t.tflagifused=0;
		t.tflagnewparticle = 0;
		t.tflagvis=0 ; t.tflagchar=0 ; t.tflagweap=0 ; t.tflagammo=0 ; t.tflagai=1 ; t.tflagsound=0 ; t.tflagsoundset=0 ; t.tflagnosecond=0;
		t.tflagmobile=0 ; t.tflaghurtfall=0 ; t.tflaghasweapon=0 ; t.tflagammoclip=0 ; t.tflagstats=0 ; t.tflagquantity=0;
		t.tflagvideo=0;
		t.tflagplayersettings=0;
		t.tflagusekey=0;
		t.tflagteamfield=0;
		int tflagtext=0;
		int tflagimage=0;

		//  If its static and arena mode, only do optional visuals, ignore rest
		t.tstatic=0;

		// 070510 - simplified character properties
		if (  g.gsimplifiedcharacterediting == 1 && t.entityprofile[t.gridentity].ischaracter == 1 ) 
		{
			//  flag the simple character properties layout (FPGC)
			t.tsimplecharview=1;
		}
		else
		{
			//  FPGC - 260310 - new entitylight indicated with new flag
			if (  t.entityprofile[t.gridentity].islightmarker == 1 ) 
			{
				t.tflaglight=1;
			}
			else
			{
				if (  t.entityprofile[t.gridentity].ismarker == 0 ) 
				{
					t.tflagvis=1 ; t.tflagmobile=1 ; t.tflagobjective=1 ; t.tflagsound=1 ; t.tflagstats=1 ; t.tflagspawn=1;
					// 070115 - removed until UBER character (multiweapon) is ready for action
					// t.entityprofile[t.gridentity].ischaracter>0 then t.tflagchar = 1  ) ; t.tflaghasweapon = 1 ; t.tflagsoundset = 1 ; t.tflagsound = 0
					if (  t.entityprofile[t.gridentity].ischaracter>0 ) { t.tflagchar = 1  ; t.tflagsoundset = 1 ; t.tflagsound = 0; }
					if (  Len(t.entityprofile[t.gridentity].isweapon_s.Get())>2 ) { t.tflagweap = 1  ; t.tflagammoclip = 1 ; t.tflagsound = 0; }
					if (  t.entityprofile[t.gridentity].isammo>0 ) { t.tflagammo = 1  ; t.tflagobjective = 0 ; t.tflagsound = 0; }
					t.tflagusekey=1;
				}
				else
				{
					if (  t.entityprofile[t.gridentity].ismarker == 1 ) 
					{
						t.tflagai=0;
						//  FPGC - 160909 - filtered fpgcgenre=1 is shooter genre
						if (  g.fpgcgenre == 1 ) 
						{
							//  Shooter legacy properties for player start
							if (  t.entityprofile[t.gridentity].lives>0 ) 
							{
								t.tflagstats=1 ; t.tflaglives=1 ; t.tflagsoundset=1 ; t.tflaghurtfall=1 ; t.tflaghasweapon=1 ; t.tflagquantity=1;
								t.tflagplayersettings=1;
								t.tflagnosecond=1;
							}
							else
							{
								t.tflagsound=1 ; t.tflagnosecond=1;
							}
						}
						else
						{
							//  Other genre's have no ammo quantity and weapon is renamed as equipment
							if (  t.entityprofile[t.gridentity].lives == -1 ) 
							{
								//  checkpint marker is type 1
								t.tflagsound=1 ; t.tflagnosecond=1;
							}
							else
							{
								t.tflagstats=1 ; t.tflaglives=1 ; t.tflagsoundset=1 ; t.tflaghurtfall=1 ; t.tflaghasweapon=1;
							}
						}
					}
					if (  t.entityprofile[t.gridentity].ismarker == 3 || t.entityprofile[t.gridentity].ismarker == 6 || t.entityprofile[t.gridentity].ismarker == 8 ) 
					{
						t.tflagnosecond=1 ; t.tflagifused=1;
						#ifdef VRTECH
						#else
						t.tflagsound=1;
						#endif
					}
					if (  t.entityprofile[t.gridentity].ismarker == 4 ) { t.tflagtdecal = 1  ; t.tflagdecalparticle = 1; }
					#ifdef WICKEDENGINE
					// handled next to Behavior component for MAX
					#else
					if (  t.entityprofile[t.gridentity].ismarker == 10 ) { t.tflagnewparticle = 1; }
					#endif
					if (  t.entityprofile[t.gridentity].ismarker == 3 ) 
					{
						if (  t.entityprofile[t.gridentity].markerindex <= 1 ) 
						{
							if (  t.entityprofile[t.gridentity].markerindex == 1 ) 
							{
								// video
								t.tflagvideo=1;
							}
							else
							{
								// sound
								t.tflagsound=1;
							}
						}
						else
						{
							if ( t.entityprofile[t.gridentity].markerindex == 2 ) tflagtext=1;
							#ifdef VRTECH
							#else
							 if ( t.entityprofile[t.gridentity].markerindex == 3 ) tflagimage=1;
							#endif
						}
					}
					if (  t.entityprofile[t.gridentity].ismarker == 7 ) 
					{
						//  multiplayer start marker
						t.tflagstats=1;
						t.tflaghurtfall=1;
						t.tflagplayersettings=1;
						t.tflagteamfield=1;
					}
					if (  t.entityprofile[t.gridentity].ismarker == 8 ) 
					{
						// floor zone marker
						t.tflagsound=0;
					}
					if (  t.entityprofile[t.gridentity].ismarker == 9 ) 
					{
						// cover zone marker
						t.tflagifused = 1;
					}
				}
			}
		}

		// parental control removes weapons and violence properties
		if ( g.quickparentalcontrolmode == 2 )
		{
			t.tflagweap = 0;
			t.tflagammo = 0;
		}

		#ifdef VRTECH
		// special VR mode can remove even more
		t.tflagnotionofhealth = 1;
		t.tflagsimpler = 0;
		if ( bVRQ2ZeroViolenceMode == true )
		{
			t.tflaglives=0; 
			t.tflaghurtfall=0; 
			t.tflaghasweapon=0; 
			t.tflagammoclip=0;
			t.tflagnotionofhealth=0;
			t.tflagsimpler = 1;
		}
		#endif

		//  set array and counters to track scope of contents of each group
		Dim (  t.propfield,16  );
		for ( t.t = 0 ; t.t <= 16 ; t.t++ ) t.propfield[t.t]=0 ; 

		//  set the window title
		setpropertybase(ENTITY_WINDOW_TITLE,t.strarr_s[411].Get());

		//  FPGC - 070510 - open entity properties filemap and wait for signal to write
		OpenFileMap ( 3, "ENTITYPROPERTIES" );
		g.g_filemapoffset = 8;
		if ( DLLExist(1) == 0 )  DLLLoad (  "Kernel32.dll", 1 );
		while (  GetFileMapDWORD(3,0)  ==  1 ) 
		{
			CallDLL (  1,"Sleep",10 );
		}

		if (  t.tsimplecharview == 1 ) 
		{
			//  Wizard (simplified) property editing
			t.group=0 ; startgroup("Character Info") ; t.controlindex=0;
			#ifdef VRTECH
			setpropertystring2(t.group,t.grideleprof.name_s.Get(),t.strarr_s[413].Get(),"Choose a unique name for this character") ; ++t.controlindex;
			#else
			setpropertystring2(t.group,t.grideleprof.name_s.Get(),t.strarr_s[478].Get(),"Choose a unique name for this character") ; ++t.controlindex;
			#endif
			setpropertylist2(t.group,t.controlindex,t.grideleprof.aimain_s.Get(),"Behaviour","Select a behaviour for this character",11) ; ++t.controlindex;
			setpropertyfile2(t.group,t.grideleprof.soundset1_s.Get(),"Voiceover","Select t.a WAV or OGG file this character will use during their behavior","audiobank\\") ; ++t.controlindex;
			setpropertystring2(t.group,t.grideleprof.ifused_s.Get(),"If Used","Sometimes used to specify the name of an entity to be activated") ; ++t.controlindex;
		}
		else
		{
			//  Name
			t.group=0 ; startgroup(t.strarr_s[412].Get()) ; t.controlindex=0;
			#ifdef VRTECH
			if ( t.entityprofile[t.gridentity].ischaracter > 0 )
			{
				setpropertystring2(t.group,t.grideleprof.name_s.Get(),t.strarr_s[478].Get(),t.strarr_s[204].Get());
			}
			else
			{
				if ( t.entityprofile[t.gridentity].ismarker > 0 )
				{
					if ( t.entityprofile[t.gridentity].islightmarker > 0 )
						setpropertystring2(t.group,t.grideleprof.name_s.Get(),t.strarr_s[483].Get(),t.strarr_s[204].Get());
					else
						setpropertystring2(t.group,t.grideleprof.name_s.Get(),t.strarr_s[479].Get(),t.strarr_s[204].Get());
				}
				else
					setpropertystring2(t.group,t.grideleprof.name_s.Get(),t.strarr_s[413].Get(),t.strarr_s[204].Get());
			}
			++t.controlindex;
			#else
			setpropertystring2(t.group,t.grideleprof.name_s.Get(),t.strarr_s[413].Get(),t.strarr_s[204].Get()) ; ++t.controlindex;
			#endif
			if (  t.entityprofile[t.gridentity].ismarker == 0 || t.entityprofile[t.gridentity].islightmarker == 1 ) 
			{
				if (  g.gentitytogglingoff == 0 ) 
				{
					t.tokay=1;
					if (  ObjectExist(g.entitybankoffset+t.gridentity) == 1 ) 
					{
						if (  GetNumberOfFrames(g.entitybankoffset+t.gridentity)>0 ) 
						{
							t.tokay=0;
						}
					}
					if (  t.tokay == 1 ) 
					{
						//PE: 414=Static Mode
						setpropertylist2(t.group,t.controlindex,Str(t.gridentitystaticmode),t.strarr_s[414].Get(),t.strarr_s[205].Get(),0) ; ++t.controlindex;
					}
				}
			}

			// 101016 - Additional General Parameters
			if ( t.tflagchar == 0 && t.tflagvis == 1 ) 
			{
				#ifdef VRTECH
				if ( t.tflagsimpler == 0 )
				{
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.isocluder),"Occluder","Set to YES makes this object an occluder",0) ; ++t.controlindex;
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.isocludee),"Occludee","Set to YES makes this object an occludee",0) ; ++t.controlindex;
				}
				#else
				setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.isocluder),"Occluder","Set to YES makes this entity an occluder",0) ; ++t.controlindex;
				setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.isocludee),"Occludee","Set to YES makes this entity an occludee",0) ; ++t.controlindex;
				#endif
				
				// these will be back when EBE needs doors and windows
				//setpropertystring2(t.group,Str(t.grideleprof.parententityindex),"Parent Index","Selects another entity element to be a parent") ; ++t.controlindex;
				//setpropertystring2(t.group,Str(t.grideleprof.parentlimbindex),"Parent Limb","Specifies the limb index of the parent to connect with") ; ++t.controlindex;
			}

			// 281116 - added Specular Control per entity
			if ( t.tflagvis == 1 ) 
			{
				#ifdef VRTECH
				if ( t.tflagsimpler == 0 )
				{
					setpropertystring2(t.group,Str(t.grideleprof.specularperc),"Specular","Set specular percentage to modulate object specular effect")  ; ++t.controlindex; 
				}
				#else
				setpropertystring2(t.group,Str(t.grideleprof.specularperc),"Specular","Set specular percentage to modulate entity specular effect")  ; ++t.controlindex; 
				#endif
			}

			//  Basic AI
			if (  t.tflagai == 1 ) 
			{
				// can redirect to better folders if in g.quickparentalcontrolmode
				LPSTR pAIRoot = "scriptbank\\";
				if ( g.quickparentalcontrolmode == 2 )
				{
					if ( t.entityprofile[t.gridentity].ismarker == 0 ) 
					{
						if ( t.tflagchar == 1 )
							pAIRoot = "scriptbank\\people\\";
						else
							pAIRoot = "scriptbank\\objects\\";
					}
					else
					{
						pAIRoot = "scriptbank\\markers\\";
					}
				}

				t.propfield[t.group]=t.controlindex;
				#ifdef VRTECH
				++t.group ; startgroup(t.strarr_s[415].Get()) ; t.controlindex=0;
				#else
				++t.group ; startgroup("AI System") ; t.controlindex=0;
				#endif
				setpropertyfile2(t.group,t.grideleprof.aimain_s.Get(),t.strarr_s[417].Get(),t.strarr_s[207].Get(),pAIRoot) ; ++t.controlindex;
			}

			//  Has Weapon
			if (  t.tflaghasweapon == 1 && t.playercontrol.thirdperson.enabled == 0 && g.quickparentalcontrolmode != 2 ) 
			{
				setpropertylist2(t.group,t.controlindex,t.grideleprof.hasweapon_s.Get(),t.strarr_s[419].Get(),t.strarr_s[209].Get(),1) ; ++t.controlindex;
			}

			//  Is Weapon (FPGC - 280809 - filtered fpgcgenre=1 is shooter genre)
			if (  t.tflagweap == 1 && g.fpgcgenre == 1 ) 
			{
				setpropertystring2(t.group,Str(t.grideleprof.damage),t.strarr_s[420].Get(),t.strarr_s[210].Get()) ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.grideleprof.accuracy),t.strarr_s[421].Get(),"Increases the inaccuracy of conical distribution by 1/100th of t.a degree") ; ++t.controlindex;
				if (  t.grideleprof.weaponisammo == 0 ) 
				{
					setpropertystring2(t.group,Str(t.grideleprof.reloadqty),t.strarr_s[422].Get(),t.strarr_s[212].Get()) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.fireiterations),t.strarr_s[423].Get(),t.strarr_s[213].Get()) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.range),"Range","Maximum range of bullet travel") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.dropoff),"Dropoff","Amount in inches of vertical dropoff per 100 feet of bullet travel") ; ++t.controlindex;
				}
				else
				{
					setpropertystring2(t.group,Str(t.grideleprof.lifespan),t.strarr_s[424].Get(),t.strarr_s[214].Get()) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.throwspeed),t.strarr_s[425].Get(),t.strarr_s[215].Get()) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.throwangle),t.strarr_s[426].Get(),t.strarr_s[216].Get()) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.bounceqty),t.strarr_s[427].Get(),t.strarr_s[217].Get()) ; ++t.controlindex;
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.explodeonhit),t.strarr_s[428].Get(),t.strarr_s[218].Get(),0) ; ++t.controlindex;
				}
				#ifdef VRTECH
				if ( t.tflagsimpler == 0 )
				{
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.usespotlighting),"Spot Lighting","Set whether emits dynamic spot lighting",0) ; ++t.controlindex;
				}
				#else
				setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.usespotlighting),"Spot Lighting","Set whether emits dynamic spot lighting",0) ; ++t.controlindex;
				#endif
			}

			//  Is Character
			if (  t.tflagchar == 1 ) 
			{
				#ifdef VRTECH
				if ( t.tflagsimpler == 0 )
				{
					// 020316 - special check to avoid offering can take weapon if no HUD.X
					t.tfile_s = cstr("gamecore\\guns\\") + t.grideleprof.hasweapon_s + cstr("\\HUD.X");
					if ( FileExist(t.tfile_s.Get()) == 1 ) 
					{
						setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.cantakeweapon),t.strarr_s[429].Get(),t.strarr_s[219].Get(),0) ; ++t.controlindex;
						setpropertystring2(t.group,Str(t.grideleprof.quantity),t.strarr_s[430].Get(),t.strarr_s[220].Get()) ; ++t.controlindex;
					}
					setpropertystring2(t.group,Str(t.grideleprof.rateoffire),t.strarr_s[431].Get(),t.strarr_s[221].Get()) ; ++t.controlindex;
				}
				#else
				// 020316 - special check to avoid offering can take weapon if no HUD.X
				t.tfile_s = cstr("gamecore\\guns\\") + t.grideleprof.hasweapon_s + cstr("\\HUD.X");
				if ( FileExist(t.tfile_s.Get()) == 1 ) 
				{
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.cantakeweapon),t.strarr_s[429].Get(),t.strarr_s[219].Get(),0) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.quantity),t.strarr_s[430].Get(),t.strarr_s[220].Get()) ; ++t.controlindex;
				}
				setpropertystring2(t.group,Str(t.grideleprof.rateoffire),t.strarr_s[431].Get(),t.strarr_s[221].Get()) ; ++t.controlindex;
				#endif
			}
			if ( t.tflagquantity == 1 && g.quickparentalcontrolmode != 2 ) 
			{ 
				setpropertystring2(t.group,Str(t.grideleprof.quantity),t.strarr_s[432].Get(),t.strarr_s[222].Get())  ; ++t.controlindex; 
			}

			//  AI Extra
			if (  t.tflagvis == 1 && t.tflagai == 1 ) 
			{
				if (  t.tflagchar == 1 ) 
				{
					setpropertystring2(t.group,Str(t.grideleprof.coneangle),t.strarr_s[434].Get(),t.strarr_s[224].Get()) ; ++t.controlindex;
					#ifdef VRTECH
					setpropertystring2(t.group,Str(t.grideleprof.conerange),t.strarr_s[476].Get(),"The range within which the AI may see the player. Zero triggers the characters default range.") ; ++t.controlindex;
					#else
					setpropertystring2(t.group,Str(t.grideleprof.conerange),"View Range","The range within which the AI may see the player. Zero triggers the characters default range.") ; ++t.controlindex;
					#endif
					setpropertystring2(t.group,t.grideleprof.ifused_s.Get(),t.strarr_s[437].Get(),t.strarr_s[226].Get()) ; ++t.controlindex;
					if ( g.quickparentalcontrolmode != 2 )
					{
						setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.isviolent),"Blood Effects","Sets whether blood and screams should be used",0) ; ++t.controlindex;
					}
					#ifdef VRTECH
					if ( t.tflagsimpler == 0 )
					{
						setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.colondeath),"End Collision","Set to NO switches off collision when die",0) ; ++t.controlindex;
					}
					#else
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.colondeath),"End Collision","Set to NO switches off collision when die",0) ; ++t.controlindex;
					#endif
				}
				else
				{
					if (  t.tflagweap == 0 && t.tflagammo == 0 ) 
					{
						t.propfield[t.group]=t.controlindex;
						++t.group ; startgroup(t.strarr_s[435].Get()) ; t.controlindex=0;
						setpropertystring2(t.group,t.grideleprof.usekey_s.Get(),t.strarr_s[436].Get(),t.strarr_s[225].Get()) ; ++t.controlindex;
						#ifdef VRTECH
						if ( t.tflagsimpler != 0 & t.entityprofile[t.gridentity].ismarker == 3 && t.entityprofile[t.gridentity].trigger.stylecolor == 1 )
						{
							// only one level - no winzone chain option
						}
						else
						{
							setpropertystring2(t.group,t.grideleprof.ifused_s.Get(),t.strarr_s[437].Get(),t.strarr_s[226].Get()) ; ++t.controlindex;
						}
						#else
						setpropertystring2(t.group,t.grideleprof.ifused_s.Get(),t.strarr_s[437].Get(),t.strarr_s[226].Get()) ; ++t.controlindex;
						#endif
					}
				}
			}
			if (  t.tflagifused == 1 ) 
			{
				if (  t.tflagusekey == 1 ) 
				{
					setpropertystring2(t.group,t.grideleprof.usekey_s.Get(),t.strarr_s[436].Get(),t.strarr_s[225].Get()) ; ++t.controlindex;
				}
				#ifdef VRTECH
				if ( t.tflagsimpler != 0 & t.entityprofile[t.gridentity].ismarker == 3 && t.entityprofile[t.gridentity].trigger.stylecolor == 1 )
				{
					// only one level - no winzone chain option
				}
				else
				{
					setpropertystring2(t.group,t.grideleprof.ifused_s.Get(),t.strarr_s[437].Get(),t.strarr_s[227].Get()) ; ++t.controlindex;
				}
				#else
				setpropertystring2(t.group,t.grideleprof.ifused_s.Get(),t.strarr_s[437].Get(),t.strarr_s[227].Get()) ; ++t.controlindex;
				#endif
			}

			//  Spawn Settings
			if (  t.tflagspawn == 1 ) 
			{
				t.propfield[t.group]=t.controlindex;
				++t.group ; startgroup(t.strarr_s[439].Get()) ; t.controlindex=0;
				setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.spawnatstart),t.strarr_s[562].Get(),t.strarr_s[563].Get(),0) ; ++t.controlindex;
				//     `setpropertystring2(group,Str(grideleprof.spawnmax),strarr$(440),strarr$(231)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnupto),strarr$(441),strarr$(232)) ; inc controlindex
				//     `setpropertylist2(group,controlindex,Str(grideleprof.spawnafterdelay),strarr$(442),strarr$(233),0) ; inc controlindex
				//     `setpropertylist2(group,controlindex,Str(grideleprof.spawnwhendead),strarr$(443),strarr$(234),0) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawndelay),strarr$(444),strarr$(235)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawndelayrandom),strarr$(564),strarr$(565)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnqty),strarr$(445),strarr$(236)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnqtyrandom),strarr$(566),strarr$(567)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnvel),strarr$(568),strarr$(569)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnvelrandom),strarr$(570),strarr$(571)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnangle),strarr$(572),strarr$(573)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnanglerandom),strarr$(574),strarr$(575)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnlife),strarr$(576),strarr$(577)) ; inc controlindex
			}

			//  Visual
			//    `if tflagvis=1
			//     `propfield(group)=controlindex
			//     `inc group ; startgroup(strarr$(446)) ; controlindex=0
			//     `setpropertyfile2(group,grideleprof.texd$,strarr$(447),strarr$(237),"") ; inc controlindex
			//     `setpropertyfile2(group,grideleprof.texaltd$,strarr$(448),strarr$(238),"") ; inc controlindex
			//     `setpropertyfile2(group,grideleprof.effect$,strarr$(578),strarr$(579),"effectbank\\") ; inc controlindex
			//     `setpropertystring2(group,Str(grideleprof.transparency),strarr$(449),strarr$(240)) ; inc controlindex
			//     `setpropertystring2(group,Str(grideleprof.reducetexture),strarr$(450),strarr$(241)) ; inc controlindex
			//    `endif
			//if ( t.tflagvis == 1 ) // more engine needs improving to allow on the spot changes to shader!
			//{
			//	setpropertyfile2(t.group,t.grideleprof.effect_s.Get(),t.strarr_s[578].Get(),t.strarr_s[579].Get(),"effectbank\\"); ++t.controlindex;
			//	setpropertystring2(t.group,Str(t.grideleprof.transparency),t.strarr_s[449].Get(),t.strarr_s[240].Get()); ++t.controlindex;
			//}

			//  Statistics
			if (  (t.tflagvis == 1 || t.tflagobjective == 1 || t.tflaglives == 1 || t.tflagstats == 1) && t.tflagweap == 0 && t.tflagammo == 0 ) 
			{
				t.propfield[t.group]=t.controlindex;
				++t.group ; startgroup(t.strarr_s[451].Get()) ; t.controlindex=0;
				#ifdef VRTECH
				#else
				 if (  t.tflaglives == 1 ) { setpropertystring2(t.group,Str(t.grideleprof.lives),t.strarr_s[452].Get(),t.strarr_s[242].Get())  ; ++t.controlindex; }
				 if (  t.tflagvis == 1 || t.tflagstats == 1 ) 
				 {
					if (  t.tflaglives == 1 ) 
					{
						setpropertystring2(t.group,Str(t.grideleprof.strength),t.strarr_s[453].Get(),t.strarr_s[243].Get()) ; ++t.controlindex;
					}
					else
					{
						#ifdef VRTECH
						if ( t.tflagnotionofhealth == 1 )
						{
							setpropertystring2(t.group,Str(t.grideleprof.strength),t.strarr_s[454].Get(),t.strarr_s[244].Get()) ; ++t.controlindex;
						}
						#else
						setpropertystring2(t.group,Str(t.grideleprof.strength),t.strarr_s[454].Get(),t.strarr_s[244].Get()) ; ++t.controlindex;
						#endif
					}
					if (  t.tflagplayersettings == 1 ) 
					{
						if ( g.quickparentalcontrolmode != 2 )
						{
							setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.isviolent),"Blood Effects","Sets whether blood and screams should be used",0) ; ++t.controlindex;
						}
						#ifdef VRTECH
						if ( t.tflagnotionofhealth == 1 )
						{
							setpropertystring2(t.group,Str(t.playercontrol.regenrate),"Regeneration Rate","Sets the increase value at which the players health will restore")  ; ++t.controlindex;
							setpropertystring2(t.group,Str(t.playercontrol.regenspeed),"Regeneration Speed","Sets the speed in milliseconds at which the players health will regenerate") ; ++t.controlindex;
							setpropertystring2(t.group,Str(t.playercontrol.regendelay),"Regeneration Delay","Sets the delay in milliseconds after last damage hit before health starts regenerating") ; ++t.controlindex;
						}
						#else
						setpropertystring2(t.group,Str(t.playercontrol.regenrate),"Regeneration Rate","Sets the increase value at which the players health will restore")  ; ++t.controlindex;
						setpropertystring2(t.group,Str(t.playercontrol.regenspeed),"Regeneration Speed","Sets the speed in milliseconds at which the players health will regenerate") ; ++t.controlindex;
						setpropertystring2(t.group,Str(t.playercontrol.regendelay),"Regeneration Delay","Sets the delay in milliseconds after last damage hit before health starts regenerating") ; ++t.controlindex;
						#endif
					}
					setpropertystring2(t.group,Str(t.grideleprof.speed),t.strarr_s[455].Get(),t.strarr_s[245].Get()) ; ++t.controlindex;
					//PE: we cant do this , as t.playercontrol.thirdperson.enabled is a global and will trigger for ALL objects.
					//PE: https://github.com/TheGameCreators/GameGuruRepo/issues/310
//					if (  t.playercontrol.thirdperson.enabled == 1 ) 
//					{
//						t.tanimspeed_f=t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed;
//					}
//					else
//					{
						t.tanimspeed_f=t.grideleprof.animspeed;
//					}
					#ifdef VRTECH
					setpropertystring2(t.group,Str(t.tanimspeed_f),t.strarr_s[477].Get(),"Sets the default speed of any animation associated with this entity"); ++t.controlindex;
					#else
					setpropertystring2(t.group,Str(t.tanimspeed_f),"Anim Speed","Sets the default speed of any animation associated with this entity"); ++t.controlindex;
					#endif
				 }
				 if (  t.tflaghurtfall == 1 ) { setpropertystring2(t.group,Str(t.grideleprof.hurtfall),t.strarr_s[456].Get(),t.strarr_s[246].Get())  ; ++t.controlindex; }
				#endif
				if (  t.tflagplayersettings == 1 ) 
				{
					setpropertystring2(t.group,Str(t.playercontrol.jumpmax_f),"Jump Speed","Sets the jump speed of the player which controls overall jump height") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.playercontrol.gravity_f),"Gravity","Sets the modified force percentage of the players own gravity") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.playercontrol.fallspeed_f),"Fall Speed","Sets the maximum speed percentage at which the player will fall") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.playercontrol.climbangle_f),"Climb Angle","Sets the maximum angle permitted for the player to ascend a slope") ; ++t.controlindex;
					if (  t.playercontrol.thirdperson.enabled == 0 ) 
					{
						setpropertystring2(t.group,Str(t.playercontrol.wobblespeed_f),"Wobble Speed","Sets the rate of motion applied to the camera when moving") ; ++t.controlindex;
						setpropertystring2(t.group,Str(t.playercontrol.wobbleheight_f*100),"Wobble Height","Sets the degree of motion applied to the camera when moving") ; ++t.controlindex;
						setpropertystring2(t.group,Str(t.playercontrol.footfallpace_f*100),"Footfall Pace","Sets the rate at which the footfall sound is played when moving") ; ++t.controlindex;
					}
					setpropertystring2(t.group,Str(t.playercontrol.accel_f*100),"Acceleration","Sets the acceleration curve used when t.moving from t.a stood position") ; ++t.controlindex;
				}
				if ( t.tflagmobile == 1 ) { setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.isimmobile),t.strarr_s[457].Get(),t.strarr_s[247].Get(),0); ++t.controlindex; }
				if ( t.tflagmobile == 1 ) 
				{ 
					#ifdef VRTECH
					if ( t.tflagsimpler == 0 )
					{
						setpropertystring2(t.group,Str(t.grideleprof.lodmodifier),"LOD Modifier","Modify when the LOD transition takes effect. The default value is 0, increase this to a percentage reduce the LOD effect.") ; ++t.controlindex; 
					}
					#else
					setpropertystring2(t.group,Str(t.grideleprof.lodmodifier),"LOD Modifier","Modify when the LOD transition takes effect. The default value is 0, increase this to a percentage reduce the LOD effect.") ; ++t.controlindex; 
					#endif
				}
			}

			//  Team field
			#ifdef PHOTONMP
			#else
			if (  t.tflagteamfield == 1 ) 
			{
				setpropertylist3(t.group,t.controlindex,Str(t.grideleprof.teamfield),"Team","Specifies any team affiliation for multiplayer start marker",0) ; ++t.controlindex;
			}
			#endif

			//  Physics Data (non-multiplayer)
			if (  t.entityprofile[t.gridentity].ismarker == 0 && t.entityprofile[t.gridentity].islightmarker == 0 ) 
			{
				t.propfield[t.group]=t.controlindex;
				++t.group ; startgroup(t.strarr_s[596].Get()) ; t.controlindex=0;
				if (  t.grideleprof.physics != 1  )  t.grideleprof.physics = 0;
				setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.physics),t.strarr_s[580].Get(),t.strarr_s[581].Get(),0) ; ++t.controlindex;
				setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.phyalways),t.strarr_s[582].Get(),t.strarr_s[583].Get(),0) ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.grideleprof.phyweight),t.strarr_s[584].Get(),t.strarr_s[585].Get()) ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.grideleprof.phyfriction),t.strarr_s[586].Get(),t.strarr_s[587].Get()) ; ++t.controlindex;
				//     `setpropertystring2(group,Str(grideleprof.phyforcedamage),strarr$(588),strarr$(589)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.rotatethrow),strarr$(590),strarr$(591)) ; inc controlindex
				#ifdef VRTECH
				if ( t.tflagsimpler == 0 )
				{
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.explodable),t.strarr_s[592].Get(),t.strarr_s[593].Get(),0) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.explodedamage),t.strarr_s[594].Get(),t.strarr_s[595].Get()) ; ++t.controlindex;
				}
				#else
				setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.explodable),t.strarr_s[592].Get(),t.strarr_s[593].Get(),0) ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.grideleprof.explodedamage),t.strarr_s[594].Get(),t.strarr_s[595].Get()) ; ++t.controlindex;
				#endif
			}

			//  Ammo data (FPGC - 280809 - filtered fpgcgenre=1 is shooter genre
			if (  g.fpgcgenre == 1 ) 
			{
				if (  t.tflagammo == 1 || t.tflagammoclip == 1 ) 
				{
					t.propfield[t.group]=t.controlindex;
					++t.group ; startgroup(t.strarr_s[459].Get()) ; t.controlindex=0;
					setpropertystring2(t.group,Str(t.grideleprof.quantity),t.strarr_s[460].Get(),t.strarr_s[249].Get()) ; ++t.controlindex;
				}
			}

			//  Light data
			if (  t.tflaglight == 1 ) 
			{
				t.propfield[t.group]=t.controlindex;
				++t.group ; startgroup(t.strarr_s[461].Get()) ; t.controlindex=0; //PE: 461=Light
				setpropertystring2(t.group,Str(t.grideleprof.light.range),t.strarr_s[462].Get(),t.strarr_s[250].Get()) ; ++t.controlindex; //PE: 462=Light Range
				setpropertycolor2(t.group,t.grideleprof.light.color,t.strarr_s[463].Get(),t.strarr_s[251].Get()) ; ++t.controlindex; //PE: 463=Light Color
				#ifdef VRTECH
				if ( t.tflagsimpler == 0 )
				{
					setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.usespotlighting), "Spot Lighting", "Change dynamic light to spot lighting", 0); ++t.controlindex;
				}
				#else
				setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.usespotlighting), "Spot Lighting", "Change dynamic light to spot lighting", 0); ++t.controlindex;
				#endif
			}

			//  Decal data
			if (  t.tflagtdecal == 1 ) 
			{
				t.propfield[t.group]=t.controlindex;

				//  FPGC - 300710 - could never change base decal, so comment out this property (entity denotes decal choice)
				//     `inc group ; startgroup(strarr$(464)) ; controlindex=0
				//     `setpropertyfile2(group,grideleprof.basedecal$,strarr$(465),strarr$(252),"gamecore\\decals\\") ; inc controlindex

				//  Decal Particle data
				if (  t.tflagdecalparticle == 1 ) 
				{
					++t.group ; startgroup("Decal Particle") ; t.controlindex=0;
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.particleoverride),"Custom Settings","Whether you wish to override default settings",0) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.offsety),"OffsetY","Vertical adjustment of start position") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.scale),"Scale","A value from 0 to 100, denoting size of particle") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.randomstartx),"Random Start X","Random start area") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.randomstarty),"Random Start Y","Random start area") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.randomstartz),"Random Start Z","Random start area") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.linearmotionx),"Linear Motion X","Constant motion direction") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.linearmotiony),"Linear Motion Y","Constant motion direction") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.linearmotionz),"Linear Motion Z","Constant motion direction") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.randommotionx),"Random Motion X","Random motion direction") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.randommotiony),"Random Motion Y","Random motion direction") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.randommotionz),"Random Motion Z","Random motion direction") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.mirrormode),"Mirror Mode","Set to one to reverse the particle") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.camerazshift),"Camera Z Shift","Shift t.particle towards camera") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.scaleonlyx),"Scale Only X","Percentage X over Y scale") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.lifeincrement),"Life Increment","Control lifespan of particle") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.alphaintensity),"Alpha Intensity","Control alpha percentage of particle") ; ++t.controlindex;
					//  V118 - 060810 - knxrb - Decal animation setting (Added animation choice setting).
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.particle.animated),"Animated Text (  ( ure","Sets whether the t.particle t.decal Texture is animated or static.", 0)  ; ++t.controlindex;
				}
			}

			// Sound
			if ( t.tflagsound == 1 || t.tflagsoundset == 1 || tflagtext == 1 || tflagimage == 1 ) 
			{
				t.propfield[t.group]=t.controlindex;
				++t.group ;
				if ( tflagtext == 1 || tflagimage == 1 )
				{
					if ( tflagtext == 1 ) startgroup("Text");
					if ( tflagimage == 1 ) startgroup("Image");
				}
				else
				{
					startgroup("Media");
				}
				t.controlindex=0;
				if ( g.fpgcgenre == 1 ) 
				{
					if ( g.vrqcontrolmode != 0 )
					{
						#ifdef VRTECH
						if ( t.tflagsound == 1 ) { setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),t.strarr_s[469].Get(),t.strarr_s[253].Get(),"audiobank\\")  ; ++t.controlindex; }
						#else
						if ( t.tflagsound == 1 ) { setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),"Audio",t.strarr_s[253].Get(),"audiobank\\")  ; ++t.controlindex; }
						#endif
					}
					else
					{
						if ( t.tflagsound == 1 ) { setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),t.strarr_s[467].Get(),t.strarr_s[253].Get(),"audiobank\\")  ; ++t.controlindex; }
					}
					if ( t.tflagsoundset == 1 ) { setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),t.strarr_s[469].Get(),t.strarr_s[255].Get(),"audiobank\\voices\\")  ; ++t.controlindex; }
					if ( tflagtext == 1 ) { setpropertystring2(t.group,t.grideleprof.soundset_s.Get(),"Text to Appear","Enter text to appear in-level") ; ++t.controlindex; }
					if ( tflagimage == 1 ) { setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),"Image File","Select image to appear in-level","scriptbank\\images\\imagesinzone\\") ; ++t.controlindex; }
					if ( t.tflagnosecond == 0 ) 
					{
						if ( t.tflagsound == 1 || t.tflagsoundset == 1 )
						{ 
							setpropertyfile2(t.group,t.grideleprof.soundset1_s.Get(),t.strarr_s[468].Get(),t.strarr_s[254].Get(),"audiobank\\")  ; ++t.controlindex; 
							#ifdef VRTECH
							setpropertyfile2(t.group,t.grideleprof.soundset2_s.Get(),t.strarr_s[480].Get(),t.strarr_s[254].Get(),"audiobank\\")  ; ++t.controlindex; 
							setpropertyfile2(t.group,t.grideleprof.soundset3_s.Get(),t.strarr_s[481].Get(),t.strarr_s[254].Get(),"audiobank\\")  ; ++t.controlindex; 
							setpropertyfile2(t.group, t.grideleprof.soundset5_s.Get(), t.strarr_s[482].Get(), t.strarr_s[254].Get(), "audiobank\\"); ++t.controlindex;
							setpropertyfile2(t.group, t.grideleprof.soundset6_s.Get(), "Sound5", t.strarr_s[254].Get(), "audiobank\\"); ++t.controlindex;
							#else
							setpropertyfile2(t.group,t.grideleprof.soundset2_s.Get(),"Sound2",t.strarr_s[254].Get(),"audiobank\\")  ; ++t.controlindex; 
							setpropertyfile2(t.group,t.grideleprof.soundset3_s.Get(),"Sound3",t.strarr_s[254].Get(),"audiobank\\")  ; ++t.controlindex; 
							setpropertyfile2(t.group,t.grideleprof.soundset4_s.Get(),"Sound4",t.strarr_s[254].Get(),"audiobank\\")  ; ++t.controlindex; 
							#endif
						}
					}
				}
				else
				{
					if ( t.tflagsoundset == 1 ) 
					{
						setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),t.strarr_s[469].Get(),t.strarr_s[255].Get(),"audiobank\\voices\\") ; ++t.controlindex;
					}
					else
					{
						setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),t.strarr_s[467].Get(),t.strarr_s[253].Get(),"audiobank\\") ; ++t.controlindex;
					}
					setpropertyfile2(t.group,t.grideleprof.soundset1_s.Get(),t.strarr_s[468].Get(),t.strarr_s[254].Get(),"audiobank\\") ; ++t.controlindex;
				}
			}

			// Video
			if ( t.tflagvideo == 1 ) 
			{
				t.propfield[t.group]=t.controlindex;
				++t.group ; startgroup(t.strarr_s[597].Get()) ; t.controlindex=0;
				#ifdef VRTECH
				setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),t.strarr_s[469].Get(),t.strarr_s[599].Get(),"audiobank\\") ; ++t.controlindex;
				setpropertyfile2(t.group,t.grideleprof.soundset1_s.Get(),"Video Slot",t.strarr_s[601].Get(),"videobank\\") ; ++t.controlindex;
				#else
				setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),"Audio",t.strarr_s[599].Get(),"audiobank\\") ; ++t.controlindex;
				setpropertyfile2(t.group,t.grideleprof.soundset1_s.Get(),"Video",t.strarr_s[601].Get(),"videobank\\") ; ++t.controlindex;
				#endif
			}

			//  Third person settings
			if (  t.tflagplayersettings == 1 && t.playercontrol.thirdperson.enabled == 1 ) 
			{
				t.propfield[t.group]=t.controlindex;
				++t.group ; startgroup("Third Person") ; t.controlindex=0;
				t.livegroupforthirdperson=t.group;
				setpropertylist2(t.group,t.controlindex,Str(t.playercontrol.thirdperson.cameralocked),"Camera Locked","Fixes camera height and angle for third person view",0) ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.playercontrol.thirdperson.cameradistance),"Camera Distance","Sets the distance of the third person camera") ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.playercontrol.thirdperson.camerashoulder),"Camera X Offset","Sets the distance to shift the camera over shoulder") ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.playercontrol.thirdperson.cameraheight),"Camera Y Offset","Sets the vertical height of the third person camera. If more than twice the camera distance, camera collision disables") ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.playercontrol.thirdperson.camerafocus),"Camera Focus","Sets the camera X angle offset to align focus of the third person camera") ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.playercontrol.thirdperson.cameraspeed),"Camera Speed","Sets the retraction speed percentage of the third person camera") ; ++t.controlindex;
				setpropertylist2(t.group,t.controlindex,Str(t.playercontrol.thirdperson.camerafollow),"Run Mode","If set to yes, protagonist uses WASD t.movement mode",0) ; ++t.controlindex;
				setpropertylist2(t.group,t.controlindex,Str(t.playercontrol.thirdperson.camerareticle),"Show Reticle","Show the third person 'crosshair' reticle Dot ( ",0)  ; ++t.controlindex;
			}

		}

		//  End of data
		t.propfield[t.group]=t.controlindex;
		t.propfieldgroupmax=t.group;

		//  FPGC - 070510 - finish bulk entity properties population
		SetFileMapDWORD (  3,g.g_filemapoffset,0  ); g.g_filemapoffset += 4;
		SetFileMapDWORD (  3,0,1 );

	}

	//  FPGC - 070510 - close bulk file map
	SetEventAndWait ( 2 );
	#endif
}

void interface_copydatatoentity ( void )
{
	//  go through all active fields
	for ( t.iGroup = 0 ; t.iGroup<=  t.propfieldgroupmax; t.iGroup++ )
	{
		for ( t.iControl = 0 ; t.iControl<=  t.propfield[t.iGroup]-1; t.iControl++ )
		{

			//  Get data
			t.tfield_s = getpropertyfield(t.iGroup,t.iControl);
			t.tdata_s = getpropertydata(t.iGroup,t.iControl);

			//  If tdata$ was absolute file, truncate to remove first part
			if ( t.tdata_s.Get()[1] == ':' )
			{
				t.chopthis_s=g.rootdir_s;
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[413].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				#ifdef VRTECH
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[478].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[479].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				#endif
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[416].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[561].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[417].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[418].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[433].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[464].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"gamecore\\decals\\";
				LPSTR pPreferredFolder = "audiobank\\voices\\";
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[469].Get()) ) == 0 )  
				{
					// 151016 - determine if data points to voices folder
					if ( strnicmp ( t.tdata_s.Get() + strlen(t.chopthis_s.Get()), pPreferredFolder, strlen(pPreferredFolder) ) == NULL )
					{
						// default soundset entry into voices folder
						t.chopthis_s = t.chopthis_s + "audiobank\\voices\\";
					}
					else
					{
						// allow normal WAV sounds to be placed in character SoundSet slot (zombies)
						t.chopthis_s = t.chopthis_s;
						pPreferredFolder = NULL;
					}
				}
				t.tdata_s=Right(t.tdata_s.Get(),Len(t.tdata_s.Get())-Len(t.chopthis_s.Get()));
				if ( cstr(Lower(t.tfield_s.Get())) == cstr(Lower(t.strarr_s[464].Get())) 
				||	(cstr(Lower(t.tfield_s.Get())) == cstr(Lower(t.strarr_s[469].Get())) && pPreferredFolder != NULL) ) 
				{
					//  get path (folder name) only
					t.tdata_s=getpath(t.tdata_s.Get()) ; t.tdata_s=Left(t.tdata_s.Get(),Len(t.tdata_s.Get())-1);
				}
			}

			//  All YES and NO strings are auto converted if value expected
			t.tokay=1;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[413].Get()) ) == 0 )  t.tokay = 0;
			#ifdef VRTECH
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[478].Get()) ) == 0 )  t.tokay = 0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[479].Get()) ) == 0 )  t.tokay = 0;
			#endif
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[436].Get()) ) == 0 )  t.tokay = 0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[437].Get()) ) == 0 )  t.tokay = 0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[464].Get()) ) == 0 )  t.tokay = 0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[469].Get()) ) == 0 )  t.tokay = 0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[469].Get()) ) == 0 )  t.tokay = 0;
			if (  t.tokay == 1 ) 
			{
				if (  strcmp ( Lower(t.tdata_s.Get()) , Lower(t.strarr_s[470].Get()) ) == 0 )  t.tdata_s = "1";
				if (  strcmp ( Lower(t.tdata_s.Get()) , Lower(t.strarr_s[471].Get()) ) == 0 )  t.tdata_s = "0";
				if (  strcmp ( Lower(t.tdata_s.Get()) , Lower("no") ) == 0 )  t.tdata_s = "0";
				if (  strcmp ( Lower(t.tdata_s.Get()) , Lower("a") ) == 0 )  t.tdata_s = "1";
				if (  strcmp ( Lower(t.tdata_s.Get()) , Lower("b") ) == 0 )  t.tdata_s = "2";
			}

			//  FPGC - 070510 - add behaviour folder back, along with FPI (from combo friendly name to script filename)
			if (  cstr(Lower(t.tfield_s.Get())) == "behaviour" ) 
			{
				t.tdata_s = ""; t.tdata_s=t.tdata_s+"behaviours\\"+t.tdata_s+".fpi";
			}

			//  Clipped alternative
			t.tdataclipped_s=Left(t.tdata_s.Get(),63);

			//  get field data
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[413].Get()) ) == 0 )  t.grideleprof.name_s = t.tdataclipped_s;
			#ifdef VRTECH
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[478].Get()) ) == 0 )  t.grideleprof.name_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[479].Get()) ) == 0 )  t.grideleprof.name_s = t.tdataclipped_s;
			#endif
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[414].Get()) ) == 0 )  t.gridentitystaticmode = ValF(t.tdata_s.Get());
			// if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[561].Get()) ) == 0 )  t.grideleprof.aiinit_s = t.tdataclipped_s; //PE: Not used anymore.
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[417].Get()) ) == 0 )  t.grideleprof.aimain_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , "behaviour" ) == 0 )  t.grideleprof.aimain_s = t.tdataclipped_s;
			//if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[418].Get()) ) == 0 )  t.grideleprof.aidestroy_s = t.tdataclipped_s;  //PE: Not used anymore.
			//if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[433].Get()) ) == 0 )  t.grideleprof.aishoot_s = t.tdataclipped_s; //PE: Not used anymore.
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[434].Get()) ) == 0 )  t.grideleprof.coneangle = ValF(t.tdata_s.Get());
			#ifdef VRTECH
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[476].Get()) ) == 0 )  t.grideleprof.conerange = ValF(t.tdata_s.Get());
			#else
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("View Range") ) == 0 )  t.grideleprof.conerange = ValF(t.tdata_s.Get());
			#endif
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[419].Get()) ) == 0 )  t.grideleprof.hasweapon_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[436].Get()) ) == 0 )  t.grideleprof.usekey_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[437].Get()) ) == 0 )  t.grideleprof.ifused_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[562].Get()) ) == 0 )  t.grideleprof.spawnatstart = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[440].Get()) ) == 0 )  t.grideleprof.spawnmax = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[441].Get()) ) == 0 )  t.grideleprof.spawnupto = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[442].Get()) ) == 0 )  t.grideleprof.spawnafterdelay = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[443].Get()) ) == 0 )  t.grideleprof.spawnwhendead = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[444].Get()) ) == 0 )  t.grideleprof.spawndelay = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[445].Get()) ) == 0 )  t.grideleprof.spawnqty = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[564].Get()) ) == 0 )  t.grideleprof.spawndelayrandom = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[566].Get()) ) == 0 )  t.grideleprof.spawnqtyrandom = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[568].Get()) ) == 0 )  t.grideleprof.spawnvel = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[570].Get()) ) == 0 )  t.grideleprof.spawnvelrandom = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[572].Get()) ) == 0 )  t.grideleprof.spawnangle = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[574].Get()) ) == 0 )  t.grideleprof.spawnanglerandom = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[576].Get()) ) == 0 )  t.grideleprof.spawnlife = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[447].Get()) ) == 0 )  t.grideleprof.texd_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[448].Get()) ) == 0 )  t.grideleprof.texaltd_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[578].Get()) ) == 0 )  t.grideleprof.effect_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[449].Get()) ) == 0 )  t.grideleprof.transparency = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[450].Get()) ) == 0 )  t.grideleprof.reducetexture = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[454].Get()) ) == 0 )  t.grideleprof.strength = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[453].Get()) ) == 0 )  t.grideleprof.strength = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[457].Get()) ) == 0 )  t.grideleprof.isimmobile = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("LOD Modifier") ) == 0 ) 
			{
				// 301115 - new LOD Modifie value for this entity parent, so propagate to ALL other entities of this parent
				t.grideleprof.lodmodifier = ValF(t.tdata_s.Get());
				int iThisBankIndex = t.gridentity;
				if ( t.entityprofile[iThisBankIndex].addhandlelimb==0 )
				{
					for ( int e=1; e<=g.entityelementlist; e++ )
					{
						if ( t.entityelement[e].bankindex==iThisBankIndex )
						{
							t.entityelement[e].eleprof.lodmodifier = t.grideleprof.lodmodifier;
							entity_calculateentityLODdistances ( iThisBankIndex, t.entityelement[e].obj, t.entityelement[e].eleprof.lodmodifier );
						}
					}
					int iParentSrcObj = g.entitybankoffset + iThisBankIndex;
					entity_calculateentityLODdistances ( iThisBankIndex, iParentSrcObj, t.grideleprof.lodmodifier );
				}
			}
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Occluder") ) == 0 )  t.grideleprof.isocluder = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Occludee") ) == 0 )  t.grideleprof.isocludee = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Specular") ) == 0 )  t.grideleprof.specularperc = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("End Collision") ) == 0 )  t.grideleprof.colondeath = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Parent Index") ) == 0 )  t.grideleprof.parententityindex = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Parent Limb") ) == 0 )  t.grideleprof.parentlimbindex = ValF(t.tdata_s.Get());

			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[429].Get()) ) == 0 )  t.grideleprof.cantakeweapon = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[430].Get()) ) == 0 )  t.grideleprof.quantity = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[431].Get()) ) == 0 )  t.grideleprof.rateoffire = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[420].Get()) ) == 0 )  t.grideleprof.damage = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[421].Get()) ) == 0 )  t.grideleprof.accuracy = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[422].Get()) ) == 0 )  t.grideleprof.reloadqty = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[423].Get()) ) == 0 )  t.grideleprof.fireiterations = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Range") ) == 0 )  t.grideleprof.range = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Dropoff") ) == 0 )  t.grideleprof.dropoff = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Spot Lighting") ) == 0 )  t.grideleprof.usespotlighting = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[424].Get()) ) == 0 )  t.grideleprof.lifespan = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[425].Get()) ) == 0 )  t.grideleprof.throwspeed = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[426].Get()) ) == 0 )  t.grideleprof.throwangle = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[427].Get()) ) == 0 )  t.grideleprof.bounceqty = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[428].Get()) ) == 0 )  t.grideleprof.explodeonhit = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[455].Get()) ) == 0 )  t.grideleprof.speed = ValF(t.tdata_s.Get());
			#ifdef VRQUEST
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[477].Get()) ) == 0 ) 
			{
				if (  t.playercontrol.thirdperson.enabled == 1 ) 
				{
					t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed=ValF(t.tdata_s.Get());
				}
				else
				{
					t.grideleprof.animspeed=ValF(t.tdata_s.Get());
				}
			}
			#else
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Anim Speed") ) == 0 ) 
			{
				//PE: we cant do this , as t.playercontrol.thirdperson.enabled is a global and will trigger for ALL objects.
				//PE: https://github.com/TheGameCreators/GameGuruRepo/issues/310
//				if (  t.playercontrol.thirdperson.enabled == 1 ) 
//				{
//					t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed=ValF(t.tdata_s.Get());
//				}
//				else
//				{
					t.grideleprof.animspeed=ValF(t.tdata_s.Get());
//				}
			}
			#endif
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[432].Get()) ) == 0 )  t.grideleprof.quantity = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[460].Get()) ) == 0 )  t.grideleprof.quantity = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[452].Get()) ) == 0 )  t.grideleprof.lives = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[456].Get()) ) == 0 )  t.grideleprof.hurtfall = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Blood Effects")  ) == 0 ) t.grideleprof.isviolent = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Regeneration Rate")  ) == 0 ) t.playercontrol.regenrate = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Regeneration Speed")  ) == 0 ) t.playercontrol.regenspeed = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Regeneration Delay")  ) == 0 ) t.playercontrol.regendelay = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Jump Speed")  ) == 0 ) t.playercontrol.jumpmax_f = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Gravity")  ) == 0 ) t.playercontrol.gravity_f = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Fall Speed")  ) == 0 ) t.playercontrol.fallspeed_f = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Climb Angle")  ) == 0 ) t.playercontrol.climbangle_f = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Wobble Speed")  ) == 0 ) t.playercontrol.wobblespeed_f = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Wobble Height")  ) == 0 ) t.playercontrol.wobbleheight_f = ValF(t.tdata_s.Get())/100.0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Footfall Pace")  ) == 0 ) t.playercontrol.footfallpace_f = ValF(t.tdata_s.Get())/100.0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Acceleration")  ) == 0 ) t.playercontrol.accel_f = ValF(t.tdata_s.Get())/100.0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Camera Locked")  ) == 0 ) t.playercontrol.thirdperson.cameralocked = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Camera Distance")  ) == 0 ) t.playercontrol.thirdperson.cameradistance = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Camera Y Offset")  ) == 0 ) t.playercontrol.thirdperson.cameraheight = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Camera Focus")  ) == 0 ) t.playercontrol.thirdperson.camerafocus = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Camera Speed")  ) == 0 ) t.playercontrol.thirdperson.cameraspeed = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Camera X Offset")  ) == 0 ) t.playercontrol.thirdperson.camerashoulder = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Run Mode")  ) == 0 ) t.playercontrol.thirdperson.camerafollow = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Show Reticle")  ) == 0 ) t.playercontrol.thirdperson.camerareticle = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[458].Get()) ) == 0 )  t.grideleprof.isobjective = ValF(t.tdata_s.Get());
			// if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[464].Get()) ) == 0 )  t.grideleprof.basedecal_s = t.tdataclipped_s; //PE: Not used anymore.

			//  FPGC - 300710 - read data changes back into grideleprof
			if (  strcmp ( Lower(t.tfield_s.Get()) , "custom settings"  ) == 0 ) t.grideleprof.particleoverride = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "offsety"  ) == 0 )  t.grideleprof.particle.offsety = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "scale"  ) == 0 )  t.grideleprof.particle.scale = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "random start x"  ) == 0 )  t.grideleprof.particle.randomstartx = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "random start y"  ) == 0 )  t.grideleprof.particle.randomstarty = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "random start z"  ) == 0 )  t.grideleprof.particle.randomstartz = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "linear motion x"  ) == 0 )  t.grideleprof.particle.linearmotionx = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "linear motion y"  ) == 0 )  t.grideleprof.particle.linearmotiony = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "linear motion z"  ) == 0 )  t.grideleprof.particle.linearmotionz = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "random motion x"  ) == 0 )  t.grideleprof.particle.randommotionx = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "random motion y"  ) == 0 )  t.grideleprof.particle.randommotiony = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "random motion z"  ) == 0 )  t.grideleprof.particle.randommotionz = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "mirror mode"  ) == 0 )  t.grideleprof.particle.mirrormode = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "camera z shift"  ) == 0 )  t.grideleprof.particle.camerazshift = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "scale only x"  ) == 0 )  t.grideleprof.particle.scaleonlyx = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "life increment"  ) == 0 )  t.grideleprof.particle.lifeincrement = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "alpha intensity"  ) == 0 )  t.grideleprof.particle.alphaintensity = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "animated texture"  ) == 0 )  t.grideleprof.particle.animated , ValF(t.tdata_s.Get()) ;

			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[467].Get()) ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[468].Get()) ) == 0 )  t.grideleprof.soundset1_s = t.tdataclipped_s;
			#ifdef VRTECH
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[480].Get()) ) == 0 )  t.grideleprof.soundset2_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[481].Get()) ) == 0 )  t.grideleprof.soundset3_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[482].Get())) == 0)	t.grideleprof.soundset5_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Sound5")) == 0)					t.grideleprof.soundset6_s = t.tdataclipped_s;
			#else
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Sound2") ) == 0 )  t.grideleprof.soundset2_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Sound3") ) == 0 )  t.grideleprof.soundset3_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Sound4") ) == 0 )  t.grideleprof.soundset4_s = t.tdataclipped_s;
			#endif
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[469].Get()) ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[598].Get()) ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[600].Get()) ) == 0 )  t.grideleprof.soundset1_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , "voiceover"  ) == 0 ) t.grideleprof.soundset1_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[462].Get()) ) == 0 )  t.grideleprof.light.range = ValF(t.tdata_s.Get());
			#ifdef VRTECH
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Text to Appear") ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Image File") ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[469].Get()) ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Video Slot") ) == 0 )  t.grideleprof.soundset1_s = t.tdataclipped_s;
			#else
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Text String") ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Image File") ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Audio") ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Video") ) == 0 )  t.grideleprof.soundset1_s = t.tdataclipped_s;
			#endif

			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[580].Get()) ) == 0 )  t.grideleprof.physics = ValF(t.tdata_s.Get());
			if (  t.grideleprof.physics != 1  )  t.grideleprof.physics = 2;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[582].Get()) ) == 0 )  t.grideleprof.phyalways = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[584].Get()) ) == 0 )  t.grideleprof.phyweight = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[586].Get()) ) == 0 )  t.grideleprof.phyfriction = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[588].Get()) ) == 0 )  t.grideleprof.phyforcedamage = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[590].Get()) ) == 0 )  t.grideleprof.rotatethrow = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[592].Get()) ) == 0 )  t.grideleprof.explodable = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[594].Get()) ) == 0 )  t.grideleprof.explodedamage = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("team")  ) == 0 )  t.grideleprof.teamfield = ValF(t.tdata_s.Get());

			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[463].Get()) ) == 0 ) 
			{
				t.tr_s=t.tdata_s;
				for ( t.t = 1 ; t.t<=  Len(t.tr_s.Get()); t.t++ )
				{
					if (  t.tr_s.Get()[t.t-1] == ' ' ) { t.tr_s = Left(t.tr_s.Get(),t.t) ; break; }
				}
				t.tdata_s=Right(t.tdata_s.Get(),(Len(t.tdata_s.Get())-Len(t.tr_s.Get())));
				t.tg_s=t.tdata_s;
				for ( t.t = 1 ; t.t<=  Len(t.tg_s.Get()); t.t++ )
				{
					if (  t.tg_s.Get()[t.t-1] == ' ' ) { t.tg_s = Left(t.tg_s.Get(),t.t)  ; break; }
				}
				t.tb_s=Right(t.tdata_s.Get(),(Len(t.tdata_s.Get())-Len(t.tg_s.Get())));
				t.grideleprof.light.color=Rgb(ValF(t.tr_s.Get()),ValF(t.tg_s.Get()),ValF(t.tb_s.Get()));
			}

		}
	}
}

void interface_closepropertywindow ( void )
{
	//  Close proprty window
	#ifdef FPSEXCHANGE
	if (  t.editorinterfaceactive>0 )
	{
		//  Close dialog
		OpenFileMap (  1, "FPSEXCHANGE" );
		SetFileMapDWORD (  1, 978, 2 );
		SetFileMapDWORD (  1, 462, 0 );
		SetEventAndWait (  1 );
		t.editorinterfaceactive=0;
	}
	#endif
}

void interface_handlepropertywindow ( void )
{
	#ifdef FPSEXCHANGE
	//  If interface active
	if (  t.editorinterfaceactive>0 ) 
	{
		//  Open for management
		OpenFileMap (  2, "FPSENTITY" );
		SetEventAndWait (  2 );

		//  if APPLY clicked, copy data to entity
		if (  GetFileMapDWORD( 2, 112 ) == 1 ) 
		{
			interface_copydatatoentity ( );
			SetFileMapDWORD (  2, 112, 0 );
			SetEventAndWait (  2 );
			t.editorinterfaceleave=1;
			t.interactive.applychangesused=1;
		}

		//  see if the user clicked on the close button
		if (  GetFileMapDWORD( 2, 108 )  ==  1 ) 
		{
			SetFileMapDWORD (  2, 108, 0 );
			SetEventAndWait (  2 );
			t.editorinterfaceleave=1;
		}

		//  see if the user clicked on the CANCEL button
		if (  GetFileMapDWORD( 2, 116 )  ==  1 ) 
		{
			SetFileMapDWORD (  2, 116, 0 );
			SetEventAndWait (  2 );
			t.editorinterfaceleave=1;
		}
	}
	#endif
}

void interface_live_updates(void)
{
	#ifdef FPSEXCHANGE
	//  constantly open access to properties values
	//  so can represent the values prior to using APPLY CHANGES
	if (Timer() > t.lastliveupdatestimer)
	{
		t.lastliveupdatestimer = Timer() + 200;
		OpenFileMap(2, "FPSENTITY");
		SetEventAndWait(2);
		t.iGroup = t.livegroupforthirdperson;
		t.iControl = 1; t.tfield_s = getpropertyfield(t.iGroup, t.iControl); t.tdata_s = getpropertydata(t.iGroup, t.iControl);
		if (cstr(Lower(t.tfield_s.Get())) == Lower("Camera Distance"))  t.playercontrol.thirdperson.livecameradistance = ValF(t.tdata_s.Get());
		t.iControl = 2; t.tfield_s = getpropertyfield(t.iGroup, t.iControl); t.tdata_s = getpropertydata(t.iGroup, t.iControl);
		if (cstr(Lower(t.tfield_s.Get())) == Lower("Camera X Offset"))  t.playercontrol.thirdperson.livecamerashoulder = ValF(t.tdata_s.Get());
		t.iControl = 3; t.tfield_s = getpropertyfield(t.iGroup, t.iControl); t.tdata_s = getpropertydata(t.iGroup, t.iControl);
		if (cstr(Lower(t.tfield_s.Get())) == Lower("Camera Y Offset"))  t.playercontrol.thirdperson.livecameraheight = ValF(t.tdata_s.Get());
		t.iControl = 4; t.tfield_s = getpropertyfield(t.iGroup, t.iControl); t.tdata_s = getpropertydata(t.iGroup, t.iControl);
		if (cstr(Lower(t.tfield_s.Get())) == Lower("Camera Focus"))  t.playercontrol.thirdperson.livecamerafocus = ValF(t.tdata_s.Get());
		//CloseFileMap (  2 );
	}
	#endif
}

// 
//  Interface Properties Functions
// 

#ifdef ENABLEIMGUI
char* imgui_setpropertyfile2_ex_dlua(int group, char* data_s, char* field_s, char* desc_s, char* within_s, int* piEditedField, char* pButtonControlIfBlocked)
{
	char *cRet;
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s, lwithin_s = within_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";
	if (cstr(within_s) == "" || !within_s)  lwithin_s = "";

	std::string uniquiField = "";
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	if (lfields_s != "") {
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
		ImGui::Text(lfields_s.Get());
		ImGui::SameLine();
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
		#ifndef WICKEDENGINE
		ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
		#endif
	}
	strcpy(cTmpInput, ldata_s.Get());

#ifdef WICKEDENGINE
	ImGui::PushItemWidth(-ImGui::CalcTextSize(lfields_s.Get()).x);

	// Display the filename only.
	char filename[MAX_PATH];
	int iCopyLocation = 0;
	for (int i = strlen(cTmpInput) - 1; i >= 0; i--)
	{
		if (cTmpInput[i] == '/' || cTmpInput[i] == '\\')
		{
			iCopyLocation = i+1;
			break;
		}
	}
	strcpy(filename, cTmpInput + iCopyLocation);
	ImGui::InputText(uniquiField.c_str(), &filename[0], MAXTEXTINPUT, ImGuiInputTextFlags_ReadOnly);
	#else
	ImGui::PushItemWidth(-10 - ((ImGui::GetFontSize()*2.0)*3.0) - 2); //-6 padding.
	ImGui::InputText(uniquiField.c_str(), &cTmpInput[0], MAXTEXTINPUT);
	#endif

	if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());
	if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

	ImGui::PopItemWidth();
	ImGui::SameLine();

	uniquiField = "...";
	uniquiField = uniquiField + "##";
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	ImGui::PushItemWidth(ImGui::GetFontSize()*2.0);

	bool bAudio = false;
	bool bImage = false;
	bool bVideo = false;
	bool bScript = false;
	bool bParticle = false;
	bool bUseNewAudioWindow = false;
#ifdef USENEWMEDIASELECTWINDOWS
	//bUseNewAudioWindow = true;
	if (pestrcasestr(lwithin_s.Get(), "audiobank"))
	{
		bUseNewAudioWindow = true;
		bAudio = true;
	}
	if (pestrcasestr(lwithin_s.Get(), "\\imagesinzone"))
	{
		bUseNewAudioWindow = true;
		bImage = true;
	}
	if (pestrcasestr(lwithin_s.Get(), "imagebank"))
	{
		bUseNewAudioWindow = true;
		bImage = true;
	}
	if (pestrcasestr(lwithin_s.Get(), "videobank"))
	{
		bUseNewAudioWindow = true;
		bVideo = true;
	}
	if (pestrcasestr(lwithin_s.Get(), "scriptbank"))
	{
		bUseNewAudioWindow = true;
		bScript = true;
	}
	if (pestrcasestr(lwithin_s.Get(), "particlesbank"))
	{
		bUseNewAudioWindow = true;
		bParticle = true;
	}

#endif

	if (bUseNewAudioWindow )
	{
		ImGuiWindow* window = ImGui::GetCurrentWindow();

		bool bProceed = true;
		if (piEditedField)
		{
			if (*piEditedField == 2)
			{
				bProceed = false;
			}
		}
		if (!bProceed)
		{
			ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
			ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
		}
		if (ImGui::StyleButton(uniquiField.c_str(), ImVec2(ImGui::GetFontSize()*1.48, 0)) || iSelectedLibraryStingReturnID == window->GetID(uniquiField.c_str()))
		{
			if (bProceed == true)
			{
				cStr tOldDir = GetDir();
				if (iSelectedLibraryStingReturnID == window->GetID(uniquiField.c_str()))
				{
					//Update selected var.
					//MessageBoxA(NULL, sSelectedLibrarySting.Get(), "ReturnVar", 0);

					char * cFileSelected = sSelectedLibrarySting.Get();

					SetDir(tOldDir.Get());

					if (cFileSelected && strlen(cFileSelected) > 0)
					{
						if (piEditedField) *piEditedField = 1;
						std::string relative = cFileSelected;
						std::string fullpath = tOldDir.Get();
						fullpath += "\\";
						if (pestrcasestr(lwithin_s.Get(), "scriptbank"))
							fullpath += lwithin_s.Get();
						replaceAll(relative, fullpath, "");
						strcpy(cTmpInput, relative.c_str());
					}

					iSelectedLibraryStingReturnID = -1; //disable.
					sSelectedLibrarySting = "";
				}
				else
				{
					bExternal_Entities_Window = true;
					iDisplayLibraryType = 0;
					iDisplayLibrarySubType = 0;
					if (bAudio)
						iDisplayLibraryType = 1;
					if (bImage)
						iDisplayLibraryType = 2;
					if (bVideo)
						iDisplayLibraryType = 3;
					if (bScript)
						iDisplayLibraryType = 4;
					if (bParticle)
						iDisplayLibraryType = 5;

					iLibraryStingReturnToID = window->GetID(uniquiField.c_str());
					if (iDisplayLibraryType > 0)
					{
						if (strlen(cTmpInput) > 0)
							sMakeDefaultSelecting = cTmpInput;
					}

				}
			}
		}

		if (!bProceed)
		{
			ImGui::PopItemFlag();
			ImGui::PopStyleVar();
		}

	}
	else
	{
		if (ImGui::StyleButton(uniquiField.c_str(), ImVec2(ImGui::GetFontSize()*1.48, 0)))
		{
			bool bProceed = true;
			if (piEditedField)
			{
				if (*piEditedField == 2)
				{
					MessageBoxA(NULL, pButtonControlIfBlocked, "Notification", MB_OK);
					bProceed = false;
				}
			}
			if (bProceed == true)
			{
				cStr tOldDir = GetDir();
				char * cFileSelected;
				cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "All\0*.*\0", lwithin_s.Get(), NULL);
				SetDir(tOldDir.Get());
				if (cFileSelected && strlen(cFileSelected) > 0)
				{
					if (piEditedField) *piEditedField = 1;
					std::string relative = cFileSelected;
					std::string fullpath = tOldDir.Get();
					fullpath += "\\";
					if (pestrcasestr(lwithin_s.Get(), "scriptbank"))
						fullpath += lwithin_s.Get();
					replaceAll(relative, fullpath, "");
					strcpy(cTmpInput, relative.c_str());
				}
			}
		}
	}
	ImGui::PopItemWidth();

	return &cTmpInput[0];

}

char* imgui_setpropertyfile2_dlua(int group, char* data_s, char* field_s, char* desc_s, char* within_s)
{
	return imgui_setpropertyfile2_ex_dlua(group, data_s, field_s, desc_s, within_s, NULL, NULL);
}

char * imgui_setpropertyfile2(int group, char* data_s, char* field_s, char* desc_s, char* within_s)
{
	char *cRet;
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s, lwithin_s = within_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";
	if (cstr(within_s) == "" || !within_s)  lwithin_s = "";

	std::string uniquiField = "";
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	if (lfields_s != "") {
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
		ImGui::Text(lfields_s.Get());
		ImGui::SameLine();
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
		ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
	}
	strcpy(cTmpInput, ldata_s.Get());

	bool bSoundSet = false;
	if (pestrcasestr(lfields_s.Get(), "soundset") || lfields_s == "Type") {
		bSoundSet = true;
	}
	if (bSoundSet && t.entityprofile[t.gridentity].ischaracter > 0) {

		ImGui::PushItemWidth(-10);

		//Only displayt Male,FeMale selection.
		const char* items[] = { "Male", "Female" };
		int item_current_type_selection = 0; //Default Custom.
		if (pestrcasestr(cTmpInput, "Female")) {
			item_current_type_selection = 1;
		}
		if (ImGui::Combo(uniquiField.c_str(), &item_current_type_selection, items, IM_ARRAYSIZE(items))) {
			strcpy(cTmpInput, items[item_current_type_selection]);
		}
		if (ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());

		ImGui::PopItemWidth();
		return &cTmpInput[0];

	}

	ImGui::PushItemWidth( -10 - (ImGui::GetFontSize()*2.0) ); //-6 padding.

	ImGui::InputText(uniquiField.c_str(), &cTmpInput[0], MAXTEXTINPUT);
	if (ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());
	if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

	ImGui::PopItemWidth();
	ImGui::SameLine();

	uniquiField = "...";
	uniquiField = uniquiField + "##";
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	ImGui::PushItemWidth(ImGui::GetFontSize()*2.0);

	if (ImGui::StyleButton(uniquiField.c_str(), ImVec2(ImGui::GetFontSize()*1.48, 0))) { //ImVec2(ImGui::GetFontSize()*2.0,0)
		//PE: filedialogs change dir so.
		cStr tOldDir = GetDir();
		char * cFileSelected;
		//NOC_FILE_DIALOG_DIR
//		if(bSoundSet)
//			cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_DIR, "All\0*.*\0", lwithin_s.Get(), NULL);
//		else
			cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "All\0*.*\0", lwithin_s.Get(), NULL);

		SetDir(tOldDir.Get());

		if (cFileSelected && strlen(cFileSelected) > 0) {
			std::string relative = cFileSelected;
			std::string fullpath = tOldDir.Get();
			fullpath += "\\";

			// scriptbank\  //
			if (bSoundSet || pestrcasestr(lwithin_s.Get(), "scriptbank")) {
				if( pestrcasestr(cFileSelected,".lua"))
					fullpath += "scriptbank\\"; //lwithin_s.Get(); PE: This can change in parent mode 2
			}

			replaceAll(relative, fullpath , "");
			strcpy(cTmpInput, relative.c_str() );

			if (bSoundSet) {
				char *found = (char *) pestrcasestr(cTmpInput, "\\");
				if (found)
					found[0] = 0;
				//Remove everything after \\

			}
		}
		//File Selector.
	}

	ImGui::PopItemWidth();

	return &cTmpInput[0];

}

char * imgui_setpropertystring2(int group, char* data_s, char* field_s, char* desc_s)
{
	char *cRet;
	cstr ldata_s = data_s, ldesc_s = desc_s , lfields_s = field_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";

	std::string uniquiField = ""; //lfields_s.Get();
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField  = uniquiField+ std::to_string(grideleprof_uniqui_id++);

	if (lfields_s != "") {
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
		ImGui::Text(lfields_s.Get());
		ImGui::SameLine();
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
		ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
	}
	ImGui::PushItemWidth(-10);

	int inputFlags = 0;
//	if (!ImGui::IsWindowHovered()) //Not needed input is already disabled in rendertarget.
//		inputFlags = ImGuiInputTextFlags_ReadOnly;

	strcpy(cTmpInput, ldata_s.Get());
	if (ImGui::InputText(uniquiField.c_str(), &cTmpInput[0], MAXTEXTINPUT, inputFlags)) {
		bImGuiGotFocus = true;
	}
	if (ImGui::IsItemHovered() && ldesc_s != "" ) ImGui::SetTooltip("%s", ldesc_s.Get());
	if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

	ImGui::PopItemWidth();

	return &cTmpInput[0];
}

char * imgui_setpropertylist2c(int group, int controlindex, char* data_s, char* field_s, char* desc_s, int listtype)
{
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";

	int current_selection = atoi(ldata_s.Get());


	int listmax = 0;
	listmax = 0;
	if (listtype == 0)
	{
		listmax = 1;
		t.list_s[0] = t.strarr_s[471];
		t.list_s[1] = t.strarr_s[470];
	}
	if (listtype == 1)
	{
		listmax = fillgloballistwithweaponsQuick(false, true, true);
		for (int n = 0; n <= listmax; n++)
		{
			if (ldata_s == t.list_s[n]) {
				current_selection = n;
				break;
			}
		}
	}
	if (listtype == 11)
	{
		listmax = fillgloballistwithbehaviours();
		for (int n = 0; n <= listmax; n++)
		{
			if (ldata_s == t.list_s[n]) {
				current_selection = n;
				break;
			}
		}
	}

	const char* current_item = t.list_s[current_selection].Get();

	std::string uniquiField = ""; //lfields_s.Get()
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);


	ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
	ImGui::Text(lfields_s.Get());
	ImGui::SameLine();
	ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
	ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));

	ImGui::PushItemWidth(-10);

	if (ImGui::BeginCombo(uniquiField.c_str() , current_item)) // The second parameter is the label previewed before opening the combo.
	{
		for (int n = 0; n <= listmax; n++)
		{
			bool is_selected = (current_item == t.list_s[n].Get()); // You can store your selection however you want, outside or inside your objects
			if (ImGui::Selectable(t.list_s[n].Get(), is_selected)) {
				current_selection = n;
				current_item = t.list_s[n].Get();
			}
			if (is_selected)
				ImGui::SetItemDefaultFocus();   // You may set the initial focus when opening the combo (scrolling + for keyboard navigation support)
		}
		ImGui::EndCombo();
	}
	
	ImGui::PopItemWidth();
	return t.list_s[current_selection].Get();
}

int imgui_setpropertylist2(int group, int controlindex, char* data_s, char* field_s, char* desc_s, int listtype)
{
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";

	int current_selection = atoi(ldata_s.Get());


	int listmax = 0;

	listmax = 0;
	if (listtype == 0)
	{
		listmax = 1;
		t.list_s[0] = t.strarr_s[471];
		t.list_s[1] = t.strarr_s[470];
	}
	if (listtype == 1)
	{
		listmax = fillgloballistwithweapons();
	}
	if (listtype == 11)
	{
		listmax = fillgloballistwithbehaviours();
	}

	const char* current_item = t.list_s[current_selection].Get();
	
	std::string uniquiField = ""; //lfields_s.Get()
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
	ImGui::Text(lfields_s.Get());
	ImGui::SameLine();
	ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
	ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));

	ImGui::PushItemWidth(-10);

	if (ImGui::BeginCombo(uniquiField.c_str() , current_item)) // The second parameter is the label previewed before opening the combo.
	{
		for (int n = 0; n <= listmax; n++)
		{
			bool is_selected = (current_item == t.list_s[n].Get() ); // You can store your selection however you want, outside or inside your objects
			if (ImGui::Selectable(t.list_s[n].Get(), is_selected)) {
				current_selection = n;
				current_item = t.list_s[n].Get();
			}
			if (is_selected)
				ImGui::SetItemDefaultFocus();   // You may set the initial focus when opening the combo (scrolling + for keyboard navigation support)
		}
		ImGui::EndCombo();
	}
	if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", ldesc_s.Get() );

	ImGui::PopItemWidth();
	return current_selection;
}
#endif

#ifdef FPSEXCHANGE

void startgroup ( char* s_s )
{
	if (  cstr(s_s) == ""  )  s_s = "";
	SetFileMapDWORD (  3,g.g_filemapoffset,2  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(s_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,s_s  ); g.g_filemapoffset += ((Len(s_s)+3)/4 )*4;
}

void endgroup ( void )
{
	SetFileMapDWORD (  3,g.g_filemapoffset,0  ); g.g_filemapoffset += 4;
}

void setpropertystring2 ( int group, char* data_s, char* field_s, char* desc_s )
{
	if (  cstr(data_s) == ""  )  data_s = "";
	SetFileMapDWORD (  3,g.g_filemapoffset,3  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,group  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(field_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,field_s  ); g.g_filemapoffset += ((Len(field_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(data_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,data_s  ); g.g_filemapoffset += ((Len(data_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(desc_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,desc_s  ); g.g_filemapoffset += ((Len(desc_s)+3)/4 )*4;
}

void setpropertycolor2 ( int group, int dataval, char* field_s, char* desc_s )
{
	cstr data_s =  "";
	data_s=data_s+Str(RgbR(dataval))+" "+Str(RgbG(dataval))+" "+Str(RgbB(dataval));
	SetFileMapDWORD (  3,g.g_filemapoffset,4  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,group  );  g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(field_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,field_s ); g.g_filemapoffset += ((Len(field_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(data_s.Get())  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,data_s.Get()); g.g_filemapoffset += ((Len(data_s.Get())+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(desc_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,desc_s  ); g.g_filemapoffset += ((Len(desc_s)+3)/4 )*4;
//endfunction

}

void setpropertyfile2 ( int group, char* data_s, char* field_s, char* desc_s, char* within_s )
{
	cstr s_s =  "";
	if (  cstr(data_s) == ""  )  data_s = "";
	SetFileMapDWORD (  3,g.g_filemapoffset,5  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,group  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(field_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,field_s  ); g.g_filemapoffset += ((Len(field_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(data_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,data_s  ); g.g_filemapoffset += ((Len(data_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(desc_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,desc_s ); g.g_filemapoffset += ((Len(desc_s)+3)/4 )*4;
	s_s = g.rootdir_s+within_s;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(s_s.Get())  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,s_s.Get()  ); g.g_filemapoffset += ((Len(s_s.Get())+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(t.strarr_s[321].Get())  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,t.strarr_s[321].Get() ); g.g_filemapoffset += ((Len(t.strarr_s[321].Get())+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(t.strarr_s[322].Get()) ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,t.strarr_s[322].Get() ); g.g_filemapoffset += ((Len(t.strarr_s[322].Get())+3)/4 )*4;
//endfunction

}

void setpropertylist2 ( int group, int controlindex, char* data_s, char* field_s, char* desc_s, int listtype )
{
	int listmax = 0;
	if ( strcmp ( data_s , "" ) == 0  )  strcpy ( data_s , "" );
	if (  listtype == 0 ) 
	{
		//  yesno
		if (  strcmp ( data_s , "0" ) == 0  )  strcpy ( data_s , t.strarr_s[471].Get() );
		if (  strcmp ( data_s , "1" ) == 0  )  strcpy ( data_s , t.strarr_s[470].Get() );
	}
	if (  listtype == 11 ) 
	{
		//  behaviours (trim scriptbank behaviours and .fpi)
		strcpy ( data_s , Right(data_s,Len(data_s)-Len("behavioursx")) );
		strcpy ( data_s , Left(data_s,Len(data_s)-4) );
		t.strwork = "" ; t.strwork = t.strwork + Upper(Left(data_s,1))+Lower(Right(data_s,Len(data_s)-1));
		strcpy ( data_s , t.strwork.Get() );
	}
	SetFileMapDWORD (  3,g.g_filemapoffset,6  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,group  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,controlindex  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(field_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,field_s  ); g.g_filemapoffset += ((Len(field_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(data_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,data_s  ); g.g_filemapoffset += ((Len(data_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(desc_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,desc_s  ); g.g_filemapoffset += ((Len(desc_s)+3)/4 )*4;
	listmax=0;
	if (  listtype == 0 ) 
	{
		listmax=1;
		t.list_s[0]=t.strarr_s[471];
		t.list_s[1]=t.strarr_s[470];
	}
	if (  listtype == 1 ) 
	{
		listmax=fillgloballistwithweapons();
	}
	if (  listtype == 11 ) 
	{
		listmax=fillgloballistwithbehaviours();
	}
	SetFileMapDWORD (  3,g.g_filemapoffset,listmax  ); g.g_filemapoffset += 4;
	for ( int i = 0 ; i<=  listmax; i++ )
	{
		SetFileMapDWORD (  3,g.g_filemapoffset,Len(t.list_s[ i ].Get())  ); g.g_filemapoffset += 4;
		SetFileMapString (  3,g.g_filemapoffset,t.list_s[ i ].Get()  ); g.g_filemapoffset += ((Len(t.list_s[ i ].Get())+3)/4 )*4;
	}
//endfunction

}

void setpropertylist3 ( int group, int controlindex, char* data_s, char* field_s, char* desc_s, int listtype )
{
	int listmax = 0;
	if (  strcmp ( data_s , "" ) == 0  )  strcpy ( data_s , "" );
	if (  strcmp ( data_s , "0" ) == 0  )  strcpy ( data_s , "No" );
	if (  strcmp ( data_s , "1" ) == 0  )  strcpy ( data_s , "A" );
	if (  strcmp ( data_s , "2" ) == 0  )  strcpy ( data_s , "B" );
	SetFileMapDWORD (  3,g.g_filemapoffset,6  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,group  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,controlindex  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(field_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,field_s  ); g.g_filemapoffset += ((Len(field_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(data_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,data_s  ); g.g_filemapoffset += ((Len(data_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(desc_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,desc_s  ); g.g_filemapoffset += ((Len(desc_s)+3)/4 )*4;
	listmax=2;
	Dim (  t.list_s,2  );
	t.list_s[0]="No";
	t.list_s[1]="A";
	t.list_s[2]="B";
	SetFileMapDWORD (  3,g.g_filemapoffset,listmax  ); g.g_filemapoffset += 4;
	for ( int i = 0 ; i<=  listmax; i++ )
	{
		SetFileMapDWORD (  3,g.g_filemapoffset,Len(t.list_s[ i ].Get())  ); g.g_filemapoffset += 4;
		SetFileMapString (  3,g.g_filemapoffset,t.list_s[ i ].Get()  ); g.g_filemapoffset += ((Len(t.list_s[ i ].Get())+3)/4 )*4;
	}
//endfunction

}

void setpropertybase ( int code, char*  s_s )
{
	if ( strcmp ( s_s , "" ) == 0  )  strcpy ( s_s , "" );
	SetFileMapString (  2, STRING_A, s_s );
	SetFileMapString (  2, STRING_B, "" );
	SetFileMapString (  2, STRING_C, "" );
	SetFileMapDWORD (  2, code, 1 );
	SetEventAndWait (  2 );
	while (  GetFileMapDWORD( 2, code )  ==  1 ) 
	{
		SetEventAndWait (  2 );
	}
//endfunction

}

void setpropertystring ( int group, char* data_s, char* field_s, char* desc_s )
{
	if (  strcmp ( data_s , "" )  )  strcpy ( data_s , "" );
	SetFileMapString (  2, STRING_A, field_s );
	SetFileMapString (  2, STRING_B, data_s );
	SetFileMapString (  2, STRING_C, desc_s );
	SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
	SetFileMapDWORD (  2, ENTITY_ADD_EDIT_BOX, 1 );
	SetEventAndWait (  2 );
	while (  GetFileMapDWORD( 2, ENTITY_ADD_EDIT_BOX )  ==  1 ) 
	{
		SetEventAndWait (  2 );
	}
//endfunction

}

void setpropertycolor ( int group, int dataval, char* field_s, char* desc_s )
{
	cstr data_s =  "";
	data_s=data_s+Str(RgbR(dataval))+" "+Str(RgbG(dataval))+" "+Str(RgbB(dataval));
	SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
	SetFileMapString (  2, STRING_A, field_s );
	SetFileMapString (  2, STRING_B, data_s.Get() );
	SetFileMapString (  2, STRING_C, desc_s );
	SetFileMapDWORD (  2, ENTITY_ADD_COLOR_PICKER, 1 );
	SetEventAndWait (  2 );
	while (  GetFileMapDWORD( 2, ENTITY_ADD_COLOR_PICKER )  ==  1 ) 
	{
		SetEventAndWait (  2 );
	}
//endfunction

}

void setpropertyfile ( int group, char* data_s, char* field_s, char* desc_s, char* within_s )
{
	if ( strcmp ( data_s , "" ) == 0 )  strcpy ( data_s , "" );
	SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
	SetFileMapString (  2, STRING_A, field_s );
	SetFileMapString (  2, STRING_B, data_s );
	SetFileMapString (  2, STRING_C, desc_s );
	t.strwork = "" ; t.strwork = t.strwork + g.rootdir_s+within_s;
	SetFileMapString (  2, 2024, t.strwork.Get() );
	SetFileMapString (  2, 2280, t.strarr_s[321].Get() );
	SetFileMapString (  2, 2536, t.strarr_s[322].Get() );
	SetFileMapDWORD (  2, ENTITY_ADD_FILE_PICKER, 1 );
	SetEventAndWait (  2 );
	while (  GetFileMapDWORD( 2, ENTITY_ADD_FILE_PICKER )  ==  1 ) 
	{
		SetEventAndWait (  2 );
	}
}
#endif

int fillgloballistwithweaponsQuick(bool forcharacters, bool bForShooting, bool bForMelee)
{
	int retvalue = 0;
	int gunid = 0;
	Dim(t.list_s, 1 + g.gunmax);

	// For drop down , so quick with no file checks.
	if (forcharacters==true && bForShooting == true)
	{
		// when using shooting weapon cannot have No Weapon (use different behavior if want that)
		t.list_s[0] = "enhanced\\Mk19T"; // standard issue pistol
	}
	else
	{
		t.list_s[0] = "";
	}
	int iListCount = 0;
	for (gunid = 1; gunid <= g.gunmax; gunid++)
	{
		bool bIncludeThisWeapon = false;
		if (bForShooting == true)
		{
			if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\AK") == NULL) bIncludeThisWeapon = true;
			if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\AR") == NULL) bIncludeThisWeapon = true;
			if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\M29S") == NULL) bIncludeThisWeapon = true;
			if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\Mk18") == NULL) bIncludeThisWeapon = true;
			if (forcharacters == true && bForShooting == true)
			{
				// already included above as the default
			}
			else
			{
				if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\Mk19T") == NULL) bIncludeThisWeapon = true; 
			}
			if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\R870") == NULL) bIncludeThisWeapon = true;
		}
		if (bForMelee == true)
		{
			if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\B810") == NULL) bIncludeThisWeapon = true;
			if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\Gloves_Unarmed") == NULL) bIncludeThisWeapon = true;
			if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\SledgeHammer") == NULL) bIncludeThisWeapon = true;
			if (stricmp(t.gun[gunid].name_s.Get(), "aztec\\AztecAxe") == NULL) bIncludeThisWeapon = true;
			if (stricmp(t.gun[gunid].name_s.Get(), "aztec\\AztecDagger") == NULL) bIncludeThisWeapon = true;
			if (stricmp(t.gun[gunid].name_s.Get(), "aztec\\AztecSpear") == NULL) bIncludeThisWeapon = true;
		}
		if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\M67") == NULL) bIncludeThisWeapon = false;
		if (forcharacters == true)
		{
			if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\B810") == NULL) bIncludeThisWeapon = false;
			if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\Gloves_Unarmed") == NULL) bIncludeThisWeapon = false;
			if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\SledgeHammer") == NULL) bIncludeThisWeapon = false;
		}
		// any another category should be revealed for all cases (restrict later as new items come in - via gunspec!)
		if (strnicmp(t.gun[gunid].name_s.Get(), "enhanced\\", 9) != NULL && strnicmp(t.gun[gunid].name_s.Get(), "aztec\\", 6) != NULL)
		{
			bIncludeThisWeapon = true;
		}
		if (bIncludeThisWeapon == true)
		{
			iListCount++;
			t.list_s[iListCount] = t.gun[gunid].name_s;
		}
	}

	// 190416 - sort weapons into alpha order
	for (int iSortA = 0; iSortA <= iListCount; iSortA++)
	{
		for (int iSortB = 0; iSortB <= iListCount; iSortB++)
		{
			if (iSortA != iSortB && strcmp(t.list_s[iSortA].Get(), t.list_s[iSortB].Get()) < 0)
			{
				// swap over for bubble sort
				cstr pStoreA = t.list_s[iSortA];
				t.list_s[iSortA] = t.list_s[iSortB];
				t.list_s[iSortB] = pStoreA;
			}
		}
	}

	// return valid gun name count
	return iListCount;
}

bool g_bCheckedBoosterAnims = false;
bool g_bDoWeHaveBoosterAnims = false;

int fillgloballistwithCharAnimSetsQuick(int iSpecialValue)
{
	// one time check to see if booster anims available
	if (g_bCheckedBoosterAnims == false)
	{
		if (FileExist("charactercreatorplus\\parts\\adult male\\default animations-pistol-lowered.dbo"))
		{
			g_bDoWeHaveBoosterAnims = true;
		}
		g_bCheckedBoosterAnims = true;
	}

	// create list of available animations for standard user dropdown
	Dim(t.list_s, 10);
	int iIndex = 0;
	t.list_s[iIndex] = "Default Animation";
	iIndex++; t.list_s[iIndex] = "Original Animation";
	if (iSpecialValue == 1)
	{
		// adult male soldier
		iIndex++; t.list_s[iIndex] = "Adult Male Pistol";
		iIndex++; t.list_s[iIndex] = "Adult Male Rifle";
		if (g_bDoWeHaveBoosterAnims)
		{
			iIndex++; t.list_s[iIndex] = "Adult Male Pistol Lowered";
			iIndex++; t.list_s[iIndex] = "Adult Male Rifle Lowered";
			iIndex++; t.list_s[iIndex] = "Adult Male Shotgun Lowered";
		}
	}
	if (iSpecialValue == 2)
	{
		// adult male melee
		iIndex++; t.list_s[iIndex] = "Adult Male Melee";
		iIndex++; t.list_s[iIndex] = "Adult Male Axe";
		iIndex++; t.list_s[iIndex] = "Adult Male Spear";
	}
	if (iSpecialValue == 3)
	{
		// adult female soldier
		iIndex++; t.list_s[iIndex] = "Adult Female Pistol";
		iIndex++; t.list_s[iIndex] = "Adult Female Rifle";
		if (g_bDoWeHaveBoosterAnims)
		{
			iIndex++; t.list_s[iIndex] = "Adult Female Pistol Lowered";
			iIndex++; t.list_s[iIndex] = "Adult Female Rifle Lowered";
			iIndex++; t.list_s[iIndex] = "Adult Female Shotgun Lowered";
		}
	}
	if (iSpecialValue == 4)
	{
		// adult female melee
		iIndex++; t.list_s[iIndex] = "Adult Female Melee";
		iIndex++; t.list_s[iIndex] = "Adult Female Axe";
		iIndex++; t.list_s[iIndex] = "Adult Female Spear";
	}
	if (iSpecialValue == 5)
	{
		// zombie male
		iIndex++; t.list_s[iIndex] = "Zombie Male";
	}
	if (iSpecialValue == 6)
	{
		// zombie female
		iIndex++; t.list_s[iIndex] = "Zombie Female";
	}
	// return count
	return iIndex;
}

int fillgloballistwithweapons ( void )
{
	int retvalue = 0;
	int gunid = 0;
	Dim (  t.list_s,1+g.gunmax  );
	t.list_s[0] = "";
	int iListCount = 0; // 020316 - v1.13b1 - list can exclude player weapons with no HUDs
	for ( gunid = 1; gunid <= g.gunmax; gunid++ )
	{
		// 020316 - v1.13b1 - quickly check the existence of the HUD.X file to see if we exclude (later change when weapon changes for characters)
		t.tfile_s = cstr("gamecore\\guns\\") + t.gun[gunid].name_s + cstr("\\HUD.X");
		if ( FileExist(t.tfile_s.Get()) == 1 ) 
		{
			iListCount++;
			t.list_s[iListCount] = t.gun[gunid].name_s;
		}
	}

	// 190416 - sort weapons into alpha order
	for ( int iSortA = 0; iSortA <= iListCount; iSortA++ )
	{
		for ( int iSortB = 0; iSortB <= iListCount; iSortB++ )
		{
			if ( iSortA != iSortB && strcmp ( t.list_s[iSortA].Get(), t.list_s[iSortB].Get() ) < 0 )
			{
				// swap over for bubble sort
				cstr pStoreA = t.list_s[iSortA];
				t.list_s[iSortA] = t.list_s[iSortB];
				t.list_s[iSortB] = pStoreA;
			}
		}
	}

	// return valid gun name count
	return iListCount;
}

int fillgloballistwithbehaviours_init ( void )
{
	cstr storedir_s =  "";
	int retvalue = 0;
	cstr file_s =  "";
	int c = 0;
	retvalue=0;
	t.strwork = "" ; t.strwork = t.strwork + g.rootdir_s+"scriptbank\\behaviours";
	if (  PathExist( t.strwork.Get() ) == 1 ) 
	{
		storedir_s=GetDir();
		SetDir (  t.strwork.Get() );
		ChecklistForFiles ();
		Dim (  t.behaviourlist_s,ChecklistQuantity( ) );
		for ( c = 1 ; c<=  ChecklistQuantity(); c++ )
		{
			file_s=ChecklistString(c);
			if (  strcmp ( Lower(Right(file_s.Get(),4)) , ".fpi" ) == 0 ) 
			{
				++retvalue;
				t.strwork = "" ; t.strwork=t.strwork+Left(file_s.Get(),Len(file_s.Get())-4);
				file_s = t.strwork;
				t.behaviourlist_s[retvalue] = ""; t.behaviourlist_s[retvalue]=t.behaviourlist_s[retvalue]+Upper(Left(file_s.Get(),1))+Lower(Right(file_s.Get(),Len(file_s.Get())-1));
			}
		}
		SetDir (  storedir_s.Get() );
	}
//endfunction retvalue
	return retvalue;
}

int fillgloballistwithbehaviours ( void )
{
	int behaviourlistmax = 0;
	int retvalue = 0;
	int n;
	retvalue=behaviourlistmax;
	Dim (  t.list_s,retvalue  );
	t.list_s[0]="";
	if (  retvalue>0 ) 
	{
		for ( n = 1 ; n<=  retvalue; n++ )
		{
			t.list_s[n-1]=t.behaviourlist_s[n];
		}
		retvalue=retvalue-1;
	}
//endfunction retvalue
	return retvalue
;
}

void setpropertylist ( int group, int controlindex, char* data_s, char* field_s, char* desc_s, int listtype )
{
	int listmax = 0;
	if ( strcmp ( data_s , "" ) == 0  )  strcpy ( data_s , "" );
	if (  listtype == 0 ) 
	{
		if (  strcmp ( data_s , "0" ) == 0  )  strcpy ( data_s , t.strarr_s[471].Get() );
		if (  strcmp ( data_s , "1" ) == 0  )  strcpy ( data_s , t.strarr_s[470].Get() );
	}
	SetFileMapString (  2, STRING_A, field_s );
	SetFileMapString (  2, STRING_B, data_s );
	SetFileMapString (  2, STRING_C, desc_s );
	SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
	SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, controlindex );
	SetFileMapDWORD (  2, ENTITY_ADD_LIST_BOX, 1 );
	SetEventAndWait (  2 );
	while (  GetFileMapDWORD( 2, ENTITY_ADD_LIST_BOX )  ==  1 ) 
	{
		SetEventAndWait (  2 );
	}
	listmax=0;
	if (  listtype == 0 ) 
	{
		t.list_s[0]=t.strarr_s[471];
		t.list_s[1]=t.strarr_s[470];
		listmax=1;
	}
	if (  listtype == 1 ) 
	{
		listmax=fillgloballistwithweapons();
	}
	if (  listtype == 11 ) 
	{
		listmax=fillgloballistwithbehaviours();
	}
	for ( int i = 0 ; i<=  listmax; i++ )
	{
		SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
		SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, controlindex );
		SetFileMapString (  2, STRING_A, t.list_s[ i ].Get() );
		SetFileMapDWORD (  2, ENTITY_ADD_ITEM_TO_LIST_BOX, 1 );
		SetEventAndWait (  2 );
		while (  GetFileMapDWORD( 2, ENTITY_ADD_ITEM_TO_LIST_BOX )  ==  1 ) 
		{
			SetEventAndWait (  2 );
		}
	}
//endfunction

}

// 
//  Interface Properties Expressions
// 

char* getpropertyfield ( int group, int iControl )
{
	cstr field_s =  "";
	SetFileMapDWORD (  2, ENTITY_GET_CONTROL_NAME, 1 );
	SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
	SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, iControl );
	SetEventAndWait (  2 );
	while (  GetFileMapDWORD( 2, ENTITY_GET_CONTROL_NAME )  ==  1 ) 
	{
		SetEventAndWait (  2 );
	}
	field_s = GetFileMapString( 2, STRING_A );
//endfunction field$
	strcpy ( t.szreturn , field_s.Get() );
	return t.szreturn;
}

char* getpropertydata ( int group, int iControl )
{
	cstr data_s =  "";
	SetFileMapDWORD (  2, ENTITY_GET_CONTROL_CONTENTS, 1 );
	SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
	SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, iControl );
	SetEventAndWait (  2 );
	while (  GetFileMapDWORD( 2, ENTITY_GET_CONTROL_CONTENTS )  ==  1 ) 
	{
		SetEventAndWait (  2 );
	}
	data_s = GetFileMapString( 2, STRING_B );
//endfunction data$
	strcpy ( t.szreturn , data_s.Get() );
	return t.szreturn;
;
}


//COMMON INTERFACE FUNCTIONS


void set_progress_position ( int  item, int  position )
{
			SetFileMapDWORD (  1, SET_PROGRESS_ITEM, item );
			SetFileMapDWORD (  1, SET_PROGRESS_POSITION, position );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, SET_PROGRESS_ITEM ) ==  1 ) 
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

char* get_list_box ( int  item, int  index )
{
	cstr contents_s =  "";
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapDWORD (  1, SET_LIST_INDEX, index );
			SetFileMapDWORD (  1, GET_LIST_ITEM, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, GET_LIST_ITEM )  ==  1 )
			{
				SetEventAndWait (  1 );
			}
			contents_s = GetFileMapString (  1, STRING_A );
//endfunction contents$
	strcpy ( t.szreturn , contents_s.Get() );
	return t.szreturn;
}

void set_radio_state ( int  item, int  state )
{
			if (  state == 0  )  state = 2;
			SetFileMapDWORD (  1, SET_RADIO_ITEM, item );
			SetFileMapDWORD (  1, SET_RADIO_STATE, state );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, SET_RADIO_STATE ) > 0 )  
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

int get_radio_state ( int  item )
{
			int state = 0;
			SetFileMapDWORD (  1, SET_RADIO_ITEM, item );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, SET_RADIO_ITEM ) > 0 ) 
			{
				SetEventAndWait (  1 );
			}
			state = GetFileMapDWORD ( 1, GET_RADIO_ITEM );
//endfunction state
	return state;
}

void set_edit_item ( int  item, char*  text_s )
{
			SetFileMapDWORD (  1, SET_EDIT_ITEM, item );
			SetFileMapString (  1, STRING_A, text_s );
			SetFileMapDWORD (  1, SET_EDIT_TEXT, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, SET_EDIT_TEXT )  ==  1 ) 
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

char* get_edit_item ( int  item )
{
	cstr text_s =  "";
			SetFileMapDWORD (  1, SET_EDIT_ITEM, item );
			SetFileMapDWORD (  1, GET_EDIT_TEXT, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, GET_EDIT_TEXT )  ==  1 )
			{
				SetEventAndWait (  1 );
			}
			text_s = GetFileMapString ( 1, STRING_A );
//endfunction text$
	strcpy ( t.szreturn , text_s.Get() );
	return t.szreturn;
}

void browse ( char*  title_s, char*  directory_s, char*  filter_s )
{
			SetFileMapString (  1, STRING_A, title_s );
			SetFileMapString (  1, STRING_B, directory_s );
			SetFileMapString (  1, STRING_C, filter_s );
			SetFileMapDWORD (  1, BROWSE_DISPLAY, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, BROWSE_FILE_SELECTED ) ==  0 )
			{
				SetEventAndWait (  1 );
			}
			SetFileMapDWORD (  1, BROWSE_FILE_SELECTED, 0 );
			SetFileMapDWORD (  1, BUTTON_CLICKED, 0 );
//endfunction

}

char* browse_for_folder ( char*  directory_s )
{
			cstr text_s =  "";
			SetFileMapString (  1, STRING_A, directory_s );
			SetFileMapDWORD (  1, 200, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD (  1, 204 )  ==  0 )
			{
				SetEventAndWait (  1 );
			}
			SetFileMapDWORD (  1, 204, 0 );
			SetEventAndWait (  1 );
			text_s = GetFileMapString ( 1, STRING_A );
			SetFileMapDWORD (  1, BUTTON_CLICKED, 0 );
			SetEventAndWait (  1 );
//endfunction text$
	strcpy ( t.szreturn , text_s.Get() );
	return t.szreturn;
}

void add_list_item ( int  item, char*  text_s )
{
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapString (  1, STRING_A, text_s );
			SetFileMapDWORD (  1, ADD_LIST_ITEM, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, ADD_LIST_ITEM )  ==  1 )
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

char* get_list_item ( int  item, int  index )
{
	cstr text_s =  "";
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapDWORD (  1, SET_LIST_INDEX, index );
			SetFileMapDWORD (  1, GET_LIST_ITEM, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, GET_LIST_ITEM )  ==  1 ) 
			{
				SetEventAndWait (  1 );
			}
			text_s = GetFileMapString ( 1, STRING_A );
//endfunction text$
	strcpy ( t.szreturn , text_s.Get() );
	return t.szreturn;
}

void delete_list_item ( int  item, int  index )
{
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapDWORD (  1, SET_LIST_INDEX, index );
			SetFileMapDWORD (  1, DELETE_LIST_ITEM, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD (   1, DELETE_LIST_ITEM )  ==  1  ) 
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

void clear_list ( int  item )
{
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapDWORD (  1, LIST_CLEAR, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD (  1, LIST_CLEAR )  ==  1  ) 
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

void select_list_item ( int  item, int  selectionindex )
{
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapDWORD (  1, LIST_SELECT_ITEM_INDEX, selectionindex );
			SetFileMapDWORD (  1, LIST_SELECT_ITEM, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD (  1, LIST_SELECT_ITEM )  ==  1  ) 
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

int get_list_item_selection ( int  item )
{
			int selection = -1;
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapDWORD (  1, GET_LIST_SELECTION, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD (  1, GET_LIST_SELECTION )  ==  1 ) 
			{
				SetEventAndWait (  1 );
			}
			selection = GetFileMapDWORD( 1, LIST_SELECTION );
//endfunction selection
	return selection
;
}

void insert_list_item ( int  item, int  position, char*  text_s )
{
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapDWORD (  1, LIST_INSERT_POSITION, position );
			SetFileMapString (  1, STRING_A, text_s );
			SetFileMapDWORD (  1, LIST_INSERT_ITEM, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD (  1, LIST_INSERT_ITEM )  ==  1 ) 
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

void add_combo_box ( int  item, char*  text_s )
{
			SetFileMapDWORD (  1, SET_COMBO_ITEM, item );
			SetFileMapString (  1, STRING_A, text_s );
			SetFileMapDWORD (  1, ADD_COMBO_ITEM, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, ADD_COMBO_ITEM )  ==  1 ) 
			{
				SetEventAndWait (  1 );
			}
//endfunction

}


//Property Functions


void add_group ( char*  name_s )
{
			SetFileMapString (  2, STRING_A, name_s );
			SetFileMapDWORD (  2, ENTITY_ADD_GROUP, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_ADD_GROUP )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
//endfunction

}

void add_edit_box ( int  group, char*  name_s, char*  contents_s, char*  description_s )
{
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapString (  2, STRING_A, name_s );
			SetFileMapString (  2, STRING_B, contents_s );
			SetFileMapString (  2, STRING_C, description_s );
			SetFileMapDWORD (  2, ENTITY_ADD_EDIT_BOX, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_ADD_EDIT_BOX )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
//endfunction

}

void add_color_picker ( int  group, char*  name_s, char*  contents_s, char*  description_s )
{
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapString (  2, STRING_A, name_s );
			SetFileMapString (  2, STRING_B, contents_s );
			SetFileMapString (  2, STRING_C, description_s );
			SetFileMapDWORD (  2, ENTITY_ADD_COLOR_PICKER, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_ADD_COLOR_PICKER )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
//endfunction

}

void add_file_picker_ex ( int  group, char*  name_s, char*  contents_s, char*  description_s, char*  dir_s, char*  filter_s, char*  title_s )
{
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapString (  2, STRING_A, name_s );
			SetFileMapString (  2, STRING_B, contents_s );
			SetFileMapString (  2, STRING_C, description_s );
			SetFileMapString (  2, 2024, dir_s );
			if (  filter_s != "" ) 
			{
				SetFileMapString (  2, 2280, filter_s );
			}
			else
			{
				SetFileMapString (  2, 2280, t.strarr_s[323].Get() );
			}
			if (  cstr(title_s) != "" ) 
			{
				SetFileMapString (  2, 2536, title_s );
			}
			else
			{
				SetFileMapString (  2, 2536, t.strarr_s[324].Get() );
			}
			SetFileMapDWORD (  2, ENTITY_ADD_FILE_PICKER, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_ADD_FILE_PICKER )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
//endfunction

}

void add_file_picker ( int  group, char*  name_s, char*  contents_s, char*  description_s, char*  dir_s )
{
	add_file_picker_ex( group, name_s, contents_s, description_s, dir_s, "", "" );
//endfunction

}

void add_font_picker ( int  group, char*  name_s, char*  contents_s, char*  description_s )
{
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapString (  2, STRING_A, name_s );
			SetFileMapString (  2, STRING_B, contents_s );
			SetFileMapString (  2, STRING_C, description_s );
			SetFileMapDWORD (  2, ENTITY_ADD_FONT_PICKER, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_ADD_FONT_PICKER )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
//endfunction

}

void add_list_box ( int  group, char*  name_s, char*  contents_s, char*  description_s )
{
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapString (  2, STRING_A, name_s );
			SetFileMapString (  2, STRING_B, contents_s );
			SetFileMapString (  2, STRING_C, description_s );
			SetFileMapDWORD (  2, ENTITY_ADD_LIST_BOX, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_ADD_LIST_BOX )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
//endfunction

}

void add_item_to_list_box ( int  group, int  control, char*  item_s )
{
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, control );
			SetFileMapString (  2, STRING_A, item_s );
			SetFileMapDWORD (  2, ENTITY_ADD_ITEM_TO_LIST_BOX, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_ADD_ITEM_TO_LIST_BOX )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
//endfunction

}

char* get_control_name ( int  group, int  control )
{
	cstr name_s =  "";
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, control );
			SetFileMapDWORD (  2, ENTITY_GET_CONTROL_NAME, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_GET_CONTROL_NAME )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
			name_s =  GetFileMapString( 2, STRING_A );
//endfunction name$
	strcpy ( t.szreturn , name_s.Get() );
	return t.szreturn;
}

char* get_control_contents ( int  group, int  control )
{
	cstr contents_s =  "";
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, control );
			SetFileMapDWORD (  2, ENTITY_GET_CONTROL_CONTENTS, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_GET_CONTROL_CONTENTS )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
			contents_s = GetFileMapString( 2, STRING_B );
//endfunction contents$
	strcpy ( t.szreturn , contents_s.Get() );
	return t.szreturn;
}

char* get_control_description ( int  group, int  control )
{
	cstr description_s =  "";
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, control );
			SetFileMapDWORD (  2, ENTITY_GET_CONTROL_DESCRIPTION, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_GET_CONTROL_DESCRIPTION )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
			description_s = GetFileMapString( 2, STRING_C );
//endfunction description$
	strcpy ( t.szreturn , description_s.Get() );
	return t.szreturn;
}

//Memory check behaviour for MAP EDITOR / TEST GAME

void checkmemoryforgracefulexit ( void )
{
	int recoverdonotuseany3dreferences = 0;
	int ttogglebannertimer = 0;
	int tredscreencount = 0;
	int tsmemavailable = 0;
	int ttogglebanner = 0;
	int tokay = 0;

	//  if cannot create 100MB of contiguous memory, we're nearing the max fragmentation level
	if (  t.game.gameisexe == 0 && g.globals.memorydetector == 1 ) 
	{
	tsmemavailable=SMEMAvailable(1);
	if (  tsmemavailable>1600000 ) 
	{

		//  The Red Screen of Resurrection
		t.strwork = ""; t.strwork = t.strwork + "checkmemoryforgracefulexit - memory detector "+Str(tsmemavailable)+" Kb";
		timestampactivity(0, t.strwork.Get() );
		tredscreencount=Timer()+2000;
		ttogglebannertimer=Timer()+450;
		while (  Timer()<tredscreencount ) 
		{
			CLS (  Rgb(128,0,0) );
			if (  Timer()>ttogglebannertimer ) 
			{
				ttogglebannertimer=Timer()+450;
				ttogglebanner=1-ttogglebanner;
			}
			PasteImage (  g.editorimagesoffset+5+ttogglebanner,(GetDisplayWidth()-ImageWidth(g.editorimagesoffset+5))/2,(GetDisplayHeight()-ImageHeight(g.editorimagesoffset+5))/2 );
			Sync (  );
		}

		#ifdef FPSEXCHANGE
		//  close conmunication with editor
		OpenFileMap (  1, "FPSEXCHANGE" );
		SetFileMapDWORD (  1,974,2 );

		//  Before we 'BIN OUT', signal IDE that we wish to return to the IDE editor state
		OpenFileMap (  1, "FPSEXCHANGE" );
		SetFileMapDWORD (  1, 970, 1 );
		SetEventAndWait (  1 );

		//  message Box (  - resolution has been changed - must restart - save changes? )
		OpenFileMap (  1, "FPSEXCHANGE" );
		SetFileMapDWORD (  1, 900, 1 );
		SetFileMapString (  1, 1256, t.strarr_s[622].Get() );
		SetFileMapString (  1, 1000, t.strarr_s[623].Get() );
		SetEventAndWait (  1 );
		while (  GetFileMapDWORD(1, 900) == 1 ) 
		{
			SetEventAndWait (  1 );
		}
		tokay=GetFileMapDWORD(1, 904);
		#endif

		if (  tokay == 1 ) 
		{
			//  no references to 3D objects
			recoverdonotuseany3dreferences=1;
			//  save as now
			gridedit_saveas_map ( );
		}

		//  call a new map editor
		#ifdef FPSEXCHANGE
		OpenFileMap (  2, "FPSEXCHANGE" );
		SetFileMapString (  2, 1000, "Guru-MapEditor.exe" );
		SetFileMapString (  2, 1256, "-r" );
		SetFileMapDWORD (  2, 994, 0 );
		SetFileMapDWORD (  2, 924, 1 );
		SetEventAndWait (  2 );
		#endif

		//  Terminate fragmented EXE
		common_justbeforeend();
		ExitProcess ( 0 );
	}
	}
}

int get_cursor_scale_for_obj ( int tObj )
{
	t.tSizeX_f = ObjectSizeX(tObj,1);
	t.tSizeZ_f = ObjectSizeZ(tObj,1);
	t.tscale_f= Sqrt(t.tSizeX_f*t.tSizeX_f + t.tSizeZ_f*t.tSizeZ_f)*3.0;
	return t.tscale_f;
}

#ifdef ENABLEIMGUI
void AddPayLoad(ImGuiPayload* payload, bool addtocursor)
{
#ifdef WICKEDENGINE
	//PE: For this to work in wicked we need to shutdown ALL objects created in new enitylib.
	//PE: or g.entidmaster will get reset. and not display anything.
	bool bSetEntIDMaster = false;
	if ( g_TempimageList.size() > 0)
	{
		if(iRestoreEntidMaster >= 0)
			bSetEntIDMaster = true;
		FreeTempImageList();
	}

#endif
	extern cFolderItem::sFolderFiles *pDragDropFile;
	if (pDragDropFile) {

		IM_ASSERT(payload->DataSize == sizeof(cFolderItem::sFolderFiles *));
		cFolderItem::sFolderFiles * payload_n = (cFolderItem::sFolderFiles *) payload->Data;
		payload_n = payload_n->m_dropptr;
		if (payload_n) 
		{
			//Add the item.
			CloseDownEditorProperties();
			t.inputsys.constructselection = 0;
			#ifdef WICKEDENGINE
			iLastEntityOnCursor = 0;
			#endif

			t.addentityfile_s = payload_n->m_sFolder.Get();
			if (t.addentityfile_s != "")
			{
				entity_adduniqueentity(false);
				t.tasset = t.entid;
				if (t.talreadyloaded == 0)
				{
					editor_filllibrary();
				}
			}
			if (addtocursor) 
			{
				bool bNormalMasterAdd = true;
				#ifdef WICKEDENGINE
				if (payload_n->iAnimationFrom >= 200000)
				{
					//Special multiply object drag drop.
					g.entityrubberbandlist.clear();
					float centerx = GGORIGIN_X;
					float centery = GGORIGIN_Y;
					float centerz = GGORIGIN_Z;
					int iAnchorEntityIndex = -1;
					float higesty = -999999.0f, lowesty = 999999.0;
					int gridcol = sqrt(selected_library_fpe.size());
					if (gridcol < 1) gridcol = 1;
					int gridcolcount = 0;
					for (std::map<std::string, int>::iterator it = selected_library_fpe.begin(); it != selected_library_fpe.end(); ++it)
					{
						if (it->first.length() > 0)
						{
							//Add
							t.addentityfile_s = it->first.c_str();
							if (t.addentityfile_s != "")
							{
								entity_adduniqueentity(false);
								t.tasset = t.entid;
								if (t.talreadyloaded == 0)
								{
									editor_filllibrary();
								}
							}

							int masterobj = g.entitybankoffset + t.entid;

							// duplicate new entity as clone of relevant original clipboard entity
							bool bLowestFound = false;
							t.gridentity = t.entid;

							#define MINGRIDSIZE 20
							float gsx = ObjectSizeX(masterobj) / 2.0f;
							if (gsx < MINGRIDSIZE) gsx = MINGRIDSIZE;
							centerx += gsx * 1.05f;

							//PE: all t.gridentity... need to be set for this to work correctly.
							entity_fillgrideleproffromprofile();  // t.entid
							t.gridentitystaticmode = t.entityprofile[t.entid].defaultstatic;
							t.gridentityposx_f = centerx;
							t.gridentityposy_f = centery;
							t.gridentityposz_f = centerz;
							t.gridentityrotatex_f = ObjectAngleX(masterobj);
							t.gridentityrotatey_f = ObjectAngleY(masterobj);
							t.gridentityrotatez_f = ObjectAngleZ(masterobj);
							t.gridentityrotatequatmode = 0;
							t.gridentityrotatequatx_f = 0;
							t.gridentityrotatequaty_f = 0;
							t.gridentityrotatequatz_f = 0;
							t.gridentityrotatequatw_f = 1;
							t.gridentityscalex_f = ObjectScaleX(masterobj);
							t.gridentityscaley_f = ObjectScaleY(masterobj);
							t.gridentityscalez_f = ObjectScaleZ(masterobj);

							if (higesty < t.gridentityposy_f) higesty = t.gridentityposy_f;
							if (lowesty > t.gridentityposy_f)
							{
								lowesty = t.gridentityposy_f;
								bLowestFound = true;
							}

							#ifdef WICKEDENGINE
							//PE: InstanceObject - Cursor,Object Tools - objects must always be real clones.
							extern bool bNextObjectMustBeClone;
							bNextObjectMustBeClone = true;
							#endif

							gridedit_addentitytomap(); //Add it to map set t.e

							#ifdef WICKEDENGINE
							bNextObjectMustBeClone = false;
							#endif

							if (iAnchorEntityIndex == -1 || bLowestFound) iAnchorEntityIndex = t.e;

							// and add to new rubber band group
							sRubberBandType rubberbandItem;
							rubberbandItem.e = t.e;
							rubberbandItem.x = t.entityelement[t.e].x;
							rubberbandItem.y = t.entityelement[t.e].y;
							rubberbandItem.z = t.entityelement[t.e].z;
							#ifdef WICKEDENGINE
							rubberbandItem.px = t.entityelement[t.e].x;
							rubberbandItem.py = t.entityelement[t.e].y;
							rubberbandItem.pz = t.entityelement[t.e].z;
							rubberbandItem.rx = t.entityelement[t.e].rx;
							rubberbandItem.ry = t.entityelement[t.e].ry;
							rubberbandItem.rz = t.entityelement[t.e].rz;						
							rubberbandItem.quatmode = t.entityelement[t.e].quatmode;
							rubberbandItem.quatx = t.entityelement[t.e].quatx;
							rubberbandItem.quaty = t.entityelement[t.e].quaty;
							rubberbandItem.quatz = t.entityelement[t.e].quatz;
							rubberbandItem.quatw = t.entityelement[t.e].quatw;
							rubberbandItem.scalex = t.entityelement[t.e].scalex;
							rubberbandItem.scaley = t.entityelement[t.e].scaley;
							rubberbandItem.scalez = t.entityelement[t.e].scalez;
							#endif
							g.entityrubberbandlist.push_back(rubberbandItem);

							/* grids shape not predictable, so lets go for a simple row
							//Make grid , perhaps wrap.
							#define MINGRIDSIZE 120
							float gsx = ObjectSizeX(masterobj);
							float gsz = ObjectSizeZ(masterobj);
							if (gsx < MINGRIDSIZE) gsx = MINGRIDSIZE;
							if (gsz < MINGRIDSIZE) gsz = MINGRIDSIZE;
							centerx += gsx * 1.25;
							if (++gridcolcount >= gridcol)
							{
								centerz += gsz * 1.25;
								centerx = GGORIGIN_X;
								gridcolcount = 0;
							}
							*/
							centerx += gsx * 1.05f;
						}
					}
					if (iAnchorEntityIndex != -1)
					{
						//Select and add first entity to cursor, along with the rubberband.
						AddEntityToCursor(iAnchorEntityIndex, false);

						//Change to just place under cursor.
						t.inputsys.dragoffsetx_f = 0;
						t.inputsys.dragoffsety_f = 0;
						fHitPointX = 0;
						fHitPointY = HITPOINTYSTARTPOS;
						fHitPointZ = 0;
						fHitOffsetX = 0;
						fHitOffsetY = 0;
						fHitOffsetZ = 0;

						g_bHoldGridEntityPosWhenManaged = true;
						g_fHoldGridEntityPosX = t.gridentityposx_f;
						g_fHoldGridEntityPosY = t.gridentityposy_f;
						g_fHoldGridEntityPosZ = t.gridentityposz_f;

						/*LB: not robust enough, and should not change modes without users permission
						//PE: Make sure cursor offset is set at bottom of selection list.
						float seletion_height = higesty - lowesty;
						if (seletion_height > 1.0f && seletion_height < 5000.0f)
						{
							fHitOffsetY = seletion_height;
						}
						//PE: Always start in horizontal mode.
						iObjectMoveMode = 0;
						*/
					}
					bNormalMasterAdd = false;
					t.onetimeentitypickup = 0;

					//When dragging in many objects, window is in the way , close it down.
					if (bExternal_Entities_Window && selected_library_fpe.size() > 2 )
						bCheckForClosing = true;
				}
				else if (payload_n->iAnimationFrom >= 100000)
				{
					int l = payload_n->iAnimationFrom - 100000;
					DuplicateFromListToCursor(vEntityGroupList[l]);
					bNormalMasterAdd = false;
					t.onetimeentitypickup = 0;
					//bCreateNewGroupOnNextDrop = true; //PE: Dont create a new group when drag/drop a group.
				}
				else if (payload_n->iAnimationFrom > 0 )
				{
					AddEntityToCursor(payload_n->iAnimationFrom,true);
					bNormalMasterAdd = false;
					t.onetimeentitypickup = 0;
				}
				#endif
				if (bNormalMasterAdd)
				{
					//PE: TODO check if t.entid is valid here.
					//Make sure we are in entty mode.
					bForceKey = true;
					csForceKey = "e";
					#ifdef WICKEDENGINE
					csForceKey = "o";
					iExtractMode = 0; //PE: Always start in find floor mode.
					t.inputsys.dragoffsetx_f = 0;
					t.inputsys.dragoffsety_f = 0;
					fHitPointX = 0;
					fHitPointY = HITPOINTYSTARTPOS;
					fHitPointZ = 0;
					fHitOffsetX = 0;
					fHitOffsetY = 0;
					fHitOffsetZ = 0;

					g_bHoldGridEntityPosWhenManaged = true;
					g_fHoldGridEntityPosX = t.gridentityposx_f;
					g_fHoldGridEntityPosY = t.gridentityposy_f;
					g_fHoldGridEntityPosZ = t.gridentityposz_f;

					#endif
					t.inputsys.constructselection = t.tasset;
					t.gridentity = t.entid;
					t.inputsys.constructselection = t.entid;
					t.inputsys.domodeentity = 1;
					t.grideditselect = 5;
					#ifdef WICKEDENGINE
					//Make sure we use a fresh t.grideleprof
					entity_fillgrideleproffromprofile();
					#endif
					editor_refresheditmarkers();
				}
				//PE: Removed in design "Keep window open when dragging in objects to level".
				//PE: Now always close window.
				//#ifndef WICKEDENGINE
				if(bExternal_Entities_Window)
					bCheckForClosing = true;
				//#endif
			}
		}
		pDragDropFile = NULL;
	}

	#ifdef WICKEDENGINE
	if (bSetEntIDMaster)
	{
		iRestoreEntidMaster = g.entidmaster;
	}
	#endif
}

bool TutorialNextAction(void)
{
	tut.iCurrent_Step++;
	return true;
}


//Check if we need to point in the game scene.
bool bReadyForMouseRelease = false;
bool CheckTutorialPlaceit(void)
{
	if (tut.bActive && t.inputsys.mclick == 0 && t.gridentity != 0 ) //
		return CheckTutorialAction("PLACEIT"); //Tutorial: check if we are waiting for this action
	if (tut.bActive && t.gridentity == 0) //terrain
	{
		if (CheckTutorialAction("PLACEIT")) {
			if (t.inputsys.mclick == 0) {
				if (bReadyForMouseRelease) {
					//released.
					TutorialNextAction();
					bReadyForMouseRelease = false;
				}
			}
			else {
				bReadyForMouseRelease = true;
			}
		}
		else bReadyForMouseRelease = false;
		return false;
	}
	else {
		bReadyForMouseRelease = false;
	}
	return false;
}

bool CheckTutorialAction(const char * action, float x_adder)
{
	g_bInTutorialMode = false;
	if (bHelp_Window && tutorial_files.size() >= selected_tutorial) 
	{
		if (tut.bActive) 
		{
			//Tutorial Active.
			g_bInTutorialMode = true;
			if (tut.iCurrent_Step >= 0 && tut.iCurrent_Step < TUTORIALMAXSTEPS) {
				if (pestrcasestr(tut.cStepAction[tut.iCurrent_Step], action)) {

					if (!bTutorialRendered && bImGuiFrameState && !bImGuiReadyToRender) {

						ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
						ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;

						//Display the pointer here.
						bTutorialRendered = true; //Make sure we only render one window.
		
						ImVec2 oldpos = ImGui::GetCursorPos();

						ImGuiStyle &st = ImGui::GetStyle();
						float oldborder = st.PopupBorderSize;

						static float sincounter = 0.0f;
						ImGuiWindow* window = ImGui::GetCurrentWindow();
						ImVec2 pos = window->DC.CursorPos;

						//if ((pos.y-32.0f) > viewPortPos.y) //Dont allow it to display outside main viewport
						//{
							float icon_additional_size = 32.0f;
							st.PopupBorderSize = 0;
							pos.x += x_adder + 4;
							pos.x -= (icon_additional_size*0.60);
							//pos.y -= 80.0f;
							pos.y += 80.0f; // pointer points up now (could make this a toggle mode)
							pos.y -= icon_additional_size;
							pos.y += sin(sincounter) * 22.0f;
							sincounter = sincounter + (5.5f*t.ElapsedTime_f);
							if (sincounter >= 360.0f) sincounter -= 360.0f;

							if (strcmp(tut.cStepAction[tut.iCurrent_Step], "PLACEIT") == 0) {
								pos = OldrenderTargetPos + ImVec2((OldrenderTargetSize.x*0.5f) - 64.0f, 60 + (sin(sincounter) * 22.0f));
								pos += tut.vOffsetPointer[tut.iCurrent_Step];
								//ImGui::SetNextWindowPos(OldrenderTargetPos + ImVec2((OldrenderTargetSize.x*0.5f) - 64.0f, 80 + (sin(sincounter) * 22.0f)));
							}

							void* lpTexture = GetImagePointer(TUTORIAL_POINTERUP);
							if (lpTexture) 
							{
								ImGuiWindow* window = ImGui::GetCurrentWindow();
								ImGui::GetForegroundDrawList()->AddImage((ImTextureID)lpTexture, pos , pos + ImVec2(64+icon_additional_size, 64+icon_additional_size), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
							}

							/*
							//This system will make non transparent window when outside main viewport. (has its own main window).
							ImGui::SetNextWindowPos(pos);
							ImGui::SetNextWindowBgAlpha(0.0f);
							ImGuiWindowFlags flags = ImGuiNextWindowDataFlags_HasBgAlpha | ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDocking;
							ImGui::Begin("##TutorialPointerWindow", NULL, flags);
							ImGui::ImgBtn(TUTORIAL_POINTER, ImVec2(64, 64), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false);
							ImGui::End();
							*/
						//}
						st.PopupBorderSize = oldborder;
						ImGui::SetCursorPos(oldpos);
					}
					bTutorialCheckAction = true;
					return true;
				}
			}
		}
	}
	//selected_tutorial
	bTutorialCheckAction = false;
	return false;
}


float ApplyPivot(sObject* pObject, int iMode, GGVECTOR3 vecValue, float fValue)
{
	if (pObject->position.bApplyPivot)
	{
		GGVec3TransformCoord(&vecValue, &vecValue, &pObject->position.matPivot);

		if (iMode == 0) return vecValue.x;
		if (iMode == 1) return vecValue.y;
		if (iMode == 2) return vecValue.z;
	}

	return fValue;
}


void RenderToPreview(int displayobj)
{
	float oldx_f, oldy_f, oldz_f, oldangx_f, oldangy_f;
	int entid = displayobj - g.entitybankoffset;

	// prepare for thumb , set camera.
	oldx_f = t.editorfreeflight.c.x_f;
	oldy_f = t.editorfreeflight.c.y_f;
	oldz_f = t.editorfreeflight.c.z_f;
	oldangx_f = t.editorfreeflight.c.angx_f;
	oldangy_f = t.editorfreeflight.c.angy_f;

	float fLargestY = ObjectSizeY(displayobj,1); // Also add scale (,1)
	float fLargestX = ObjectSizeX(displayobj,1);
	float fLargestZ = ObjectSizeZ(displayobj,1);

	float fOffsetX = 0.0f,fOffsetZ = 0.0f;

	float terrain_height = BT_GetGroundHeight(t.terrain.TerrainID, GGORIGIN_X, GGORIGIN_Z, 1);

	sObject* pObject = g_ObjectList[displayobj];
	if (pObject && t.entityprofile[entid].ischaracter != 1) {
		float fAdjustScaleX = 1.0, fAdjustScaleZ = 1.0;
		if (pObject->pInstanceOfObject)
		{
			fAdjustScaleX = pObject->position.vecScale[0];
			fAdjustScaleZ = pObject->position.vecScale[2];
			pObject = pObject->pInstanceOfObject;
		}
		float fValue = (pObject->collision.vecMax[0] + pObject->collision.vecMin[0]);
		fValue = ApplyPivot(pObject, 0, GGVECTOR3(pObject->collision.vecMax - pObject->collision.vecMin), fValue);
		fValue = fValue * pObject->position.vecScale[0] * fAdjustScaleX;
		fOffsetX = fValue * 0.5f;

		fValue = (pObject->collision.vecMax[2] + pObject->collision.vecMin[2]);
		fValue = ApplyPivot(pObject, 2, GGVECTOR3(pObject->collision.vecMax - pObject->collision.vecMin), fValue);
		fValue = fValue * pObject->position.vecScale[2] * fAdjustScaleZ;
		fOffsetZ = fValue * 0.5f;
	}
	float fLargest = fLargestX;

	if (fLargestZ > fLargest)
		fLargest = fLargestZ;
	
	fLargest += (fLargestY * 0.2);
	//Prevent camera for getting to far away.
	if (fLargest >= 1500) fLargest = 1500;
	if (fLargestY >= 1500) fLargestY = 1500;

	t.editorfreeflight.c.x_f = 25650 + (fLargest*2.4);
	if(fLargestY < 10.0f)
		t.editorfreeflight.c.y_f = terrain_height + 80 + (fLargestY*1.85);
	else
		t.editorfreeflight.c.y_f = terrain_height + 50 + (fLargestY*1.85);
	t.editorfreeflight.c.z_f = 25550 - (fLargest*2.4);
	t.editorfreeflight.c.angx_f = 13;
	t.editorfreeflight.c.angy_f = -180;
	t.editorfreeflight.s = t.editorfreeflight.c;

	//Preview object could be reused so store old pos.
	float fOldObjPosX = ObjectPositionX(displayobj), fOldObjPosY = ObjectPositionY(displayobj), fOldObjPosZ = ObjectPositionZ(displayobj);
	bool bDisplayObjVisible = false;
	bool bWaterVisible = false;

	if (g_ObjectList[t.terrain.objectstartindex + 2] && g_ObjectList[t.terrain.objectstartindex + 2]->bVisible)
		bWaterVisible = true;

	if (g_ObjectList[displayobj] && g_ObjectList[displayobj]->bVisible)
		bDisplayObjVisible = true;

	//custom clear color.
	custom_back_color[0] = 119.0f/255.0f; custom_back_color[1] = 154.0f / 255.0f; custom_back_color[2] = 181.0f / 255.0f; custom_back_color[3] = 1.0f;

	//Hide everything.
	widget_hide();
	ebe_hide();
	terrain_paintselector_hide();
	#ifdef WICKEDENGINE
	t.geditorhighlightingtentityID = 0;
	#endif

	editor_restoreentityhighlightobj();
	gridedit_clearentityrubberbandlist();
	waypoint_hideall();

	//  "hide" all entities in map by moving them out the way
	for (t.tcce = 1; t.tcce <= g.entityelementlist; t.tcce++)
	{
		t.tccentid = t.entityelement[t.tcce].bankindex;
		if (t.tccentid > 0)
		{
			t.tccsourceobj = t.entityelement[t.tcce].obj;
			if (ObjectExist(t.tccsourceobj) == 1)
			{
				PositionObject(t.tccsourceobj, 0, 0, 0);
			}
		}
	}


	PositionCamera(t.editorfreeflight.c.x_f, t.editorfreeflight.c.y_f, t.editorfreeflight.c.z_f);
	RotateCamera(t.editorfreeflight.c.angx_f, t.editorfreeflight.c.angy_f, 0);
	PointCamera(GGORIGIN_X + fOffsetX, terrain_height, GGORIGIN_Z + fOffsetZ);
	
	if(fLargestY > 1000.0f)
		t.editorfreeflight.c.angx_f = CameraAngleX() - 9.0f; //6.0
	else if (fLargestY > 500.0f)
		t.editorfreeflight.c.angx_f = CameraAngleX() - 8.0f; //6.0
	else if (fLargestY > 150.0f)
		t.editorfreeflight.c.angx_f = CameraAngleX() - 7.0f; //6.0
	else if (fLargestY > 100.0f)
		t.editorfreeflight.c.angx_f = CameraAngleX() - 6.0f; //6.0
	else if (fLargestY > 50.0f)
		t.editorfreeflight.c.angx_f = CameraAngleX() - 5.0f; //6.0
	else
		t.editorfreeflight.c.angx_f = CameraAngleX() - 4.0f; //6.0
	t.editorfreeflight.c.angy_f = CameraAngleY();
	RotateCamera(t.editorfreeflight.c.angx_f, t.editorfreeflight.c.angy_f, 0);

	PositionObject(displayobj, GGORIGIN_X, terrain_height, GGORIGIN_Z);

	HideObject(t.terrain.objectstartindex + 2); //hide water

	if (t.entityprofile[entid].ismarker != 0 || t.entityprofile[entid].zdepth == 0)
	{
		SetObjectMask(displayobj, 1);
	}
	else
	{
		SetObjectMask(displayobj, 1 + (1 << 31));
	}

	ShowObject(displayobj);
	
	visuals_justshaderupdate();

	int iOldSpeedshadows = g.globals.speedshadows;
	g.globals.speedshadows = 0; //We need all cascades.
	terrain_shadowupdate();
	g.globals.speedshadows = iOldSpeedshadows;

	bImGuiInTestGame = true; //just reuse this to prevent imgui rendering.
	FastSync();
	bImGuiInTestGame = false;

	if(bWaterVisible)
		ShowObject(t.terrain.objectstartindex + 2);
	if( bDisplayObjVisible )
		ShowObject(displayobj);
	else
		HideObject(displayobj);



	PositionObject(displayobj, fOldObjPosX, fOldObjPosY, fOldObjPosZ);
	
	// delete previous thumbnail
	if (GetImageExistEx(g.importermenuimageoffset + 50))
	{
		image_setlegacyimageloading(true);
		DeleteImage(g.importermenuimageoffset + 50);
		image_setlegacyimageloading(false);
	}

	// we can't grab from the backbuffer when we use a camera image.
	extern DBPRO_GLOBAL CCameraManager m_CameraManager;
	DBPRO_GLOBAL tagCameraData* m_mycam;
	m_mycam = m_CameraManager.GetData(0);
	float thumbnail_dimension = 512;
	if (m_mycam)
	{
		extern GlobStruct* g_pGlob;
		LPGGSURFACE	pTmpSurface = g_pGlob->pCurrentBitmapSurface;
		g_pGlob->pCurrentBitmapSurface = m_mycam->pCameraToImageSurface;

		ImVec2 grab = ImVec2((m_mycam->viewPort3D.Width*0.5) - (thumbnail_dimension*0.5) , (m_mycam->viewPort3D.Height*0.5) - (thumbnail_dimension*0.5) );

		GrabImage(g.importermenuimageoffset + 50, grab.x, grab.y, grab.x+thumbnail_dimension, grab.y + thumbnail_dimension, 0);
		g_pGlob->pCurrentBitmapSurface = pTmpSurface;
	}


	//Restore camera.
	t.editorfreeflight.c.x_f = oldx_f;
	t.editorfreeflight.c.y_f = oldy_f;
	t.editorfreeflight.c.z_f = oldz_f;
	t.editorfreeflight.c.angx_f = oldangx_f;
	t.editorfreeflight.c.angy_f = oldangy_f;
	PositionCamera(t.editorfreeflight.c.x_f, t.editorfreeflight.c.y_f, t.editorfreeflight.c.z_f);
	RotateCamera(t.editorfreeflight.c.angx_f, t.editorfreeflight.c.angy_f, 0);


	//Display everything again.
	t.inputsys.dowaypointview = 0;
	
	//Restore.
	waypoint_restore();
	t.gridentityhidemarkers = 0;
	editor_updatemarkervisibility();
	editor_refresheditmarkers();

	//  put all entities back where they were
	for (t.tcce = 1; t.tcce <= g.entityelementlist; t.tcce++)
	{
		t.tccentid = t.entityelement[t.tcce].bankindex;
		if (t.tccentid > 0)
		{
			t.tccsourceobj = t.entityelement[t.tcce].obj;
			if (ObjectExist(t.tccsourceobj) == 1)
			{
				PositionObject(t.tccsourceobj, t.entityelement[t.tcce].x, t.entityelement[t.tcce].y, t.entityelement[t.tcce].z);
			}
		}
	}


	g.globals.speedshadows = 0; //We need all cascades.
	terrain_shadowupdate(); //Remove preview objects shadow from cascades.
	g.globals.speedshadows = iOldSpeedshadows;

	//Turn off custom clear color.
	custom_back_color[0] = 0.0f; custom_back_color[1] = 0.0f; custom_back_color[2] = 0.0f; custom_back_color[3] = 0.0f;

	bImGuiInTestGame = true;
	FastSync();
	bImGuiInTestGame = false;

}


void CheckTooltipObjectDelete(void)
{
	if (!iTooltipAlreadyLoaded) {

		t.tentitytoselect = iTooltipLastObjectId;
		t.entobj = g.entitybankoffset + iTooltipLastObjectId;
		//entity_deleteentityfrommap(); //We dont actually have a entityelement
		if (ObjectExist(g.entitybankoffset + iTooltipLastObjectId)) {
			DeleteObject(g.entitybankoffset + iTooltipLastObjectId);
		}
		iTooltipLastObjectId = 0;
	}
}

void get_tutorials(void)
{
	cStr tOldDir = GetDir();

	tutorial_files.clear();
	tutorial_videos.clear();
	tutorial_description.clear();

	//PE: Add introduction video by hand.
	cstr cIntroVideo = "9901 - Introduction Video";
	tutorial_files.insert(std::make_pair(cIntroVideo.Get(), "tutorialbank\\9901-introduction-video.tut"));
	tutorial_videos.insert(std::make_pair(cIntroVideo.Get(), "tutorialbank\\9901-introduction-video.mp4"));
	tutorial_description.insert(std::make_pair(cIntroVideo.Get(), "Introduction Video"));


	SetDir("tutorialbank");

	ChecklistForFiles();
	for (int i = 1; i <= ChecklistQuantity(); i++)
	{
		if (ChecklistValueA(i) == 0)
		{
			cstr file_s = ChecklistString(i);
			if (cstr(Left(file_s.Get(), 1)) != ".")
			{
				cstr ext = Lower(Right(file_s.Get(), 4));
				if (ext == ".tut") 
				{
					//Read file and get tut: entry.
					//Read in TUT: entrie.
					FILE* fTut = GG_fopen(file_s.Get(), "r");
					if (fTut)
					{
						bool bVideoAdded = false;
						bool bTutorialAdded = false;
						bool bDescriptionAdded = false;
						char ctmp[TUTORIALMAXTEXT];
						char cVideoPath[MAX_PATH] = "\0";
						char cTutorialSet[TUTORIALMAXTEXT] = "\0";
						char cTutorialDescription[TUTORIALMAXTEXT] = "\0";
						while (!feof(fTut))
						{
							fgets(ctmp, TUTORIALMAXTEXT - 1, fTut);
							if (strlen(ctmp) > 0 && ctmp[strlen(ctmp) - 1] == '\n')
								ctmp[strlen(ctmp) - 1] = 0;

							if (strncmp(ctmp, "TUT:", 4) == 0)
							{
								if (!strlen(cTutorialName) > 0)
									strcpy(cTutorialName, &ctmp[5]);

								strcpy(cTutorialSet, &ctmp[5]);
								cstr path = "tutorialbank\\";
								path += file_s;
								tutorial_files.insert(std::make_pair(&ctmp[5], path.Get()));
								bTutorialAdded = true;
							}
							if (strncmp(ctmp, "DESC:", 5) == 0)
							{
								bDescriptionAdded = true;
								strcpy(cTutorialDescription, &ctmp[6]);
								std::string clean_string = cTutorialDescription;
								replaceAll(clean_string, "’", "'"); //Replace UTF8. 0xE2 0x90 0x99
								strcpy(cTutorialDescription, clean_string.c_str());
							}
							if (strncmp(ctmp, "VIDEO:", 6) == 0)
							{
								strcpy(cVideoPath, &ctmp[7]);
								SetDir(tOldDir.Get());
								char resolved[MAX_PATH];
								int retval = GetFullPathNameA(cVideoPath, MAX_PATH, resolved, NULL);
								if (retval > 0) {
									strcpy(cVideoPath, resolved);
								}
								SetDir("tutorialbank");
								bVideoAdded = true;
							}
							if (bTutorialAdded && bVideoAdded && bDescriptionAdded)
								break;

						}
						fclose(fTut);
						if (bTutorialAdded && bVideoAdded) {
							tutorial_videos.insert(std::make_pair(cTutorialSet, cVideoPath));
						}
						if (bTutorialAdded && bDescriptionAdded) {
							tutorial_description.insert(std::make_pair(cTutorialSet, cTutorialDescription));
						}
						if (bTutorialAdded && !bDescriptionAdded) {
							//If no desc , just add title.
							tutorial_description.insert(std::make_pair(cTutorialSet, cTutorialSet));
						}

						if (bTutorialAdded && !bVideoAdded) {
							//Add default video path. must always be the same as tutorial_files
							tutorial_videos.insert(std::make_pair(cTutorialSet, ""));
						}
					}
				}
			}
		}
	}
	SetDir(tOldDir.Get());

}
#endif

void generic_preloadfiles(void)
{
	//PE: We might have to edit this list when we have the final media to use.
	timestampactivity(0, "preload generic textures early");
	image_preload_files_start();

	#ifndef WICKEDENGINE
	image_preload_files_add("effectbank\\reloaded\\media\\water.dds");

	image_preload_files_add("gamecore\\projectiletypes\\fantasy\\fireball\\fireball_D.dds");
	image_preload_files_add("gamecore\\projectiletypes\\fantasy\\fireball\\fireball_N.dds");
	image_preload_files_add("gamecore\\projectiletypes\\fantasy\\fireball\\fireball_S.dds");
	image_preload_files_add("gamecore\\projectiletypes\\fantasy\\magicbolt\\magicbolt_D.dds");
	image_preload_files_add("gamecore\\projectiletypes\\fantasy\\magicbolt\\magicbolt_N.dds");
	image_preload_files_add("gamecore\\projectiletypes\\fantasy\\magicbolt\\magicbolt_S.dds");
	image_preload_files_add("gamecore\\projectiletypes\\fantasy\\magicbolt\\explode.dds");
	image_preload_files_add("gamecore\\projectiletypes\\fantasy\\magicbolt\\smoke.dds");
	image_preload_files_add("gamecore\\projectiletypes\\fantasy\\magicbolt\\trail.dds");
	image_preload_files_add("gamecore\\projectiletypes\\modern\\handgrenade\\handgrenade_D.dds");
	image_preload_files_add("gamecore\\projectiletypes\\modern\\handgrenade\\handgrenade_N.dds");
	image_preload_files_add("gamecore\\projectiletypes\\modern\\handgrenade\\handgrenade_S.dds");
	image_preload_files_add("gamecore\\projectiletypes\\modern\\rpggrenade\\rpggrenade_D.dds");
	image_preload_files_add("gamecore\\projectiletypes\\modern\\rpggrenade\\rpggrenade_N.dds");
	image_preload_files_add("gamecore\\projectiletypes\\modern\\rpggrenade\\rpggrenade_S.dds");

	image_preload_files_add("skybank\\clear\\clear_F.dds",1);
	image_preload_files_add("skybank\\clear\\clear_L.dds",1);
	image_preload_files_add("skybank\\clear\\clear_U.dds",1);
	image_preload_files_add("skybank\\clear\\clear_B.dds",1);
	image_preload_files_add("skybank\\clear\\clear_R.dds",1);
	image_preload_files_add("skybank\\clear\\clear_D.dds",1);
	image_preload_files_add("skybank\\clear\\clear_CLOUDS.dds",1);
	image_preload_files_add("skybank\\cloudportal.dds",1);

	#endif

	image_preload_files_add("effectbank\\explosion\\animatedspark.dds");
	image_preload_files_add("effectbank\\explosion\\explosion2.dds");
	image_preload_files_add("effectbank\\explosion\\fireball.dds");
	image_preload_files_add("effectbank\\explosion\\rollingsmoke.dds");
	image_preload_files_add("effectbank\\explosion\\explosion3.dds");
	image_preload_files_add("effectbank\\explosion\\darksmoke.dds");
	image_preload_files_add("effectbank\\explosion\\rubble.dds");
	image_preload_files_add("effectbank\\explosion\\concretechunk.dds");
	image_preload_files_add("effectbank\\explosion\\metalchunk.dds");

	image_preload_files_add("effectbank\\particles\\flare.dds");
	image_preload_files_add("effectbank\\particles\\64smoke2.dds");
	image_preload_files_add("effectbank\\particles\\flame.dds");
	
	//At this point.
	//Thread Job Done Time: 1657 
	//Add more know textures we need later.

	#ifndef WICKEDENGINE
	image_preload_files_add("terrainbank\\lush\\texture_D.dds");
	image_preload_files_add("effectbank\\reloaded\\media\\blank_N.dds");
	image_preload_files_add("effectbank\\reloaded\\media\\circle2.dds");
	image_preload_files_add("vegbank\\weedy 01\\grass.dds");

	image_preload_files_add("effectbank\\reloaded\\media\\blank_none_S.dds");
	image_preload_files_add("effectbank\\reloaded\\media\\blank_O.dds");
	image_preload_files_add("effectbank\\reloaded\\media\\materials\\0_Gloss.dds");
	#endif

	image_preload_files_add("editors\\gfx\\cursor.dds");

	

	//PNG Test.
	image_preload_files_add("languagebank\\english\\artwork\\quick-start-testlevel-prompt.png",1);
	image_preload_files_add("languagebank\\english\\artwork\\quick-help.png",1);
	image_preload_files_add("languagebank\\english\\artwork\\testgamelayout-vr.png",1);
	image_preload_files_add("languagebank\\english\\artwork\\testgamelayout-noweapons.png",1);

	image_preload_files_add("languagebank\\english\\artwork\\gurumeditation.png",1);
	image_preload_files_add("languagebank\\english\\artwork\\gurumeditationoff.png",1);

	image_preload_files_add("editors\\gfx\\memorymeter.png",1);
	#ifdef WICKEDENGINE
	image_preload_files_add("editors\\gfx\\4.png",1);
	image_preload_files_add("editors\\gfx\\5.png",1);
	image_preload_files_add("editors\\gfx\\13.png",1);
	image_preload_files_add("editors\\gfx\\26.png",1);
	#else
	image_preload_files_add("editors\\gfx\\4.bmp",1);
	image_preload_files_add("editors\\gfx\\5.bmp",1);
	image_preload_files_add("editors\\gfx\\13.bmp",1);
	image_preload_files_add("editors\\gfx\\26.bmp",1);
	#endif

	image_preload_files_add("editors\\gfx\\9.png",1);
	image_preload_files_add("editors\\gfx\\14.png",1);
	#ifdef WICKEDENGINE
	#else
	image_preload_files_add("editors\\gfx\\18.png",1);
	#endif

	image_preload_files_add("languagebank\\english\\artwork\\f9-help-terrain.png",1);
	image_preload_files_add("languagebank\\english\\artwork\\f9-help-entity.png",1);
	image_preload_files_add("languagebank\\english\\artwork\\f9-help-conkit.png",1);

	///image_preload_files_add("languagebank\\neutral\\gamecore\\huds\\interactive\\close-highlight.png",1);

	image_preload_files_add("editors\\gfx\\resources.png",1);
	image_preload_files_add("editors\\gfx\\resourceslow.png",1);

	image_preload_files_add("editors\\gfx\\resourcesgone.png",1);
	image_preload_files_add("editors\\gfx\\resourcesworking.png",1);


	image_preload_files_finish();
}

#ifdef VRTECH
void CloseDownEditorProperties(void)
{
	if (t.gridentityinzoomview > 0) 
	{
		t.tpressedtoleavezoommode = 2; //Exit zoom and save.
		int olges = t.grideditselect;
		//Make sure to exit fast. and restore cursor object.
		int igridentity = t.gridentity;
		if (iOldgridentity != t.gridentity && iOldgridentity > -1)
			t.gridentity = iOldgridentity;

		t.grideditselect = 4;
		editor_viewfunctionality();
		t.grideditselect = olges;
		t.gridentity = igridentity;
	}
}

void FormatTTS(LPSTR pFormattedTTS, LPSTR pFormattedTTSOut)
{
	memset(pFormattedTTSOut, 0, 1000);
	int nout = 0;
	for (int n = 0; n < strlen(pFormattedTTS); n++)
	{
		if ( pFormattedTTS[n] >= 32 && pFormattedTTS[n] <= 255 )
			pFormattedTTSOut[nout++] = pFormattedTTS[n];
	}
	pFormattedTTSOut[nout] = 0;
}

bool g_bVoiceSettingsChanged = false;
int g_iVoiceSettingsUpdateSpeechID = 0;

void SpeechControls(int speech_entries, bool bUpdateMainString, entityeleproftype *edit_grideleprof)
{
	if (!edit_grideleprof)
	{
		edit_grideleprof = &t.grideleprof;
	}

	//LB: Solve intend and incorrect component inclusion inside FPE (behavior area)
	ImGui::TextCenter("Speech Control");
	//if (ImGui::StyleCollapsingHeader("Speech Control", ImGuiTreeNodeFlags_DefaultOpen)) 
	{
		bool sapi_available = false;
		if (g_voiceList_s.size() > 0)
			sapi_available = true;

		ImGui::Indent(10);
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

		if (sapi_available) 
		{
			ImGui::Text("Voice");
			ImGui::SameLine();
			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
			//Combo
			ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
			ImGui::PushItemWidth(-10);
			if (ImGui::BeginCombo("##SelectVoiceCCP", pCCPVoiceSet)) // The second parameter is the label previewed before opening the combo.
			{
				int size = g_voiceList_s.size();
				for (int vloop = 0; vloop < size; vloop++) {

					bool is_selected = false;
					if (strcmp(g_voiceList_s[vloop].Get(), pCCPVoiceSet) == 0)
						is_selected = true;

					if (ImGui::Selectable(g_voiceList_s[vloop].Get(), is_selected)) 
					{
						//Change Voice set
						pCCPVoiceSet = g_voiceList_s[vloop].Get();
						CCP_SelectedToken = g_voicetoken[vloop];
						edit_grideleprof->voiceset_s = pCCPVoiceSet;
						if (g_bVoiceSettingsChanged == false)
						{
							g_bVoiceSettingsChanged = true;
							g_iVoiceSettingsUpdateSpeechID = 0;
						}
					}
					if (is_selected)
						ImGui::SetItemDefaultFocus();
				}
				ImGui::EndCombo();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Voice to Use For Speak");

			ImGui::PopItemWidth();

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
			ImGui::Text("Rate");
			ImGui::SameLine();
			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));

			ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
			ImGui::PushItemWidth(-10);
			int iOldRate = CCP_Speak_Rate;
			ImGui::SliderInt("##speakrate", &CCP_Speak_Rate, -5, 5);
			if (CCP_Speak_Rate != iOldRate)
			{
				edit_grideleprof->voicerate = CCP_Speak_Rate;
				if (g_bVoiceSettingsChanged == false)
				{
					g_bVoiceSettingsChanged = true;
					g_iVoiceSettingsUpdateSpeechID = 0;
				}
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set Speak Rate");

			ImGui::PopItemWidth();

		}
		//LOOP speech_entries
		//Use unique IDs

		// monitor lip sync generator
		bool bLipSyncGenerationBusy = false;
		float fProgressOfGeneration = GetWAVtoLIPProgress();
		if (fProgressOfGeneration > 0.0f && fProgressOfGeneration < 1.0f)
			bLipSyncGenerationBusy = true;

		for (int SpeechLoop = 0; SpeechLoop < speech_entries; SpeechLoop++)
		{
			if (speech_ids[SpeechLoop] >= 0)
			{
				cstr tmpvar = edit_grideleprof->PropertiesVariable.Variable[speech_ids[SpeechLoop]];
				tmpvar = tmpvar.Lower();

				//Display soundset file entry.
				int iButtonControlAndState = 0; // 0-can edit button, 1-buttom used, 2-background task in progress (so should not press button until done)
				if ( bLipSyncGenerationBusy == true ) iButtonControlAndState = 2;
				LPSTR pButtonControlIfBlocked = "Still Generating Lip Sync Data";
				cstr used_soundset;
				if (tmpvar == "speech1" || tmpvar == "speech 1") 
				{
					edit_grideleprof->soundset1_s = imgui_setpropertyfile2_ex_dlua(t.group, edit_grideleprof->soundset1_s.Get(), "SPEECH 1", t.strarr_s[254].Get(), "audiobank\\", &iButtonControlAndState, pButtonControlIfBlocked );
					used_soundset = edit_grideleprof->soundset1_s;
				}
				else if (tmpvar == "speech2" || tmpvar == "speech 2") 
				{
					edit_grideleprof->soundset2_s = imgui_setpropertyfile2_ex_dlua(t.group, edit_grideleprof->soundset2_s.Get(), "SPEECH 2", t.strarr_s[254].Get(), "audiobank\\", &iButtonControlAndState, pButtonControlIfBlocked );
					used_soundset = edit_grideleprof->soundset2_s;
				}
				else if (tmpvar == "speech3" || tmpvar == "speech 3") 
				{
					edit_grideleprof->soundset3_s = imgui_setpropertyfile2_ex_dlua(t.group, edit_grideleprof->soundset3_s.Get(), "SPEECH 3", t.strarr_s[254].Get(), "audiobank\\", &iButtonControlAndState, pButtonControlIfBlocked );
					used_soundset = edit_grideleprof->soundset3_s;
				}
				else if (tmpvar == "speech0" || tmpvar == "speech 0") 
				{
					edit_grideleprof->soundset_s = imgui_setpropertyfile2_ex_dlua(t.group, edit_grideleprof->soundset_s.Get(), "SPEECH", t.strarr_s[254].Get(), "audiobank\\", &iButtonControlAndState, pButtonControlIfBlocked );
					used_soundset = edit_grideleprof->soundset_s;
				}
				else 
				{
					edit_grideleprof->soundset_s = imgui_setpropertyfile2_ex_dlua(t.group, edit_grideleprof->soundset_s.Get(), "SPEECH 4", t.strarr_s[254].Get(), "audiobank\\", &iButtonControlAndState, pButtonControlIfBlocked );
					used_soundset = edit_grideleprof->soundset_s;
				}
				if (iButtonControlAndState == 1)
				{
					// user changed one of the speech fields, so generate LIP file for it
					ConvertWAVtoLIP(used_soundset.Get());
				}

				std::string uniquiField = ">";
				uniquiField = uniquiField + "##";
				uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);
				#ifdef WICKEDENGINE
				#else
				ImGui::SameLine();
				#endif
				ImGui::PushItemWidth(ImGui::GetFontSize()*2.0);

				int iButImageSize = 16;
				ImGui::PushID(grideleprof_uniqui_id++);

			#ifdef WICKEDENGINE
				ImGui::Indent(-10);
				if (ImGui::StyleButton("Play back current voiceover", ImVec2(ImGui::GetContentRegionAvail().x - 10, ImGui::GetFontSize()*1.5)))
				{
					// the sound we will use for the preview
					bool bJustStopped = false;
						int iFreeSoundID = g.temppreviewsoundoffset;
						if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
						{
							// stop currently playing preview
							StopSound(iFreeSoundID);
								bJustStopped = true;
						}
					if (used_soundset.Len() > 0)
					{
						// play custom wav file directly.
						if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
						if (FileExist(used_soundset.Get()) == 1 && bJustStopped == false)
						{
							LoadSound(used_soundset.Get(), iFreeSoundID, 0, 1);
							if (SoundExist(iFreeSoundID) == 1)
								PlaySound(iFreeSoundID);
						}
					}
				}
				ImGui::PopID();

				static bool g_bRecordingSound = false;
				static cstr g_recordingFile_s;
				uniquiField = "o";
				uniquiField = uniquiField + "##";
				uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);
				//ImGui::SameLine();
				//ImGui::PushItemWidth(ImGui::GetFontSize()*2.0);
				ImGui::PushID(grideleprof_uniqui_id++);
				//ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() - 6.0, ImGui::GetCursorPosY()));
				int iRecordBtnImg = MEDIA_RECORD;
				if (g_bRecordingSound == true) iRecordBtnImg = MEDIA_RECORDING;
				if (bLipSyncGenerationBusy == true) iRecordBtnImg = MEDIA_RECORDPROCESSING;
				if(ImGui::StyleButton("Record a new voiceover", ImVec2(ImGui::GetContentRegionAvail().x - 10, ImGui::GetFontSize()*1.5)))
				{
					if (g_bRecordingSound == false)
					{
						// can only start recording once any lip sync progress has finished
						if (bLipSyncGenerationBusy == true)
						{
							MessageBoxA(NULL, "Cannot start recording until lip sync generation finished", "Notification", MB_OK);
						}
						else
						{
							// choose a unique recording name
							int iRecordingNum = 1;
							while (iRecordingNum < 9999)
							{
								// find a free recording WAV filename
								g_recordingFile_s = cstr("audiobank\\recordings\\Recording-") + cstr(iRecordingNum) + ".wav";
								if (FileExist(g_recordingFile_s.Get()) == 0)
									break;
								iRecordingNum++;
							}

							// start recording
							cstr absWAVPath_s = g.fpscrootdir_s + "\\Files\\" + g_recordingFile_s;
							char pRealAbsWAVForRecording[MAX_PATH];
							strcpy(pRealAbsWAVForRecording, absWAVPath_s.Get());
							GG_GetRealPath(pRealAbsWAVForRecording, 1);
							RecordWAV(pRealAbsWAVForRecording);
							g_bRecordingSound = true;
						}
					}
				}
				ImGui::PopID();
				ImGui::Indent(10);
				ImGui::PopItemWidth();
				ImGui::Spacing();
			#else
				if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(iButImageSize, iButImageSize), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
				{
					// the sound we will use for the preview
					bool bJustStopped = false;
					int iFreeSoundID = g.temppreviewsoundoffset;
					if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
					{
						// stop currently playing preview
						StopSound(iFreeSoundID);
						bJustStopped = true;
					}
					if (used_soundset.Len() > 0) 
					{
						// play custom wav file directly.
						if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
						if (FileExist(used_soundset.Get()) == 1 && bJustStopped==false )
						{
							LoadSound(used_soundset.Get(), iFreeSoundID, 0, 1);
							if ( SoundExist(iFreeSoundID)==1 )
								PlaySound(iFreeSoundID);
						}
					}
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Play");

				ImGui::PopItemWidth();
				ImGui::PopID();

				// Recording button
				static bool g_bRecordingSound = false;
				static cstr g_recordingFile_s;
				uniquiField = "o";
				uniquiField = uniquiField + "##";
				uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);
				ImGui::SameLine();
				ImGui::PushItemWidth(ImGui::GetFontSize()*2.0);
				ImGui::PushID(grideleprof_uniqui_id++);
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() - 6.0, ImGui::GetCursorPosY()));
				int iRecordBtnImg = MEDIA_RECORD;
				if (g_bRecordingSound == true) iRecordBtnImg = MEDIA_RECORDING;
				if (bLipSyncGenerationBusy == true) iRecordBtnImg = MEDIA_RECORDPROCESSING;
				if (ImGui::ImgBtn(iRecordBtnImg, ImVec2(iButImageSize, iButImageSize), drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true, false, false, false, true))
				{
					if (g_bRecordingSound == false)
					{
						// can only start recording once any lip sync progress has finished
						if (bLipSyncGenerationBusy == true)
						{
							MessageBoxA(NULL, "Cannot start recording until lip sync generation finished", "Notification", MB_OK);
						}
						else
						{
							// choose a unique recording name
							int iRecordingNum = 1;
							while (iRecordingNum < 9999)
							{
								// find a free recording WAV filename
								g_recordingFile_s = cstr("audiobank\\recordings\\Recording-") + cstr(iRecordingNum) + ".wav";
								if (FileExist(g_recordingFile_s.Get()) == 0)
									break;
								iRecordingNum++;
							}

							// start recording
							cstr absWAVPath_s = g.fpscrootdir_s + "\\Files\\" + g_recordingFile_s;
							char pRealAbsWAVForRecording[MAX_PATH];
							strcpy(pRealAbsWAVForRecording, absWAVPath_s.Get());
							GG_GetRealPath(pRealAbsWAVForRecording, 1);
							RecordWAV(pRealAbsWAVForRecording);
							g_bRecordingSound = true;
						}
					}
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Record");
				ImGui::PopItemWidth();
				ImGui::PopID();
			#endif
				
				if (g_bRecordingSound == true)
				{
					if ( RecordWAVProgress() >= 1.0f && bLipSyncGenerationBusy == false )
					{
						// end recording mode
						g_bRecordingSound = false;

						// stop recording and save
						if (tmpvar == "speech1" || tmpvar == "speech 1") edit_grideleprof->soundset1_s = g_recordingFile_s;
						if (tmpvar == "speech2" || tmpvar == "speech 2") edit_grideleprof->soundset2_s = g_recordingFile_s;
						if (tmpvar == "speech3" || tmpvar == "speech 3") edit_grideleprof->soundset3_s = g_recordingFile_s;
						if (tmpvar == "speech0" || tmpvar == "speech 0") edit_grideleprof->soundset_s = g_recordingFile_s;

						// generate LIP file from recording
						cstr absWAVPath_s = g.fpscrootdir_s + "\\Files\\" + g_recordingFile_s;
						ConvertWAVtoLIP(absWAVPath_s.Get());
						bLipSyncGenerationBusy = true;
					}
				}

				if (sapi_available) 
				{
					//The edit_grideleprof->soundset_s to use is already known so:
					//Store the actual text entered in the DLUA value fields.
					ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
					ImGui::PushItemWidth(-10);

					ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());

					uniquiField = "";
					uniquiField = uniquiField + "##speakTTStext";
					uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

					// detect any editing of TTS text
					static bool bDetectWhenFinishedEditingTTSText = false;
					if (ImGui::InputTextMultiline(uniquiField.c_str(), &edit_grideleprof->PropertiesVariable.VariableValue[speech_ids[SpeechLoop]][0], 1024, ImVec2(0, ImGui::GetFontSize()*3.0f)))
					{
						// flagged any time TTS text changes
						bDetectWhenFinishedEditingTTSText = true;
					}
					if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

					// can also trigger regeneration of text when Voice Settings changed
					if (g_bVoiceSettingsChanged == true)
					{
						// go through all speeches and regeneate them one by one
						float fProgressOfGeneration = GetWAVtoLIPProgress();
						if (fProgressOfGeneration > 0.0f && fProgressOfGeneration < 1.0f)
						{
							// but if lip sync busy, we wait until free!
						}
						else
						{
							// when speech loop comes around to the next speech to refresh, trigger it now
							if (g_iVoiceSettingsUpdateSpeechID == SpeechLoop)
							{
								// regenerate this speech TTS
								bDetectWhenFinishedEditingTTSText = true;
								g_iVoiceSettingsUpdateSpeechID++;
								if (g_iVoiceSettingsUpdateSpeechID >= speech_entries)
								{
									// when no more speeches to refresh, finish voice settings cascade refresh
									g_bVoiceSettingsChanged = false;
								}
							}
						}
					}
					// only proceed when LIP sync not busy
					bool bLipSyncBusy = false;
					float fProgressOfGeneration = GetWAVtoLIPProgress();
					if (fProgressOfGeneration > 0.0f && fProgressOfGeneration < 1.0f) bLipSyncBusy = true;
					if (ImGui::IsItemActive() == false && bDetectWhenFinishedEditingTTSText==true && bLipSyncBusy==false)
					{
						// and reset as we are now doing the conversion and LIP file creation below
						bDetectWhenFinishedEditingTTSText = false;

						// this is the text we want to turn into WAV
						cstr TTSText_s = edit_grideleprof->PropertiesVariable.VariableValue[speech_ids[SpeechLoop]];

						// first, create a location to store the level-based TTS recordings
						// which will be in levelbank\ttsfiles\*.wav (keeps them local to FPM and transportable to Players)
						cstr pOldDir = GetDir();
						char pRealRoot[MAX_PATH];
						strcpy(pRealRoot, g.fpscrootdir_s.Get());
						strcat(pRealRoot, "\\Files\\levelbank\\");
						GG_GetRealPath(pRealRoot, 1);
						SetDir(pRealRoot);
						if (PathExist("testmap") == 0) MakeDirectory("testmap");
						SetDir("testmap");
						if (PathExist("ttsfiles") == 0) MakeDirectory("ttsfiles");
						SetDir("ttsfiles");

						// format typed text into something we can store as a reference in the TTS table below
						char pFormattedTTS[1000];
						int iInputTextMax = TTSText_s.Len();
						if (iInputTextMax > 999) iInputTextMax = 999;
						memcpy(pFormattedTTS, TTSText_s.Get(), iInputTextMax);
						pFormattedTTS[iInputTextMax] = 0;
						strcat(pFormattedTTS, pCCPVoiceSet);
						strcat(pFormattedTTS, cstr('A'+CCP_Speak_Rate).Get());
						char pFormattedTTSOut_Keeper[1000];
						FormatTTS(pFormattedTTS, pFormattedTTSOut_Keeper);

						// prepare two absolute paths for later
						char pRelLocationOfWAV[MAX_PATH];
						strcpy(pRelLocationOfWAV, "levelbank\\testmap\\ttsfiles\\"); // WAV added below

						// load in TTS table to see what TTS text we already have recordings for
						bool bIsTTSUnique = true;
						int iTTSTableMax = 0;
						std::vector <cstr> tempLines_s;
						Dim ( tempLines_s, 9999 );
						LPSTR pTTSTableFile = "ttstable.txt";
						if (FileExist(pTTSTableFile) == 1)
						{
							OpenToRead(1,pTTSTableFile);
							while (FileEnd(1) == 0)
							{
								tempLines_s[iTTSTableMax] = ReadString(1);
								iTTSTableMax++;
							}
							iTTSTableMax--;
							CloseFile(1);
						}
						if (iTTSTableMax > 0)
						{
							for (int line = 0; line < iTTSTableMax; line++)
							{
								// get the ref part of this line (and the WAV part for later)
								char pWAVItem[1001];
								char pRefItem[1001];
								strcpy(pWAVItem, "");
								strcpy(pRefItem, tempLines_s[line].Get());
								for (int n = 0; n < strlen(pRefItem); n++)
								{
									if (pRefItem[n] == 9)
									{
										strcpy(pWAVItem, pRefItem+n+1);
										pRefItem[n] = 0;
										break;
									}
								}

								// does it match what we are looking to add in
								if (stricmp(pRefItem, pFormattedTTSOut_Keeper) == NULL)
								{
									// yes, found the TTS we want already in the table
									if (FileExist(pWAVItem) == 1)
									{
										strcat(pRelLocationOfWAV, pWAVItem);
										bIsTTSUnique = false;
										break;
									}
								}
							}
						}

						// determine if what we have is unique
						if ( bIsTTSUnique == true )
						{
							// if so, create a unique file name entry for this one
							cstr pTTSFile;
							int iTTSNum = 1;
							while (iTTSNum < 9999)
							{
								pTTSFile = cstr("TTS") + cstr(iTTSNum) + ".wav";
								if (FileExist(pTTSFile.Get()) == 0)
									break;
								else
									iTTSNum++;
							}
							if (iTTSNum <= 9999)
							{
								// complete path new TTS WAV
								strcat(pRelLocationOfWAV, pTTSFile.Get());

								// add to table for future reference and potential use
								LPSTR pTTSTableFile = "ttstable.txt";
								if (FileExist(pTTSTableFile) == 1) DeleteFileA(pTTSTableFile);
								OpenToWrite(1,pTTSTableFile);
								for ( int i = 0; i<iTTSTableMax; i++ )
								{
									WriteString(1, tempLines_s[i].Get());
								}
								char pNewLine[1000];
								strcpy(pNewLine, pFormattedTTSOut_Keeper);
								pNewLine[strlen(pFormattedTTSOut_Keeper)+0] = 9;
								pNewLine[strlen(pFormattedTTSOut_Keeper)+1] = 0;
								strcat(pNewLine, pTTSFile.Get());
								WriteString(1,pNewLine);
								CloseFile(1);

								// need to be back in Files\\ folder for conversion to work properly
								SetDir(pOldDir.Get());

								// turn TEXT into WAV, store in this folder
								LPSTR pWAVFilename = pRelLocationOfWAV;
								if (FileExist(pWAVFilename)) DeleteFileA(pWAVFilename);
								LPSTR pWhatToSay = TTSText_s.Get();
								CComPtr<ISpVoice> spVoice;
								HRESULT hr = spVoice.CoCreateInstance(CLSID_SpVoice);
								if (SUCCEEDED(hr))
								{
									hr = spVoice->SetVoice(CCP_SelectedToken);
									if (SUCCEEDED(hr))
									{
										char pFinalWAVFilename[MAX_PATH];
										strcpy(pFinalWAVFilename, pWAVFilename);
										#ifdef WICKEDENGINE
										GG_GetRealPath(pFinalWAVFilename, 1);
										#endif
										ConvertTXTtoWAVMeatyPart(spVoice, CCP_SelectedToken, CCP_Speak_Rate, pWhatToSay, pFinalWAVFilename);
									}
								}
							}
						}
						else
						{
							// if not, the 'pRelLocationOfWAV' carries the previous WAV we can use from the TTS table
						}

						// change field of SPEECH X to [use text speech] - indicating its using the internal TTS wav created
						if (tmpvar == "speech1" || tmpvar == "speech 1") edit_grideleprof->soundset1_s = pRelLocationOfWAV;
						if (tmpvar == "speech2" || tmpvar == "speech 2") edit_grideleprof->soundset2_s = pRelLocationOfWAV;
						if (tmpvar == "speech3" || tmpvar == "speech 3") edit_grideleprof->soundset3_s = pRelLocationOfWAV;
						if (tmpvar == "speech0" || tmpvar == "speech 0") edit_grideleprof->soundset_s = pRelLocationOfWAV;

						// restore original folder for LIP file creation
						SetDir(pOldDir.Get());

						// can begin the WAV to LIP file now as we have the WAV file created
						ConvertWAVtoLIP(pRelLocationOfWAV);

						// and before we leave, take the opportunity to scan ALL entities and see if there are
						// any entries in the TTS table (and associated WAVs) that are not needed (probably due to recent change above)
						char pRealTTSFilesFolder[MAX_PATH];
						strcpy(pRealTTSFilesFolder, g.fpscrootdir_s.Get());
						strcat(pRealTTSFilesFolder, "\\Files\\levelbank\\testmap\\");
						SetDir(pRealTTSFilesFolder);
						if (PathExist("ttsfiles") == 0) MakeDirectory("ttsfiles");
						SetDir("ttsfiles");

						// load in latest TTS (given above activity of possible addition of new one)
						std::vector <cstr> tempRefs_s;
						Dim ( tempRefs_s, 9999 );
						iTTSTableMax = 0;
						pTTSTableFile = "ttstable.txt";
						if (FileExist(pTTSTableFile) == 1)
						{
							OpenToRead(1,pTTSTableFile);
							while (FileEnd(1) == 0)
							{
								char pRefItem[1001];
								tempLines_s[iTTSTableMax] = ReadString(1);
								strcpy ( pRefItem, tempLines_s[iTTSTableMax].Get() );
								for (int n = 0; n < strlen(pRefItem); n++)
								{
									if (pRefItem[n] == 9)
									{
										pRefItem[n] = 0;
										break;
									}
								}
								tempRefs_s[iTTSTableMax] = pRefItem;
								iTTSTableMax++;
							}
							iTTSTableMax--;
							CloseFile(1);
						}

						// start an array to hold flag as to whether to keep TTS table entry
						// and go through to auto-accept the one we've just added above (so it does not get deleted)
						bool* pbKeepInTable = new bool[iTTSTableMax+1];
						for (int iTTS = 0; iTTS < iTTSTableMax; iTTS++)
						{
							pbKeepInTable[iTTS] = false;
							if (stricmp(pFormattedTTSOut_Keeper, tempRefs_s[iTTS].Get()) == NULL)
								pbKeepInTable[iTTS] = true;
						}

						// go through ALL entities in current level (and all speech TTS texts buried in each one)
						for ( int e2 = 1; e2 <= g.entityelementlist; e2++ )
						{
							// need voice and speak rate from this entity
							LPSTR pVoiceSet2 = t.entityelement[e2].eleprof.voiceset_s.Get();
							int iSpeakRate2 = t.entityelement[e2].eleprof.voicerate;
							if (strlen(pVoiceSet2) == 0)
							{
								// default to first voice at startard rate
								pVoiceSet2 = g_voiceList_s[0].Get();
								iSpeakRate2 = 0;
							}

							int speech_ids2[5];
							for ( int n2 = 0; n2 < 5; n2++ ) speech_ids2[n2] = -1;
							int speech_entries2 = 0;
							for (int i2 = 0; i2 < t.entityelement[e2].eleprof.PropertiesVariable.iVariables; i2++)
							{
								cstr tmpvar = t.entityelement[e2].eleprof.PropertiesVariable.Variable[i2];
								tmpvar = tmpvar.Lower();
								if (speech_entries2 <= 3)
								{
									if (tmpvar == "speech1" || tmpvar == "speech 1") speech_ids2[speech_entries2++] = i2;
									if (tmpvar == "speech2" || tmpvar == "speech 2") speech_ids2[speech_entries2++] = i2;
									if (tmpvar == "speech3" || tmpvar == "speech 3") speech_ids2[speech_entries2++] = i2;
									if (tmpvar == "speech0" || tmpvar == "speech 0") speech_ids2[speech_entries2++] = i2;
								}
							}
							for (int iSpeechLoop2 = 0; iSpeechLoop2 < 4; iSpeechLoop2++)
							{
								LPSTR pSpeechItem = NULL;
								if (speech_ids2[iSpeechLoop2] != -1)
								{
									if (iSpeechLoop2 == 0) pSpeechItem = t.entityelement[e2].eleprof.PropertiesVariable.VariableValue[speech_ids2[iSpeechLoop2]];
									if (iSpeechLoop2 == 1) pSpeechItem = t.entityelement[e2].eleprof.PropertiesVariable.VariableValue[speech_ids2[iSpeechLoop2]];
									if (iSpeechLoop2 == 2) pSpeechItem = t.entityelement[e2].eleprof.PropertiesVariable.VariableValue[speech_ids2[iSpeechLoop2]];
									if (iSpeechLoop2 == 3) pSpeechItem = t.entityelement[e2].eleprof.PropertiesVariable.VariableValue[speech_ids2[iSpeechLoop2]];
									if (pSpeechItem)
									{
										// ensure the TTS string is formatted so can be matched against table (who's refs are formatted) [nice to do a hash here?]
										char pSpeechItemFormatted[1000];
										strcpy(pSpeechItemFormatted, pSpeechItem);
										strcat(pSpeechItemFormatted, pVoiceSet2);
										strcat(pSpeechItemFormatted, cstr('A'+iSpeakRate2).Get());
										char pSpeechItemFormattedOut[1000];
										FormatTTS(pSpeechItemFormatted, pSpeechItemFormattedOut);

										// a TTS text in one of the entity sound slots
										for (int iTTS = 0; iTTS < iTTSTableMax; iTTS++)
										{
											// compare the table entry with this entities TTS
											if (stricmp(pSpeechItemFormattedOut, tempRefs_s[iTTS].Get()) == NULL)
											{
												// found a match, flag this table entry as a keeper
												pbKeepInTable[iTTS] = true;
											}
										}
									}
								}
							}
						}
						// finally create a new table of only the keepers
						if (iTTSTableMax > 0)
						{
							// before table creation, check for duplicates (can happen when editing an entity over and over)
							for (int i1 = 0; i1 < iTTSTableMax; i1++)
							{
								if (pbKeepInTable[i1] == true)
								{
									for (int i2 = 0; i2 < iTTSTableMax; i2++)
									{
										if (i1 != i2)
										{
											if (pbKeepInTable[i2] == true)
											{
												// comparing two entries, both valid and not same index
												// ensure primary (i) survives at expense of any identical entries (i2)
												LPSTR i1Ref = tempRefs_s[i1].Get();
												LPSTR i2Ref = tempRefs_s[i2].Get();
												if (stricmp(i1Ref, i2Ref) == NULL)
												{
													// remove duplicate
													pbKeepInTable[i2] = false;

													// also delete WAV and LIP files associated with this duplicate
													char pWAVItem[1001];
													strcpy(pWAVItem, "");
													char pRefItem[1001];
													strcpy(pRefItem, tempLines_s[i2].Get());
													for (int n = 0; n < strlen(pRefItem); n++)
													{
														if (pRefItem[n] == 9)
														{
															strcpy(pWAVItem, pRefItem+n+1);
															break;
														}
													}
													if (FileExist(pWAVItem) == 1) DeleteFileA(pWAVItem);
													char pLIPItem[1001];
													strcpy(pLIPItem, pWAVItem); 
													pLIPItem[strlen(pLIPItem) - 4] = 0;
													strcat(pLIPItem, ".lip");
													if (FileExist(pLIPItem) == 1) DeleteFileA(pLIPItem);

													// and finally reroute entities that used this WAV to the primary one
													for (int e2 = 1; e2 <= g.entityelementlist; e2++)
													{
														for (int s2 = 0; s2 < 4; s2++)
														{
															LPSTR pThisSlotsWAV = NULL;
															if (s2 == 0) pThisSlotsWAV = t.entityelement[e2].eleprof.soundset_s.Get();
															if (s2 == 1) pThisSlotsWAV = t.entityelement[e2].eleprof.soundset1_s.Get();
															if (s2 == 2) pThisSlotsWAV = t.entityelement[e2].eleprof.soundset2_s.Get();
															if (s2 == 3) pThisSlotsWAV = t.entityelement[e2].eleprof.soundset3_s.Get();
															if (pThisSlotsWAV)
															{
																if (stricmp(pThisSlotsWAV, pWAVItem) == NULL)
																{
																	cstr newWAV_s = (LPSTR)tempLines_s[i1].Get()+strlen(tempRefs_s[i1].Get());
																	if (s2 == 0) t.entityelement[e2].eleprof.soundset_s = newWAV_s;
																	if (s2 == 1) t.entityelement[e2].eleprof.soundset1_s = newWAV_s;
																	if (s2 == 2) t.entityelement[e2].eleprof.soundset2_s = newWAV_s;
																	if (s2 == 3) t.entityelement[e2].eleprof.soundset3_s = newWAV_s;
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}

							// final creation of table
							LPSTR pTTSTableFile = "ttstable.txt";
							if (FileExist(pTTSTableFile) == 1) DeleteFileA(pTTSTableFile);
							OpenToWrite(1, pTTSTableFile);
							for (int i = 0; i < iTTSTableMax; i++)
							{
								if (pbKeepInTable[i] == true)
								{
									// keep this in table
									WriteString(1, tempLines_s[i].Get());
								}
								else
								{
									// remove from table - and also delete the associated WAV file
									char pWAVItem[1001];
									strcpy(pWAVItem, "");
									char pRefItem[1001];
									strcpy(pRefItem, tempLines_s[i].Get());
									for (int n = 0; n < strlen(pRefItem); n++)
									{
										if (pRefItem[n] == 9)
										{
											strcpy(pWAVItem, pRefItem+n+1);
											break;
										}
									}
									if (FileExist(pWAVItem) == 1) DeleteFileA(pWAVItem);
									char pLIPItem[1001];
									strcpy(pLIPItem, pWAVItem); 
									pLIPItem[strlen(pLIPItem) - 4] = 0;
									strcat(pLIPItem, ".lip");
									if (FileExist(pLIPItem) == 1) DeleteFileA(pLIPItem);
								}
							}
							CloseFile(1);
						}

						// and free resources
						SAFE_DELETE(pbKeepInTable);

						// restore original folder when finished
						SetDir(pOldDir.Get());

						// trigger a main string update
						bUpdateMainString = true;
					}

					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Enter Text to Speak");

					ImGui::PopItemWidth();

				}
			}
		}

		//Update DLUA if changed. this is stored in soundset4_s.
		//Update soundset4_s when we have changes.
		entityeleproftype *tmpeleprof = edit_grideleprof;
		if (bUpdateMainString) 
		{
			cstr sLuaScriptName = tmpeleprof->PropertiesVariable.VariableScript;
			sLuaScriptName += "_properties(";
			//Check if we need to update with new default values.
			if (tmpeleprof->PropertiesVariable.iVariables > 0) 
			{
				tmpeleprof->soundset4_s = sLuaScriptName;
				//Add varables.
				for (int i = 0; i < tmpeleprof->PropertiesVariable.iVariables; i++) 
				{

					char val[3];
					val[0] = tmpeleprof->PropertiesVariable.VariableType[i] + '0';
					val[1] = 0;

					tmpeleprof->soundset4_s += val;
					tmpeleprof->soundset4_s += "\"";
					std::string clean_string = tmpeleprof->PropertiesVariable.VariableValue[i];
					replaceAll(clean_string, "\"", ""); //cant use "
					tmpeleprof->soundset4_s += (char *) clean_string.c_str();
					//tmpeleprof->soundset4_s += tmpeleprof->PropertiesVariable.VariableValue[i];
					tmpeleprof->soundset4_s += "\"";
					if (i < tmpeleprof->PropertiesVariable.iVariables - 1)
						tmpeleprof->soundset4_s += ",";
				}
				tmpeleprof->soundset4_s += ")";
			}
		}

		ImGui::Indent(-10);
	}
}

void RedockWindow(char *name)
{
	if (refresh_gui_docking >= 4 ) {

		ImGuiID dockspace_id;

		//dock it.
		int winNodeId = ImGui::GetWindowDockID();
		dockspace_id = ImGui::GetID("MyDockspace");
		ImGui::DockBuilderDockWindow(name, dock_tools_windows);
		int winNodeId2 = ImGui::GetWindowDockID();
		if (winNodeId != 0 && winNodeId2 != 0 && winNodeId != winNodeId2) {
			//Somthing wrong we cant rebuild.
			//Change window size to normal and undock:
			//m_editor->resizewindownext = true;
		}
		else {
			ImGui::DockBuilderFinish(dockspace_id);
		}
	}
}

int pehuntingbug = 0;
void CheckMinimumDockSpaceSize(float minsize)
{
	//Only make these change when not resizing/moving ...
	int mcursor = ImGui::GetMouseCursor();
	if (mcursor == 0 || !ImGui::IsAnyMouseDown() ) {
		if (ImGui::IsWindowDocked()) {
			int winNodeId = ImGui::GetWindowDockID();
			ImGuiDockNode* testnode = ImGui::DockBuilderGetNode(winNodeId);
			if (testnode->Size.x < minsize && testnode->Size.y > 80.0f ) {
				//Something wrong , adjust.
				if (minsize == 50.0f) {
					//PE: Found it this happens when you use minimize :) , just need to check for that.

					//PE: Bug left panel get small. add breakpoint here to check.
					pehuntingbug = 1;
				}
				//PE: When i got it this was the values ? 12,32
				//PE: testnode->SizeRef was the correct values.
				if (testnode->Size.x != 12 && testnode->Size.x != 13 && testnode->Size.y != 32) {
					testnode->Size.x = minsize;
					testnode->SizeRef.x = minsize;
				}
				//ImGui::DockNodeTreeUpdatePosSize(testnode, testnode->Pos, testnode->Size,false);
			}
			if (testnode->Size.y < 20.0f) {
				//Something wrong , adjust.
				if (minsize == 50.0f) {
					//PE: Bug left panel get small. add breakpoint here to check.
					pehuntingbug = 2;
				}
				if (testnode->Size.x != 12 && testnode->Size.x != 13 && testnode->Size.y != 32) {
					testnode->Size.y = 50.0f;
					testnode->SizeRef.y = 50.0f;
				}
				//ImGui::DockNodeTreeUpdatePosSize(testnode, host_window->Pos, host_window->Size);
			}
		}
	}
}
#endif


#ifdef WICKEDENGINE
#define TABPAGEWEATHER 1

#include "..\..\Guru-WickedMAX\master.h"

extern wiECS::Entity g_weatherEntityID;
extern MasterRenderer * master_renderer;

//Visuals
void tab_tab_Column_text(char *text,float fColumn)
{
	ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
	ImGui::Text(text);
	ImGui::SameLine();
	ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
	ImGui::SetCursorPos(ImVec2(fColumn, ImGui::GetCursorPosY()));
}



static void DisplayPerformanceData(bool* p_open)
{
	const float DISTANCE = 10.0f;
	static int corner = 0;
	ImGuiIO& io = ImGui::GetIO();
	if (corner != -1)
	{
		ImGuiViewport* viewport = ImGui::GetMainViewport();
		ImVec2 window_pos = ImVec2((corner & 1) ? (viewport->Pos.x + viewport->Size.x - DISTANCE) : (viewport->Pos.x + DISTANCE), (corner & 2) ? (viewport->Pos.y + viewport->Size.y - DISTANCE) : (viewport->Pos.y + DISTANCE));
		ImVec2 window_pos_pivot = ImVec2((corner & 1) ? 1.0f : 0.0f, (corner & 2) ? 1.0f : 0.0f);
		ImGui::SetNextWindowPos(window_pos, ImGuiCond_Always, window_pos_pivot);
		ImGui::SetNextWindowViewport(viewport->ID); //PE: Always main viewport.
	}
	ImGui::SetNextWindowBgAlpha(0.35f); // Transparent background
	if (ImGui::Begin("##DisplayPerformanceData", p_open, (corner != -1 ? ImGuiWindowFlags_NoMove : 0) | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav))
	{
		ImGui::Text("Performance data\n");
		ImGui::Separator();

		int dc = wiProfiler::GetDrawCalls();
		int dcs = wiProfiler::GetDrawCallsShadows();
		int dct = wiProfiler::GetDrawCallsTransparent();

		int tris = wiProfiler::GetPolygons();
		int trisShadow = wiProfiler::GetPolygonsShadows();
		int trisTransparent = wiProfiler::GetPolygonsTransparent();
		
		ImGui::Text("FPS: %.1f - Draw Calls: %5d, %5d, %5d", ImGui::GetIO().Framerate, dc, dcs, dct);
		ImGui::Text("Triangles: %7d, %7d, %7d", tris, trisShadow, trisTransparent);
		//ImGui::Text("Draw Calls Objects: %d", dc - dcs);
		//ImGui::Text("Draw Calls Shadows: %d", dcs);

		ImGui::Separator();

		std::string profiler_data = wiProfiler::GetProfilerData();
		ImGui::Text(profiler_data.c_str());

		ImGui::Separator();
	}
	ImGui::End();
}

void imgui_Customize_Water(int mode);

// build up data structure we need
struct sLeafNode
{
	int iInstructionIndex;
	int iUniqueSignatureCode;
	int iState;
	int iCondition;
	char pConditionParam1[250];
	char pConditionParam2[250];
	int iAction;
	char pActionParam1[250];
	char pActionParam2[250];
	sLeafNode* pGoToInstruction;
	ImVec2 vReturnPointPos;
	float fWidthRequired;
	sLeafNode* pParent;
	sLeafNode* pAlso;
	sLeafNode* pElse;
};

struct sStateNode
{
	char pName[250];
	int iStateIndex;
	sLeafNode* instruction_root;
	bool bAllowInterupt;
	bool bRecalcRightMost;
	float fRightMostX;
};
std::vector<sStateNode> instruction_state_list;

bool instruction_createstate = false;
char instruction_newstatename[256];
int instruction_deletestate = -1;

float instruction_block_width;
float instruction_block_height;
float instruction_vertical_gap;
float instruction_border;
float instruction_centerline;
float instruction_centerline_absolutex;
ImVec2 instruction_furthestcursor;
bool instruction_regenerateinstructionindices = false;
sLeafNode* instruction_deletethis = NULL;
sStateNode* instruction_deleteinthisstate = NULL;
int instruction_pickstateorinstruction = 0;
sLeafNode* instruction_pickaninstruction = NULL;
sLeafNode* instruction_hoveringover = NULL;
int instruction_picknewendnode = 0;
sLeafNode* instruction_pickanewnode = NULL;
std::vector<sLeafNode*> instruction_singlelist;
bool instruction_freezewheneditingbehavior = false;
int instruction_running_e = 0;
int instruction_running_index = 0;
char instruction_objectscriptbeingedited[256] = { 0 };
bool instruction_recreatebehaviorlist = true;

void gridedit_restartanybehaviorediting()
{
	strcpy (instruction_objectscriptbeingedited, "");
	instruction_recreatebehaviorlist = true;
}

void gridedit_refreshallinstructionindices ( int iStateIndex, sLeafNode* pThis, int* piInstructionCount)
{
	pThis->iState = iStateIndex;
	pThis->iInstructionIndex = *piInstructionCount;
	instruction_singlelist.push_back(pThis);
	*piInstructionCount = *piInstructionCount + 1;
	if (pThis->pAlso) gridedit_refreshallinstructionindices(iStateIndex, pThis->pAlso, piInstructionCount);
	if (pThis->pElse) gridedit_refreshallinstructionindices(iStateIndex, pThis->pElse, piInstructionCount);
}

int gridedit_generateuniqueinstructionindices ( void )
{
	// build single list of all instructions from above nodes
	instruction_singlelist.clear();

	// also, go through all states, re-order instruction indices
	int iInstructionCount = 1;
	for (int iStateIndex = 0; iStateIndex < instruction_state_list.size(); iStateIndex++)
	{
		gridedit_refreshallinstructionindices(1+iStateIndex, instruction_state_list[iStateIndex].instruction_root, &iInstructionCount);
	}

	// return number of instructions
	return iInstructionCount - 1;
}

bool gridedit_instruction_inthisstate_rec (sLeafNode* pinstruction)
{
	bool bResult = false;
	if (pinstruction->iInstructionIndex == 1 + instruction_running_index)
	{
		// the instruction is in THIS state
		return true;
	}
	else
	{
		// keep looking
		bool bResult = false;
		if (pinstruction->pAlso) bResult = gridedit_instruction_inthisstate_rec(pinstruction->pAlso);
		if (pinstruction->pElse && bResult==false) bResult = gridedit_instruction_inthisstate_rec(pinstruction->pElse);
		return bResult;
	}
}

float gridedit_instruction_calculatewidth_rec (sLeafNode* pinstruction)
{
	float fTotalWidthNeededForChildren = 0.0f;
	if (pinstruction->pAlso==NULL && pinstruction->pElse==NULL)
	{
		// leaf node
		fTotalWidthNeededForChildren += 0.55f;
	}
	else
	{
		// new system needed, this is a little hard to navigate when have LARGE behaviors!!
		if (pinstruction->pAlso) fTotalWidthNeededForChildren += 0.05f + gridedit_instruction_calculatewidth_rec(pinstruction->pAlso);
		if (pinstruction->pElse) fTotalWidthNeededForChildren += 0.1f + gridedit_instruction_calculatewidth_rec(pinstruction->pElse);
		// works but is massively wide!!
		// parent node
		//float fLeftSide = 0.0f; if (pinstruction->pAlso) fLeftSide = gridedit_instruction_calculatewidth_rec(pinstruction->pAlso);
		//float fRightSide = 0.0f; if (pinstruction->pElse) fRightSide = gridedit_instruction_calculatewidth_rec(pinstruction->pElse);
		/// taker largest child width and make it symetrical
		//fTotalWidthNeededForChildren = fLeftSide;
		//if (fRightSide > fTotalWidthNeededForChildren) fTotalWidthNeededForChildren = fRightSide;
		//fTotalWidthNeededForChildren *= 2;
	}
	pinstruction->fWidthRequired = fTotalWidthNeededForChildren;
	return fTotalWidthNeededForChildren;
}

struct sCondActTable
{
	int iID;
	cstr sLabel;
	cstr sTip;
};
std::vector<sCondActTable> g_ConditionsTable;
std::vector<sCondActTable> g_ActionsTable;
char** combo_conditions = NULL;
int* combo_conditions_lookup = NULL;
char** combo_actions = NULL;
int* combo_actions_lookup = NULL;
int combo_animations_count = 0;
char** combo_animations = NULL;

void gridedit_instruction_parseandpopulateinstructions (void)
{
	// free any previous list
	if (combo_conditions)
	{
		for (int i = 0; i < g_ConditionsTable.size(); i++)
		{
			delete combo_conditions[i];
		}
		delete[] combo_conditions;
		delete[] combo_conditions_lookup;
	}
	if (combo_actions)
	{
		for (int i = 0; i < g_ActionsTable.size(); i++)
		{
			delete combo_actions[i];
		}
		delete[] combo_actions;
		delete[] combo_actions_lookup;
	}

	// clear lists
	g_ConditionsTable.clear();
	g_ActionsTable.clear();

	// condition list has extra ability
	sCondActTable deleteitem;
	deleteitem.iID = 0;
	deleteitem.sLabel = "(delete instruction)";
	deleteitem.sTip = "Select this to delete the current instruction block";
	g_ConditionsTable.push_back(deleteitem);
	sCondActTable moveitem;
	moveitem.iID = 1;
	moveitem.sLabel = "(move instruction)";
	moveitem.sTip = "Select this to move the current instruction block chain to a new position in the state flow";
	g_ConditionsTable.push_back(moveitem);

	// parse 'masterinterpreter.lua' and extract condition and action ordinals, labels and tooltips
	char pMasterInterpreterFile[MAX_PATH];
	sprintf(pMasterInterpreterFile, "scriptbank\\masterinterpreter.lua");
	OpenToRead(1, pMasterInterpreterFile);
	while (FileEnd(1) == 0)
	{
		// get line by line
		cstr line_s = ReadString(1);
		LPSTR pLine = line_s.Get();

		// extract conditions and actions
		int iParseThisLine = 0;
		LPSTR pFind = "g_masterinterpreter_cond_"; if (strnicmp (pLine, pFind, strlen(pFind)) == NULL) iParseThisLine = 1;
		pFind = "g_masterinterpreter_act_"; if (strnicmp (pLine, pFind, strlen(pFind)) == NULL) iParseThisLine = 2;
		if (iParseThisLine > 0)
		{
			LPSTR pEndOfCondActVar = strstr(pLine, " = ");
			if (pEndOfCondActVar)
			{
				LPSTR pStartOfLabel = strstr(pEndOfCondActVar, "-- ");
				if (pStartOfLabel)
				{
					LPSTR pOpenBracket = strstr(pStartOfLabel, "(");
					if (pOpenBracket)
					{
						LPSTR pCloseBracket = strstr(pOpenBracket, ")");
						if (pCloseBracket)
						{
							// line is valid, parse into entries
							char pValue[32];
							memset(pValue, 0, 32);
							pEndOfCondActVar += 3;
							memcpy(pValue, pEndOfCondActVar, pStartOfLabel - pEndOfCondActVar);
							char pLabel[256];
							memset(pLabel, 0, 256);
							pStartOfLabel += 3;
							memcpy(pLabel, pStartOfLabel, pOpenBracket - pStartOfLabel);
							char pTip[1024];
							memset(pTip, 0, 1024);
							pOpenBracket += 1;
							memcpy(pTip, pOpenBracket, pCloseBracket - pOpenBracket);

							// create item
							sCondActTable item;
							item.iID = atoi(pValue);
							item.sLabel = pLabel;
							item.sTip = pTip;

							// add to list
							if (iParseThisLine == 1) g_ConditionsTable.push_back(item);
							if (iParseThisLine == 2) g_ActionsTable.push_back(item);
						}
					}
				}
			}
		}
	}
	CloseFile(1);

	// create new lists
	combo_conditions_lookup = new int[g_ConditionsTable.size()];
	combo_conditions = new char*[g_ConditionsTable.size()];
	for (int i = 0; i < g_ConditionsTable.size(); i++)
	{
		combo_conditions_lookup[i] = g_ConditionsTable[i].iID;
		combo_conditions[i] = new char[256];
		strcpy (combo_conditions[i], g_ConditionsTable[i].sLabel.Get());
	}
	combo_actions_lookup = new int[g_ActionsTable.size()];
	combo_actions = new char*[g_ActionsTable.size()];
	for (int i = 0; i < g_ActionsTable.size(); i++)
	{
		combo_actions_lookup[i] = g_ActionsTable[i].iID;
		combo_actions[i] = new char[256];
		strcpy (combo_actions[i], g_ActionsTable[i].sLabel.Get());
	}
}

void gridedit_instruction_populateanimationlist ( int iObj )
{
	// free any previous animation list
	if (combo_animations)
	{
		for (int i = 0; i < combo_animations_count; i++)
		{
			delete combo_animations[i];
		}
		delete[] combo_animations;
		combo_animations = NULL;
	}

	// create animation list
	combo_animations_count = 0;
	if (iObj > 0)
	{
		sObject* pObject = GetObjectData(iObj);
		sAnimationSet* pAnimSet = pObject->pAnimationSet;
		while (pAnimSet)
		{
			combo_animations_count++;
			pAnimSet = pAnimSet->pNext;
		}
		combo_animations = new char*[combo_animations_count];
		combo_animations_count = 0;
		pAnimSet = pObject->pAnimationSet;
		while (pAnimSet)
		{
			combo_animations[combo_animations_count] = new char[256];
			strcpy (combo_animations[combo_animations_count], pAnimSet->szName);
			combo_animations_count++;
			pAnimSet = pAnimSet->pNext;
		}
	}
}

void gridedit_instruction_block_rec ( sStateNode* pState, ImVec2 vTopCenterPos, LPSTR pStateName, sLeafNode* pinstruction, float fMargin, int iRowIndex)
{
	// Insert instruction block
	float fAbsInstructionLeftX = vTopCenterPos.x - (instruction_block_width / 2);
	ImGui::SetCursorPos(ImVec2(fAbsInstructionLeftX, vTopCenterPos.y));
	ImVec2 vInstructionPos = ImGui::GetCurrentWindow()->DC.CursorPos;
	ImVec2 vOutline = vInstructionPos - ImVec2(instruction_border, instruction_border);
	const ImRect instruction_bb(vOutline.x, vOutline.y, vOutline.x + instruction_block_width + (instruction_border * 2), vOutline.y + instruction_block_height + (instruction_border * 2));
	pinstruction->vReturnPointPos = ImVec2(vOutline.x, vOutline.y + (instruction_block_height / 2));

	// record left-most block (so can shift whole state to the left for more room)
	if (pState->bRecalcRightMost == true)
	{
		float fRightSideOfBlock = fAbsInstructionLeftX + instruction_block_width;
		if (pState->fRightMostX < fRightSideOfBlock) pState->fRightMostX = fRightSideOfBlock;
	}

	// In instruction pick mode, subdue colors
	ImGuiIO& io = ImGui::GetIO();
	ImVec4 block_col = ImVec4(1.0f, 1.0f, 1.0f, 0.2f);
	ImVec4 block_col_border = ImVec4(1.0f, 1.0f, 1.0f, 0.75f);
	if (instruction_pickaninstruction != NULL)
	{
		block_col = ImVec4(0.6f, 0.6f, 0.6f, 0.1f);
		block_col_border = ImVec4(0.6f, 0.6f, 0.6f, 0.5f);
		bool bHoveringOver = false;
		if (io.MousePos.x > instruction_bb.Min.x && io.MousePos.x < instruction_bb.Max.x && io.MousePos.y > instruction_bb.Min.y && io.MousePos.y < instruction_bb.Max.y)
		{
			if (instruction_pickstateorinstruction == 1)
			{
				// pick anything from any other state
				if (instruction_pickaninstruction->iState != pinstruction->iState)
				{
					block_col = ImVec4(1.0f, 1.0f, 1.0f, 0.4f);
					block_col_border = ImVec4(1.0f, 1.0f, 1.0f, 0.9f);
					instruction_hoveringover = pinstruction;
					bHoveringOver = true;
				}
			}
			if (instruction_pickstateorinstruction == 2)
			{
				// pick an instruction in same state
				if (instruction_pickaninstruction->iState == pinstruction->iState)
				{
					block_col = ImVec4(1.0f, 1.0f, 1.0f, 0.4f);
					block_col_border = ImVec4(1.0f, 1.0f, 1.0f, 0.9f);
					instruction_hoveringover = pinstruction;
					bHoveringOver = true;
				}
			}
		}
	}
	else
	{
		// when logic running, can highlight currently active instruction
		if (instruction_freezewheneditingbehavior == false)
		{
			if (instruction_running_e > 0)
			{
				if (instruction_running_index > 0)
				{
					if (pinstruction->iInstructionIndex == 1 + instruction_running_index)
					{
						block_col = ImVec4(1.0f, 1.0f, 0.6f, 0.6f);
						block_col_border = ImVec4(1.0f, 1.0f, 0.6f, 0.9f);
					}
				}
			}
		}
	}

	// Draw outline of instruction block
	ImGui::GetCurrentWindow()->DrawList->AddRectFilled(instruction_bb.Min, instruction_bb.Max, ImGui::GetColorU32(block_col), 0.0f, 15);
	ImGui::GetCurrentWindow()->DrawList->AddRect(instruction_bb.Min, instruction_bb.Max, ImGui::GetColorU32(block_col_border), 0.0f, 15, 2.0f);
	// condition combo
	char pInstructionDisplay[1024];
	sprintf(pInstructionDisplay, "##BehaviorEditorCondition%s%d", pStateName, pinstruction->iInstructionIndex);
	ImGui::PushItemWidth(instruction_block_width);
	int iPreviousConditionValue = pinstruction->iCondition;
	int iConditionListIndex = 0;
	for (int iFind = 0; iFind < g_ConditionsTable.size(); iFind++)
	{
		if (combo_conditions_lookup[iFind] == pinstruction->iCondition) iConditionListIndex = iFind;
	}
	if (ImGui::Combo(pInstructionDisplay, &iConditionListIndex, combo_conditions, g_ConditionsTable.size()))
	{
		pinstruction->iCondition = combo_conditions_lookup[iConditionListIndex];
		if (pinstruction->iCondition == 0)
		{
			// special case - until newer UI idea comes along, delete this instruction
			instruction_deletethis = pinstruction;
			instruction_deleteinthisstate = pState;
			pinstruction->iCondition = iPreviousConditionValue;
		}
		if (pinstruction->iCondition == 1)
		{
			// special case - select a new location for this instruction to be connected to
			instruction_picknewendnode = 1;
			instruction_pickanewnode = pinstruction;
			pinstruction->iCondition = iPreviousConditionValue;
		}
		instruction_freezewheneditingbehavior = true;
	}
	if (ImGui::IsItemHovered()) ImGui::SetTooltip(combo_conditions[iConditionListIndex]);
	// optional condition param
	sprintf(pInstructionDisplay, "##BehaviorEditorConditionParam1%s%d", pStateName, pinstruction->iInstructionIndex);
	ImGui::SetCursorPos(ImVec2(fAbsInstructionLeftX, ImGui::GetCursorPos().y));
	if (ImGui::InputText(pInstructionDisplay, &pinstruction->pConditionParam1[0], 250, ImGuiInputTextFlags_None))
	{
		instruction_freezewheneditingbehavior = true;
	}
	// action combo
	sprintf(pInstructionDisplay, "##BehaviorEditorAction%s%d", pStateName, pinstruction->iInstructionIndex);
	ImGui::SetCursorPos(ImVec2(fAbsInstructionLeftX, ImGui::GetCursorPos().y));
	int iPreviousActionValue = pinstruction->iAction;
	int iActionListIndex = 0;
	for (int iFind = 0; iFind < g_ActionsTable.size(); iFind++)
	{
		if (combo_actions_lookup[iFind] == pinstruction->iAction) iActionListIndex = iFind;
	}
	if (ImGui::Combo(pInstructionDisplay, &iActionListIndex, combo_actions, g_ActionsTable.size()))
	{
		pinstruction->iAction = combo_actions_lookup[iActionListIndex];

		// special instruction index change
		if (pinstruction->iAction == 0 || pinstruction->iAction == 1)
		{
			// can only change instruction block if no instructions in ALSO
			if (pinstruction->pAlso == NULL)
			{
				if (pinstruction->iAction == 0)
				{
					// special case - go to state
					instruction_pickstateorinstruction = 1;
					instruction_pickaninstruction = pinstruction;
				}
				if (pinstruction->iAction == 1)
				{
					// special case - go to instruction
					instruction_pickstateorinstruction = 2;
					instruction_pickaninstruction = pinstruction;
				}
			}
			else
			{
				pinstruction->iAction = iPreviousActionValue;
			}
		}
		else
		{
			// regular action
			pinstruction->pGoToInstruction = NULL;
		}
		instruction_freezewheneditingbehavior = true;
	}
	if (ImGui::IsItemHovered()) ImGui::SetTooltip(combo_actions[iActionListIndex]);
	// optional action param
	if (pinstruction->iAction == 12 || pinstruction->iAction == 13 || pinstruction->iAction == 66 || pinstruction->iAction == 67)
	{
		// play and loop shows animation list for this object
		sprintf(pInstructionDisplay, "##BehaviorEditorActionParam1Combo%s%d", pStateName, pinstruction->iInstructionIndex);
		ImGui::SetCursorPos(ImVec2(fAbsInstructionLeftX, ImGui::GetCursorPos().y));
		int iAnimationListIndex = 0;
		for (int iFind = 0; iFind < combo_animations_count; iFind++)
		{
			if ( stricmp (combo_animations[iFind], pinstruction->pActionParam1)==NULL) iAnimationListIndex = iFind;
		}
		if (ImGui::Combo(pInstructionDisplay, &iAnimationListIndex, combo_animations, combo_animations_count))
		{
			strcpy ( pinstruction->pActionParam1, combo_animations[iAnimationListIndex]);
		}
	}
	else
	{
		// regular text field
		sprintf(pInstructionDisplay, "##BehaviorEditorActionParam1%s%d", pStateName, pinstruction->iInstructionIndex);
		ImGui::SetCursorPos(ImVec2(fAbsInstructionLeftX, ImGui::GetCursorPos().y));
		if (ImGui::InputText(pInstructionDisplay, &pinstruction->pActionParam1[0], 250, ImGuiInputTextFlags_None))
		{
			instruction_freezewheneditingbehavior = true;
		}
	}
	// labels
	ImVec2 vCursorPos = ImVec2(fAbsInstructionLeftX, ImGui::GetCursorPos().y);
	ImGui::SetCursorPos(vCursorPos + ImVec2(5.0f, 0));
	ImGui::Text("True");
	if (pinstruction->iCondition != 11)
	{
		ImGui::SameLine();
		ImGui::SetCursorPos(vCursorPos + ImVec2(instruction_block_width - 35.0f, 0));
		ImGui::Text("False");
	}
	// lines and add buttons
	float fLineVertGap = ImGui::GetFontSize() / 2.0f;
	ImGui::SetCursorPos(ImVec2(fAbsInstructionLeftX, ImGui::GetCursorPos().y+fLineVertGap));
	float fHalfInstructionWidth = instruction_block_width / 2;
	float fAddButtonWidth = instruction_block_width / 3.0f;
	float fButtonMargin = (fHalfInstructionWidth - fAddButtonWidth) / 2.0f;
	float fButtonPosY = ImGui::GetCursorPos().y;
	float fLeftALSOBranchX = 0.0f;
	float fRightELSEBranchX = 0.0f;
	float fVertYPosToNextInstruction = instruction_block_height + 46.0f;
	int buttoncount = 2;
	if ( pinstruction->iCondition == 11) buttoncount = 1;
	for (int buttonindex = 0; buttonindex < buttoncount; buttonindex++)
	{
		float fWhichHalf = buttonindex * fHalfInstructionWidth;
		bool bHaveAnotherInstruction = false;
		if (buttonindex == 0)
		{
			if (pinstruction->pAlso) bHaveAnotherInstruction = true;
		}
		else
		{
			if (pinstruction->pElse) bHaveAnotherInstruction = true;
		}
		float fDestinationAdjustmentX = 0.0f;
		if (buttonindex == 0 && pinstruction->pAlso && pinstruction->pElse) fDestinationAdjustmentX -= (pinstruction->pAlso->fWidthRequired) * instruction_block_width;
		if (buttonindex == 1 && pinstruction->pElse)
		{
			if (pinstruction->iAction == 0 || pinstruction->iAction == 1)
			{
				// Go To State and Go To Instruction has no block
			}
			else
			{
				fDestinationAdjustmentX += (pinstruction->pElse->fWidthRequired) * instruction_block_width;
			}
		}
		float fAdjustLabelX = 0.0f;
		if (buttonindex == 0)
			fAdjustLabelX = -10.0f;
		else
			fAdjustLabelX = 10.0f;
		ImVec2 vLineFrom = vInstructionPos + ImVec2(fWhichHalf + (instruction_block_width / 4) + fAdjustLabelX, instruction_block_height + instruction_border);
		ImVec2 vLineTo = vInstructionPos + ImVec2(fWhichHalf + (instruction_block_width / 4) + fDestinationAdjustmentX, instruction_block_height + instruction_border + 10);
		bool bFirstLineIsInstructionJump = false;
		if (buttonindex == 0 && pinstruction->pGoToInstruction) bFirstLineIsInstructionJump = true;
		if (bFirstLineIsInstructionJump == true)
		{
			// returen to start and goto instruction have shorter vert line to 'miss' the regular line (if on right - phewy)
			vLineTo.y -= 5.0f;
		}
		ImGui::GetCurrentWindow()->DrawList->AddLine(vLineFrom, vLineTo, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 0.75f)), 2.0f);
		if (buttonindex == 0)
			fLeftALSOBranchX = fDestinationAdjustmentX;
		else
			fRightELSEBranchX = fDestinationAdjustmentX;
		if (bFirstLineIsInstructionJump == true)
		{
			// if 'go to' instruction block, protrude a line leftward
			vLineFrom = vLineTo;

			// left side or right side
			ImVec2 vShiftToSide = ImVec2(-((instruction_block_width/4)+(instruction_block_width/2)), 0);
			ImVec2 vConnectTo = pinstruction->pGoToInstruction->vReturnPointPos;
			float fDecidingXPos = vLineFrom.x;
			if (buttonindex == 0) fDecidingXPos += instruction_block_width;
			if (fDecidingXPos > instruction_centerline_absolutex)
			{
				vShiftToSide = ImVec2(instruction_block_width+(instruction_block_width/2), 0);
				vConnectTo.x += instruction_block_width + (instruction_border/2);
			}

			// only complete connection to instruction if within state
			if (pinstruction->iAction == 0)
			{
				// when jump to new state, no connecting line to the new state component (yet)
				vLineTo.x += vShiftToSide.x / 5.0f;
				ImGui::GetCurrentWindow()->DrawList->AddLine(vLineFrom, vLineTo, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 0.75f)), 2.0f);

				// mark state jump with square
				ImVec2 vEndOfLine = vLineTo;
				vLineFrom = ImVec2(vEndOfLine.x - 5.0f, vEndOfLine.y - 2.5f);
				vLineTo = ImVec2(vEndOfLine.x, vEndOfLine.y + 2.5f);
				ImGui::GetCurrentWindow()->DrawList->AddRect(vLineFrom, vLineTo, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 0.75f)), 2.0f);
			}
			if (pinstruction->iAction == 1)
			{
				// if 'go to' instruction block, protrude a line left/rightward
				vLineTo.x += vShiftToSide.x;
				ImGui::GetCurrentWindow()->DrawList->AddLine(vLineFrom, vLineTo, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 0.75f)), 2.0f);

				// then draw a line up or down to destination Y pos
				ImVec2 vLevelWith = ImVec2(vLineTo.x, vConnectTo.y);
				ImGui::GetCurrentWindow()->DrawList->AddLine(vLineTo, vLevelWith, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 0.75f)), 2.0f);

				// and to destination
				ImGui::GetCurrentWindow()->DrawList->AddLine(vLevelWith, vConnectTo, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 0.75f)), 2.0f);
			}
		}
		else
		{
			if (bHaveAnotherInstruction == true)
			{
				// insert an instruction at this point
				sprintf(pInstructionDisplay, "Insert##BehaviorEditorInsert%s%d%d", pStateName, buttonindex, pinstruction->iInstructionIndex);

				// and a line dropping down to instruction below
				vLineFrom = vInstructionPos + ImVec2(fWhichHalf + (instruction_block_width / 4) + fAdjustLabelX + fDestinationAdjustmentX, instruction_block_height + instruction_border + 10);
				vLineTo = vInstructionPos + ImVec2(fWhichHalf + (instruction_block_width / 4) + fDestinationAdjustmentX, fVertYPosToNextInstruction + instruction_border);
				ImGui::GetCurrentWindow()->DrawList->AddLine(vLineFrom, vLineTo, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 0.75f)), 2.0f);
			}
			else
			{
				// add a new instruction button
				if (buttonindex == 0)
					sprintf(pInstructionDisplay, "True##BehaviorEditorAdd%s%d%d", pStateName, buttonindex, pinstruction->iInstructionIndex);
				else
					sprintf(pInstructionDisplay, "False##BehaviorEditorAdd%s%d%d", pStateName, buttonindex, pinstruction->iInstructionIndex);
			}
			ImGui::SetCursorPos(ImVec2(fButtonMargin + fWhichHalf + fAbsInstructionLeftX + fDestinationAdjustmentX, fButtonPosY));
			if (ImGui::Button(pInstructionDisplay, ImVec2(fAddButtonWidth, 0)))
			{
				// check if special case with user selecting node to connect instruction to
				if (instruction_picknewendnode == 1)
				{
					// detatch old instruction chain from current connection
					sLeafNode* pOldParent = instruction_pickanewnode->pParent;
					if (pOldParent->pAlso == instruction_pickanewnode) pOldParent->pAlso = NULL;
					if (pOldParent->pElse == instruction_pickanewnode) pOldParent->pElse = NULL;
					instruction_pickanewnode->pParent = NULL;

					// attach instruction chain to new node location
					if (buttonindex == 0)
						pinstruction->pAlso = instruction_pickanewnode;
					else
						pinstruction->pElse = instruction_pickanewnode;
					instruction_pickanewnode->pParent = pinstruction;

					// finished moving instruction chain
					instruction_picknewendnode = 0;
				}
				else
				{
					// create new instruction
					sLeafNode* pNewInstruction = new sLeafNode();
					memset(pNewInstruction, 0, sizeof(sLeafNode));
					pNewInstruction->iUniqueSignatureCode = rand() % 999999;
					pNewInstruction->pParent = pinstruction;
					pNewInstruction->iInstructionIndex = -1;
					pNewInstruction->iState = 1;
					pNewInstruction->iCondition = 11;
					pNewInstruction->iAction = 11;
					if (bHaveAnotherInstruction == true)
					{
						// insert
						if (buttonindex == 0)
						{
							sLeafNode* pExisting = pinstruction->pAlso;
							pinstruction->pAlso = pNewInstruction;
							pNewInstruction->pAlso = pExisting;
							pExisting->pParent = pNewInstruction;
						}
						else
						{
							sLeafNode* pExisting = pinstruction->pElse;
							pinstruction->pElse = pNewInstruction;
							pNewInstruction->pAlso = pExisting;
							pExisting->pParent = pNewInstruction;
						}
					}
					else
					{
						// add
						if (buttonindex == 0)
							pinstruction->pAlso = pNewInstruction;
						else
							pinstruction->pElse = pNewInstruction;
					}
				}

				// when add instruction, old instruction indices now invalid
				instruction_regenerateinstructionindices = true;
				instruction_freezewheneditingbehavior = true;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select this to add a new instruction to the state.");
		}
	}
	ImGui::SetCursorPos(ImVec2(fAbsInstructionLeftX, ImGui::GetCursorPos().y + fLineVertGap));

	// finished instruction block
	ImGui::PopItemWidth();

	// Follow down tree of instructions
	ImVec2 vShiftPos;
	if (pinstruction->pAlso)
	{
		vShiftPos = ImVec2(fLeftALSOBranchX, fVertYPosToNextInstruction + (instruction_border*2));
		gridedit_instruction_block_rec (pState, vTopCenterPos + vShiftPos, pStateName, pinstruction->pAlso, fMargin, iRowIndex+1);
	}
	if (pinstruction->pElse)
	{
		vShiftPos = ImVec2(fRightELSEBranchX, fVertYPosToNextInstruction + (instruction_border*2));
		gridedit_instruction_block_rec (pState, vTopCenterPos + vShiftPos, pStateName, pinstruction->pElse, fMargin, iRowIndex+1);
	}

	// record deepest Y position as recursion can end on instruction blocks further up
	vCursorPos = ImGui::GetCursorPos();
	if (vCursorPos.y > instruction_furthestcursor.y)
	{
		instruction_furthestcursor = vCursorPos;
	}
}

void gridedit_savebehavior ( LPSTR pByteFilename )
{
	// re-number instruction indices, and create single instruction list
	int iInstructionCount = gridedit_generateuniqueinstructionindices();

	// get real path to script BYC file
	char pByteCodeFile[MAX_PATH];
	strcpy (pByteCodeFile, pByteFilename);
	GG_GetRealPath(pByteCodeFile, 1);
	if (FileExist(pByteCodeFile) == 1) DeleteFileA(pByteCodeFile);

	// latest version for saving
	int iVersionNumber = 102;

	// write new BYC file
	OpenToWrite(1, pByteCodeFile);
	WriteString(1, "42"); // magic number

	// write version number
	char pVersionNumber[250];
	sprintf (pVersionNumber, "%d", iVersionNumber);
	WriteString(1, pVersionNumber); // version number

	// find largest state index in all instructions
	int iStateCount = 0;
	for (int index = 0; index < iInstructionCount; index++)
	{
		int iThisStateIndex = instruction_singlelist[index]->iState;
		if (iThisStateIndex > iStateCount) iStateCount = iThisStateIndex;
	}

	// write state count
	char pStateCount[32];
	sprintf(pStateCount, "%d", iStateCount);
	WriteString(1, pStateCount);

	// write instruction count
	char pInstructionCount[32];
	sprintf(pInstructionCount, "%d", iInstructionCount);
	WriteString(1, pInstructionCount); // instruction count

	// version 101
	char pLine[2048];
	if (iVersionNumber >= 101)
	{
		// all states
		for (int iStateIndex = 0; iStateIndex < iStateCount; iStateIndex++)
		{
			sStateNode* pState = &instruction_state_list[iStateIndex];
			sprintf(pLine, "%s", pState->pName); WriteString(1, pLine);
			sprintf(pLine, "%d", (int)pState->bAllowInterupt); WriteString(1, pLine);
		}
		WriteString(1, "---"); // separator
		// all instuctions
		for (int index = 0; index < iInstructionCount; index++)
		{
			sLeafNode* pThis = instruction_singlelist[index];
			sprintf(pLine, "%d", pThis->iUniqueSignatureCode); WriteString(1, pLine); // UniqueSignatureCode
			sprintf(pLine, "%d", pThis->iState); WriteString(1, pLine); // state
			sprintf(pLine, "%d", pThis->iCondition); WriteString(1, pLine); // condition
			sprintf(pLine, "%s", pThis->pConditionParam1); WriteString(1, pLine); // condition param1
			sprintf(pLine, "%s", pThis->pConditionParam2); WriteString(1, pLine); // condition param2
			sprintf(pLine, "%d", pThis->iAction); WriteString(1, pLine); // action
			sprintf(pLine, "%s", pThis->pActionParam1); WriteString(1, pLine); // action param1
			sprintf(pLine, "%s", pThis->pActionParam2); WriteString(1, pLine); // action param2
			int iAlsoInstructionNumber = 0;	if (pThis->pAlso) iAlsoInstructionNumber = pThis->pAlso->iInstructionIndex;
			int iElseInstructionNumber = 0;	if (pThis->pElse) iElseInstructionNumber = pThis->pElse->iInstructionIndex;
			if ((pThis->iAction == 0 || pThis->iAction == 1) && pThis->pGoToInstruction)
			{
				// store goto instruction index in ALSO (does same thing in the end as ALSO)
				iAlsoInstructionNumber = pThis->pGoToInstruction->iInstructionIndex;
			}
			sprintf(pLine, "%d", iAlsoInstructionNumber); WriteString(1, pLine); // also
			sprintf(pLine, "%d", iElseInstructionNumber); WriteString(1, pLine); // else
			WriteString(1, "---"); // separator
		}
	}
	if (iVersionNumber >= 102)
	{
		// save the instruction index from the root of the damage state (if any)
		int iDamageStateRootInstructionIndex = -1;
		for (int iStateIndex = 0; iStateIndex < iStateCount; iStateIndex++)
		{
			sStateNode* pState = &instruction_state_list[iStateIndex];
			if (stricmp (pState->pName, "damage") == NULL)
			{
				iDamageStateRootInstructionIndex = pState->instruction_root->iInstructionIndex;
				break;
			}
		}
		sprintf(pLine, "%d", iDamageStateRootInstructionIndex); WriteString(1, pLine);
	}
	CloseFile(1);
}

void gridedit_deletebehaviornodes_rec ( sLeafNode* pThis )
{
	if (pThis == NULL) return;
	gridedit_deletebehaviornodes_rec (pThis->pAlso);
	gridedit_deletebehaviornodes_rec (pThis->pElse);
	pThis->pAlso = NULL;
	pThis->pElse = NULL;
	delete pThis;
}

void gridedit_deletebehavior(void)
{
	for (int iStateIndex = 0; iStateIndex < instruction_state_list.size(); iStateIndex++)
	{
		sStateNode* pState = &instruction_state_list[iStateIndex];
		if (pState->instruction_root)
		{
			gridedit_deletebehaviornodes_rec(pState->instruction_root);
			pState->instruction_root = NULL;
		}
	}
	instruction_state_list.clear();
	instruction_singlelist.clear();
}

bool gridedit_loadbehavior (LPSTR pByteFilename)
{
	// delete any previous node tree from all states and clear single list to populate from BYC file
	gridedit_deletebehavior();

	// get real path to script BYC file
	int* pAlsoTable = NULL;
	int* pElseTable = NULL;
	int iStateCount = 0;
	int iInstructionCount = 0;
	char pByteCodeFile[MAX_PATH];
	strcpy (pByteCodeFile, pByteFilename);
	GG_GetRealPath(pByteCodeFile, 0);
	if (FileExist(pByteCodeFile) == 1)
	{
		// read BYC file
		OpenToRead(1, pByteCodeFile);
		LPSTR pMagicNumber = ReadString(1); // magic number
		LPSTR pVersionNumber = ReadString(1); // version number
		int iVersionNumber = atoi(pVersionNumber);
		LPSTR pStateCount = ReadString(1); // state count
		iStateCount = atoi(pStateCount);
		LPSTR pInstructionCount = ReadString(1); // instruction count
		iInstructionCount = atoi(pInstructionCount);

		// table to store alsoe and else instruction numbers
		pAlsoTable = new int[iInstructionCount];
		memset(pAlsoTable, 0, sizeof(int)*iInstructionCount);
		pElseTable = new int[iInstructionCount];
		memset(pElseTable, 0, sizeof(int)*iInstructionCount);

		// Version 101
		if (iVersionNumber >= 101)
		{
			// all states
			for (int iStateIndex = 0; iStateIndex < iStateCount; iStateIndex++)
			{
				sStateNode state;
				state.iStateIndex = 1 + iStateIndex;
				LPSTR pName = ReadString(1); strcpy (state.pName, pName);
				LPSTR pAllowInterupt = ReadString(1); state.bAllowInterupt = atoi(pAllowInterupt);
				state.instruction_root = NULL;
				instruction_state_list.push_back(state);
			}
			LPSTR pStateSeparator = ReadString(1);
			// all instructions
			for (int index = 0; index < iInstructionCount; index++)
			{
				// create new instruction
				sLeafNode* pThis = new sLeafNode();
				memset(pThis, 0, sizeof(sLeafNode));
				instruction_singlelist.push_back(pThis);

				// read instruction data
				LPSTR pUniqueSignatureCode = ReadString(1); pThis->iUniqueSignatureCode = atoi(pUniqueSignatureCode);
				LPSTR pState = ReadString(1); pThis->iState = atoi(pState);
				LPSTR pCondition = ReadString(1); pThis->iCondition = atoi(pCondition);
				LPSTR pConditionParam1 = ReadString(1); strcpy (pThis->pConditionParam1, pConditionParam1);
				LPSTR pConditionParam2 = ReadString(1); strcpy (pThis->pConditionParam2, pConditionParam2);
				LPSTR pAction = ReadString(1); pThis->iAction = atoi(pAction);
				LPSTR pActionParam1 = ReadString(1); strcpy (pThis->pActionParam1, pActionParam1);
				LPSTR pActionParam2 = ReadString(1); strcpy (pThis->pActionParam2, pActionParam2);
				LPSTR pAlsoInstructionNumber = ReadString(1); pAlsoTable[index] = atoi(pAlsoInstructionNumber);
				LPSTR pElseInstructionNumber = ReadString(1); pElseTable[index] = atoi(pElseInstructionNumber);
				LPSTR pSeparator = ReadString(1);
			}
		}
		CloseFile(1);
	}

	// all nodes created, now construct the tree
	if (iInstructionCount > 0)
	{
		// populate state root instruction
		int iCurrentState = -1;

		// create node tree from behavior single list
		for (int index = 0; index < iInstructionCount; index++)
		{
			// for each instruction in list
			sLeafNode* pInstructionFromList = instruction_singlelist[index];

			// find and connect root instruction to state
			int iThisState = pInstructionFromList->iState - 1;
			if (iThisState > iCurrentState)
			{
				sStateNode* pState = &instruction_state_list[iThisState];
				pState->instruction_root = pInstructionFromList;
				iCurrentState = iThisState;
			}

			// link up nodes
			sLeafNode* pInstructionAlsoRef = NULL; if (pAlsoTable[index] > 0) pInstructionAlsoRef = instruction_singlelist[pAlsoTable[index] - 1];
			sLeafNode* pInstructionElseRef = NULL; if (pElseTable[index] > 0) pInstructionElseRef = instruction_singlelist[pElseTable[index] - 1];
			pInstructionFromList->pAlso = pInstructionAlsoRef;
			pInstructionFromList->pElse = pInstructionElseRef;

			// special case for restart state and goto instruction
			if (pInstructionFromList->iAction == 0 || pInstructionFromList->iAction == 1)
			{
				// move to GOTO instruction and remove from ALSO ref
				pInstructionFromList->pGoToInstruction = pInstructionFromList->pAlso;
				pInstructionFromList->pAlso = NULL;
				pInstructionAlsoRef = NULL;
			}

			// and link up parent ref
			if (pInstructionAlsoRef) pInstructionAlsoRef->pParent = pInstructionFromList;
			if (pInstructionElseRef) pInstructionElseRef->pParent = pInstructionFromList;
		}
	}
	else
	{
		// fresh new behavior (one state, one instruction)
		sLeafNode* pInstruction = new sLeafNode();
		pInstruction->iUniqueSignatureCode = rand() % 999999;
		pInstruction->iInstructionIndex = -1;
		pInstruction->iCondition = 11;
		pInstruction->iAction = 11;
		instruction_singlelist.push_back(pInstruction);
		sStateNode state;
		state.iStateIndex = 1;
		strcpy (state.pName, "Initial");
		state.bAllowInterupt = true;
		state.instruction_root = pInstruction;
		instruction_state_list.push_back(state);
	}

	// and finally generate updated instruction indices
	instruction_regenerateinstructionindices = true;

	// free resources
	if (pAlsoTable)
	{
		delete[] pAlsoTable;
		pAlsoTable = NULL;
	}
	if (pElseTable)
	{
		delete[] pElseTable;
		pElseTable = NULL;
	}

	// when load new behavior, reset running data (debugging)
	instruction_running_index = 0;
	instruction_freezewheneditingbehavior = false;

	// success
	return true;
}

void tab_tab_visuals(int iPage, int iMode)
{
	//iMode = 0 , editor.
	//iMode = 1 , test game.
	//iPage = 0 , game
	//iPage = 1 , performance data
	//iPage = 2 , visuals panel
	//iPage = 2? , behavior editor. (developer mode)

	//Try to match visuals.ini
	cStr sWindowName = "Environment Effects##VisualsToolsWindow";
	bNeedImGuiInput = false;

	if (iMode == 1 && !bRenderTabTab && !bImGuiFrameState) // lee added !bImGuiFrameState to prevent double newframes
	{
		//We need a new frame.
		ImGui_NewFrame();
		ImGui_ImplWin32_NewFrame();
		ImGui::NewFrame();
		extern bool bSpriteWinVisible;
		bSpriteWinVisible = false;
		bBlockImGuiUntilNewFrame = false;
		bImGuiRenderWithNoCustomTextures = false;
		bRenderTabTab = true;
	}

	if (iMode == 1 && iPage >= 1)
	{
		//Display performance data.
		bool bStatOpen = true;
		if (!wiProfiler::IsEnabled())
			wiProfiler::SetEnabled(true);
		DisplayPerformanceData(&bStatOpen);
	}
	else
	{
		if (!bProfilerEnable)
		{
			if (wiProfiler::IsEnabled())
				wiProfiler::SetEnabled(false);
		}
	}

	if (iMode == 1 && iPage == 1)
	{
		//Make window a floating one for testgame.
		ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
		ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;
		float window_width = 20 * ImGui::GetFontSize();
		float window_height = 50 * ImGui::GetFontSize();
		if (iPage == 1)
		{
			ImGui::SetNextWindowPos(viewPortPos + ImVec2(viewPortSize.x - window_width - 2.0, 2.0), ImGuiCond_Once); //ImGuiCond_FirstUseEver
			ImGui::SetNextWindowSize(ImVec2(window_width, viewPortSize.y - 4.0), ImGuiCond_Once); //ImGuiCond_FirstUseEver}
		}
		sWindowName = "Visuals##VisualsTabTabWindow";
		bNeedImGuiInput = true;
	}

	bool bVisualUpdated = false;
	float fTabColumnWidth = 120;
	static bool bSetSimpleSky = false;
	static std::vector<cstr> lutImages_s;
	static int g_lutimage_item_count = 0;
	static char** g_lutimage_items = NULL;
	static int current_lutimage_selection = 0;

	// for now, switch visual window for behavior editor!
	bool bBehaviorEditor = false;
	if (bRenderTabTab && iPage == 1)
	{
		// if object selected for in-game debug view/live editing
		if (g_bBehaviorEditorActive ==true) bBehaviorEditor = true;
	}

	// visual window or behavior window
	if (bBehaviorEditor == false && (Visuals_Tools_Window && iMode == 0 || bRenderTabTab) && iPage == 1)
	{
		extern int iGenralWindowsFlags;
		int winflag = iGenralWindowsFlags;
		if (iMode == 1 && iPage == 1)
		{
			winflag |= ImGuiWindowFlags_NoMove;
			winflag |= ImGuiWindowFlags_NoResize;
		}
		ImGui::Begin(sWindowName.Get(), &Visuals_Tools_Window, winflag);

		float w = ImGui::GetWindowContentRegionWidth();

		//PE: Default to closed.
		int wflags = ImGuiTreeNodeFlags_None;

		if (bRenderTabTab)
		{
			imgui_Customize_Sky_V2(1);
			imgui_Customize_Water_V2(1);
			imgui_Customize_Weather_V2(1);
			wflags = ImGuiTreeNodeFlags_None;
		}
		else
		{
			//Condition from test game tab tab. possible.
			if (iLastOpenHeader == 2 || iLastOpenHeader == 3)
			{
				ImGui::SetNextItemOpen(true, ImGuiCond_Always);
				iLastOpenHeader = 1;
			}
			imgui_Customize_Sky_V2(0);
		}

		if (bRenderTabTab)
		{
			if (pref.bAutoClosePropertySections && iLastOpenHeader != 7)
				ImGui::SetNextItemOpen(false, ImGuiCond_Always);

			if (ImGui::StyleCollapsingHeader("Camera Settings", wflags))
			{
				ImGui::Indent(10);
				iLastOpenHeader = 7;
				bool bUpdateCam = false;
				if (ImGui::SliderFloat("##WickedCameraNear", &t.visuals.CameraNEAR_f, 1.0f, 30.0f, "%.2f", 1.0f))
				{
					if ( t.visuals.CameraFAR_f < t.visuals.CameraNEAR_f + 0.1f ) t.visuals.CameraFAR_f = t.visuals.CameraNEAR_f + 0.1f;
					t.gamevisuals.CameraNEAR_f = t.visuals.CameraNEAR_f;
					bUpdateCam = true;
				}
				if (ImGui::SliderFloat("##WickedCameraFar", &t.visuals.CameraFAR_f, DEFAULT_NEAR_PLANE, DEFAULT_FAR_PLANE, "%.2f", 2.0f))
				{
					if ( t.visuals.CameraNEAR_f > t.visuals.CameraFAR_f - 0.1f ) t.visuals.CameraNEAR_f = t.visuals.CameraFAR_f - 0.1f;
					t.gamevisuals.CameraFAR_f = t.visuals.CameraFAR_f;
					//bVisualUpdated = true;
					bUpdateCam = true;
				}

				//PE: Now reverse again as we now follow weapon in tab tab.
				//if (ImGui::MaxSliderInputFloat("##WickedCameraFov", &t.visuals.CameraFOV_f, 20.0f, 110.0f, "Camera Field Of View (FOV)"))
				//LB: Use real degree value so users know the FOV they are choosing
				ImGui::Text("Camera FOV");
				ImGui::SameLine();
				int iCamFOV = t.visuals.CameraFOV_f;
				if ( ImGui::SliderInt("##WickedCameraFov", &iCamFOV, 1, 120) )
				{
					t.visuals.CameraFOV_f = iCamFOV;
					t.gamevisuals.CameraFOV_f = t.visuals.CameraFOV_f;
					bUpdateCam = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Vertical Field Of View (FOV)");

				// ZJ: Update camera settings separately to stop the water going crazy. See https://github.com/TheGameCreators/GameGuruRepo/issues/1851
				if (bUpdateCam)
				{
					float fUsedFOV = t.visuals.CameraFOV_f;
					if (bImGuiInTestGame == false) fUsedFOV = 45;
					float fCameraFov = XM_PI / (fUsedFOV / 15.0f); //Fit GG settings.
					if (bImGuiInTestGame == true)
					{
						//PE: Visual change also need reerse fov in test game and standalone.
						// when in game, weapon FOV correction
						fCameraFov = GGToRadian(fUsedFOV); // Oops - backwards logic, lower FOV needs lower angle passed in
					}
					wiScene::GetCamera().CreatePerspective((float)master.masterrenderer.GetLogicalWidth(), (float)master.masterrenderer.GetLogicalHeight(), t.visuals.CameraNEAR_f, t.visuals.CameraFAR_f, fCameraFov);
				}
				ImGui::Indent(-10);
			}

			extern int g_iDevToolsOpen;
			if (g_iDevToolsOpen != 0 )
			{
				if (ImGui::StyleCollapsingHeader("Physics", wflags))
				{
					ImGui::Indent(10);
					bool bDrawPhysicsShapes = t.visuals.iPhysicsDebugDraw;
					bool bRenderTransform = t.visuals.iPhysicsDebugDrawTransforms;
					bool bRenderConstraints = t.visuals.iPhysicsDebugDrawConstraints;
					if (ImGui::Checkbox("Render Physics Shapes", &bDrawPhysicsShapes))
					{
						t.visuals.iPhysicsDebugDraw = bDrawPhysicsShapes;
						physics_set_debug_draw(bDrawPhysicsShapes);
						bVisualUpdated = true;
					}
					if (bDrawPhysicsShapes)
					{
						if (ImGui::Checkbox("Render Object Transforms", &bRenderTransform))
						{
							t.visuals.iPhysicsDebugDrawTransforms = bRenderTransform;
							physics_set_debug_draw(bDrawPhysicsShapes);
						}
						if (ImGui::Checkbox("Render Constraints", &bRenderConstraints))
						{
							t.visuals.iPhysicsDebugDrawConstraints = bRenderConstraints;
							physics_set_debug_draw(bDrawPhysicsShapes);
						}
					}
					ImGui::Indent(-10);
				}
			}
		}

		//PE: Ambient Music Track only in Editor, in test game its already playing. so..
		if (iMode == 0)
		{
			if (pref.bAutoClosePropertySections && iLastOpenHeader != 11)
				ImGui::SetNextItemOpen(false, ImGuiCond_Always);

			if (ImGui::StyleCollapsingHeader("Music Tracks", wflags))
			{
				ImGui::Indent(10);
				iLastOpenHeader = 11;

				static bool bTestSound = false;
				float but_gadget_size = ImGui::GetFontSize()*10.0;

				// allow for ambient and combat selections
				for (int iGlobalGameSounds = 0; iGlobalGameSounds < 2; iGlobalGameSounds++)
				{
					// 0-ambient, 1-combat
					LPSTR pTextEnable = "";
					LPSTR pTextTitle = "";
					LPSTR pTextSelect = "";
					LPSTR pTextName = "";
					LPSTR pTextVolume = "";
					LPSTR pTextPlay = "";
					LPSTR pTextStop = "";
					int iFreeSoundID = 0;
					bool bEnableMusicTrack = 0;
					if (iGlobalGameSounds == 0)
					{
						pTextEnable = "Enable Ambient Music Track";
						pTextTitle = "Ambient Music Track";
						pTextSelect = "Select Ambient Music Track";
						pTextName = "##iAmbientMusicTrackVolume";
						pTextVolume = "Select Ambient Music Track Volume";
						pTextPlay = "Play Ambient Music##TabTabEditBehaviors";
						pTextStop = "Stop Ambient Music##TabTabEditBehaviors";
						iFreeSoundID = g.temppreviewsoundoffset + 3;
						bEnableMusicTrack = t.visuals.bEndableAmbientMusicTrack;
					}
					if (iGlobalGameSounds == 1)
					{
						pTextEnable = "Enable Combat Music Track";
						pTextTitle = "Combat Music Track";
						pTextSelect = "Select Combat Music Track";
						pTextName = "##iCombatMusicTrackVolume";
						pTextVolume = "Select Combat Music Track Volume";
						pTextPlay = "Play Combat Music##TabTabEditBehaviors";
						pTextStop = "Stop Combat Music##TabTabEditBehaviors";
						iFreeSoundID = g.temppreviewsoundoffset + 5;
						bEnableMusicTrack = t.visuals.bEnableCombatMusicTrack;
					}

					// gadgets for managing music track
					if (ImGui::Checkbox(pTextEnable, &bEnableMusicTrack))
					{
						if (iGlobalGameSounds == 0) t.gamevisuals.bEndableAmbientMusicTrack = t.visuals.bEndableAmbientMusicTrack = bEnableMusicTrack;
						if (iGlobalGameSounds == 1) t.gamevisuals.bEnableCombatMusicTrack = t.visuals.bEnableCombatMusicTrack = bEnableMusicTrack;
						if (!bEnableMusicTrack)
						{
							if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
							{
								// stop currently playing preview
								StopSound(iFreeSoundID);
							}
							bTestSound = false;
						}
					}
					if (bEnableMusicTrack || iGlobalGameSounds == 1)
					{
						cstr cMusicTrack = "";
						if (iGlobalGameSounds == 0) cMusicTrack = t.visuals.sAmbientMusicTrack;
						if (iGlobalGameSounds == 1) cMusicTrack = t.visuals.sCombatMusicTrack;
						cstr cNewMusicTrack = imgui_setpropertyfile2_v2(0, cMusicTrack.Get(), pTextTitle, pTextSelect, "audiobank\\", false);
						if (cNewMusicTrack != cMusicTrack)
						{
							if (iGlobalGameSounds == 0)
							{
								t.visuals.sAmbientMusicTrack = cNewMusicTrack;
								t.gamevisuals.sAmbientMusicTrack = t.visuals.sAmbientMusicTrack;
							}
							if (iGlobalGameSounds == 1)
							{
								t.visuals.sCombatMusicTrack = cNewMusicTrack;
								t.gamevisuals.sCombatMusicTrack = t.visuals.sCombatMusicTrack;
							}
							if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
							{
								// stop currently playing preview
								StopSound(iFreeSoundID);
							}
							bTestSound = false;
						}
						int iMusicTrackVolume = 0;
						if (iGlobalGameSounds == 0) iMusicTrackVolume = t.visuals.iAmbientMusicTrackVolume;
						if (iGlobalGameSounds == 1) iMusicTrackVolume = t.visuals.iCombatMusicTrackVolume;
						if (ImGui::MaxSliderInputInt(pTextName, &iMusicTrackVolume, 0, 100, pTextVolume))
						{
							if (iGlobalGameSounds == 0) t.visuals.iAmbientMusicTrackVolume = iMusicTrackVolume;
							if (iGlobalGameSounds == 1) t.visuals.iCombatMusicTrackVolume = iMusicTrackVolume;
							if (iGlobalGameSounds == 0) t.gamevisuals.iAmbientMusicTrackVolume = t.visuals.iAmbientMusicTrackVolume;
							if (iGlobalGameSounds == 1) t.gamevisuals.iCombatMusicTrackVolume = t.visuals.iCombatMusicTrackVolume;
							if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
							{
								SetSoundVolume(iFreeSoundID, iMusicTrackVolume);
							}
						}
						if (cMusicTrack.Len() > 0)
						{
							if (!bTestSound)
							{
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
								if (ImGui::StyleButton(pTextPlay, ImVec2(but_gadget_size, 0)))
								{
									// play music
									if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
									if (FileExist(cMusicTrack.Get()) == 1)
									{
										LoadSound(cMusicTrack.Get(), iFreeSoundID, 0, 1);
										if (SoundExist(iFreeSoundID) == 1)
										{
											SetSoundVolume(iFreeSoundID, iMusicTrackVolume);
											LoopSound(iFreeSoundID);
											bTestSound = true;
										}
									}
								}
							}
							else
							{
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
								if (ImGui::StyleButton(pTextStop, ImVec2(but_gadget_size, 0)))
								{
									if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
									{
										// stop currently playing preview
										StopSound(iFreeSoundID);
									}
									bTestSound = false;
								}
							}
						}
					}
				}
				ImGui::Indent(-10);
			}
		}

		//PE: Filter Effect.
		if (pref.bAutoClosePropertySections && iLastOpenHeader != 10)
			ImGui::SetNextItemOpen(false, ImGuiCond_Always);

		if (ImGui::StyleCollapsingHeader("Filter Effect", wflags))
		{
			ImGui::Indent(10);
			iLastOpenHeader = 10;
			static int iFilterThumbnailCount = 0;

			//LUT color grading.
			if (lutImages_s.size() <= 0)
			{
				g_lutimage_item_count = 0;
				cstr oldDir_s = GetDir();
				SetDir(g.fpscrootdir_s.Get());
				SetDir("Files\\editors\\lut");
				ChecklistForFiles();
				std::vector<cstr> fileAnnotates_s;

				for (int f = 1; f <= ChecklistQuantity(); f++)
				{
					cstr tfile_s = ChecklistString(f);
					LPSTR pFilename = tfile_s.Get();
					if (tfile_s != "." && tfile_s != "..")
					{
						if (strnicmp(pFilename + strlen(pFilename) - 4, ".png", 4) == NULL)
						{
							// ZJ: Now get titles from text file, this serves as a backup in case something goes wrong with the file.
							// create a readable title from file
							char pTitleName[256];
							strcpy(pTitleName, pFilename);
							pTitleName[strlen(pTitleName) - 4] = 0;
							for (int n = 0; n < strlen(pTitleName); n++)
							{
								if (n == 0)
								{
									if (pTitleName[n] >= 'a' && pTitleName[n] <= 'z')
										pTitleName[n] -= ('a' - 'A');
								}
								else
								{
									if (pTitleName[n] >= 'A' && pTitleName[n] <= 'Z')
										pTitleName[n] += ('a' - 'A');
								}
								if (pTitleName[n] == '_') pTitleName[n] = ' ';
							}

							if (!g_lutimage_items)
							{
								g_lutimage_items = new char*[ChecklistQuantity() + 1];
								//PE: Always add a none.
								lutImages_s.push_back(cstr("None"));
								g_lutimage_items[g_lutimage_item_count] = new char[256];
								strcpy(g_lutimage_items[g_lutimage_item_count], "None");
								g_lutimage_item_count++;
							}
							// add script and title to list
							lutImages_s.push_back(cstr("editors\\lut\\") + tfile_s);
							g_lutimage_items[g_lutimage_item_count] = new char[256];
							strcpy(g_lutimage_items[g_lutimage_item_count], pTitleName);
							g_lutimage_item_count++;
						}

						// Extract lut names from text file.
						if (strcmp(pFilename, "filternames.txt") == NULL)
						{
							if (FileExist(pFilename) == 1)
							{
								OpenToRead(1, pFilename);
								while (FileEnd(1) == 0)
								{
									// Get line by line.
									cstr line_s = ReadString(1);
									if (strlen(line_s.Get()) > 0)
										fileAnnotates_s.push_back(line_s);
								}
								CloseFile(1);
							}
						}
					}
				}

				// Assign the names to the filters.
				if (fileAnnotates_s.size() > 0)
				{
					for (int i = 0; i < fileAnnotates_s.size(); i++)
					{
						if(i < g_lutimage_item_count)
							strcpy(g_lutimage_items[i], fileAnnotates_s[i].Get());
					}
				}

				// Load the thumbnails for the filters, so its easier to see the effect it will have on the scene.
				SetDir("thumbnails");
				ChecklistForFiles();

				image_setlegacyimageloading(true);
				for (int f = 1; f <= ChecklistQuantity(); f++)
				{
					cstr tfile_s = ChecklistString(f);
					LPSTR pFilename = tfile_s.Get();
					if (tfile_s != "." && tfile_s != "..")
					{
						// Only load .jpg files for the thumbnails.
						if (strnicmp(pFilename + strlen(pFilename) - 4, ".jpg", 4) == NULL)
						{
							LoadImage(pFilename, FILTER_THUMBS+iFilterThumbnailCount);
							if (ImageExist(FILTER_THUMBS+iFilterThumbnailCount))
							{
								iFilterThumbnailCount++;
							}
							else
							{
								// Number of loaded thumbnails must match the number of filters, otherwise they will be mismatched.
								for (int i = FILTER_THUMBS; i < FILTER_THUMBS + iFilterThumbnailCount; i++)
								{
									// Load failed, free any loaded images and display text only.
									if (ImageExist(i))
										DeleteImage(i);
								}
								iFilterThumbnailCount = 0;
							}
						}
					}
				}
				image_setlegacyimageloading(false);

				SetDir(oldDir_s.Get());
			}

			if (master_renderer)
			{
				ImGui::PushItemWidth(-10);
				//PE: Set default selection. if not the correct.
				if (t.visuals.ColorGradingLUT != lutImages_s[current_lutimage_selection])
				{
					for (int l = 0; l < g_lutimage_item_count; l++)
					{
						if (t.visuals.ColorGradingLUT == lutImages_s[l])
						{
							current_lutimage_selection = l;
							break;
						}
					}
				}

				// Thumbnail didn't load, display as text instead.
				if (iFilterThumbnailCount == 0)
				{
					if (ImGui::Combo("##WickedLUTImageCombo", &current_lutimage_selection, g_lutimage_items, g_lutimage_item_count, 20))
					{
						if (current_lutimage_selection == 0)
							t.visuals.bColorGrading = false;
						else
							t.visuals.bColorGrading = true;

						t.gamevisuals.bColorGrading = t.visuals.bColorGrading;

						master_renderer->setColorGradingEnabled(t.visuals.bColorGrading);

						t.visuals.ColorGradingLUT = lutImages_s[current_lutimage_selection].Get();
						t.gamevisuals.ColorGradingLUT = t.visuals.ColorGradingLUT;
						bVisualUpdated = true;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Filter Effect");
				}
				else
				{
					float fButtonSize = ImGui::GetContentRegionAvailWidth() / 4 - 4.0f;
					int id = 54321;

					ImGui::Columns(4, "##filters", false);

					for (int i = 0; i < iFilterThumbnailCount; i++)
					{
						ImGui::PushID(id++);

						// Move the buttons closer together.
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(-10.0f, 0.0f));

						if (current_lutimage_selection == i)
						{
							ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
							ImVec2 padding = { 3.0, 3.0 };
							ImGuiWindow* window = ImGui::GetCurrentWindow();
							const ImRect image_bb(window->DC.CursorPos + padding, window->DC.CursorPos + padding + padding + ImVec2(fButtonSize, fButtonSize));
							window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.f);
						}

						// Display and handle selection of filter.
						if (ImGui::ImgBtn(i == 0 ? CCP_NONE : i + FILTER_THUMBS, ImVec2(fButtonSize, fButtonSize), ImVec4(0.0f, 0.0f, 0.0f, 0.0f), ImVec4(1.0f, 1.0f, 1.0f, 1.0f),
							ImVec4(0.8f, 0.8f, 0.8f, 0.8f), ImVec4(0.8f, 0.8f, 0.8f, 0.8f)))
						{
							current_lutimage_selection = i;

							if (current_lutimage_selection == 0)
								t.visuals.bColorGrading = false;
							else
								t.visuals.bColorGrading = true;

							t.gamevisuals.bColorGrading = t.visuals.bColorGrading;

							master_renderer->setColorGradingEnabled(t.visuals.bColorGrading);

							t.visuals.ColorGradingLUT = lutImages_s[current_lutimage_selection].Get();
							t.gamevisuals.ColorGradingLUT = t.visuals.ColorGradingLUT;
							bVisualUpdated = true;
						}
					
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(10.0f, -10.0f));

						// Enlarged thumbnail.
						if (ImGui::IsItemHovered())
						{
							ImGui::BeginTooltip();
							ImGui::ImgBtn(i + FILTER_THUMBS, ImVec2(fButtonSize * 2, fButtonSize * 2), ImVec4(0.0f, 0.0f, 0.0f, 0.0f), ImVec4(1.0f, 1.0f, 1.0f, 1.0f),
								ImVec4(0.8f, 0.8f, 0.8f, 0.8f), ImVec4(0.8f, 0.8f, 0.8f, 0.8f));
							ImGui::Text(g_lutimage_items[i]);
							ImGui::EndTooltip();
						}

						ImGui::NextColumn();

						ImGui::PopID();
					}
			
					ImGui::Text("");
					ImGui::Columns(1);
					/*;
								fCWidth = ImGui::GetContentRegionAvailWidth();
								ImGuiWindow* window = ImGui::GetCurrentWindow();
								//Add background rect.
								ImVec4 background_col = ImGui::GetStyle().Colors[ImGuiCol_Button]; //ImVec4(0.5, 0.5, 0.5, 0.6);
								background_col.w = 0.60;
								const ImRect image_bb((window->DC.CursorPos), window->DC.CursorPos + ImVec2(fCWidth, fCWidth));
								window->DrawList->AddRectFilled(image_bb.Min, image_bb.Max, ImGui::GetColorU32(background_col), 8.0f, 15);

								if (is_selected)
								{
									ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
									ImVec2 padding = { 3.0, 3.0 };
									const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + ImVec2(fCWidth, fCWidth));
									window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
								}
*/
				}
				
				ImGui::PopItemWidth();
			}

			ImGui::Indent(-10);
		}

		if (pref.iEnableAdvancedPostProcessing)
		{
			if (pref.bAutoClosePropertySections && iLastOpenHeader != 8)
				ImGui::SetNextItemOpen(false, ImGuiCond_Always);

#ifdef ADVANCEDCOLORS
			ImGui::PushStyleColor(ImGuiCol_Text, ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram]);
#endif
			if (ImGui::StyleCollapsingHeader("Post Processing", wflags))
			{
				ImGui::Indent(10);
				iLastOpenHeader = 8;

				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("VSync##setVSyncEnabled", &master.bVsyncEnabled)) {
					wiEvent::SetVSync( master.bVsyncEnabled );
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enabling VSync will use less energy in some cases and prevent screen tearing");

				ImGui::PopItemWidth();

				//Bloom
				//tab_tab_Column_text("Bloom Enabled", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("Bloom Enabled##setBloomEnabled", &t.visuals.bBloomEnabled)) {
					t.gamevisuals.bBloomEnabled = t.visuals.bBloomEnabled;
					if (master_renderer)
						master_renderer->setBloomEnabled(t.visuals.bBloomEnabled);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Setting Bloom enabled will cause bright objects or locations to appear to emit more light");

				ImGui::PopItemWidth();
				if (master_renderer && master_renderer->getBloomEnabled())
				{
					ImGui::PushItemWidth(-10);
					if (ImGui::SliderFloat("##WickedsetBloomThreshold", &t.visuals.fsetBloomThreshold, 0.1f, 10.0f, "%.2f", 2.0f))
					{
						t.gamevisuals.fsetBloomThreshold = t.visuals.fsetBloomThreshold;
						if (master_renderer) {
							master_renderer->setBloomThreshold(t.visuals.fsetBloomThreshold);
						}
						//bVisualUpdated = true;
						g.projectmodified = 1;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Bloom Threshold is a measure of how bright an object or area must be before the bloom effect is applied");

					if (ImGui::SliderFloat("##WickedsetBloomStrength", &t.visuals.fsetBloomStrength, 0.1f, 3.0f, "%.2f", 1.0f))
					{
						t.gamevisuals.fsetBloomStrength = t.visuals.fsetBloomStrength;
						if (master_renderer) {
							master_renderer->setBloomStrength(t.visuals.fsetBloomStrength);
						}
						//bVisualUpdated = true;
						g.projectmodified = 1;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Bloom Strength is a measure of how strongly the bloom is applied to the scene");

					ImGui::PopItemWidth();
				}

				//tab_tab_Column_text("SSR", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("SSR##setSSREnabled", &t.visuals.bSSREnabled)) {
					t.gamevisuals.bSSREnabled = t.visuals.bSSREnabled;
					if (master_renderer)
						master_renderer->setSSREnabled(t.visuals.bSSREnabled);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Screen Space Reflections use data from lights and objects shown on-screen to produce reflections");

				ImGui::PopItemWidth();

				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("Reflections##setReflectionsEnabled", &t.visuals.bReflectionsEnabled)) {
					t.gamevisuals.bReflectionsEnabled = t.visuals.bReflectionsEnabled;
					if (master_renderer)
						master_renderer->setReflectionsEnabled(t.visuals.bReflectionsEnabled);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Reflections are calculated by taking data from lights in the scene and determining how they react with the sky and terrain");

				ImGui::PopItemWidth();

				
				#ifdef POSTPROCESSRAIN
				/* moving to weather section
				ImGui::PushItemWidth(-10);

				if (ImGui::Checkbox("Rain##setRainEnabled", &t.visuals.bRainEnabled)) {
					t.gamevisuals.bRainEnabled = t.visuals.bRainEnabled;
					if (master_renderer)
						master_renderer->setRainEnabled(t.visuals.bRainEnabled); //PE: test post process shader.
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enable Rain Post Process");
				ImGui::PopItemWidth();

				if (t.visuals.bRainEnabled)
				{
					ImGui::PushItemWidth(-10);
					ImGui::TextCenter("Rain Speed X");
					if (ImGui::SliderFloat("##Rain Speed X", &t.visuals.fRainSpeedX,-100.0,100.0))
					{
						t.gamevisuals.fRainSpeedX = t.visuals.fRainSpeedX;
					}
					ImGui::PopItemWidth();

					ImGui::PushItemWidth(-10);
					ImGui::TextCenter("Rain Speed Y");
					if (ImGui::SliderFloat("##Rain Speed Y", &t.visuals.fRainSpeedY, -100.0, 100.0))
					{
						t.gamevisuals.fRainSpeedY = t.visuals.fRainSpeedY;
					}
					ImGui::PopItemWidth();


					ImGui::PushItemWidth(-10);
					ImGui::TextCenter("Rain Opacity");
					if (ImGui::SliderFloat("##Rain Opacity", &t.visuals.fRainOpacity,-1.0,1.0))
					{
						master_renderer->setRainOpacity(t.visuals.fRainOpacity);
						t.gamevisuals.fRainOpacity = t.visuals.fRainOpacity;
					}
					ImGui::PopItemWidth();

					ImGui::PushItemWidth(-10);
					ImGui::TextCenter("Rain Scale X");
					if (ImGui::SliderFloat("##Rain Scal X", &t.visuals.fRainScaleX, -4.0, 4.0))
					{
						master_renderer->setRainScaleX(t.visuals.fRainScaleX);
						t.gamevisuals.fRainScaleX = t.visuals.fRainScaleX;
					}
					ImGui::PopItemWidth();

					ImGui::PushItemWidth(-10);
					ImGui::TextCenter("Rain Scale Y");
					if (ImGui::SliderFloat("##Rain Scal Y", &t.visuals.fRainScaleY, -4.0, 4.0))
					{
						master_renderer->setRainScaleY(t.visuals.fRainScaleY);
						t.gamevisuals.fRainScaleY = t.visuals.fRainScaleY;
					}
					ImGui::PopItemWidth();


					ImGui::PushItemWidth(-10);
					ImGui::TextCenter("Refreaction Scale");
					if (ImGui::SliderFloat("##RefreactionScale", &t.visuals.fRainRefreactionScale, 0.0, 0.5))
					{
						master_renderer->setRainRefreactionScale(t.visuals.fRainRefreactionScale);
						t.gamevisuals.fRainRefreactionScale = t.visuals.fRainRefreactionScale;
					}
					ImGui::PopItemWidth();

				}
				*/
				#endif

				//tab_tab_Column_text("FXAA", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("FXAA##setFXAAEnabled", &t.visuals.bFXAAEnabled)) {
					t.gamevisuals.bFXAAEnabled = t.visuals.bFXAAEnabled;
					if (master_renderer)
						master_renderer->setFXAAEnabled(t.visuals.bFXAAEnabled);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("FXAA can smooth out edges on-screen that look pixelated, at the cost of a slight blur");
				ImGui::PopItemWidth();

				//tab_tab_Column_text("Tessellation", fTabColumnWidth);
				//PE: Tessellation dont work, it deform some objects , so cant be used for now. it need to be controlled per mesh.
				/*
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("Tessellation##setTessellationEnabled", &t.visuals.bTessellation)) {
					t.gamevisuals.bTessellation = t.visuals.bTessellation;
					if (master_renderer)
					{
						wiRenderer::SetTessellationEnabled(t.visuals.bTessellation);
					}
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Increases polygon counts for some objects based on how close they are to the camera");

				ImGui::PopItemWidth();
				*/

				if (!bSetSimpleSky)
				{
					//tab_tab_Column_text("Light Shafts", fTabColumnWidth);
					ImGui::PushItemWidth(-10);
					if (ImGui::Checkbox("Light Shafts##setLightShaftsEnabled", &t.visuals.bLightShafts)) {
						t.gamevisuals.bLightShafts = t.visuals.bLightShafts;
						if (master_renderer)
							master_renderer->setLightShaftsEnabled(t.visuals.bLightShafts);
						g.projectmodified = 1;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enables light rays to cast from the sun");

					//if (t.visuals.bLightShafts)
					//{
					//	ImGui::PushItemWidth(-20.0f);
					//	float fTmp = 0.0f;
					//	int iLightShaftsNeedUpdating = 0;
					//
					//	fTmp = t.visuals.lightShaftDensity * 100.0f;
					//	ImGui::TextCenter("Density");
					//	if (ImGui::MaxSliderInputFloat("##LightShaftDensity", &fTmp, 0.0f, 100.0f, 0))
					//	{
					//		t.visuals.lightShaftDensity = fTmp * 0.01f;
					//		t.gamevisuals.lightShaftDensity = t.visuals.lightShaftDensity;
					//		iLightShaftsNeedUpdating = 1;
					//	}
					//	fTmp = t.visuals.lightShaftWeight * 100.0f;
					//	ImGui::TextCenter("Weight");
					//	if (ImGui::MaxSliderInputFloat("##LightShaftWeight", &fTmp, 0.0f, 100.0f, 0))
					//	{
					//		t.visuals.lightShaftWeight = fTmp * 0.01f;
					//		t.gamevisuals.lightShaftWeight = t.visuals.lightShaftWeight;
					//		iLightShaftsNeedUpdating = 1;
					//	}
					//	fTmp = t.visuals.lightShaftDecay * 100.0f;
					//	ImGui::TextCenter("Decay");
					//	if (ImGui::MaxSliderInputFloat("##LightShaftDecay", &fTmp, 0.0f, 100.0f, 0))
					//	{
					//		t.visuals.lightShaftDecay = fTmp * 0.01f;
					//		t.gamevisuals.lightShaftDecay = t.visuals.lightShaftDecay;
					//		iLightShaftsNeedUpdating = 1;
					//	}
					//	fTmp = t.visuals.lightShaftExposure * 100.0f;
					//	ImGui::TextCenter("Exposure");
					//	if (ImGui::MaxSliderInputFloat("##LightShaftExposure", &fTmp, 0.0f, 100.0f, 0))
					//	{
					//		t.visuals.lightShaftExposure = fTmp * 0.01f;
					//		t.gamevisuals.lightShaftExposure = t.visuals.lightShaftExposure;
					//		iLightShaftsNeedUpdating = 1;
					//	}
					//
					//	if (iLightShaftsNeedUpdating)
					//	{
					//		WickedCall_SetLightShaftParameters(t.visuals.lightShaftDensity, t.visuals.lightShaftWeight,
					//			t.visuals.lightShaftDecay, t.visuals.lightShaftExposure);
					//		g.projectmodified = 1;
					//	}
					//	ImGui::PopItemWidth();
					//}
					ImGui::PopItemWidth();

				}

				// LB: aded lens flare
				//tab_tab_Column_text("Lens Flare", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("Lens Flare##setLensFlareEnabled", &t.visuals.bLensFlare)) 
				{
					t.gamevisuals.bLensFlare = t.visuals.bLensFlare;
					if (master_renderer)
						master_renderer->setLensFlareEnabled(t.visuals.bLensFlare);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enables lens flare from light cast from the sun");
				ImGui::PopItemWidth();

				// LB: added auto-exposure toggle
				//tab_tab_Column_text("Auto Exposure", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("Auto Exposure##setAutoExposureEnabled", &t.visuals.bAutoExposure))
				{
					t.gamevisuals.bAutoExposure = t.visuals.bAutoExposure;
					if (master_renderer)
						master_renderer->setEyeAdaptionEnabled(t.visuals.bAutoExposure);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Automatically adjusts the appearance of the light intensity when the brightness of an area changes");
				ImGui::PopItemWidth();

				tab_tab_Column_text("Auto Exp Rate", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::SliderFloat("##fAutoExpRate:", &t.visuals.fAutoExposureRate, 0.01, 4.0)) {
					t.gamevisuals.fAutoExposureRate = t.visuals.fAutoExposureRate;
					master_renderer->setEyeAdaptionRate(t.visuals.fAutoExposureRate);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Sets how fast the brightness is adjusted");

				tab_tab_Column_text("Auto Exp Level", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::SliderFloat("##fAutoExpKey:", &t.visuals.fAutoExposureKey, 0.01, 0.5)) {
					t.gamevisuals.fAutoExposureKey = t.visuals.fAutoExposureKey;
					master_renderer->setEyeAdaptionKey(t.visuals.fAutoExposureKey);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set Auto Exposure Level - lower values are darker, higher values are lighter");

				tab_tab_Column_text("Gamma", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::SliderFloat("##fGamma:", &t.visuals.fGamma, 0.1, 10.0))
				{
					t.gamevisuals.fGamma = t.visuals.fGamma;
					wiRenderer::SetGamma(t.visuals.fGamma);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Gamma Correction alters how bright colors are perceived");

				ImGui::PopItemWidth();

				const char* msaa_items_align[] = { "1 (disabled)", "2", "4", "8" };
				int msaa_current_type_selection = 0;
				if (t.visuals.iMSAASampleCount == 1) msaa_current_type_selection = 0;
				else if (t.visuals.iMSAASampleCount == 2) msaa_current_type_selection = 1;
				else if (t.visuals.iMSAASampleCount == 4) msaa_current_type_selection = 2;
				else msaa_current_type_selection = 3;
				tab_tab_Column_text("MSAA", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setMSAASampleCount", &msaa_current_type_selection, msaa_items_align, IM_ARRAYSIZE(msaa_items_align)))
				{
					if (msaa_current_type_selection == 0) t.visuals.iMSAASampleCount = 1;
					else if (msaa_current_type_selection == 1) t.visuals.iMSAASampleCount = 2;
					else if (msaa_current_type_selection == 2) t.visuals.iMSAASampleCount = 4;
					else t.visuals.iMSAASampleCount = 8;
					t.gamevisuals.iMSAASampleCount = t.visuals.iMSAASampleCount;

					if (master_renderer)
					{
						master_renderer->setMSAASampleCount(t.visuals.iMSAASampleCount);
						old_iMSAASampleCount = t.visuals.iMSAASampleCount;
					}
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("MSAA can smooth out edges detected on objects. The higher the number of samples the greater the performance cost");

				ImGui::PopItemWidth();

				// SSAO
				//const char* ao_options[] = { "Disabled", "SSAO", "HBAO", "MSAO", "RTAO" };
				const char* ao_options[] = { "Disabled", "Enabled" };
				tab_tab_Column_text("SSAO", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setAmbientOcclusion", &t.visuals.iMSAO, ao_options, IM_ARRAYSIZE(ao_options)))
				{
					t.gamevisuals.iMSAO = master.iAOSetting = t.visuals.iMSAO;
					//master.masterrenderer.setAO( (RenderPath3D::AO) master.iAOSetting );
					if ( master.iAOSetting > 0 ) master.masterrenderer.setAO( RenderPath3D::AO_MSAO );
					else master.masterrenderer.setAO( RenderPath3D::AO_DISABLED );
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Ambient Occlusion makes objects in corners or holes receive less ambient light");
				ImGui::PopItemWidth();

				if (t.visuals.iMSAO > 0 )
				{
					tab_tab_Column_text("AO Power", fTabColumnWidth);
					ImGui::PushItemWidth(-10);
					if ( ImGui::SliderFloat("##setAmbientOcclusionPower", &t.visuals.fMSAOPower, 0.01f, 8.0f, "%.2f", 2.0f) )
					{
						t.gamevisuals.fMSAOPower = master.fAOPower = t.visuals.fMSAOPower;
						master.masterrenderer.setAOPower( master.fAOPower );
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set Ambient Occlusion power (default=1.0)");
					ImGui::PopItemWidth();
					/*
					tab_tab_Column_text("AO Range", fTabColumnWidth);
					ImGui::PushItemWidth(-10);
					if ( ImGui::SliderFloat("##setAmbientOcclusionRange", &master.fAORange, 1.0f, 300.0f, "%.2f", 1.5f) )
					{
						master.masterrenderer.setAORange( master.fAORange );
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set Ambient Occlusion range (default=40.0)");
					ImGui::PopItemWidth();

					tab_tab_Column_text("AO Samples", fTabColumnWidth);
					ImGui::PushItemWidth(-10);
					if ( ImGui::SliderInt("##setAmbientOcclusionSamples", &master.iAOSamples, 1, 64) )
					{
						master.masterrenderer.setAOSampleCount( master.iAOSamples );
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set number of Ambient Occlusion samples (default=16)");
					ImGui::PopItemWidth();
					*/
				}

				ImGui::Indent(-10);
			}
#ifdef ADVANCEDCOLORS
			ImGui::PopStyleColor();
#endif
		}

		if (pref.iEnableAdvancedShadows)
		{
			if (pref.bAutoClosePropertySections && iLastOpenHeader != 9)
				ImGui::SetNextItemOpen(false, ImGuiCond_Always);

			if (ImGui::StyleCollapsingHeader("Shadows", wflags))
			{
				ImGui::Indent(10);

				iLastOpenHeader = 9;

				ImGui::TextCenter( "Shadow Resolution" );
				//PE: Change from 1024 to 4096, adds around 2 gb additional gpu mem ?.
				//PE: See comment about point light below.
				const char* shadow_spot_items_align[] = { "Off", "128", "256", "512", "1024", "2048" }; //, "4096" };
				int shadow_cascade_current_type_selection = 0;
				if (t.visuals.iShadowSpotCascadeResolution == 0) shadow_cascade_current_type_selection = 0;
				else if (t.visuals.iShadowSpotCascadeResolution == 128) shadow_cascade_current_type_selection = 1;
				else if (t.visuals.iShadowSpotCascadeResolution == 256) shadow_cascade_current_type_selection = 2;
				else if (t.visuals.iShadowSpotCascadeResolution == 512) shadow_cascade_current_type_selection = 3;
				else if (t.visuals.iShadowSpotCascadeResolution == 1024) shadow_cascade_current_type_selection = 4;
				else if (t.visuals.iShadowSpotCascadeResolution == 2048) shadow_cascade_current_type_selection = 5;
				else shadow_cascade_current_type_selection = 5; //6;
				tab_tab_Column_text("Sun ", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setshadow_spotresolution", &shadow_cascade_current_type_selection, shadow_spot_items_align, IM_ARRAYSIZE(shadow_spot_items_align)))
				{
					if (shadow_cascade_current_type_selection == 0) t.visuals.iShadowSpotCascadeResolution = 0;
					else if (shadow_cascade_current_type_selection == 1) t.visuals.iShadowSpotCascadeResolution = 128;
					else if (shadow_cascade_current_type_selection == 2) t.visuals.iShadowSpotCascadeResolution = 256;
					else if (shadow_cascade_current_type_selection == 3) t.visuals.iShadowSpotCascadeResolution = 512;
					else if (shadow_cascade_current_type_selection == 4) t.visuals.iShadowSpotCascadeResolution = 1024;
					else if (shadow_cascade_current_type_selection == 5) t.visuals.iShadowSpotCascadeResolution = 2048;
					else t.visuals.iShadowSpotCascadeResolution = 2048;
					t.gamevisuals.iShadowSpotCascadeResolution = t.visuals.iShadowSpotCascadeResolution;
					bVisualUpdated = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Choose a shadow quality for sun shadows");
				ImGui::PopItemWidth();


				//SPOT
				//const char* shadow_spot_items_align[] = { "Off", "128", "256", "512", "1024", "2048" }; //, "4096" };
				int shadow_spot_current_type_selection = 0;
				if (t.visuals.iShadowSpotResolution == 0) shadow_spot_current_type_selection = 0;
				else if (t.visuals.iShadowSpotResolution == 128) shadow_spot_current_type_selection = 1;
				else if (t.visuals.iShadowSpotResolution == 256) shadow_spot_current_type_selection = 2;
				else if (t.visuals.iShadowSpotResolution == 512) shadow_spot_current_type_selection = 3;
				else if (t.visuals.iShadowSpotResolution == 1024) shadow_spot_current_type_selection = 4;
				else if (t.visuals.iShadowSpotResolution == 2048) shadow_spot_current_type_selection = 5;
				else shadow_spot_current_type_selection = 5; //6;
				tab_tab_Column_text("Spot Lights ", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setshadow_spotspotresolution", &shadow_spot_current_type_selection, shadow_spot_items_align, IM_ARRAYSIZE(shadow_spot_items_align)))
				{
					if (shadow_spot_current_type_selection == 0) t.visuals.iShadowSpotResolution = 0;
					else if (shadow_spot_current_type_selection == 1) t.visuals.iShadowSpotResolution = 128;
					else if (shadow_spot_current_type_selection == 2) t.visuals.iShadowSpotResolution = 256;
					else if (shadow_spot_current_type_selection == 3) t.visuals.iShadowSpotResolution = 512;
					else if (shadow_spot_current_type_selection == 4) t.visuals.iShadowSpotResolution = 1024;
					else if (shadow_spot_current_type_selection == 5) t.visuals.iShadowSpotResolution = 2048;
					else t.visuals.iShadowSpotResolution = 2048;
					t.gamevisuals.iShadowSpotResolution = t.visuals.iShadowSpotResolution;
					bVisualUpdated = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Choose a shadow quality spot lights");
				ImGui::PopItemWidth();


				//PE: This drain memory and make everything very slow, limit to max 2048 for now.
				//PE: 1 point light have 6 * 4096x4096 textures. (BIND_DEPTH_STENCIL) DXGI_FORMAT_R16_TYPELESS (2 bytes per pixel).
				//PE: AND 6 * 4096x4096 textures (BIND_RENDER_TARGET) FORMAT_R16G16B16A16_FLOAT (8 bytes per pixel).
				//PE: So 32mb + 128mb. = 160 mb. per texture = 6 * 160mb = 960 mb. PER point light :(
				//PE: Each point light have 12 4096x4096 textures.
				//PE: On my system with 5 point light, it use around 4gb additional mem, when i set 4096 ?
				//PE: This gets allocated as shared GPU mem, and sure tons of swapping is going on.
				//PE: Latest REPO changed from:	desc.Format = FORMAT_R11G11B10_FLOAT; to: desc.Format = FORMAT_R16G16B16A16_FLOAT; (32bit to 64 bit.)
				//PE: https://github.com/turanszkij/WickedEngine/commit/d27ede94cc76a91ac1a1c9e4393db6460262d120#
				//PE: Perhaps limit to 1024 ? - 2048 = 240 mb. per point light , and 1024 = 60mb.

				const char* shadow_point_items_align[] = { "Off" , "128", "256", "512", "1024", "2048" }; //, "4096" };
				int shadow_point_current_type_selection = 0;
				if (t.visuals.iShadowPointResolution == 0) shadow_point_current_type_selection = 0;
				else if (t.visuals.iShadowPointResolution == 128) shadow_point_current_type_selection = 1;
				else if (t.visuals.iShadowPointResolution == 256) shadow_point_current_type_selection = 2;
				else if (t.visuals.iShadowPointResolution == 512) shadow_point_current_type_selection = 3;
				else if (t.visuals.iShadowPointResolution == 1024) shadow_point_current_type_selection = 4;
				else if (t.visuals.iShadowPointResolution == 2048) shadow_point_current_type_selection = 5;
				else shadow_point_current_type_selection = 5; //6;
				tab_tab_Column_text("Point Lights ", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setshadow_pointresolution", &shadow_point_current_type_selection, shadow_point_items_align, IM_ARRAYSIZE(shadow_point_items_align)))
				{
					if (shadow_point_current_type_selection == 0) t.visuals.iShadowPointResolution = 0;
					else if (shadow_point_current_type_selection == 1) t.visuals.iShadowPointResolution = 128;
					else if (shadow_point_current_type_selection == 2) t.visuals.iShadowPointResolution = 256;
					else if (shadow_point_current_type_selection == 3) t.visuals.iShadowPointResolution = 512;
					else if (shadow_point_current_type_selection == 4) t.visuals.iShadowPointResolution = 1024;
					else if (shadow_point_current_type_selection == 5) t.visuals.iShadowPointResolution = 2048;
					else t.visuals.iShadowPointResolution = 2048;
					if (t.visuals.iShadowPointResolution > 2048) t.visuals.iShadowPointResolution = 2048;
					t.gamevisuals.iShadowPointResolution = t.visuals.iShadowPointResolution;
					bVisualUpdated = true;
				}

				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Choose a shadow quality for point lights");
				ImGui::PopItemWidth();

				ImGui::TextCenter( "Shadow Quantity" );
				const char* shadow_spot_max_align[] = { "0", "4", "8", "12", "16" };
				int shadow_cascade_max_current_type_selection = 0;
				if (t.visuals.iShadowSpotMax == 0) shadow_cascade_max_current_type_selection = 0;
				else if (t.visuals.iShadowSpotMax == 4) shadow_cascade_max_current_type_selection = 1;
				else if (t.visuals.iShadowSpotMax == 8) shadow_cascade_max_current_type_selection = 2;
				else if (t.visuals.iShadowSpotMax == 12) shadow_cascade_max_current_type_selection = 3;
				else if (t.visuals.iShadowSpotMax == 16) shadow_cascade_max_current_type_selection = 4;
				tab_tab_Column_text("Spot Lights ", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setshadow_iShadowSpotMax", &shadow_cascade_max_current_type_selection, shadow_spot_max_align, IM_ARRAYSIZE(shadow_spot_max_align)))
				{
					if (shadow_cascade_max_current_type_selection == 0) t.visuals.iShadowSpotMax = 0;
					else if (shadow_cascade_max_current_type_selection == 1) t.visuals.iShadowSpotMax = 4;
					else if (shadow_cascade_max_current_type_selection == 2) t.visuals.iShadowSpotMax = 8;
					else if (shadow_cascade_max_current_type_selection == 3) t.visuals.iShadowSpotMax = 12;
					else if (shadow_cascade_max_current_type_selection == 4) t.visuals.iShadowSpotMax = 16;
					t.gamevisuals.iShadowSpotMax = t.visuals.iShadowSpotMax;
					bForceRefreshLightCount = true;
					bVisualUpdated = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Choose max shadow casters for spot lights");
				ImGui::PopItemWidth();

				int shadow_cascade_point_current_type_selection = 0;
				if (t.visuals.iShadowPointMax == 0) shadow_cascade_point_current_type_selection = 0;
				else if (t.visuals.iShadowPointMax == 4) shadow_cascade_point_current_type_selection = 1;
				else if (t.visuals.iShadowPointMax == 8) shadow_cascade_point_current_type_selection = 2;
				else if (t.visuals.iShadowPointMax == 12) shadow_cascade_point_current_type_selection = 3;
				else if (t.visuals.iShadowPointMax == 16) shadow_cascade_point_current_type_selection = 4;
				tab_tab_Column_text("Point Lights ", fTabColumnWidth);

				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setshadow_iShadowPointMax", &shadow_cascade_point_current_type_selection, shadow_spot_max_align, IM_ARRAYSIZE(shadow_spot_max_align)))
				{
					if (shadow_cascade_point_current_type_selection == 0) t.visuals.iShadowPointMax = 0;
					else if (shadow_cascade_point_current_type_selection == 1) t.visuals.iShadowPointMax = 4;
					else if (shadow_cascade_point_current_type_selection == 2) t.visuals.iShadowPointMax = 8;
					else if (shadow_cascade_point_current_type_selection == 3) t.visuals.iShadowPointMax = 12;
					else if (shadow_cascade_point_current_type_selection == 4) t.visuals.iShadowPointMax = 16;
					t.gamevisuals.iShadowPointMax = t.visuals.iShadowPointMax;
					bForceRefreshLightCount = true;
					bVisualUpdated = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Choose max shadow casters for point lights.");
				ImGui::PopItemWidth();

				if (ImGui::Checkbox("Transparent shadows", &t.visuals.bTransparentShadows))
				{
					t.gamevisuals.bTransparentShadows = t.visuals.bTransparentShadows;
					bForceRefreshLightCount = true;
					bVisualUpdated = true;
				}

//				void SetTransparentShadowsEnabled(float value) { TRANSPARENTSHADOWSENABLED = value; }
//				float GetTransparentShadowsEnabled()



				/* Shadow Bias not currently active
				static bool bSetBias = false;
				//tab_tab_Column_text("Shadow Bias", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				ImGui::Checkbox("Shadow Bias##bSetBias", &bSetBias);
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enable You to Change The Shadow Bias");

				if (bSetBias)
				{
					if (ImGui::SliderFloat("##fSunShadowBias:", &t.visuals.fSunShadowBias, -0.0005, 0.0005, "%.5f"))
					{
						//Need saving in visuals.ini
						t.gamevisuals.fSunShadowBias = t.visuals.fSunShadowBias;
						bVisualUpdated = true;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Sun Shadow Bias Default: 0.00005");
				}
				ImGui::PopItemWidth();
				*/

				/*
				extern float fWickedMaxCenterTest;
				tab_tab_Column_text("Sun Shadow Range", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::SliderFloat("##WickedfShadowFarPlane", &t.visuals.fShadowFarPlane, 50000.0f, DEFAULT_FAR_PLANE, "%.2f", 2.0f))
				{
					t.gamevisuals.fShadowFarPlane = t.visuals.fShadowFarPlane;
					bVisualUpdated = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Max distance the sun will cast shadows");
				*/

				/* Remove for now , can be used to adjust leaks in top of houses.
				if (ImGui::SliderFloat("##WickedfWickedMaxCenterTest", &fWickedMaxCenterTest, 0.0f, DEFAULT_FAR_PLANE, "%.3f", 2.0f))
				{
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Orthographic Matrix Adjust Minimum And Maximum Z");
				*/

				ImGui::PopItemWidth();
				ImGui::Indent(-10);
			}
		}

		// Control all in-game debugging options 
		if (pref.iEnableDeveloperProperties)
		{
			if (pref.bAutoClosePropertySections && iLastOpenHeader != 12)
				ImGui::SetNextItemOpen(false, ImGuiCond_Always); 

			if (ImGui::StyleCollapsingHeader("AI Management", wflags))
			{
				iLastOpenHeader = 12;
				ImGui::Indent(10);
				ImGui::PushItemWidth(-10);
				extern bool g_bShowRecastDetourDebugVisuals;
				if (ImGui::Checkbox("Show Navigation Debug Visuals", &g_bShowRecastDetourDebugVisuals))
				{
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Toggle whether the navigation system debug visuals should be shown");
				ImGui::PopItemWidth();

				float but_gadget_size = ImGui::GetFontSize()*10.0;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
				if (ImGui::StyleButton("Edit Behaviors##TabTabEditBehaviors", ImVec2(but_gadget_size, 0)))
				{
					extern bool g_bBehaviorEditorActive;
					g_bBehaviorEditorActive = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Open the Behavior Editor to debug and edit logic live");
				ImGui::Indent(-10);
			}
		}

		if (!bRenderTabTab && !pref.bHideTutorials)
		{
#ifndef REMOVED_EARLYACCESS
			if (ImGui::StyleCollapsingHeader("Tutorial (this feature is incomplete)", ImGuiTreeNodeFlags_DefaultOpen))
			{
				ImGui::Indent(10);
				cstr cShowTutorial = "01 - Getting started";
				char* tutorial_combo_items[] = { "01 - Getting started", "02 - Creating terrain", "03 - Add character and set a path" };
				SmallTutorialVideo(cShowTutorial.Get(), tutorial_combo_items, ARRAYSIZE(tutorial_combo_items), SECTION_VISUALS);
				float but_gadget_size = ImGui::GetFontSize()*12.0;
				float w = ImGui::GetWindowContentRegionWidth() - 20.0;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
				#ifdef INCLUDESTEPBYSTEP
				if (ImGui::StyleButton("View Step by Step Tutorial", ImVec2(but_gadget_size, 0)))
				{
					bHelp_Window = true;
					bHelpVideo_Window = true;
					bSetTutorialSectionLeft = false;
					strcpy(cForceTutorialName, cShowTutorial.Get());
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Start Step by Step Tutorial");
				#endif

				ImGui::Indent(-10);
			}
#endif
		}

		//Reset
		ImGui::Separator();
		float but_gadget_size = ImGui::GetFontSize()*10.0;
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
		if (ImGui::StyleButton("Reset Visuals##WickedResetVisualsUniqueId", ImVec2(but_gadget_size, 0)))
		{
			int iAction = askBoxCancel("This will delete all your visual changes, are you sure?", "Confirmation"); //1==Yes 2=Cancel 0=No
			if (iAction == 1)
			{
				//Reset
				visuals_resetvalues(false);
				t.gamevisuals = t.visuals;
				bVisualUpdated = true;
			}
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Reset Visuals to Default Values");

		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));

		if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0)
		{
			//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
			ImGui::Text("");
			ImGui::Text("");
		}

		ImGui::End();
	}

	// behavior editor
	static int iCountdownToRightShift = 0;
	if (bBehaviorEditor)
	{
		//Make window a floating one for testgame.
		ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
		ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;
		float window_width = 20 * ImGui::GetFontSize();
		float window_height = 50 * ImGui::GetFontSize();
		if (iPage == 1)
		{
			ImGui::SetNextWindowPos(viewPortPos + ImVec2(viewPortSize.x - window_width - 2.0, 2.0), ImGuiCond_Once); //ImGuiCond_FirstUseEver
			ImGui::SetNextWindowSize(ImVec2(window_width, viewPortSize.y - 4.0), ImGuiCond_Once); //ImGuiCond_FirstUseEver}
		}
		sWindowName = "Behavior Editor##BehaviorEditorTabTabWindow";
		bNeedImGuiInput = true;

		// start behavior editor window
		extern int iGenralWindowsFlags;
		int winflag = iGenralWindowsFlags;
		winflag |= ImGuiWindowFlags_NoMove;
		winflag |= ImGuiWindowFlags_AlwaysVerticalScrollbar;
		winflag |= ImGuiWindowFlags_AlwaysHorizontalScrollbar;

		//PE: This can crash if you resize window outside main viewport so always use main viewport.
		ImGuiViewport* viewport = ImGui::GetMainViewport();
		ImGui::SetNextWindowViewport(viewport->ID);

		ImGui::Begin(sWindowName.Get(), &Visuals_Tools_Window, winflag);
		int wflags = ImGuiTreeNodeFlags_DefaultOpen;

		// Window layout and dimensions
		float fMargin = 15.0f;
		float w = ImGui::GetWindowContentRegionWidth() * 2;
		instruction_centerline = (w - (fMargin * 2)) / 2.0f;

		// detect if width changes (need to trigger right shift recalc)
		static float lastw = -1.0f;
		if (w != lastw)
		{
			// update all states with latest rightmost shift
			iCountdownToRightShift = 40;
			lastw = w;
		}
		if (iCountdownToRightShift > 0)
		{
			iCountdownToRightShift--;
			if (iCountdownToRightShift == 0)
			{
				for (int iStateIndex = 0; iStateIndex < instruction_state_list.size(); iStateIndex++)
					instruction_state_list[iStateIndex].bRecalcRightMost = true;
			}
		}

		// a little code update behavior list if objects active count changes
		static int iLastActiveObjectCount = 0;
		static int iActiveObjectCount = 0;
		iActiveObjectCount = 0;
		for (int e = 1; e <= g.entityelementlist; e++)
		{
			int entid = t.entityelement[e].bankindex;
			if (entid > 0 && t.entityelement[e].active != 0)
				iActiveObjectCount++;
		}
		if (iActiveObjectCount != iLastActiveObjectCount)
		{
			// allows recently inactivated objects to be marked in real time
			iLastActiveObjectCount = iActiveObjectCount;
			instruction_recreatebehaviorlist = true;
		}

		// choose the object parent script you wish to edit
		bool bIsBehaviorToEditValid = false;
		if (ImGui::StyleCollapsingHeader("Behavior Choice##BehaviorEditor", wflags))
		{
			static int iObjectEditingID;
			static int iObjectCount = 0;
			static int* pObjectRefE = NULL;
			static char** pObjectAIScripts = NULL;
			int iTriggerNewObjectEditing = -1;
			if (instruction_recreatebehaviorlist == true)
			{
				if (iObjectCount > 0)
				{
					for (int e = 1; e <= iObjectCount; e++)
					{
						if (pObjectAIScripts[e - 1])
						{
							delete pObjectAIScripts[e - 1];
							pObjectAIScripts[e - 1] = NULL;
						}
					}
					delete[] pObjectAIScripts;
					delete[] pObjectRefE;
				}
				iObjectCount = 0;
				for (int e = 1; e <= g.entityelementlist; e++)
				{
					int entid = t.entityelement[e].bankindex;
					if (entid > 0 && t.entityprofile[entid].ismarker == 0)
					{
						LPSTR pObjectAI = t.entityelement[e].eleprof.aimain_s.Get();
						if (stricmp(pObjectAI, "no_behavior_selected.lua") != NULL)
						{
							iObjectCount++;
						}
					}
				}
				pObjectAIScripts = new char*[iObjectCount];
				pObjectRefE = new int[iObjectCount];
				memset(pObjectAIScripts, 0, iObjectCount * sizeof(char*));
				memset(pObjectRefE, 0, iObjectCount * sizeof(int));
				int iObjectIndex = 0;
				for (int e = 1; e <= g.entityelementlist; e++)
				{
					int entid = t.entityelement[e].bankindex;
					if (entid > 0 && t.entityprofile[entid].ismarker == 0)
					{
						LPSTR pThisStatus = "";
						if (t.entityelement[e].active == 0) pThisStatus = " (inactive)";
						LPSTR pObjectAI = t.entityelement[e].eleprof.aimain_s.Get();
						if (stricmp(pObjectAI, "no_behavior_selected.lua") != NULL)
						{
							pObjectAIScripts[iObjectIndex] = new char[256];
							sprintf(pObjectAIScripts[iObjectIndex], "%d : %s%s", e, pObjectAI, pThisStatus);
							pObjectRefE[iObjectIndex] = e;
							iObjectIndex++;
						}
					}
				}
				if (iObjectEditingID > iObjectCount-1) iObjectEditingID = iObjectCount-1;
				iTriggerNewObjectEditing = iObjectEditingID;
				instruction_recreatebehaviorlist = false;
			}
			ImGui::Indent(fMargin);
			char pComboObjectsDisplay[1024];
			sprintf(pComboObjectsDisplay, "##BehaviorEditorScriptCombo");
			ImGui::PushItemWidth(w - 20);
			if (ImGui::Combo(pComboObjectsDisplay, &iObjectEditingID, pObjectAIScripts, iObjectCount))
			{
				iTriggerNewObjectEditing = iObjectEditingID;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Choose the object to edit its behavior");
			if (iTriggerNewObjectEditing != -1)
			{
				// refresh conditions and actions table
				gridedit_instruction_parseandpopulateinstructions();

				// assign new script to edit
				int iEntityIndex = pObjectRefE[iTriggerNewObjectEditing];// 1 + iTriggerNewObjectEditing;
				LPSTR pObjectAI = t.entityelement[iEntityIndex].eleprof.aimain_s.Get();
				sprintf(instruction_objectscriptbeingedited, "scriptbank\\%s", pObjectAI);
				instruction_objectscriptbeingedited[strlen(instruction_objectscriptbeingedited) - 4] = 0;
				strcat(instruction_objectscriptbeingedited, ".byc");

				// fill in animation list
				gridedit_instruction_populateanimationlist(t.entityelement[iEntityIndex].obj);

				// erase last instruction data (so new can be auto loaded)
				gridedit_deletebehavior();

				// and change which entity element we observe for the debug view
				instruction_running_e = 0;
				if (pObjectAI)
				{
					if (strlen(pObjectAI) > 0)
					{
						instruction_running_e = pObjectRefE[iTriggerNewObjectEditing]; //1 + iTriggerNewObjectEditing;
					}
				}
				instruction_running_index = 0;

				// also update layout as script may have changed!
				iCountdownToRightShift = 10;
			}
			ImGui::PopItemWidth();

			float but_gadget_size = ImGui::GetFontSize()*10.0;
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
			if (ImGui::StyleButton("Close Behavior Editor##TabTabCloseBehaviorEditor", ImVec2(but_gadget_size, 0)))
			{
				extern bool g_bBehaviorEditorActive;
				g_bBehaviorEditorActive = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Close the Behavior Editor to return to standard in-game controls");

			ImGui::Indent(-fMargin);
		}
		if (instruction_running_e > 0) bIsBehaviorToEditValid = true;
		if (bIsBehaviorToEditValid == true)
		{
			/* not for EA
			if (ImGui::StyleCollapsingHeader("Behavior Description##BehaviorEditor", wflags))
			{
				ImGui::Indent(fMargin);
				float TextHeight = ImGui::GetFontSize()*7.5f;
				static char cBehaviorDescription[4096] = { "Will show script behavior description along with DLUA values (feature not yet complete)" };
				extern int CLB(ImGuiTextEditCallbackData* data);
				ImGui::PushItemWidth(w - 20);
				ImGui::InputTextMultiline("##cBehaviorDescription", &cBehaviorDescription[0], 4096, ImVec2(0, TextHeight), ImGuiInputTextFlags_CallbackAlways, CLB, &(w));
				ImGui::PopItemWidth();
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Shows the description for this behavior (feature not yet complete)");
				ImGui::Indent(-fMargin);
			}
			*/

			// which state are we in right now?
			int iCurrentlyInsideState = -1;
			if (instruction_freezewheneditingbehavior == false)
			{
				if (instruction_running_e > 0)
				{
					if (instruction_running_index > 0)
					{
						for (int iStateIndex = 0; iStateIndex < instruction_state_list.size(); iStateIndex++)
						{
							sStateNode* pState = &instruction_state_list[iStateIndex];
							if (gridedit_instruction_inthisstate_rec(pState->instruction_root) == true)
							{
								iCurrentlyInsideState = iStateIndex;
								break;
							}
						}
					}
				}
			}

			// go through all states
			instruction_hoveringover = NULL;
			for (int iStateIndex = 0; iStateIndex < instruction_state_list.size(); iStateIndex++)
			{
				// Get state details
				sStateNode* pState = &instruction_state_list[iStateIndex];

				// Format display of state name
				char pStateName[1024];
				strcpy (pStateName, pState->pName);
				if (iStateIndex == iCurrentlyInsideState)
				{
					// in this state now
					strupr(pStateName);
				}

				// Component for this state
				char pStateNameDisplay[1024];
				sprintf(pStateNameDisplay, "%s State##BehaviorEditor", pStateName);
				if (ImGui::StyleCollapsingHeader(pStateNameDisplay, wflags))
				{
					// Flow Chart
					instruction_border = 4.0f;
					instruction_vertical_gap = 10.0f;
					instruction_block_width = ImGui::GetFontSize()*6.0f;
					instruction_block_height = ImGui::GetFontSize()*8.6f;

					// start state panel
					ImGui::Indent(fMargin);

					// calculate required widths from hierarchy
					gridedit_instruction_calculatewidth_rec(pState->instruction_root);

					// can scan state layout and work out rightmost X block (so can shift right) 
					ImVec2 vCursorPos = ImGui::GetCursorPos();
					ImVec2 vTopCenterPos = vCursorPos + ImVec2(instruction_centerline, instruction_vertical_gap);
					if (pState->bRecalcRightMost == true)
					{
						// starts the process of working out right most margin to shift within
						pState->fRightMostX = -99999.0f;
					}
					else
					{
						// when not calculating new right most shift distance, use it to move whole state to the right
						float fDistanceToShiftRight = ((w-fMargin) - pState->fRightMostX);

						// allow for single column instruction layout (only shift if start to get WIDE)
						fDistanceToShiftRight -= 80.0f;
						if (fDistanceToShiftRight < 0) fDistanceToShiftRight = 0;

						// do the shift
						vTopCenterPos.x += fDistanceToShiftRight;
					}

					// go through all intructions for this state
					ImGui::SetCursorPos(vTopCenterPos);
					instruction_centerline_absolutex = ImGui::GetCurrentWindow()->DC.CursorPos.x;
					instruction_furthestcursor = vCursorPos;
					gridedit_instruction_block_rec (pState, vTopCenterPos, pStateName, pState->instruction_root, fMargin, 0);
					ImGui::SetCursorPos(instruction_furthestcursor);

					// once calculated, can keep 'fRightMostX' stored to affect new position of block placement
					if (pState->bRecalcRightMost == true)
						pState->bRecalcRightMost = false;

					// Allow Interupt
					char pAllowInteruptDisplay[1024];
					sprintf(pAllowInteruptDisplay, "Allow Interuptions##BehaviorEditor%s", pStateName);
					ImGui::SetCursorPos(ImVec2(vCursorPos.x, ImGui::GetCursorPos().y));
					if (ImGui::Checkbox(pAllowInteruptDisplay, &pState->bAllowInterupt))
					{
						instruction_freezewheneditingbehavior = true;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("When this is ticked, the state can be interupted when the object takes damage.");

					// Delete button for state
					float fDeleteButtonWidth = ImGui::GetFontSize()*5.0f;
					ImGui::SameLine();
					ImGui::SetCursorPos(ImVec2(w - fMargin - fDeleteButtonWidth, ImGui::GetCursorPos().y));
					char pDeleteButtonDisplay[1024];
					sprintf(pDeleteButtonDisplay, "Delete State##BehaviorEditor%s", pStateName);
					if (ImGui::Button(pDeleteButtonDisplay, ImVec2(fDeleteButtonWidth, 0)))
					{
						// delete this state
						instruction_deletestate = iStateIndex;
						instruction_freezewheneditingbehavior = true;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select this to permanently delete this state from the behavior");

					// end state panel
					ImGui::Indent(-fMargin);
				}
			}

			// Behavior management buttons
			if (ImGui::StyleCollapsingHeader("Behavior Management##BehaviorEditor", wflags))
			{
				float but_gadget_size = ImGui::GetFontSize()*10.0;
				float fNewMargin = fMargin + instruction_centerline - (but_gadget_size / 2.0f);
				ImGui::Indent(fNewMargin);
				if (ImGui::Button("Add New State##BehaviorEditor", ImVec2(but_gadget_size, 0)))
				{
					// Add new state
					instruction_createstate = true;
					strcpy (instruction_newstatename, "");
					instruction_freezewheneditingbehavior = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add a new state to this behavior");
				if (ImGui::Button("Update Behavior##BehaviorEditor", ImVec2(but_gadget_size, 0)))
				{
					// Save behavior byte code file
					if (strlen(instruction_objectscriptbeingedited) > 0)
					{
						// save BYC file
						gridedit_savebehavior(instruction_objectscriptbeingedited);

						// the magic - we can trigger this script to reload its BYC data file
						// and resume from its current instruction using the 'iUniqueSignatureCode'
						if (instruction_running_e > 0)
						{
							// quick trigger to 
							LuaSetFunction("UpdateEntityDebugger", 2, 0);
							LuaPushInt(instruction_running_e);
							LuaPushInt(1);
							LuaCall();

							// release any freeze caused by a change/edit o the logic
							instruction_freezewheneditingbehavior = false;
						}
					}
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Save any changes that have been made to this behavior");
				if (ImGui::Button("Restart Behavior##BehaviorEditor", ImVec2(but_gadget_size, 0)))
				{
					if (instruction_running_e > 0)
					{
						LuaSetFunction("UpdateEntityDebugger", 2, 0);
						LuaPushInt(instruction_running_e);
						LuaPushInt(2);
						LuaCall();
					}
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Restarts the behavior to the first state");
				if (ImGui::Button("Stop Behavior##BehaviorEditor", ImVec2(but_gadget_size, 0)))
				{
					// freeze so can edit
					instruction_freezewheneditingbehavior = false;
					if (instruction_running_e > 0)
					{
						LuaSetFunction("UpdateEntityDebugger", 2, 0);
						LuaPushInt(instruction_running_e);
						LuaPushInt(3);
						LuaCall();
					}
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Restarts the behavior to the first state");
				ImGui::Indent(-fNewMargin);
			}
		}

		// solves vertical scroll flicker
		if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0)
		{
			ImGui::Text("");
			ImGui::Text("");
		}

		// end behavior editor window
		ImGui::End();
	}
	else
	{
		// ensures we update layout each time we enter B.E
		iCountdownToRightShift = 2;
	}

	// if added a new instruction, must regenerate instruction indices
	if (instruction_regenerateinstructionindices == true)
	{
		gridedit_generateuniqueinstructionindices();
		instruction_regenerateinstructionindices = false;
	}

	// create a new state with unique name
	if (instruction_createstate == true)
	{
		// Can create new behvaior state
		ImGui::SetNextWindowSize(ImVec2(26 * ImGui::GetFontSize(), 8 * ImGui::GetFontSize()), ImGuiCond_Once);
		ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
		cstr sUniqueWinName = cstr("Enter A Name for your New Behavior State##BehaviorEditorNewState");
		ImGui::Begin(sUniqueWinName.Get(), &instruction_createstate, 0);
		ImGui::Indent(10);
		cstr sUniqueInputName = cstr("##Behavior State Name") + cstr(1);
		ImGui::PushItemWidth(-10);
		ImGui::Text("");
		ImGui::Text("Type a name for your new Behavior State and press ENTER:");
		if (ImGui::IsRootWindowOrAnyChildFocused() && !ImGui::IsAnyItemActive() && !ImGui::IsMouseClicked(0)) ImGui::SetKeyboardFocusHere(0);
		if (ImGui::InputText(sUniqueInputName.Get(), instruction_newstatename, 250, ImGuiInputTextFlags_EnterReturnsTrue))
		{
			// create the new behavior state
			sStateNode state;
			memset(&state, 0, sizeof(state));
			strcpy (state.pName, instruction_newstatename);

			// create new instruction root node for this new state
			state.instruction_root = new sLeafNode();
			memset(state.instruction_root, 0, sizeof(sLeafNode));
			state.instruction_root->iUniqueSignatureCode = rand() % 999999;
			state.instruction_root->iInstructionIndex = -1;
			state.instruction_root->iCondition = 11;
			state.instruction_root->iAction = 11;
			state.bAllowInterupt = true;

			// add to state list
			instruction_state_list.push_back(state);

			// finished here
			instruction_createstate = false;
			strcpy(instruction_newstatename, "");

			// new changes means new instruction indices!
			instruction_regenerateinstructionindices = true;
		}
		ImGui::PopItemWidth();
		ImGui::Indent(-10);
		bImGuiGotFocus = true;
		ImGui::End();
	}

	// if delete state, wait until IMGUI stuff done
	if (instruction_deletestate != -1)
	{
		// delete all the instructions in this state
		sLeafNode* pThis = instruction_state_list[instruction_deletestate].instruction_root;
		gridedit_deletebehaviornodes_rec(pThis);

		// delete the state itself
		instruction_state_list.erase(instruction_state_list.begin() + instruction_deletestate);
		instruction_deletestate = -1;

		// new changes means new instruction indices!
		instruction_regenerateinstructionindices = true;
	}

	// if delete an instruction, do it outside of recursion
	if (instruction_deletethis)
	{
		// record relationship ptrs and delete
		sLeafNode* pParentInstruction = instruction_deletethis->pParent;
		sLeafNode* pNextAlso = instruction_deletethis->pAlso;
		sLeafNode* pNextElse = instruction_deletethis->pElse;

		// a little protection, you cannot delete an instruction that has BOTH ALSE and ELSE!! Or the last instruction in a state.
		if ((pNextAlso && pNextElse) || (pParentInstruction==NULL && pNextAlso==NULL && pNextElse ==NULL) )
		{
			// reason is, where does the other instruction chain go - not showing
			//strcpy(cTriggerMessage, "Cannot delete an instruction if it has both ALSO and ELSE instructions.");
			//bTriggerMessage = true;
			// end now, no delete today!
			instruction_deletethis = NULL;
		}
		else
		{
			// next instruction after one we deleted
			sLeafNode* pNextInstruction = pNextAlso;
			if (pNextInstruction == NULL) pNextInstruction = pNextElse;

			// reconstruct parent ref and sibling refs
			if (pParentInstruction)
			{
				if (pParentInstruction->pAlso == instruction_deletethis)
				{
					// parent also ref
					pParentInstruction->pAlso = pNextInstruction;
					if (pNextInstruction) pNextInstruction->pParent = pParentInstruction;
				}
				if (pParentInstruction->pElse == instruction_deletethis)
				{
					// parent else ref
					pParentInstruction->pElse = pNextInstruction;
					if (pNextInstruction) pNextInstruction->pParent = pParentInstruction;
				}
			}
			else
			{
				// new parent
				instruction_deleteinthisstate->instruction_root = pNextInstruction;
				instruction_deleteinthisstate->instruction_root->pParent = NULL;
			}

			// finally delete it
			delete instruction_deletethis;
			instruction_deletethis = NULL;
			instruction_deleteinthisstate = NULL;
		}
	}

	// when in instruction pcik mode, wait for a click
	if (instruction_pickaninstruction != NULL)
	{
		ImGuiIO& io = ImGui::GetIO();
		if (io.MouseDown[0] != 0)
		{
			if (instruction_hoveringover && instruction_pickaninstruction)
			{
				// selected an instruction
				sLeafNode* pChosenInstruction = instruction_hoveringover;
				if (instruction_pickstateorinstruction == 1)
				{
					// the root of this state
					sLeafNode* pFindRoot = pChosenInstruction;
					int iStateIndex = pFindRoot->iState;
					while (pFindRoot && pFindRoot->pParent && pFindRoot->pParent->iState == iStateIndex) pFindRoot = pFindRoot->pParent;
					instruction_pickaninstruction->pGoToInstruction = pFindRoot;

					// and add name to action param so user can see state being switched to in UI
					int iDestinationStateIndex = pChosenInstruction->iState - 1;
					strcpy (instruction_pickaninstruction->pActionParam1, instruction_state_list[iDestinationStateIndex].pName);
				}
				if (instruction_pickstateorinstruction == 2)
				{
					// a specific instruction
					instruction_pickaninstruction->pGoToInstruction = pChosenInstruction;
					strcpy (instruction_pickaninstruction->pActionParam1, "");
				}
			}
			instruction_pickaninstruction = NULL;
			instruction_pickstateorinstruction = 0;
		}
	}

	// states have at leat one instruction
	if (instruction_state_list.size() == 0)
	{
		if (strlen(instruction_objectscriptbeingedited) > 0)
		{
			// test load template behavior, will change as we PICK objects to edit
			gridedit_loadbehavior(instruction_objectscriptbeingedited);
		}
	}

	if (bVisualUpdated)
	{
		// visuals have been updated, inform wicked engine and mark level has modified
		Wicked_Update_Visuals((void *)&t.visuals);
		g.projectmodified = 1;
	}
}

void Wicked_Update_Shadows(void *voidvisual)
{
	extern int spot_lights_count;
	extern int point_lights_count;

	visualstype* visuals = (visualstype *)voidvisual;
	if (visuals == NULL) visuals = &t.visuals;

	static int total_active_2d_shadows = -1;

	bool bTransparentChanged = false;
	static bool bOldTransparent = false;
	wiRenderer::SetTransparentShadowsEnabled(visuals->bTransparentShadows);
	if (bOldTransparent != visuals->bTransparentShadows)
	{
		bOldTransparent = visuals->bTransparentShadows;
		bTransparentChanged = true;
	}

	if (old_iShadowSpotCascadeResolution != visuals->iShadowSpotCascadeResolution || bTransparentChanged )
	{
		char debug[256];
		sprintf(debug, "wiRenderer::SetShadowProps2D: 5");
		timestampactivity(0, debug);
		if (visuals->iShadowSpotCascadeResolution > 2048) visuals->iShadowSpotCascadeResolution = 2048;
		old_iShadowSpotCascadeResolution = visuals->iShadowSpotCascadeResolution;
		if(visuals->iShadowSpotCascadeResolution == 0)
			wiRenderer::SetShadowProps2D(visuals->iShadowSpotCascadeResolution, 0 ); //cascade only now.
		else
			wiRenderer::SetShadowProps2D(visuals->iShadowSpotCascadeResolution, 5); //cascade only now.
	}


	int shadows = spot_lights_count;
	if (shadows <= 2) shadows = 2;
	else if (shadows <= 4) shadows = 4;
	else if (shadows <= 8) shadows = 8;
	else if (shadows <= 12) shadows = 12;
	else if (shadows <= 16) shadows = 16;
	if (shadows > visuals->iShadowSpotMax) shadows = visuals->iShadowSpotMax;
	
	if (old_iShadowSpotResolution != visuals->iShadowSpotResolution || shadows > total_active_2d_shadows || (bForceRefreshLightCount && shadows != total_active_2d_shadows) || bTransparentChanged)
	{
		char debug[256];
		sprintf(debug, "wiRenderer::SetShadowPropsSpot2D: %d", shadows);
		timestampactivity(0, debug);
		total_active_2d_shadows = shadows;
		if (visuals->iShadowSpotResolution > 2048) visuals->iShadowSpotResolution = 2048;
		old_iShadowSpotResolution = visuals->iShadowSpotResolution;
		if(visuals->iShadowSpotResolution == 0 || visuals->iShadowSpotMax == 0 )
			wiRenderer::SetShadowPropsSpot2D(visuals->iShadowSpotResolution, 0);//soft shadow removed from here , -1);
		else
			wiRenderer::SetShadowPropsSpot2D(visuals->iShadowSpotResolution, total_active_2d_shadows);//soft shadow removed from here , -1);
	}

	//PE: MEM - 1546 : END SetShadowProps2D                                     S:529MB V: (4157,0)     
	static int total_active_cube_shadows = -1;
	int shadowscube = point_lights_count;
	if (shadowscube <= 2) shadowscube = 2;
	else if (shadowscube <= 4) shadowscube = 4;
	else if (shadowscube <= 8) shadowscube = 8;
	else if (shadowscube <= 12) shadowscube = 12;
	else if (shadowscube <= 16) shadowscube = 16;

	//LB: Increased cap in Wicked to SIXTEEN as hitting issues on even small interior levels, lets see what the fall out is
	//if (shadowscube > 5) shadowscube = 5;
	if (shadowscube > visuals->iShadowPointMax) shadowscube = visuals->iShadowPointMax;
	
	if (old_iShadowPointResolution != visuals->iShadowPointResolution || shadowscube > total_active_cube_shadows || (bForceRefreshLightCount && shadowscube != total_active_cube_shadows ) || bTransparentChanged )
	{
		bForceRefreshLightCount = false;
		char debug[256];
		sprintf(debug, "wiRenderer::SetShadowPropsCube: %d", shadowscube);
		timestampactivity(0, debug);
		total_active_cube_shadows = shadowscube;
		if (visuals->iShadowPointResolution > 2048) visuals->iShadowPointResolution = 2048;
		old_iShadowPointResolution = visuals->iShadowPointResolution;
		if(visuals->iShadowPointResolution == 0 || visuals->iShadowPointMax == 0)
			wiRenderer::SetShadowPropsCube(visuals->iShadowPointResolution, 0);
		else
			wiRenderer::SetShadowPropsCube(visuals->iShadowPointResolution, total_active_cube_shadows);
	}

	if(bForceRefreshLightCount) bForceRefreshLightCount = false;

	//PE: MEM - 1556 : END SetShadowPropsCube                                   S : 360MB V : (4518, 0)
}

void Wicked_Update_Visuals(void *voidvisual)
{
	visualstype* visuals = (visualstype *) voidvisual;
	wiScene::WeatherComponent* weather = wiScene::GetScene().weathers.GetComponent(g_weatherEntityID);

	if (weather)
	{
		weather->ambient.x = visuals->AmbienceRed_f / 255.0;
		weather->ambient.y = visuals->AmbienceGreen_f / 255.0;
		weather->ambient.z = visuals->AmbienceBlue_f / 255.0;
		weather->fogStart = visuals->FogNearest_f;
		weather->fogEnd = visuals->FogDistance_f;
		//weather->fogHeight = visuals->FogA_f; // mergecheck: field no longer present
		weather->fogColorAndOpacity.x = visuals->FogR_f / 255.0f;
		weather->fogColorAndOpacity.y = visuals->FogG_f / 255.0f;
		weather->fogColorAndOpacity.z = visuals->FogB_f / 255.0f;
		weather->fogColorAndOpacity.w = visuals->FogA_f;
		weather->horizon.x = visuals->FogR_f / 255.0f;
		weather->horizon.y = visuals->FogG_f / 255.0f;
		weather->horizon.z = visuals->FogB_f / 255.0f;
		weather->zenith.x = visuals->ZenithRed_f / 255.0f;
		weather->zenith.y = visuals->ZenithGreen_f / 255.0f;
		weather->zenith.z = visuals->ZenithBlue_f / 255.0f;
		weather->cloudScale = visuals->SkyCloudHeight;

		if (visuals->bDisableSkybox)
		{
			weather->cloudiness = 0.0f;
			weather->cloudSpeed = 0.0f;
			weather->volumetricCloudParameters.CoverageAmount = 0.0f;
			weather->volumetricCloudParameters.CoverageMinimum = 0.0f;
			weather->volumetricCloudParameters.WindSpeed = 0.0f;
			weather->SetRealisticSky(false);
			weather->SetVolumetricClouds(false);
			//weather->SetSimpleSky(false);
		}
		else if (visuals->skyindex == 0)
		{
			weather->cloudiness = visuals->SkyCloudiness;
			weather->cloudSpeed = visuals->SkyCloudSpeed;
			weather->volumetricCloudParameters.CloudStartHeight = GGTerrain_UnitsToMeters( visuals->SkyCloudHeight );
			weather->volumetricCloudParameters.CoverageAmount = visuals->SkyCloudiness;
			weather->volumetricCloudParameters.CoverageMinimum = visuals->SkyCloudCoverage;
			weather->volumetricCloudParameters.CloudThickness = GGTerrain_UnitsToMeters( visuals->SkyCloudThickness );
			weather->volumetricCloudParameters.WindSpeed = visuals->SkyCloudSpeed;
			weather->volumetricCloudParameters.CoverageWindSpeed = visuals->SkyCloudSpeed;
			weather->SetRealisticSky(true);
			weather->SetVolumetricClouds(true);
		}
		else
		{
			weather->cloudiness = 0.0f; //PE: This has changed in the new repo, same shader is now used and cloudiness turn it off, so must now be zero.
			weather->cloudSpeed = 0.0f; //To stop moving lightshaft.
			//PE: Also disable volumetricCloud.
			weather->volumetricCloudParameters.CoverageAmount = 0.0f;
			weather->volumetricCloudParameters.CoverageMinimum = 0.0f;
			weather->volumetricCloudParameters.WindSpeed = 0.0f;
			weather->SetRealisticSky(false);
			weather->SetVolumetricClouds(false);
		}

		// If in Test Level or in standalone, use visual settings, otherwise just use the temporary editor setting.
		bool bWaterEnabled;
		if(t.game.set.ismapeditormode == 1)
			bWaterEnabled = t.showeditorwater;
		else
			bWaterEnabled = visuals->bWaterEnable;

		//if (t.interactive.testgameused == 1 || t.game.gameisexe == 1)
		//	bWaterEnabled = visuals->bWaterEnable;
		//else
		//	bWaterEnabled = t.showeditorwater;

		if (bWaterEnabled)
		{
			weather->SetOceanEnabled(true);
			weather->oceanParameters.waterHeight = g.gdefaultwaterheight;
			//XMFLOAT3 waterColor = XMFLOAT3(visuals->WaterRed_f / 255.0f, visuals->WaterGreen_f / 255.0f, visuals->WaterBlue_f / 255.0f); // LB seems to tame water color with latest Wicked Engine
			XMFLOAT4 waterColor = XMFLOAT4(visuals->WaterRed_f / 255.0f, visuals->WaterGreen_f / 255.0f, visuals->WaterBlue_f / 255.0f, visuals->WaterAlpha_f / 255.0f);
			weather->oceanParameters.waterColor = waterColor;
			weather->oceanParameters.time_scale = visuals->WaterSpeed1;
			weather->oceanParameters.patch_length = visuals->fWaterPatchLength;
			weather->oceanParameters.choppy_scale = visuals->fWaterChoppyScale;
			weather->oceanParameters.wave_amplitude = visuals->fWaterWaveAmplitude;
			//weather->oceanParameters.wind_speed = visuals->WaterFlowSpeed;
			weather->oceanParameters.wind_dependency = visuals->fWaterWindDependency;
			//weather->oceanParameters.wind_dir.x = acos( visuals->WaterFlowDirectionX * PI / 180.0f );
			//weather->oceanParameters.wind_dir.y = asin( visuals->WaterFlowDirectionX * PI / 180.0f );

			weather->oceanParameters.fogMaxDist = visuals->WaterFogMaxDist;
			weather->oceanParameters.fogMinDist = visuals->WaterFogMinDist;
			weather->oceanParameters.fogMinAmount = visuals->WaterFogMinAmount;

			wiScene::GetScene().ocean = {};
		}
		else
		{
			weather->oceanParameters.waterHeight = g.gdefaultwaterheight; //PE: Pauls shader need this set.
			weather->SetOceanEnabled(false);
		}
		
		//weather->skyIntensity = visuals->SkyIntensity_f;
	}

	WickedCall_SetSunColors(visuals->SunRed_f / 255.0, visuals->SunGreen_f / 255.0, visuals->SunBlue_f / 255.0, visuals->SunIntensity_f, 1.0f, t.visuals.fSunShadowBias);
	WickedCall_SetSunDirection(visuals->SunAngleX, visuals->SunAngleY, visuals->SunAngleZ);

	//
	if (master_renderer) 
	{
		#ifdef POSTPROCESSSNOW
		if (bImGuiInTestGame == true)
		{
			master_renderer->setSnowEnabled(visuals->bSnowEnabled);
		}
		else
		{
			if (bEnableWeather)
				master_renderer->setSnowEnabled(visuals->bSnowEnabled);
			else
				master_renderer->setSnowEnabled(false);
		}
		master_renderer->setSnowLayers(visuals->fSnowLayers);
		master_renderer->setSnowDepth(visuals->fSnowDepth);
		master_renderer->setSnowWindiness(visuals->fSnowWind);
		//master_renderer->setSnowSpeed(visuals->fSnowSpeed); //PE: Now controlled by offset.
		master_renderer->setSnowOpacity(visuals->fSnowOpacity);
		#endif

		#ifdef POSTPROCESSRAIN
		if (bImGuiInTestGame == true)
		{
			master_renderer->setRainEnabled(visuals->bRainEnabled);
		}
		else
		{
			if(bEnableWeather)
				master_renderer->setRainEnabled(visuals->bRainEnabled);
			else
				master_renderer->setRainEnabled(false);
		}
		master_renderer->setRainOpacity(visuals->fRainOpacity);
		master_renderer->setRainScaleX(visuals->fRainScaleX);
		master_renderer->setRainScaleY(visuals->fRainScaleY);
		master_renderer->setRainRefreactionScale(visuals->fRainRefreactionScale);
		#endif

		std::shared_ptr<wiResource> image = NULL;
		master_renderer->setColorGradingEnabled(visuals->bColorGrading);
		if (master_renderer->getColorGradingEnabled())
		{
			weather->colorGradingMapName = visuals->ColorGradingLUT.Get();
			weather->colorGradingMap = wiResourceManager::Load(visuals->ColorGradingLUT.Get(), wiResourceManager::IMPORT_COLORGRADINGLUT);
		}
		
		master_renderer->setBloomEnabled(visuals->bBloomEnabled);
		master_renderer->setBloomThreshold(visuals->fsetBloomThreshold);
		master_renderer->setBloomStrength(visuals->fsetBloomStrength);
		master_renderer->setSSREnabled(visuals->bSSREnabled);
		master_renderer->setReflectionsEnabled(visuals->bReflectionsEnabled);
		master_renderer->setFXAAEnabled(visuals->bFXAAEnabled);

		// when in editor, keep enforcing a fixed exposure value (so we dont see fade-ins all the time)
		if (t.game.set.ismapeditormode==0 || pref.iEnableAutoExposureInEditor )
			master_renderer->setEyeAdaptionEnabled(visuals->bAutoExposure);
		else
			master_renderer->setEyeAdaptionEnabled(false);

		master_renderer->setEyeAdaptionRate(visuals->fAutoExposureRate);
		master_renderer->setEyeAdaptionKey(visuals->fAutoExposureKey);
		master_renderer->setExposure(visuals->fExposure);

		//master_renderer->setTessellationEnabled(visuals->bTessellation); moved to renderer
		//wiRenderer::SetTessellationEnabled(visuals->bTessellation);  //PE: Tessellation dont work like this it has to be set per mesh, so have never worked.
		//PE: Still need a way to disable light shafts :)
		master_renderer->setLightShaftsEnabled(visuals->bLightShafts);
		//LB: master_renderer->setLightShaftValues(visuals->lightShaftDensity, visuals->lightShaftWeight, visuals->lightShaftDecay, visuals->lightShaftExposure);

		master_renderer->setLensFlareEnabled(visuals->bLensFlare);
		
		if (old_iMSAASampleCount != visuals->iMSAASampleCount) {
			//PE: Will also resize buffers , so only when needed.
			old_iMSAASampleCount = visuals->iMSAASampleCount;
			master_renderer->setMSAASampleCount(visuals->iMSAASampleCount);
		}

		if (old_iMSAO != visuals->iMSAO || old_fMSAOPower != visuals->fMSAOPower)
		{
			master.fAOPower = old_fMSAOPower = visuals->fMSAOPower;
			master.iAOSetting = old_iMSAO = visuals->iMSAO;
			if (master.iAOSetting > 0) master.masterrenderer.setAO(RenderPath3D::AO_MSAO);
			else master.masterrenderer.setAO(RenderPath3D::AO_DISABLED);
			if (master.iAOSetting > 0) master.masterrenderer.setAOPower(master.fAOPower);
		}

		Wicked_Update_Shadows(visuals);
	}

	extern float fWickedMaxCenterTest;
	if (visuals->CameraFAR_f < 70000.0 && visuals->CameraFAR_f < visuals->fShadowFarPlane)
		fWickedMaxCenterTest = 1500000.0;
	else if (visuals->CameraFAR_f < 250000.0 && visuals->CameraFAR_f < visuals->fShadowFarPlane)
		fWickedMaxCenterTest = 1000000.0;
	else if (visuals->CameraFAR_f < 300000.0 && visuals->CameraFAR_f < visuals->fShadowFarPlane)
		fWickedMaxCenterTest = 500000.0;
	else
		fWickedMaxCenterTest = 0.0; //PE: 0.0=Auto adjust min max z for orthographic shadow matrix, auto dont really work when CameraFAR_f < fShadowFarPlane ?

	WickedCall_SetShadowRange(visuals->fShadowFarPlane);

	wiRenderer::SetGamma(visuals->fGamma);

	float fUsedFOV = visuals->CameraFOV_f;
	if (bImGuiInTestGame == false) fUsedFOV = 45;
	float fCameraFov = XM_PI / (fUsedFOV / 15.0f); //Fit GG settings.
	if (bImGuiInTestGame == true)
	{
		//PE: Visual change also need reerse fov in test game and standalone.
		// when in game, weapon FOV correction
		fCameraFov = GGToRadian(fUsedFOV); // Oops - backwards logic, lower FOV needs lower angle passed in
	}
	wiScene::GetCamera().CreatePerspective((float)master.masterrenderer.GetLogicalWidth(), (float)master.masterrenderer.GetLogicalHeight(), visuals->CameraNEAR_f, visuals->CameraFAR_f, fCameraFov);

	if (visuals->bWaterEnable) 
	{
		static float last_wave_amplitude = -1;
		static float last_wind_dependency = -1;
		weather->oceanParameters.wave_amplitude = visuals->fWaterWaveAmplitude;
		weather->oceanParameters.wind_dependency = visuals->fWaterWindDependency;
		if (last_wave_amplitude != weather->oceanParameters.wave_amplitude || last_wind_dependency != weather->oceanParameters.wind_dependency) 
		{
			last_wave_amplitude = weather->oceanParameters.wave_amplitude;
			last_wind_dependency = weather->oceanParameters.wind_dependency;

			//wiRenderer::OceanRegenerate(); now needs a weather component
			//wiScene::WeatherComponent* weather = wiScene::GetScene().weathers.GetComponent(g_weatherEntityID);
			//wiScene::GetScene().OceanRegenerate();

			// delay update because RunWeatherUpdateSystem needs to run before our new values can take effect
			iUpdateOcean = 2;
		}
	}

	// If in Test Level or in standalone, use visual settings, otherwise just use the temporary editor setting.
	bool bSetting;
	if(t.game.set.ismapeditormode == 1)
		bSetting = t.showeditortrees;
	else
		bSetting = t.visuals.bEndableTreeDrawing;

	if(ggtrees_global_params.hide_until_update == 0)
		ggtrees_global_params.draw_enabled = bSetting;

	// If in Test Level or in standalone, use visual settings, otherwise just use the temporary editor setting.
	if (t.game.set.ismapeditormode == 1)
		bSetting = t.showeditorveg;
	else
		bSetting = t.visuals.bEndableGrassDrawing;

	gggrass_global_params.draw_enabled = bSetting;
}

#endif

//PE: Using t.gridentityposx_f,t.gridentityposy_f,t.gridentityposz_f,t.gridentity,t.gridentityobj
void Add_Grid_Snap_To_Position(void)
{
	// no snapping at all until move
	if (g_bHoldGridEntityPosWhenManaged == true)
		return;

	//  grid system for entities
	if (t.gridentitygridlock == 1)
	{
		//Snap.
		if (iObjectMoveMode == 1)
		{
			// small grid lock for better alignments on Y
			t.gridentityposy_f = (int(t.gridentityposy_f / 5) * 5);
		}
		else
		{
			// small grid lock for better alignments on XZ
			t.gridentityposx_f = (int(t.gridentityposx_f / 5) * 5);
			t.gridentityposz_f = (int(t.gridentityposz_f / 5) * 5);
		}

		//  special snap-to when edge of entity gets near another
		if (t.gridentity > 0)
		{
			t.tobj = t.gridentityobj;
			if (t.tobj > 0)
			{
				if (ObjectExist(t.tobj) == 1 )
				{
					t.tsrcx_f = t.gridentityposx_f;
					t.tsrcy_f = t.gridentityposy_f;
					t.tsrcz_f = t.gridentityposz_f;
					t.tsrcradius_f = ObjectSize(t.tobj, 1);
					t.tfindclosest = -1; t.tfindclosestbest_f = 999999;
					for (t.e = 1; t.e <= g.entityelementlist; t.e++)
					{
						// this object
						t.ttobj = t.entityelement[t.e].obj;

						//LB: never include syblings of a current group :)
						bool bThisOneIsSybling = false;
						for (int i = 0; i < g.entityrubberbandlist.size(); i++)
						{
							if (g.entityrubberbandlist[i].e == t.e)
							{
								bThisOneIsSybling = true;
								break;
							}
						}
						if (bThisOneIsSybling == true)
							continue;

						if (t.ttobj > 0 && t.tobj != t.ttobj ) //PE: Never check ourself.
						{
							if (t.entityelement[t.e].bankindex == t.gridentity)
							{
								t.tdiffx_f = t.entityelement[t.e].x - t.tsrcx_f;
								t.tdiffy_f = t.entityelement[t.e].y - t.tsrcy_f;
								t.tdiffz_f = t.entityelement[t.e].z - t.tsrcz_f;
								t.tdiff_f = Sqrt(abs(t.tdiffx_f*t.tdiffx_f) + abs(t.tdiffy_f*t.tdiffy_f) + abs(t.tdiffz_f*t.tdiffz_f));
								t.tthisradius_f = ObjectSize(t.ttobj, 1);
								if (t.tdiff_f < t.tsrcradius_f + t.tthisradius_f && t.tdiff_f < t.tfindclosestbest_f)
								{
									t.tfindclosestbest_f = t.tdiff_f;
									t.tfindclosest = t.e;
								}
							}
						}
					}
					if (t.tfindclosest != -1)
					{
						//  go through 6 magnet points of the src entity
						t.tmag1sizex_f = ObjectSizeX(t.tobj, 1) / 2;
						t.tmag1sizey_f = ObjectSizeY(t.tobj, 1) / 2;
						t.tmag1sizez_f = ObjectSizeZ(t.tobj, 1) / 2;
						t.tmag2sizex_f = ObjectSizeX(t.entityelement[t.tfindclosest].obj, 1) / 2;
						t.tmag2sizey_f = ObjectSizeY(t.entityelement[t.tfindclosest].obj, 1) / 2;
						t.tmag2sizez_f = ObjectSizeZ(t.entityelement[t.tfindclosest].obj, 1) / 2;
						if (ObjectExist(g.entityworkobjectoffset) == 0) { MakeObjectCube(g.entityworkobjectoffset, 40); HideObject(g.entityworkobjectoffset); }
						t.tbestmag_f = 99999; t.tbestmag2id = -1;
						for (t.magid = 1; t.magid <= 6; t.magid++)
						{
							t.tmagx_f = t.gridentityposx_f;
							t.tmagy_f = t.gridentityposy_f;
							t.tmagz_f = t.gridentityposz_f;
							PositionObject(g.entityworkobjectoffset, t.tmagx_f, t.tmagy_f, t.tmagz_f);
							RotateObject(g.entityworkobjectoffset, ObjectAngleX(t.tobj), ObjectAngleY(t.tobj), ObjectAngleZ(t.tobj));
							if (t.magid == 1)  MoveObjectLeft(g.entityworkobjectoffset, t.tmag1sizex_f);
							if (t.magid == 2)  MoveObjectRight(g.entityworkobjectoffset, t.tmag1sizex_f);
							if (t.magid == 3)  MoveObjectUp(g.entityworkobjectoffset, t.tmag1sizey_f);
							if (t.magid == 4)  MoveObjectDown(g.entityworkobjectoffset, t.tmag1sizey_f);
							if (t.magid == 5)  MoveObject(g.entityworkobjectoffset, t.tmag1sizez_f);
							if (t.magid == 6)  MoveObject(g.entityworkobjectoffset, t.tmag1sizez_f*-1);
							t.tmagx_f = ObjectPositionX(g.entityworkobjectoffset);
							t.tmagy_f = ObjectPositionY(g.entityworkobjectoffset);
							t.tmagz_f = ObjectPositionZ(g.entityworkobjectoffset);
							t.ttobj = t.entityelement[t.tfindclosest].obj;
							for (t.mag2id = 1; t.mag2id <= 6; t.mag2id++)
							{
								t.tmag2x_f = t.entityelement[t.tfindclosest].x;
								t.tmag2y_f = t.entityelement[t.tfindclosest].y;
								t.tmag2z_f = t.entityelement[t.tfindclosest].z;
								PositionObject(g.entityworkobjectoffset, t.tmag2x_f, t.tmag2y_f, t.tmag2z_f);
								RotateObject(g.entityworkobjectoffset, ObjectAngleX(t.ttobj), ObjectAngleY(t.ttobj), ObjectAngleZ(t.ttobj));
								if (t.mag2id == 1)  MoveObjectLeft(g.entityworkobjectoffset, t.tmag2sizex_f);
								if (t.mag2id == 2)  MoveObjectRight(g.entityworkobjectoffset, t.tmag2sizex_f);
								if (t.mag2id == 3)  MoveObjectUp(g.entityworkobjectoffset, t.tmag2sizey_f);
								if (t.mag2id == 4)  MoveObjectDown(g.entityworkobjectoffset, t.tmag2sizey_f);
								if (t.mag2id == 5)  MoveObject(g.entityworkobjectoffset, t.tmag2sizez_f);
								if (t.mag2id == 6)  MoveObject(g.entityworkobjectoffset, t.tmag2sizez_f*-1);
								t.tmag2x_f = ObjectPositionX(g.entityworkobjectoffset);
								t.tmag2y_f = ObjectPositionY(g.entityworkobjectoffset);
								t.tmag2z_f = ObjectPositionZ(g.entityworkobjectoffset);
								//  are magnets close enough together to snap?
								t.tdiffx_f = t.tmag2x_f - t.tmagx_f;
								t.tdiffy_f = t.tmag2y_f - t.tmagy_f;
								t.tdiffz_f = t.tmag2z_f - t.tmagz_f;
								t.tdiff_f = Sqrt(abs(t.tdiffx_f*t.tdiffx_f) + abs(t.tdiffy_f*t.tdiffy_f) + abs(t.tdiffz_f*t.tdiffz_f));
								if (t.tdiff_f < 25.0)
								{
									//  yes, maybe snap to this edge
									if (t.tdiff_f < t.tbestmag_f)
									{
										t.tbestmag_f = t.tdiff_f;
										t.tbestmag2id = t.mag2id;
										t.tbestmag2x_f = t.tmag2x_f + (t.gridentityposx_f - t.tmagx_f);
										t.tbestmag2y_f = t.tmag2y_f + (t.gridentityposy_f - t.tmagy_f);
										t.tbestmag2z_f = t.tmag2z_f + (t.gridentityposz_f - t.tmagz_f);
									}
								}
							}
						}
						if (t.tbestmag2id != -1)
						{
							#ifdef WICKEDENGINE
							if (iObjectMoveMode == 1)
							{
								// only magnetise Y for vert mode
								t.gridentityposy_f = t.tbestmag2y_f;
							}
							else
							{
								if (iObjectMoveMode == 0)
								{
									// only magnetise XZ for horiz modes
									t.gridentityposx_f = t.tbestmag2x_f;
									t.gridentityposz_f = t.tbestmag2z_f;
								}
								else
								{
									// magnetize all three to fix the Y coming from unstable terrain/floor (-0.0 misalignment)
									t.gridentityposx_f = t.tbestmag2x_f;
									t.gridentityposy_f = t.tbestmag2y_f;
									t.gridentityposz_f = t.tbestmag2z_f;
								}
							}
							#else
							t.gridentityposx_f = t.tbestmag2x_f;
							t.gridentityposy_f = t.tbestmag2y_f;
							t.gridentityposz_f = t.tbestmag2z_f;
							#endif
						}
					}
				}
			}
		}
	}
	if (t.gridentitygridlock == 2)
	{
		if (t.entityprofile[t.gridentity].isebe != 0)
		{
			// align EBE structure to match the 100x100 grid
			t.gridentityposx_f = 0 + (int(t.gridentityposx_f / fEditorGridSizeX) * fEditorGridSizeX);
			t.gridentityposz_f = 0 + (int(t.gridentityposz_f / fEditorGridSizeZ) * fEditorGridSizeZ);
		}
		else
		{
			//LB: apply grid alignment with custom offset for full end user control
			fHitOffsetX = 0; fHitOffsetZ = 0; // allows more intuitive placement of chosen object
			float fGripX = t.gridentityposx_f + fHitOffsetX + (fEditorGridSizeX / 2);
			float fGripZ = t.gridentityposz_f + fHitOffsetZ + (fEditorGridSizeZ / 2);
			fGripX -= fEditorGridOffsetX;
			if (fGripX < 0)
				fGripX = ((int(fGripX / fEditorGridSizeX) - 1) * fEditorGridSizeX);
			else
				fGripX = (int(fGripX / fEditorGridSizeX) * fEditorGridSizeX);
			fGripX += fEditorGridOffsetX;
			fGripZ -= fEditorGridOffsetZ;
			if (fGripZ < 0)
				fGripZ = ((int(fGripZ / fEditorGridSizeZ) - 1) * fEditorGridSizeZ);
			else
				fGripZ = (int(fGripZ / fEditorGridSizeZ) * fEditorGridSizeZ);
			fGripZ += fEditorGridOffsetZ;
			t.gridentityposx_f = fGripX;
			t.gridentityposz_f = fGripZ;
		}

		// 130517 - new EBE entity offset to align with 0,0,0 cornered entities from Aslum level and Store (Martin)
		if (t.entityprofile[t.gridentity].isebe != 0)
		{
			if (g.gdefaultebegridoffsetx != 50)
			{
				t.gridentityposx_f -= (g.gdefaultebegridoffsetx - 50);
				t.gridentityposz_f -= (g.gdefaultebegridoffsetz - 50);
			}
		}
	}
}

#ifndef PRODUCTCLASSIC
void DisplaySmallImGuiMessage(char *text)
{
	ImGui::SetNextWindowPos(OldrenderTargetPos + ImVec2(50, 50), ImGuiCond_Always); //ImGuiCond_Always
	ImGui::SetNextWindowSize(ImVec2(OldrenderTargetSize.x - 100, 0), ImGuiCond_Always); //ImGuiCond_Always
	bool winopen = true;

	ImVec4* style_colors = ImGui::GetStyle().Colors;
	ImVec4 oldBgColor = style_colors[ImGuiCol_WindowBg];
	ImVec4 oldTextColor = style_colors[ImGuiCol_Text];

	float fader = 0.75;
	style_colors[ImGuiCol_WindowBg].x = 0.0;
	style_colors[ImGuiCol_WindowBg].y = 0.0;
	style_colors[ImGuiCol_WindowBg].z = 0.0;
	style_colors[ImGuiCol_WindowBg].w *= (fader*0.25);

	style_colors[ImGuiCol_Text].x = 1.0;
	style_colors[ImGuiCol_Text].y = 1.0;
	style_colors[ImGuiCol_Text].z = 1.0;
	style_colors[ImGuiCol_Text].w *= fader;

	ImGui::Begin("##TriggerSmallMessageinfo", &winopen, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoInputs);
	ImGui::SetWindowFontScale(1.5);
//	ImGui::Text(" ");
	//Center Text.
	float fTextSize = ImGui::CalcTextSize(text).x;
	ImGui::SetCursorPos(ImVec2((ImGui::GetWindowSize().x*0.5) - (fTextSize*0.5), ImGui::GetCursorPos().y));

	ImGui::Text(text);
//	ImGui::Text(" ");
	ImGui::SetWindowFontScale(1.0);
	ImGui::End();
	style_colors[ImGuiCol_WindowBg] = oldBgColor;
	style_colors[ImGuiCol_Text] = oldTextColor;
}

//PE: We can have more then one open at the same time. but only one can play.
#define MAXTUTORIALS 100
bool bSmallVideoReady[MAXTUTORIALS];
bool bSmallVideoResumePossible[MAXTUTORIALS];
bool bSmallVideoInit[MAXTUTORIALS];
bool bSmallVideoFirstClick[MAXTUTORIALS];
int iSmallVideoSlot[MAXTUTORIALS];
int iSmallVideoThumbnail[MAXTUTORIALS];
bool bSmallVideoPerccentStart[MAXTUTORIALS];
int iSmallVideoDelayExecute[MAXTUTORIALS];
int iSmallVideoFindFirstFrame[MAXTUTORIALS];
bool bSmallStartInit[MAXTUTORIALS];
bool bSmallVideoMaximized[MAXTUTORIALS];
cstr cSmallComboSelection[MAXTUTORIALS];
cstr cSmallVideoPath ="";
cstr cSmallVideoDescription = "";
int iCurrentVideoSectionPlaying = 0;
int iStopAndFreeThisVideo = -1;

void SmallTutorialThumbLoad(int index)
{
	if (iSmallVideoThumbnail[index] == 0)
	{
		iSmallVideoThumbnail[index] = -1;
		t.tvideofile_s = cSmallVideoPath;
		t.text_s = Lower(Right(t.tvideofile_s.Get(), 4));
		if (t.text_s == ".ogv" || t.text_s == ".mp4")
		{
			cStr Thumb_s = Lower(Left(t.tvideofile_s.Get(), strlen(t.tvideofile_s.Get()) - 4)); Thumb_s += ".jpg";
			if (!FileExist(Thumb_s.Get()))
			{
				Thumb_s = "tutorialbank\\welcome-video.jpg";
			}
			if (FileExist(Thumb_s.Get()))
			{
				int iVideoThumbImage = g.videothumbnailsimageoffset + index;
				if (ImageExist(iVideoThumbImage) == 1) DeleteImage(iVideoThumbImage);
				image_setlegacyimageloading(true);
				LoadImage(Thumb_s.Get(), iVideoThumbImage);
				image_setlegacyimageloading(false);
				if (ImageExist(iVideoThumbImage) == 1) iSmallVideoThumbnail[index] = iVideoThumbImage;
			}
		}
	}
}

void SmallTutorialVideoInit(int index)
{
	if (!bSmallVideoInit[index])
	{
		t.tvideofile_s = cSmallVideoPath;
		iSmallVideoSlot[index] = 0;
		iSmallVideoThumbnail[index] = 0;
		t.text_s = Lower(Right(t.tvideofile_s.Get(), 4));
		if (t.text_s == ".ogv" || t.text_s == ".mp4")
		{
			for (int itl = 1; itl <= 32; itl++)
			{
				if (AnimationExist(itl) == 0) { iSmallVideoSlot[index] = itl; break; }
			}
			if (LoadAnimation(t.tvideofile_s.Get(), iSmallVideoSlot[index], g.videoprecacheframes, g.videodelayedload, 1) == false)
			{
				iSmallVideoSlot[index] = -999;
			}
			// also load in the thumnb image for this video
			cStr Thumb_s = Lower(Left(t.tvideofile_s.Get(), strlen(t.tvideofile_s.Get())-4)); Thumb_s += ".jpg";
			if (ImageExist(g.videothumbnailsimageoffset + index) != 1)
			{
				if (!FileExist(Thumb_s.Get()))
				{
					Thumb_s = "tutorialbank\\welcome-video.jpg";
				}
				if (FileExist(Thumb_s.Get()))
				{
					int iVideoThumbImage = g.videothumbnailsimageoffset + index;
					if (ImageExist(iVideoThumbImage) == 1) DeleteImage(iVideoThumbImage);
					image_setlegacyimageloading(true);
					LoadImage(Thumb_s.Get(), iVideoThumbImage);
					image_setlegacyimageloading(false);
					if (ImageExist(iVideoThumbImage) == 1) iSmallVideoThumbnail[index] = iVideoThumbImage;
				}
			}
		}
		if (iSmallVideoSlot[index] > 0) 
		{
			PlaceAnimation(iSmallVideoSlot[index], -1, -1, -1, -1);
			bSmallVideoResumePossible[index] = false;
			bSmallVideoPerccentStart[index] = false;
		}
		bSmallVideoInit[index] = true;
	}
}

void SmallTutorialVideoCheckStop(char *tutorial)
{
	if (!tutorial) return;
	int iVideoEntry = -1;

	if (tutorial_videos.size() > 0)
	{
		int i = 0;
		for (std::map<std::string, std::string>::iterator it = tutorial_videos.begin(); it != tutorial_videos.end(); ++it)
		{
			if (it->first.length() > 0)
			{
				if (strcmp(it->first.c_str(), tutorial) == 0)
				{
					iVideoEntry = i;
					break;
				}
			}
			i++;
		}
	}

	if (iStopAndFreeThisVideo >= 0)
	{
		if (iSmallVideoSlot[iStopAndFreeThisVideo] > 0) {
			if (AnimationExist(iSmallVideoSlot[iStopAndFreeThisVideo])) {
				if (AnimationPlaying(iSmallVideoSlot[iStopAndFreeThisVideo]))
					StopAnimation(iSmallVideoSlot[iStopAndFreeThisVideo]);
				DeleteAnimation(iSmallVideoSlot[iStopAndFreeThisVideo]);
				iSmallVideoSlot[iStopAndFreeThisVideo] = 0;
				bSmallVideoPerccentStart[iStopAndFreeThisVideo] = false;
				bSmallVideoFrameStart = false;
				bSmallVideoResumePossible[iStopAndFreeThisVideo] = false;
			}
		}
		iStopAndFreeThisVideo = -1;
		bSmallVideoInit[iVideoEntry] = false;
	}

}
void SmallTutorialVideo(char *tutorial, char* combo_items[], int combo_entries,int iVideoSection, bool bAutoStart)
{
	//LB: added lines to exit early
	if ((bStoryboardWindow && !bProceduralLevel) && iVideoSection != SECTION_STORYBOARD) return;
	if (bProceduralLevel && iVideoSection != SECTION_TERRAIN_GENERATOR) return;
	if (bWelcomeScreen_Window &&  iVideoSection != SECTION_MAX_HUB) return;

	bool bSectionHub = false;
	if (iVideoSection == SECTION_MAX_HUB) bSectionHub = true;

	int iVideoEntry = -1;

	cSmallVideoPath = "";
	cSmallVideoDescription = "";
	int iCurrentVideoEntry = -1;

	static int iOneTimeSetup = true;
	if (iOneTimeSetup)
	{
		iOneTimeSetup = false;
		for (int i = 0; i < MAXTUTORIALS; i++)
		{
			bSmallVideoFirstClick[i] = true;
			iSmallVideoDelayExecute[i] = 0;
		}
	}
	
	if (tutorial_videos.size() > 0)
	{
		int i = 0;
		for (std::map<std::string, std::string>::iterator it = tutorial_videos.begin(); it != tutorial_videos.end(); ++it)
		{
			if (it->first.length() > 0)
			{
				if (strcmp(it->first.c_str(), tutorial) == 0)
				{
					iVideoEntry = i;
					iCurrentVideoEntry = i;
					cSmallVideoPath = it->second.c_str();
					if (cSmallComboSelection[iVideoEntry].Len() > 0) {
						//PE: Overwrite settings.
						int il = 0;
						for (std::map<std::string, std::string>::iterator it = tutorial_videos.begin(); it != tutorial_videos.end(); ++it) {
							if (it->first.length() > 0 && strcmp(it->first.c_str(), cSmallComboSelection[iVideoEntry].Get()) == 0 ) {
								cSmallVideoPath = it->second.c_str();
								iCurrentVideoEntry = il;
								break;
							}
							il++;
						}
					}
					break;
				}
			}
			i++;
		}
	}
	
	if (bSectionHub && iStopAndFreeThisVideo >= 0)
	{
		if (iSmallVideoSlot[iStopAndFreeThisVideo] > 0) {
			if (AnimationExist(iSmallVideoSlot[iStopAndFreeThisVideo])) {
				if (AnimationPlaying(iSmallVideoSlot[iStopAndFreeThisVideo]))
					StopAnimation(iSmallVideoSlot[iStopAndFreeThisVideo]);
				DeleteAnimation(iSmallVideoSlot[iStopAndFreeThisVideo]);
				iSmallVideoSlot[iStopAndFreeThisVideo] = 0;
				bSmallVideoPerccentStart[iStopAndFreeThisVideo] = false;
				bSmallVideoFrameStart = false;
				bSmallVideoResumePossible[iStopAndFreeThisVideo] = false;
			}
		}
		iStopAndFreeThisVideo = -1;
		bSmallVideoInit[iVideoEntry] = false;
	}

	if (iVideoEntry >= 0 && cSmallVideoPath.Len() > 0 ) {

		//PE: Auto launch maximized , if first time in a section.

		if (iCurrentVideoSectionPlaying > 0 && iVideoSection > 0 && iCurrentVideoSectionPlaying != iVideoSection)
		{
			//PE: Pause any playing video , when changing section.
			for (int i = 0; i < MAXTUTORIALS; i++) {
				if (iSmallVideoSlot[i] > 0) {
					if (AnimationExist(iSmallVideoSlot[i])) {
						if (AnimationPlaying(iSmallVideoSlot[i]))
						{
							PauseAnim(iSmallVideoSlot[i]);
							bSmallVideoResumePossible[i] = false;
							iCurrentVideoSectionPlaying = 0;
						}
					}
				}
			}
		}

		if (iVideoSection > 0 && iVideoSection < 20)
		{
			//if (bAutoStart)
			if (0)
			{
				if (pref.iPlayedVideoSection[iVideoSection] == 0)
				{
					pref.iPlayedVideoSection[iVideoSection] = 1;
					bSmallVideoMaximized[iVideoEntry] = true;
					//PE: Perhaps auto start here ?
				}
			}
		}


		//PE: Only delete one video on first run, if same tutorials use same iVideoEntry.
		if (bSmallVideoFrameStart && !bSmallVideoInit[iVideoEntry])
		{
			if (iSmallVideoSlot[iVideoEntry] > 0) {
				if (AnimationExist(iSmallVideoSlot[iVideoEntry])) {
					if (AnimationPlaying(iSmallVideoSlot[iVideoEntry]))
						StopAnimation(iSmallVideoSlot[iVideoEntry]);
					DeleteAnimation(iSmallVideoSlot[iVideoEntry]);
					iSmallVideoSlot[iVideoEntry] = 0;
					bSmallVideoPerccentStart[iVideoEntry] = false;
					bSmallVideoFrameStart = false;
					bSmallVideoResumePossible[iVideoEntry] = false;
				}
			}
		}

		//PE: Dont init first in this system , wait until we need it.
/*
		if (!bSmallVideoInit[iVideoEntry])
		{
			
			if (iSmallVideoSlot[iVideoEntry] > 0) {
				if (AnimationExist(iSmallVideoSlot[iVideoEntry])) {
					if (AnimationPlaying(iSmallVideoSlot[iVideoEntry]))
						StopAnimation(iSmallVideoSlot[iVideoEntry]);
					DeleteAnimation(iSmallVideoSlot[iVideoEntry]);
					iSmallVideoSlot[iVideoEntry] = 0;
				}
			}

			t.tvideofile_s = cSmallVideoPath;
			iSmallVideoSlot[iVideoEntry] = 0;
			t.text_s = Lower(Right(t.tvideofile_s.Get(), 4));
			if (t.text_s == ".ogv" || t.text_s == ".mp4")
			{
				for (int itl = 1; itl <= 32; itl++)
				{
					if (AnimationExist(itl) == 0) { iSmallVideoSlot[iVideoEntry] = itl; break; }
				}
				if (LoadAnimation(t.tvideofile_s.Get(), iSmallVideoSlot[iVideoEntry], g.videoprecacheframes, g.videodelayedload, 1) == false)
				{
					iSmallVideoSlot[iVideoEntry] = -999;
				}
			}
			if (iSmallVideoSlot[iVideoEntry] > 0) {
				PlaceAnimation(iSmallVideoSlot[iVideoEntry], -1, -1, -1, -1);
				SetRenderAnimToImage(iSmallVideoSlot[iVideoEntry], true);
				//Try to get first frame.
				StopAnimation(iSmallVideoSlot[iVideoEntry]);
				PlayAnimation(iSmallVideoSlot[iVideoEntry]);
				SetRenderAnimToImage(iSmallVideoSlot[iVideoEntry], true);
				iSmallVideoFindFirstFrame[iVideoEntry] = 4;
				SetVideoVolume(0);
				UpdateAllAnimation();
				bSmallVideoResumePossible[iVideoEntry] = false;
				bSmallVideoPerccentStart[iVideoEntry] = false;
			}
			bSmallVideoInit[iVideoEntry] = true;
		}
*/
		if (1) //iSmallVideoSlot[iVideoEntry] > 0)
		{

			if (iSmallVideoFindFirstFrame[iVideoEntry] > 0) {
				if (iSmallVideoFindFirstFrame[iVideoEntry] == 1) {
					PauseAnim(iSmallVideoSlot[iVideoEntry]);
					iCurrentVideoSectionPlaying = 0;
					bSmallVideoResumePossible[iVideoEntry] = false;
					SetVideoVolume(100.0);
				}
				iSmallVideoFindFirstFrame[iVideoEntry]--;
			}

			switch (iSmallVideoDelayExecute[iVideoEntry]) {

				case 1: //Play restart
				{
					//PE: We can only start one video per frame.
					if (bSmallVideoFrameStart) {
						bSmallVideoFrameStart = false;
						iSmallVideoDelayExecute[iVideoEntry] = 0;
						SmallTutorialVideoInit(iVideoEntry);
						if (iSmallVideoSlot[iVideoEntry] > 0) {
							StopAnimation(iSmallVideoSlot[iVideoEntry]);
							PlayAnimation(iSmallVideoSlot[iVideoEntry]);
							SetRenderAnimToImage(iSmallVideoSlot[iVideoEntry], true);
							UpdateAllAnimation();
							Sleep(50); //Sleep so we get a video texture in the next call.
							UpdateAllAnimation();
							SetVideoVolume(100.0);
							bSmallVideoResumePossible[iVideoEntry] = false;
							bSmallVideoPerccentStart[iVideoEntry] = true;
							iCurrentVideoSectionPlaying = iVideoSection;
						}
					}
					break;
				}
				case 2: //Resume
				{
					SmallTutorialVideoInit(iVideoEntry);
					if (iSmallVideoSlot[iVideoEntry] > 0) {
						iSmallVideoDelayExecute[iVideoEntry] = 0;
						ResumeAnim(iSmallVideoSlot[iVideoEntry]);
						iCurrentVideoSectionPlaying = iVideoSection;
					}
					break;
				}
				case 3: //Pause
				{
					SmallTutorialVideoInit(iVideoEntry);
					if (iSmallVideoSlot[iVideoEntry] > 0) {
						iSmallVideoDelayExecute[iVideoEntry] = 0;
						PauseAnim(iSmallVideoSlot[iVideoEntry]);
						bSmallVideoResumePossible[iVideoEntry] = true;
						iCurrentVideoSectionPlaying = 0;
					}
					break;
				}
				default:
					break;
			}

			int combo_current_type_selection = 0;

			if (combo_items && combo_entries > 0 ) {
				if (cSmallComboSelection[iVideoEntry].Len() > 0)
				{
					for (int i = 0; i < combo_entries;i++)
					{
						if (combo_items[i])
						{
							if (strcmp(cSmallComboSelection[iVideoEntry].Get(), combo_items[i]) == 0)
							{
								combo_current_type_selection = i;
								break;
							}
						}
					}
				}
			}
			if (combo_items && combo_entries > 0)
			{
				std::map<std::string, std::string>::iterator it = tutorial_description.find(combo_items[combo_current_type_selection]);
				if (it != tutorial_description.end()) {
					cSmallVideoDescription = it->second.c_str();
				}
			}
			else
			{
				std::map<std::string, std::string>::iterator it = tutorial_description.find(tutorial);
				if (it != tutorial_description.end()) {
					cSmallVideoDescription = it->second.c_str();
				}
			}
			//bSmallVideoMaximized[iVideoEntry] = true; //For now.
			bool bMustEndWindow = false;
			if (bSmallVideoMaximized[iVideoEntry]) {
				
				//	Display the maximised tutorial video window.
				//if(combo_entries > 0)
				//	ImGui::SetNextWindowSize(ImVec2(55 * ImGui::GetFontSize(), 44 * ImGui::GetFontSize()), ImGuiCond_Once);
				//else
				ImGui::SetNextWindowSize(ImVec2(62 * ImGui::GetFontSize(), 45 * ImGui::GetFontSize()), ImGuiCond_Once);

				ImGui::SetNextWindowPosCenter(ImGuiCond_Once);

				//LB: ImGui::Begin("Tutorial Video##VideosMaxSize", &bSmallVideoMaximized[iVideoEntry], 0);
				ImGui::Begin("Tutorial Video##VideosMaxSize", &bSmallVideoMaximized[iVideoEntry], ImGuiWindowFlags_ForceRender);
				bMustEndWindow = true;
				bSmallVideoPlayerMaximized = true;
				ImGui::Indent(10);
			}


			if (combo_items && combo_entries > 0 ) {
				//Display combo.
				ImGui::PushItemWidth(-10);
				cstr sUniqueLabel = cstr("##TutorialSimpleInput") + cstr(iVideoEntry);
				//if (ImGui::Combo(sUniqueLabel.Get(), &combo_current_type_selection, combo_items, combo_entries)) {
				//	if (combo_items[combo_current_type_selection])
				//	{
				//		cSmallComboSelection[iVideoEntry] = combo_items[combo_current_type_selection];
				//		bSmallVideoInit[iVideoEntry] = false;
				//		bSmallVideoFrameStart = false; //PE: Wait until next frame.
				//	}
				//}
				if (combo_current_type_selection < combo_entries)
				{
					char *findcur = strstr(combo_items[combo_current_type_selection], "-");
					if (findcur) findcur++;
					else findcur = combo_items[combo_current_type_selection];

					if (ImGui::BeginCombo(sUniqueLabel.Get(), findcur, ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge))
					{
						for (int n = 0; n < combo_entries; n++)
						{
							if (combo_items[n])
							{
								bool is_selected = (combo_current_type_selection == n);
								char *find = strstr(combo_items[n], "-");
								if (find) find++;
								else find = combo_items[n];

								if (ImGui::Selectable(find, is_selected) )
								{
									combo_current_type_selection = n;
									cSmallComboSelection[iVideoEntry] = combo_items[combo_current_type_selection];
									bSmallVideoInit[iVideoEntry] = false;
									bSmallVideoFrameStart = false; //PE: Wait until next frame.
								}
								if (is_selected)
									ImGui::SetItemDefaultFocus();
							}
						}
						ImGui::EndCombo();

					}
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Tutorial Video");
				ImGui::PopItemWidth();
			}

			float fRatio = 1.0f / ((float)GetDesktopWidth() / (float)GetDesktopHeight());

			void* lpVideoTexture = NULL;
			if (bSmallVideoInit[iVideoEntry] )
				lpVideoTexture = GetAnimPointerTexture(iSmallVideoSlot[iVideoEntry]);
			float fVideoW = GetAnimWidth(iSmallVideoSlot[iVideoEntry]);
			float fVideoH = GetAnimHeight(iSmallVideoSlot[iVideoEntry]);
			if (bSmallVideoInit[iVideoEntry] && iSmallVideoSlot[iVideoEntry] > 0 && lpVideoTexture) {
				fRatio = 1.0f / (fVideoW / fVideoH);
			}

			int iActiveID = iVideoEntry;
			if (iCurrentVideoEntry >= 0 && iCurrentVideoEntry < MAXTUTORIALS && iCurrentVideoEntry != iVideoEntry) iActiveID = iCurrentVideoEntry;

			bool bShowBoder = true;
			float fLeftBorder = 10.0;
			if (bSectionHub) bShowBoder = false;
			if (bSectionHub && !bSmallVideoMaximized[iVideoEntry]) fLeftBorder = 2.0;

			float videoboxheight = (ImGui::GetContentRegionAvail().x - fLeftBorder) * fRatio;

			ImVec4 oldImGuiCol_ChildWindowBg = ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg];
			ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg] = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);

			//LB: ImGui::BeginChild("Video##TutorialVideo", ImVec2(ImGui::GetContentRegionAvail().x - 10.0, videoboxheight), true, iGenralWindowsFlags);
			ImGui::BeginChild("Video##TutorialVideo", ImVec2(ImGui::GetContentRegionAvail().x - fLeftBorder, videoboxheight), bShowBoder, ImGuiWindowFlags_NoScrollbar| ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_ForceRender | iGenralWindowsFlags);

			bool bToogleMinMax = false;
			ImGuiWindow* window = ImGui::GetCurrentWindow();
			ImRect image_bb(window->DC.CursorPos, window->DC.CursorPos + ImGui::GetContentRegionAvail());
			image_bb.Floor();

			bool bIsPlaying = false;
			//PE: We always play into iVideoEntry not iActiveID.
			if (iSmallVideoSlot[iVideoEntry] > 0)
			{
				if (AnimationExist(iSmallVideoSlot[iVideoEntry]) && AnimationPlaying(iSmallVideoSlot[iVideoEntry]))
					bIsPlaying = true;
			}

			bool bVideoAreaPressed = false;

			if (lpVideoTexture) 
			{
				SetRenderAnimToImage(iSmallVideoSlot[iVideoEntry], true);
				float animU = GetAnimU(iSmallVideoSlot[iVideoEntry]);
				float animV = GetAnimV(iSmallVideoSlot[iVideoEntry]);
				ImVec2 uv0 = ImVec2(0, 0);
				ImVec2 uv1 = ImVec2(animU, animV);
				//window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));

				ImGui::PushID(lpVideoTexture);
				const ImGuiID id = window->GetID("#image");
				ImGui::PopID();
				ImGui::ItemSize(image_bb);
				if (ImGui::ItemAdd(image_bb, id))
				{
					window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));

					bool hovered, held;
					bVideoAreaPressed = ImGui::ButtonBehavior(image_bb, id, &hovered, &held);
				}

			}
			else 
			{
				// Display thumbnail of the video (from .jpg)

				SmallTutorialThumbLoad(iActiveID);
				void* lpTexture = NULL;
				if (iSmallVideoThumbnail[iActiveID] > 0) lpTexture = GetImagePointer(iSmallVideoThumbnail[iActiveID]);

				//if (lpTexture) window->DrawList->AddImage((ImTextureID)lpTexture, image_bb.Min, image_bb.Max, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));

				ImGui::PushID(lpTexture);
				const ImGuiID id = window->GetID("#image");
				ImGui::PopID();
				ImGui::ItemSize(image_bb);
				if (ImGui::ItemAdd(image_bb, id))
				{
					if (lpTexture) window->DrawList->AddImage((ImTextureID)lpTexture, image_bb.Min, image_bb.Max, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));
					bool hovered, held;
					bVideoAreaPressed = ImGui::ButtonBehavior(image_bb, id, &hovered, &held);
				}

				//Display a play button.
				ImVec2 vOldPos = ImGui::GetCursorPos();
				float fPlayButSize = ImGui::GetContentRegionAvail().x * 0.15;
				float fCenterX = (ImGui::GetContentRegionAvail().x*0.5) - (fPlayButSize*0.5);
				float fCenterY = (videoboxheight*0.5) - (fPlayButSize*0.5);
				ImGui::SetCursorPos(ImVec2(fCenterX, fCenterY));
				ImVec4 vColorFade = { 1.0,1.0,1.0,0.5 };
				ImGui::SetItemAllowOverlap();
				if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(fPlayButSize, fPlayButSize), ImColor(255, 255, 255, 0), drawCol_normal*vColorFade, drawCol_hover*vColorFade, drawCol_Down*vColorFade, -1, 0, 0, 0, false,false,false,false,false, bBoostIconColors))
				{
					bSmallVideoPerccentStart[iVideoEntry] = true;
					bSmallVideoResumePossible[iVideoEntry] = false;
					iSmallVideoDelayExecute[iVideoEntry] = 1; //force play - restart.
					bSmallVideoFrameStart = false; //PE: Wait until next frame.
					//bVideoAreaPressed = true;
					if (!bSectionHub && bSmallVideoFirstClick[iVideoEntry])
					{
						bSmallVideoFirstClick[iVideoEntry] = false;
						bSmallVideoMaximized[iVideoEntry] = true;
					}
				}
				if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Play");

				ImGui::SetCursorPos(vOldPos);
			}

			#ifdef WICKEDENGINE
			//PE: Double click trigger an inver, so also invert here.
			if (!bStoryboardWindow && !bProceduralLevel)
			{
				if (bVideoAreaPressed || (ImGui::IsMouseDoubleClicked(0) && ImGui::IsMouseHoveringRect(image_bb.Min, image_bb.Max)))
				{
					//Video pause/play
					if (bIsPlaying)
					{
						//Pause
						bSmallVideoPerccentStart[iVideoEntry] = true;
						iSmallVideoDelayExecute[iVideoEntry] = 3; // pause
						bSmallVideoFrameStart = false; //PE: Wait until next frame.
					}
					else
					{
						//Play
						bSmallVideoPerccentStart[iVideoEntry] = true;
						if (bSmallVideoResumePossible[iVideoEntry]) {
							iSmallVideoDelayExecute[iVideoEntry] = 2; //resume
						}
						else {
							iSmallVideoDelayExecute[iVideoEntry] = 1; //play - restart.
						}
						bSmallVideoFrameStart = false; //PE: Wait until next frame.
						if (!bSectionHub && bSmallVideoFirstClick[iVideoEntry])
						{
							bSmallVideoFirstClick[iVideoEntry] = false;
							bSmallVideoMaximized[iVideoEntry] = true;
						}

					}
				}
			}
			if (ImGui::IsMouseHoveringRect(image_bb.Min, image_bb.Max))
			{
				if (!bStoryboardWindow && !bProceduralLevel )
				{
					if (ImGui::IsMouseDoubleClicked(0) && !bVideoAreaPressed)
					{
						bSmallVideoMaximized[iVideoEntry] = 1 - bSmallVideoMaximized[iVideoEntry];
					}
				}
				/*
				else
				{
					if (ImGui::IsMouseReleased(0))
					{
						if (bIsPlaying)
						{
							//Pause
							bSmallVideoPerccentStart[iVideoEntry] = true;
							iSmallVideoDelayExecute[iVideoEntry] = 3; // pause
							bSmallVideoFrameStart = false; //PE: Wait until next frame.
						}
						else
						{
							//Play
							bSmallVideoPerccentStart[iVideoEntry] = true;
							if (bSmallVideoResumePossible[iVideoEntry]) {
								iSmallVideoDelayExecute[iVideoEntry] = 2; //resume
							}
							else {
								iSmallVideoDelayExecute[iVideoEntry] = 1; //play - restart.
							}
							bSmallVideoFrameStart = false; //PE: Wait until next frame.
						}
					}
				}
				*/
			}

			ImGui::EndChild();
			ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg] = oldImGuiCol_ChildWindowBg;

			{
				float fdone = GetAnimPercentDone(iSmallVideoSlot[iVideoEntry]) / 100.0f;
				if (!bSmallVideoPerccentStart[iVideoEntry]) fdone = 0.0f;

				ImVec2 rstart = ImGui::GetWindowPos() + ImGui::GetCursorPos();
				ImGui::ProgressBar(fdone, ImVec2(ImGui::GetContentRegionAvail().x - fLeftBorder, 8), "");
				ImVec2 rend = ImGui::GetWindowPos() + ImGui::GetCursorPos() + ImVec2(ImGui::GetContentRegionAvail().x - fLeftBorder, 0.0);

				if (ImGui::IsMouseClicked(0) && ImGui::IsMouseHoveringRect(rstart, rend))
				{
					float GetVideoDuration();
					void SetVideoPositionPause(float seconds);
					void SetVideoPositionPlay(float seconds);

					ImVec2 mpos = ImGui::GetMousePos() - rstart;
					ImVec2 rwidth = rend - rstart;
					float percent = 100.0 / (rwidth.x / mpos.x);
					float videolength = GetVideoDuration();
					float vpercent = videolength / 100.0f;
					SetVideoPositionPlay((vpercent * percent) );
					ResumeAnim(iSmallVideoSlot[iVideoEntry]);
					bSmallVideoResumePossible[iVideoEntry] = false;
					if (!bSectionHub && bSmallVideoFirstClick[iVideoEntry])
					{
						bSmallVideoFirstClick[iVideoEntry] = false;
						bSmallVideoMaximized[iVideoEntry] = true;
					}
				}

				#define MEDIAICONSIZE 20

				if (bIsPlaying)
				{
					if (ImGui::ImgBtn(MEDIA_PAUSE, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
					{
						bSmallVideoPerccentStart[iVideoEntry] = true;
						iSmallVideoDelayExecute[iVideoEntry] = 3; // pause
						bSmallVideoFrameStart = false; //PE: Wait until next frame.
					}
					if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Pause");
				}
				else
				{
					if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
					{
						bSmallVideoPerccentStart[iVideoEntry] = true;
						if (bSmallVideoResumePossible[iVideoEntry]) {
							iSmallVideoDelayExecute[iVideoEntry] = 2; //resume
						}
						else {
							if (!bSectionHub && bSmallVideoFirstClick[iVideoEntry])
							{
								bSmallVideoFirstClick[iVideoEntry] = false;
								bSmallVideoMaximized[iVideoEntry] = true;
							}
							iSmallVideoDelayExecute[iVideoEntry] = 1; //play - restart.
						}
						bSmallVideoFrameStart = false; //PE: Wait until next frame.
					}
					if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Play");
				}
				ImGui::SameLine();
				if (ImGui::ImgBtn(MEDIA_REFRESH, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false,false,false,false,false, bBoostIconColors))
				{
					bSmallVideoPerccentStart[iVideoEntry] = true;
					iSmallVideoDelayExecute[iVideoEntry] = 1; //play - restart.
					bSmallVideoFrameStart = false; //PE: Wait until next frame.
				}
				if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Restart");

				if (!bSmallVideoMaximized[iVideoEntry])
				{
					ImGui::SameLine();
					if (ImGui::ImgBtn(MEDIA_MAXIMIZE, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true,false,false,false,false, bBoostIconColors))
					{
						bSmallVideoMaximized[iVideoEntry] = true;
					}
					if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Maximize");
				}
				else
				{
					ImGui::SameLine();
					if (ImGui::ImgBtn(MEDIA_MINIMIZE, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true,false,false,false,false, bBoostIconColors))
					{
						bSmallVideoMaximized[iVideoEntry] = false;
					}
					if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Minimize");
				}
			}
			#endif

			if (bMustEndWindow) 
			{

				if (cSmallVideoDescription.Len() > 0) {
					ImGui::Separator();
					ImGui::Text("Description");
					ImGui::TextWrapped(cSmallVideoDescription.Get());
				}

				bImGuiGotFocus = true;
				ImGui::Indent(-10);

				if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
					//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
					ImGui::Text("");
					ImGui::Text("");
				}

				ImGui::End();
			}

		}
	}
	return;
}

// Useful function
UINT OpenURLForGETPOST(LPSTR pServerName, LPSTR* pDataReturned, DWORD* pReturnDataSize, LPSTR pAuthHeader, LPSTR pszPostData, LPSTR pVerb, LPSTR urlWhere)
{
	// create large area to drop reply into
	int i100MB = 102400000;
	*pDataReturned = new char[i100MB];
	memset(*pDataReturned, 0, i100MB);

	UINT iError = 0;
	unsigned int dwDataLength = 0;
	HINTERNET m_hInet = InternetOpenA("InternetConnection", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
	if (m_hInet == NULL)
	{
		iError = GetLastError();
	}
	else
	{
		unsigned short wHTTPType = INTERNET_DEFAULT_HTTPS_PORT;
		HINTERNET m_hInetConnect = InternetConnectA(m_hInet, pServerName, wHTTPType, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
		if (m_hInetConnect == NULL)
		{
			iError = GetLastError();
		}
		else
		{
			int m_iTimeout = 2000;
			InternetSetOption(m_hInetConnect, INTERNET_OPTION_CONNECT_TIMEOUT, (void*)&m_iTimeout, sizeof(m_iTimeout));
			HINTERNET hHttpRequest = HttpOpenRequestA(m_hInetConnect, pVerb, urlWhere, "HTTP/1.1", NULL, NULL, INTERNET_FLAG_IGNORE_CERT_CN_INVALID | INTERNET_FLAG_NO_CACHE_WRITE | INTERNET_FLAG_SECURE, 0);
			if (hHttpRequest == NULL)
			{
				iError = GetLastError();
			}
			else
			{
				HttpAddRequestHeadersA(hHttpRequest, "Content-Type: application/x-www-form-urlencoded", -1, HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE);
				if (pAuthHeader) HttpAddRequestHeadersA(hHttpRequest, pAuthHeader, -1, HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE);
				int bSendResult = 0;
				if (pszPostData)
					bSendResult = HttpSendRequest(hHttpRequest, NULL, -1, (void*)(pszPostData), strlen(pszPostData));
				else
					bSendResult = HttpSendRequest(hHttpRequest, NULL, -1, NULL, 0);
				if (bSendResult == 0)
				{
					iError = GetLastError();
				}
				else
				{
					int m_iStatusCode = 0;
					char m_szContentType[150];
					unsigned int dwBufferSize = sizeof(int);
					unsigned int dwHeaderIndex = 0;
					HttpQueryInfo(hHttpRequest, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, (void*)&m_iStatusCode, (LPDWORD)&dwBufferSize, (LPDWORD)&dwHeaderIndex);
					dwHeaderIndex = 0;
					unsigned int dwContentLength = 0;
					HttpQueryInfo(hHttpRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, (void*)&dwContentLength, (LPDWORD)&dwBufferSize, (LPDWORD)&dwHeaderIndex);
					dwHeaderIndex = 0;
					unsigned int ContentTypeLength = 150;
					HttpQueryInfo(hHttpRequest, HTTP_QUERY_CONTENT_TYPE, (void*)m_szContentType, (LPDWORD)&ContentTypeLength, (LPDWORD)&dwHeaderIndex);
					char pBuffer[20000];
					for (;;)
					{
						unsigned int written = 0;
						if (!InternetReadFile(hHttpRequest, (void*)pBuffer, 2000, (LPDWORD)&written))
						{
							// error
						}
						if (written == 0) break;
						if (dwDataLength + written > 102400000) written = 102400000 - dwDataLength;
						memcpy(*pDataReturned + dwDataLength, pBuffer, written);
						dwDataLength = dwDataLength + written;
						if (dwDataLength >= 102400000) break;
					}
					InternetCloseHandle(hHttpRequest);
				}
			}
			InternetCloseHandle(m_hInetConnect);
		}
		InternetCloseHandle(m_hInet);
	}
	if (iError > 0)
	{
		char *szError = 0;
		if (iError > 12000 && iError < 12174)
			FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, GetModuleHandleA("wininet.dll"), iError, 0, (char*)&szError, 0, 0);
		else
			FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 0, iError, 0, (char*)&szError, 0, 0);
		if (szError)
		{
			LocalFree(szError);
		}
	}

	// complete
	*pReturnDataSize = dwDataLength;
	return iError;
}

//#####################################
//#### Process Preferences window. ####
//#####################################

#ifdef WICKEDENGINE
void ProcessPreferences(void) 
{
	if (!bPreferences_Window)
		return;

	float fs = ImGui::CalcTextSize("#").x;

	if (refresh_gui_docking == 1)
	{
		ImGui::SetNextWindowSize(ImVec2(54 * ImGui::GetFontSize(), 38 * ImGui::GetFontSize()), ImGuiCond_Always);
		ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
	}
	else
	{
		ImGui::SetNextWindowSize(ImVec2(54 * ImGui::GetFontSize(), 38 * ImGui::GetFontSize()), ImGuiCond_Once);
		ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
	}

	static float fLastContentWidth = 0;
	static ImVec2 vLastWindowSize = ImVec2(0, 0);
	if (refresh_gui_docking >= 3 )
	{
		if (fLastContentWidth > 0 && fLastContentWidth < 700.0f && vLastWindowSize.y > 0)
		{
			ImGui::SetNextWindowSize(ImVec2(700.0f, vLastWindowSize.y), ImGuiCond_Always);
		}
	}

	ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings;
	if (bDigAHoleToHWND) window_flags |= ImGuiWindowFlags_ForceRender;

	ImGui::Begin("Settings", &bPreferences_Window, window_flags);

	ImGuiWindow* bwindow = ImGui::GetCurrentWindow(); // ImGui::FindWindowByName("Save New Level##Storyboard");
	if (bDigAHoleToHWND && bwindow)
		bwindow->DrawList->AddCallback((ImDrawCallback)10, NULL); //force render.

	int inputcolx = fs * 18;
	bool change_colors = false;

	static int iCurrentTab = 0;

	//Tabs
	if (ImGui::BeginTabBar("preferencestabbar"))
	{
		int flags = 0;
		if(iSetSettingsFocusTab == 1)
			flags = ImGuiTabItemFlags_SetSelected;
		if (ImGui::BeginTabItem(" General ",NULL, flags))
		{
			iCurrentTab = 0;

			if (iSetSettingsFocusTab == 1) iSetSettingsFocusTab = 0;
			ImGui::Columns(2, "preferencescolumns2", false);  //false no border
			ImGui::SetColumnWidth(0, ImGui::GetWindowSize().x*0.45);
			ImGui::PushItemWidth(-10);
			ImGui::Text("Editor Options");
			//ImGui::Text("");
			ImGui::Indent(10);


			bool bIntroStartup = pref.iDisplayIntroScreen;
			if (ImGui::Checkbox("Show Intro Video on Start Up", &bIntroStartup)) {
				pref.iDisplayIntroScreen = bIntroStartup;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show or hide the Intro Video when GameGuru MAX first loads");

			//pref.iDisplayWelcomeScreen
			bool bWelcomeStartup = pref.iDisplayWelcomeScreen;
			if (ImGui::Checkbox("Show GameGuru MAX Hub on Startup", &bWelcomeStartup)) {
				pref.iDisplayWelcomeScreen = bWelcomeStartup;
			}
			//PE: Wicked - Moving away from showonstartup.ini and only use pref.iDisplayWelcomeScreen
			/*
			bool bWelcomeStartup = g.gshowonstartup;
			if (ImGui::Checkbox("Show Welcome Screen on Startup", &bWelcomeStartup)) {
				g.gshowonstartup = 1 - g.gshowonstartup;
				// save setting
				t.tfile_s = g.fpscrootdir_s + "\\showonstartup.ini";
				DeleteAFile(t.tfile_s.Get());
				if (FileOpen(1) == 1) CloseFile(1);
				OpenToWrite(1, t.tfile_s.Get());
				WriteString(1, cstr(g.gshowonstartup).Get());
				WriteString(1, "10");
				for (int n = 0; n < 10; n++)
				{
					WriteString(1, "0");
				}
				CloseFile(1);
			}
			*/
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show or hide the Welcome Screen when GameGuru MAX first loads");

			ImGui::Checkbox("Auto Close Property Sections", &pref.bAutoClosePropertySections);
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "After opening a new property section on the right, auto close any open ones");

			ImGui::Checkbox("Hide Tutorials Components From All Panels", &pref.bHideTutorials);
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Hides all tutorial sections from all panels");

			bool bHideShortcuts = pref.iHideKeyboardShortcuts;
			if(ImGui::Checkbox("Hide Keyboard Shortcuts From All Panels", &bHideShortcuts))
			{
				pref.iHideKeyboardShortcuts = bHideShortcuts;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Hides all keyboard shortcuts from all panels");

			bool bTmp = pref.iTurnOffUITransparent;
			if (ImGui::Checkbox("Turn Off UI Transparency", &bTmp)) {
				pref.iTurnOffUITransparent = bTmp;
				change_colors = true;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Stops the backgrounds in the UI from using transparency and uses an opaque color");

			bTmp = pref.iTurnOffEditboxTooltip;
			if (ImGui::Checkbox("Turn Off Help Pop-up Tips on Edit fields", &bTmp)) {
				pref.iTurnOffEditboxTooltip = bTmp;
				change_colors = true;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Hides the pop-up help tips when you hover over edit fields");

			//PE: TODO - This system dont really work , it need to be per object.
			bTmp = pref.iEnableAutoFlattenSystem; //g_bEnableAutoFlattenSystem;
			if (ImGui::Checkbox("Auto flatten terrain under large objects", &bTmp)) 
			{
				g_bEnableAutoFlattenSystem = bTmp;
				pref.iEnableAutoFlattenSystem = bTmp;
				bool bChangeState = false;
				if (bTmp)
				{
					bChangeState = true;
				}
				//PE: Loop into all.
				for (int i = 1; i <= g.entityelementlist; i++) {

					int entid = t.entityelement[i].bankindex;
					if (entid > 0)
					{
						int iAutoFlattenMode = t.entityprofile[entid].autoflatten;
						if(iAutoFlattenMode != 0)
							t.entityelement[i].eleprof.bAutoFlatten = bChangeState;
						else
							t.entityelement[i].eleprof.bAutoFlatten = false;
						if (!bTmp && t.entityelement[i].eleprof.iFlattenID != -1)
						{
							//PE: Disabled remove any flatten.
							GGTerrain_RemoveFlatArea(t.entityelement[i].eleprof.iFlattenID);
							t.entityelement[i].eleprof.iFlattenID = -1;
						}
						if (iAutoFlattenMode != 0 && bTmp)
						{
							if (t.entityelement[i].eleprof.iFlattenID == -1)
								entity_autoFlattenWhenAdded(i);
							else
								entity_updateautoflatten(i);
							g.projectmodified = 1;
						}
					}
				}
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Flattens the terrain and clears any trees and grass when placing large objects");

			ImGui::Indent(-10);
			ImGui::Text("Graphic Settings");
			ImGui::Indent(10);

			const char* quaity_items[] = { "Test Level - Low Settings", "Test Level - Medium Settings", "Test Level - High Settings" };
			if (ImGui::Combo("##GraphicsQualityTest", &pref.iTestGameGraphicsQuality, quaity_items, IM_ARRAYSIZE(quaity_items))) {
				//PE: This will overwrite "level designer" settings , in editor and test game, this is only for test game, so set later.
				//SetGlobalGraphicsSettings( pref.iTestGameGraphicsQuality );
			}

			//PE: Not possible at the moment.
			//ImGui::Checkbox("Disable Multiple Viewport Support", &pref.bDisableMultipleViewport);
			//if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Restart Max for this to take effect");

			ImGui::PopItemWidth();
			ImGui::Indent(-10);

			ImGui::NextColumn();

			ImGui::PushItemWidth(-10);
			ImGui::Text("Interface style");
			//ImGui::Text("");
			ImGui::Indent(10);

			//const char* style_combo[] = {	"Dark Style",//0->12
			//								"Darker Style",//1->13 
			//								"Evening blue",//2->9
			//								"Green tea",//3->2
			//								"Light Style",//4->14 
			//								"Moody red",//5->8
			//								"Purple haze",//6->4
			//								"Racing green",//7->10
			//								"Red Lines",//8->7
			//								"Retro green",//9->11
			//								"Sea blue",//10->0
			//								"Smart purple",//11->5
			//								"Striking yellow",//12->6
			//								"Sunset red",//13->3
			//								"Tango",//14->3
			//								"Blue" };//15->1

			//// current_style: 0-3 are the old styles, 10+ are the new colorful ones
			//int style_current_type_selection;
			//if (pref.current_style == 0) style_current_type_selection = 0;
			//if (pref.current_style == 1) style_current_type_selection = 1;
			//if (pref.current_style == 3) style_current_type_selection = 4;
			//if (pref.current_style >= 10) style_current_type_selection = pref.current_style - 10;

			//if (ImGui::Combo("##BehavioursSimpleInput", &style_current_type_selection, style_combo, IM_ARRAYSIZE(style_combo))) 
			//{
			//	if (style_current_type_selection == 0) {
			//		// dark
			//		pref.tint_style = ImVec4(1.0, 1.0, 1.0, 1.0);
			//		pref.shade_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			//		pref.title_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			//		pref.current_style = 0;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 1) {
			//		// darker
			//		pref.tint_style = ImVec4(1.0, 1.0, 1.0, 1.0);
			//		pref.shade_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			//		pref.title_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			//		pref.current_style = 1;
			//		myDarkStyle(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 2) {
			//		//Evening blue
			//		pref.tint_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
			//		pref.shade_style = ImVec4(0, 0, 0, 1.0);
			//		pref.title_style = ImVec4(1 / 255.0, 36 / 255.0, 73 / 255.0, 0.0);
			//		pref.current_style = 12;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 3) {
			//		//Green tea
			//		pref.tint_style = ImVec4(0, 0, 0, 1.0);
			//		pref.shade_style = ImVec4(4 / 255.0, 124 / 255.0, 10 / 255.0, 0.0);
			//		pref.title_style = ImVec4(89 / 255.0, 160 / 255.0, 93 / 255.0, 0.0);
			//		pref.current_style = 13;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 4) {
			//		// Light style
			//		pref.tint_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			//		pref.shade_style = ImVec4(1.0, 1.0, 1.0, 1.0);
			//		pref.title_style = ImVec4(1.0, 1.0, 1.0, 1.0);
			//		pref.current_style = 3;
			//		myLightStyle(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 5) {
			//		//Moody red
			//		pref.tint_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
			//		pref.shade_style = ImVec4(14 / 255.0, 12 / 255.0, 29 / 255.0, 0.0);
			//		pref.title_style = ImVec4(131 / 255.0, 16 / 255.0, 6 / 255.0, 0.0);
			//		pref.current_style = 15;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 6) {
			//		//Purple haze
			//		pref.tint_style = ImVec4(0, 0, 0, 1.0);
			//		pref.shade_style = ImVec4(163 / 255.0, 43 / 255.0, 179 / 255.0, 0.0);
			//		pref.title_style = ImVec4(251 / 255.0, 251 / 255.0, 251 / 255.0, 0.0);
			//		pref.current_style = 16;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 7) {
			//		//Racing green
			//		pref.tint_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
			//		pref.shade_style = ImVec4(0, 0, 0, 1.0);
			//		pref.title_style = ImVec4(18 / 255.0, 62 / 255.0, 0 / 255.0, 0.0);
			//		pref.current_style = 17;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 8) {
			//		//Red Lines
			//		pref.tint_style = ImVec4(0, 0, 0, 1.0);
			//		pref.shade_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
			//		pref.title_style = ImVec4(230 / 255.0, 56 / 255.0, 56 / 255.0, 0.0);
			//		pref.current_style = 18;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 9) {
			//		//Retro green
			//		pref.tint_style = ImVec4(11 / 255.0, 248 / 255.0, 25 / 255.0, 0.0);
			//		pref.shade_style = ImVec4(0, 0, 0, 1.0);
			//		pref.title_style = ImVec4(0, 0, 0, 1.0);
			//		pref.current_style = 19;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 10) {
			//		//Sea blue
			//		pref.tint_style = ImVec4(7 / 255.0, 7 / 255.0, 7 / 255.0, 1.0);
			//		pref.shade_style = ImVec4(12 / 255.0, 100 / 255.0, 168 / 255.0, 0.0);
			//		pref.title_style = ImVec4(28 / 255.0, 77 / 255.0, 244 / 255.0, 0.0);
			//		pref.current_style = 20;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 11) {
			//		//Smart purple
			//		pref.tint_style = ImVec4(0, 0, 0, 1.0);
			//		pref.shade_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
			//		pref.title_style = ImVec4(172 / 255.0, 96 / 255.0, 182 / 255.0, 0.0);
			//		pref.current_style = 21;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 12) {
			//		//Striking yellow
			//		pref.tint_style = ImVec4(0, 0, 0, 1.0);
			//		pref.shade_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
			//		pref.title_style = ImVec4(200 / 255.0, 191 / 255.0, 34 / 255.0, 0.0);
			//		pref.current_style = 22;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 13) {
			//		//Sunset red
			//		pref.tint_style = ImVec4(0,0,0, 1.0);
			//		pref.shade_style = ImVec4(164 / 255.0, 70 / 255.0, 70 / 255.0, 0.0);
			//		pref.title_style = ImVec4(204 / 255.0, 63 / 255.0, 50 / 255.0, 0.0);
			//		pref.current_style = 23;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 14) {
			//		//Tango
			//		pref.tint_style = ImVec4(0, 0, 0, 1.0);
			//		pref.shade_style = ImVec4(244 / 255.0, 251 / 255.0, 0, 0.0);
			//		pref.title_style = ImVec4(237 / 255.0, 86 / 255.0, 7 / 255.0, 0.0);
			//		pref.current_style = 24;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 15) {
			//		//Blue
			//		pref.tint_style = ImVec4(1.0, 1.0, 1.0, 1.0);
			//		pref.shade_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			//		pref.title_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			//		pref.current_style = 25;
			//		myStyleBlue(NULL);
			//		SetIconSet();
			//	}
			//}
			//if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select interface style");
const char* style_combo[] = { 
											"Blue Style", //0->1
											"Dark Style",//1->12
											"Darker Style",//2->13 
											"Evening Blue",//3->9
											"Green Tea",//4->2
											"Light Style",//5->14 
											"Moody Red",//6->8
											"Purple Haze",//7->4
											"Racing Green",//8->10
											"Red Lines",//9->7
											"Retro Green",//10->11
											"Sea Blue",//11->0
											"Smart Purple",//12->5
											"Striking Yellow",//13->6
											"Sunset Red",//14->3
											"Tango",//15->3
											};

int style_current_type_selection;
if (pref.current_style == 0) style_current_type_selection = 1;
if (pref.current_style == 1) style_current_type_selection = 2;
if (pref.current_style == 3) style_current_type_selection = 5;
if (pref.current_style >= 10) style_current_type_selection = pref.current_style - 9;
if (pref.current_style == 25) style_current_type_selection = 0; // ZJ: Moved blue to top of list, so pref.current_style - 10 no longer works.

if (ImGui::Combo("##BehavioursSimpleInput", &style_current_type_selection, style_combo, IM_ARRAYSIZE(style_combo)))
{
	if (style_current_type_selection == 0) {
		//Blue
		pref.tint_style = ImVec4(1.0, 1.0, 1.0, 1.0);
		pref.shade_style = ImVec4(0.0, 0.0, 0.0, 0.0);
		pref.title_style = ImVec4(0.0, 0.0, 0.0, 0.0);
		pref.current_style = 25;
		myStyleBlue(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 1) {
		// dark
		pref.tint_style = ImVec4(1.0, 1.0, 1.0, 1.0);
		pref.shade_style = ImVec4(0.0, 0.0, 0.0, 0.0);
		pref.title_style = ImVec4(0.0, 0.0, 0.0, 0.0);
		pref.current_style = 0;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 2) {
		// darker
		pref.tint_style = ImVec4(1.0, 1.0, 1.0, 1.0);
		pref.shade_style = ImVec4(0.0, 0.0, 0.0, 0.0);
		pref.title_style = ImVec4(0.0, 0.0, 0.0, 0.0);
		pref.current_style = 1;
		myDarkStyle(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 3) {
		//Evening blue
		pref.tint_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
		pref.shade_style = ImVec4(0, 0, 0, 1.0);
		pref.title_style = ImVec4(1 / 255.0, 36 / 255.0, 73 / 255.0, 0.0);
		pref.current_style = 12;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 4) {
		//Green tea
		pref.tint_style = ImVec4(0, 0, 0, 1.0);
		pref.shade_style = ImVec4(4 / 255.0, 124 / 255.0, 10 / 255.0, 0.0);
		pref.title_style = ImVec4(89 / 255.0, 160 / 255.0, 93 / 255.0, 0.0);
		pref.current_style = 13;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 5) {
		// Light style
		pref.tint_style = ImVec4(0.0, 0.0, 0.0, 0.0);
		pref.shade_style = ImVec4(1.0, 1.0, 1.0, 1.0);
		pref.title_style = ImVec4(1.0, 1.0, 1.0, 1.0);
		pref.current_style = 3;
		myLightStyle(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 6) {
		//Moody red
		pref.tint_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
		pref.shade_style = ImVec4(14 / 255.0, 12 / 255.0, 29 / 255.0, 0.0);
		pref.title_style = ImVec4(131 / 255.0, 16 / 255.0, 6 / 255.0, 0.0);
		pref.current_style = 15;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 7) {
		//Purple haze
		pref.tint_style = ImVec4(0, 0, 0, 1.0);
		pref.shade_style = ImVec4(163 / 255.0, 43 / 255.0, 179 / 255.0, 0.0);
		pref.title_style = ImVec4(251 / 255.0, 251 / 255.0, 251 / 255.0, 0.0);
		pref.current_style = 16;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 8) {
		//Racing green
		pref.tint_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
		pref.shade_style = ImVec4(0, 0, 0, 1.0);
		pref.title_style = ImVec4(18 / 255.0, 62 / 255.0, 0 / 255.0, 0.0);
		pref.current_style = 17;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 9) {
		//Red Lines
		pref.tint_style = ImVec4(0, 0, 0, 1.0);
		pref.shade_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
		pref.title_style = ImVec4(230 / 255.0, 56 / 255.0, 56 / 255.0, 0.0);
		pref.current_style = 18;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 10) {
		//Retro green
		pref.tint_style = ImVec4(11 / 255.0, 248 / 255.0, 25 / 255.0, 0.0);
		pref.shade_style = ImVec4(0, 0, 0, 1.0);
		pref.title_style = ImVec4(0, 0, 0, 1.0);
		pref.current_style = 19;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 11) {
		//Sea blue
		pref.tint_style = ImVec4(7 / 255.0, 7 / 255.0, 7 / 255.0, 1.0);
		pref.shade_style = ImVec4(12 / 255.0, 100 / 255.0, 168 / 255.0, 0.0);
		pref.title_style = ImVec4(28 / 255.0, 77 / 255.0, 244 / 255.0, 0.0);
		pref.current_style = 20;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 12) {
		//Smart purple
		pref.tint_style = ImVec4(0, 0, 0, 1.0);
		pref.shade_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
		pref.title_style = ImVec4(172 / 255.0, 96 / 255.0, 182 / 255.0, 0.0);
		pref.current_style = 21;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 13) {
		//Striking yellow
		pref.tint_style = ImVec4(0, 0, 0, 1.0);
		pref.shade_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
		pref.title_style = ImVec4(200 / 255.0, 191 / 255.0, 34 / 255.0, 0.0);
		pref.current_style = 22;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 14) {
		//Sunset red
		pref.tint_style = ImVec4(0, 0, 0, 1.0);
		pref.shade_style = ImVec4(164 / 255.0, 70 / 255.0, 70 / 255.0, 0.0);
		pref.title_style = ImVec4(204 / 255.0, 63 / 255.0, 50 / 255.0, 0.0);
		pref.current_style = 23;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 15) {
		//Tango
		pref.tint_style = ImVec4(0, 0, 0, 1.0);
		pref.shade_style = ImVec4(244 / 255.0, 251 / 255.0, 0, 0.0);
		pref.title_style = ImVec4(237 / 255.0, 86 / 255.0, 7 / 255.0, 0.0);
		pref.current_style = 24;
		myStyle2(NULL);
		SetIconSet();
	}
	
}
if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select your preferred user interface style");
			
			ImGui::PopItemWidth();		

			bTmp = pref.iEnableCustomColors;
			if (ImGui::Checkbox("Enable Custom Colors", &bTmp)) 
			{
				pref.iEnableCustomColors = bTmp;
				change_colors = true;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Use this to design your own custom interface style");

			if (pref.iEnableCustomColors)
			{
				//Tint
				float ChangeColor[4];
				ChangeColor[0] = pref.tint_style.x;
				ChangeColor[1] = pref.tint_style.y;
				ChangeColor[2] = pref.tint_style.z;
				ChangeColor[3] = 1.0f;

				//float hw = (ImGui::GetContentRegionAvailWidth() - 20.0f) * 0.5;
				float hw = (ImGui::GetContentRegionAvailWidth() - 20.0f) * 0.33;
				ImGui::Text("");
				ImVec2 cpos = ImGui::GetCursorPos();
				ImGui::Text("Text ");
				ImGui::SetCursorPos(cpos + ImVec2(hw + 8.0, 0));
				ImGui::Text("Background ");
				ImGui::SetCursorPos(cpos + ImVec2((hw*2) + 16.0, 0));
				ImGui::Text("Highlight "); 

				ImGui::PushItemWidth(hw);
				//ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX()+30.0, ImGui::GetCursorPosY()));
				if (ImGui::ColorPicker4("##ChangeTintColor", &ChangeColor[0], ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_DisplayRGB))
				{
					pref.tint_style.x = ChangeColor[0];
					pref.tint_style.y = ChangeColor[1];
					pref.tint_style.z = ChangeColor[2];
					change_colors = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Change the color of the text to make your own custom style");

				ChangeColor[0] = pref.shade_style.x;
				ChangeColor[1] = pref.shade_style.y;
				ChangeColor[2] = pref.shade_style.z;
				ChangeColor[3] = 1.0f;
				ImGui::SameLine();
				if (ImGui::ColorPicker4("##ChangeshadeColor", &ChangeColor[0], ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_DisplayRGB))
				{
					pref.shade_style.x = ChangeColor[0];
					pref.shade_style.y = ChangeColor[1];
					pref.shade_style.z = ChangeColor[2];
					change_colors = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Change the color of the background to make your own custom style");
				//ImGui::PopItemWidth();


				ChangeColor[0] = pref.title_style.x;
				ChangeColor[1] = pref.title_style.y;
				ChangeColor[2] = pref.title_style.z;
				ChangeColor[3] = 1.0f;
				ImGui::SameLine();
				if (ImGui::ColorPicker4("##ChangehighlightColor", &ChangeColor[0], ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_DisplayRGB))
				{
					pref.title_style.x = ChangeColor[0];
					pref.title_style.y = ChangeColor[1];
					pref.title_style.z = ChangeColor[2];
					change_colors = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Change the color of the highlight to make your own custom style");
				ImGui::PopItemWidth();


			}

			if (change_colors) {
				if (pref.current_style == 0 || pref.current_style >= 10 && pref.current_style != 25) {
					//myStyle2_colors_only();
					myStyle2(NULL);
				}
				if (pref.current_style == 1) {
					myDarkStyle(NULL);
				}
				if (pref.current_style == 3) {
					myLightStyle(NULL);
				}
				if (pref.current_style == 25) {
					myStyleBlue(NULL);
				}
				SetIconSet();
			}

			ImGui::PushItemWidth(-10);
			ImGui::Indent(-10);
			ImGui::Text("");
			ImGui::Text("Windows Layout");
			ImGui::Text("");
			ImGui::Indent(10);
			float w = ImGui::GetContentRegionAvailWidth() - 10.0f;
			if (ImGui::StyleButton("Reset Interface",ImVec2(w,0)) ) {
				refresh_gui_docking = 0;
				MaximiseWindow(); 
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "This will reset the interface to fit the current desktop size");

			/*
			if (ImGui::StyleButton("Reset view to current window size", ImVec2(w, 0)) ) {
				refresh_gui_docking = 0;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Reset view to current window size");
			*/

			ImGui::Indent(-10);

			ImGui::PopItemWidth();

			ImGui::Columns(1);
			ImGui::EndTabItem();
		}

		flags = 0;
		if (iSetSettingsFocusTab == 2)
			flags = ImGuiTabItemFlags_SetSelected;

		if (ImGui::BeginTabItem(" Advanced ", NULL , flags) )
		{
			static bool bCheckedInitialState = false;
			iCurrentTab = 1;
			if (iSetSettingsFocusTab == 2) iSetSettingsFocusTab = 0;
			static int iAdvCountDown = 10;
			if (iAdvCountDown > 0) 
			{
				iAdvCountDown--;
				if (iAdvCountDown == 0)
				{
					if (pref.iObjectEnableAdvanced == 2)
					{
						// skip message warnings when advanced user is in compact mode
					}
					else
					{
						int iAction = askBoxCancel("Are you sure you want to change settings in here? This will add a lot of additional features to the software.", "Warning"); //1==Yes 2=Cancel 0=No
						if (iAction != 1)
						{
							iAdvCountDown = 10;
							iSetSettingsFocusTab = 1;
						}
					}
				}
			}

			ImGui::Columns(2, "preferencesAdvancedcolumns2", false);  //false no border

			ImGui::PushItemWidth(-10);
			ImGui::Text("Panel and Drop-Down Menu Advanced Settings");
			ImGui::Indent(10);

			bool bTmp = pref.bAutoOpenMenuItems;
			if (ImGui::Checkbox("Auto Open Drop-down Menus", &bTmp)) {
				pref.bAutoOpenMenuItems = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Automatically open drop down menus (without clicking)");

			bTmp = pref.iEnableSingleRightPanelAdvanced;
			if (ImGui::Checkbox("Show Multiple Panels in Tabs", &bTmp)) {
				pref.iEnableSingleRightPanelAdvanced = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Allow tabbed sections in the right panel");

			bTmp = pref.iEnableAdvancedEntityList;
			if (ImGui::Checkbox("Allow Selection of Detailed Object List", &bTmp)) {
				current_sort_order = 0;
				pref.iEnableAdvancedEntityList = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Enable the detailed object list filter in the level objects window");

			void ToggleDPIAwareness(bool);
			// DPI Awareness Flag
			bool bDPIAware = true;
			// read DPI Aware from registry
			char pDPINotAware[256];
			strcpy(pDPINotAware, "0");
			HKEY hKeyNames = 0;
			DWORD Status = RegOpenKeyExA(HKEY_CURRENT_USER, "Software\\GameGuruMAX", 0L, KEY_READ, &hKeyNames);
			if (Status == ERROR_SUCCESS)
			{
				DWORD Type = REG_SZ;
				DWORD Size = 256;
				Status = RegQueryValueExA(hKeyNames, "DPINotAware", NULL, &Type, NULL, &Size);
				if (Size < 255)
				{
					RegQueryValueExA(hKeyNames, "DPINotAware", NULL, &Type, (LPBYTE)pDPINotAware, &Size);
				}
				RegCloseKey(hKeyNames);
			}
			if (pDPINotAware[0] == '1') bDPIAware = false;
			if (ImGui::Checkbox("Enable DPI Awareness", &bDPIAware))
			{
				ToggleDPIAwareness(bDPIAware);
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "If the UI is too large, enable DPI awareness to improve the scale. Requires a restart to see changes");
			ImGui::Indent(-10);
			ImGui::PopItemWidth();

			ImGui::PushItemWidth(-10);
			//ImGui::Text("");
			ImGui::Spacing();
			ImGui::Text("Game Editing Advanced Settings");
			ImGui::Indent(10);

			bTmp = pref.iEnableAxisRotationShortcuts;
			if (ImGui::Checkbox("Allow Axis Rotation Shortcuts", &bTmp)) {
				pref.iEnableAxisRotationShortcuts = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Allows you to rotate a selected object with keys 1 through 6");

			bTmp = pref.iEnableLevelEditorOpenAndNew;
			if (ImGui::Checkbox("Level Editor - Allow New And Open Options", &bTmp)) {
				pref.iEnableLevelEditorOpenAndNew = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Allows you to use menu options new and open from level editor");

			//New and Open options.


			bTmp = pref.iEnableIdentityProperties;
			if (ImGui::Checkbox("Display Identity in Object Tools", &bTmp)) {
				pref.iEnableIdentityProperties = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Display the identity of the selected object in the tools panel");

#ifdef STORYBOARD
			bTmp = pref.iStoryboardAdvanced;
			if (ImGui::Checkbox("Game Storyboard", &bTmp)) {
				pref.iStoryboardAdvanced = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show the Advanced Game Storyboard settings");
#endif
#ifdef PROCEDURALTERRAINWINDOW
			bTmp = pref.iTerrainAdvanced;
			if (ImGui::Checkbox("Terrain Generator", &bTmp)) {
				pref.iTerrainAdvanced = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show the Advanced Terrain Generator settings");

			bTmp = pref.iEnableTerrainHeightmaps;
			if (ImGui::Checkbox("Terrain Heightmaps", &bTmp)) {
				pref.iEnableTerrainHeightmaps = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show settings for importing heightmaps during terrain generation");
#endif

			bTmp = pref.iObjectEnableAdvanced;
			if (ImGui::Checkbox("Object Tools", &bTmp)) 
			{
				pref.iObjectEnableAdvanced = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show the Advanced Object Tools settings");
			if (pref.iObjectEnableAdvanced)
			{
				ImGui::SameLine();
				bTmp = false;
				if (pref.iObjectEnableAdvanced == 2) bTmp = true;
				if (ImGui::Checkbox("Compact Pos/Rot/Scl", &bTmp))
				{
					if (bTmp==false)
						pref.iObjectEnableAdvanced = 1;
					else
						pref.iObjectEnableAdvanced = 2;
					bCheckedInitialState = false;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Compact the Position, Rotation and Scale and keep component open");
			}

			bTmp = pref.iEnableAdvancedWater;
			if (ImGui::Checkbox("Water", &bTmp)) {
				pref.iEnableAdvancedWater = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show the Advanced Water customization settings");

			bTmp = pref.iEnableAdvancedCharacterCreator;
			if (ImGui::Checkbox("Character Creator", &bTmp)) {
				pref.iEnableAdvancedCharacterCreator = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show the Advanced Character Creator settings");

			bTmp = pref.iFullscreenPreviewAdvanced;
			if (ImGui::Checkbox("Object Library Preview Details", &bTmp)) {
				pref.iFullscreenPreviewAdvanced = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show more details about an object when viewing in full screen mode in the object library");
			ImGui::Indent(-10);
			ImGui::PopItemWidth();

			ImGui::NextColumn();

			ImGui::PushItemWidth(-10);
			//ImGui::Text("");
			ImGui::Text("Advanced Environmental Effects");
			ImGui::Indent(10);

			 bTmp = pref.iEnableAdvancedSky;
			if (ImGui::Checkbox("Sky", &bTmp)) {
				pref.iEnableAdvancedSky = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show the Advanced Sky customization settings");

			bTmp = pref.iEnableAdvancedPostProcessing;
			if (ImGui::Checkbox("Post Processing", &bTmp)) {
				pref.iEnableAdvancedPostProcessing = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Reveal the Post Processing properties section");

			bTmp = pref.iEnableAdvancedShadows;
			if (ImGui::Checkbox("Shadows", &bTmp)) {
				pref.iEnableAdvancedShadows = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Reveal the Shadows properties section");
			ImGui::Indent(-10);
			ImGui::PopItemWidth();

			ImGui::Text("");
			ImGui::Indent(10);

			// Determine if all the settings are on/off to check required state change.
			static std::array<int*, 16> advancedsettings = {
			&pref.bAutoOpenMenuItems,
			&pref.iEnableSingleRightPanelAdvanced,
			&pref.iEnableAdvancedEntityList,
			&pref.iEnableAxisRotationShortcuts,
			&pref.iEnableIdentityProperties,
			&pref.iStoryboardAdvanced,
			&pref.iTerrainAdvanced,
			&pref.iObjectEnableAdvanced,
			&pref.iEnableAdvancedWater,
			&pref.iEnableAdvancedCharacterCreator,
			&pref.iFullscreenPreviewAdvanced,
			&pref.iEnableAdvancedSky,
			&pref.iEnableAdvancedPostProcessing,
			&pref.iEnableAdvancedShadows,
			&pref.iImporterDome,
			&pref.iEnableAdvancedGrass
			};

			static bool bAllEnabled = false;
			
			// Check the initial state once, so that the correct button label can be assigned.
			if (!bCheckedInitialState)
			{
				bCheckedInitialState = true;
				int iEnabledSettings = 0;
				for (int i = 0; i < advancedsettings.size(); i++)
				{
					if (*advancedsettings[i] == 1)
						iEnabledSettings++;
				}
				if (iEnabledSettings == advancedsettings.size())
					bAllEnabled = true;		
			}
			
			char title[250];
			if (bAllEnabled)
				strcpy(title, "Turn Off All Advanced Settings");
			else
				strcpy(title, "Turn On All Advanced Settings");

			if (ImGui::StyleButton(title, ImVec2(ImGui::GetContentRegionAvailWidth() - 10, 0.0f))) 
			{
				int iEnabledSettings = 0;
				for (int i = 0; i < advancedsettings.size(); i++)
				{
					if (*advancedsettings[i] == 1)
						iEnabledSettings++;
				}

				int iDesiredValue = 1;
				if (iEnabledSettings == advancedsettings.size())
				{
					iDesiredValue = 0;
					if(bDPIAware)
						ToggleDPIAwareness(!bDPIAware);
				}
				
				for (int i = 0; i < advancedsettings.size(); i++)
					*advancedsettings[i] = iDesiredValue;

				if (iDesiredValue)
				{
					// Handle DPI Awareness differently.
					if (!bDPIAware)
						ToggleDPIAwareness(!bDPIAware);

					bAllEnabled = true;
				}
				else
					bAllEnabled = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Toggle all advanced settings on or off");
			ImGui::Indent(-10);

			ImGui::Text("");
			ImGui::Text("Save Game Folder Location");
			ImGui::Indent(10);
			float path_gadget_size = ImGui::GetFontSize()*2.0;
			ImGui::PushItemWidth(-10 - path_gadget_size);
			extern char szWriteDir[MAX_PATH];
			static bool bWriteFolderActive = false;
			if (strlen(pref.cCustomWriteFolder) > 0) bWriteFolderActive = true;
			if (ImGui::Checkbox("Allow the Game Save Folder to be changed", &bWriteFolderActive)) {
				if (!bWriteFolderActive)
				{
					strcpy(pref.cCustomWriteFolder, "");
					SetUpdaterWritePathFile(pref.cCustomWriteFolder);
					
					strcpy(cPreferencesMessage, "Please restart MAX for this change to take effect!");
				}
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Choose a new location for saving your game levels");
			if (bWriteFolderActive)
			{
				if (strlen(pref.cCustomWriteFolder) == 0)
					ImGui::InputText("##InputCustomWriteFolder", &szWriteDir[0], 250, ImGuiInputTextFlags_ReadOnly);
				else
					ImGui::InputText("##InputCustomWriteFolder", &pref.cCustomWriteFolder[0], 250, ImGuiInputTextFlags_ReadOnly);

				if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Current Write Folder");
				if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

				ImGui::SameLine();
				ImGui::PushItemWidth(path_gadget_size);
				if (ImGui::StyleButton("...##pathCustomWriteFolder")) {
					//PE: filedialogs change dir so.
					cStr tOldDir = GetDir();
					char * cFileSelected;
					cstr fulldir = pref.cCustomWriteFolder;
					cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_DIR, "All\0*.*\0", fulldir.Get(), NULL);
					SetDir(tOldDir.Get());

					if (cFileSelected && strlen(cFileSelected) > 0) {
						strcpy(pref.cCustomWriteFolder, cFileSelected);
						SetUpdaterWritePathFile(pref.cCustomWriteFolder);
						if (pref.cCustomWriteFolder[strlen(pref.cCustomWriteFolder) - 1] != '\\') strcat(pref.cCustomWriteFolder, "\\");
						strcpy(cPreferencesMessage, "Please restart MAX for this change to take effect!");
					}
					//Validate Write ?
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Choose a new location for saving your game levels");
				ImGui::PopItemWidth();
			}
			ImGui::PopItemWidth();

			ImGui::Text("");
			ImGui::Indent(-10);
			ImGui::Text("Default Import Folder Location");

			ImGui::Indent(10);
			path_gadget_size = ImGui::GetFontSize()*2.0;
			ImGui::PushItemWidth(-10 - path_gadget_size);
			ImGui::InputText("##InputDefaultImportFolder", &pref.cDefaultImportPath[0], 250, ImGuiInputTextFlags_ReadOnly);
			ImGui::PopItemWidth();
			if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select a new folder path from where to import models");
			if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

			ImGui::SameLine();
			ImGui::PushItemWidth(path_gadget_size);
			if (ImGui::StyleButton("...##pathDefaultImportFolder")) {
				//PE: filedialogs change dir so.
				cStr tOldDir = GetDir();
				char * cFileSelected;
				cstr fulldir = pref.cDefaultImportPath;
				cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_DIR, "All\0*.*\0", fulldir.Get(), NULL);
				SetDir(tOldDir.Get());
				if (cFileSelected && strlen(cFileSelected) > 0) {
					strcpy(pref.cDefaultImportPath, cFileSelected);
					if (pref.cDefaultImportPath[strlen(pref.cDefaultImportPath) - 1] != '\\')
						strcat(pref.cDefaultImportPath, "\\");
					sDefaultImportPath = pref.cDefaultImportPath;
				}
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select a new folder path from where to import models");
			ImGui::PopItemWidth();

			bool bTemp = pref.iImporterDome;
			if (ImGui::Checkbox("Show the Importer 'Dome' environment", &bTemp))
			{
				pref.iImporterDome = bTemp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("During the import process, a dome shape surrounds the imported model, use this to turn it off");

			//ImGui::Indent(10);
			
			//ImGui::Indent(-10);
			/* removed again for now
			ImGui::Text("");
			ImGui::Text("Store Settings");

			bTmp = pref.iGameCreaterStore;
			if (ImGui::Checkbox("Game Creator Store", &bTmp)) {
				pref.iGameCreaterStore = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Add Link to Game Creator Store");
			*/

			/* hidden features for now
			ImGui::Text("Level Editing");
			ImGui::Text("");

			bTmp = pref.iEnableArcRelationshipLines;
			if (ImGui::Checkbox("Arc Relation Lines", &bTmp)) {
				pref.iEnableArcRelationshipLines = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Enable Arc Relation Lines");

			bTmp = pref.iEnableRelationPopupWindow;
			if (ImGui::Checkbox("Use Relation Popup Window", &bTmp)) {
				pref.iEnableRelationPopupWindow = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Enable Relation Popup Window");
			*/
			
			ImGui::Indent(-10);
			ImGui::Columns(1);
			ImGui::EndTabItem();
		}

		if (ImGui::BeginTabItem(" Developer "))
		{
			iCurrentTab = 2;

			static int iDevCountDown = 10;
			if (iDevCountDown > 0) 
			{
				iDevCountDown--;
				if (iDevCountDown == 0)
				{
					if (pref.iObjectEnableAdvanced == 2)
					{
						// skip message warnings when advanced user is in compact mode
					}
					else
					{
						int iAction = askBoxCancel("Be aware these settings are for developers only, Are you very sure you want to change any of these settings ?", "Warning"); //1==Yes 2=Cancel 0=No
						if (iAction != 1)
						{
							iDevCountDown = 10;
							iSetSettingsFocusTab = 1;
						}
					}
				}
			}

			ImGui::Columns(2, "preferencestoolscolumns2", false);  //false no border

			ImGui::Text("Developer Modules");
			ImGui::Indent(10);
			extern int g_iDevToolsOpen;
			bool bT = (bool)g_iDevToolsOpen;
			if (ImGui::Checkbox("Show Additional Developer Options", &bT))
			{
				g_iDevToolsOpen = bT;
				wiProfiler::SetEnabled(bProfilerEnable);
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Make additional developer settings available");
			
			if (ImGui::Checkbox("Enable the 3D Editor Profiler", &bProfilerEnable))
			{
				wiProfiler::SetEnabled(bProfilerEnable);
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Display the rendering profile data in the level editor");
			//ImGui::NextColumn();
			//ImGui::Text("");
			//ImGui::Text("");
			//ImGui::NextColumn();
			ImGui::Indent(-10);

			ImGui::Text("");
			ImGui::Text("Multi-Monitor Support");
			ImGui::Indent(10);
			bool bTmp = pref.iAllowUndocking;
			if (ImGui::Checkbox("Enable Window Undocking", &bTmp)) {
				pref.iAllowUndocking = bTmp;
				if (pref.iAllowUndocking)
				{
					//PE: When enabling we need to reset layout, or docked windows display with no tabbar, and docking node can hide.
					//PE: This is caused by window where we set ImGuiDockNodeFlags_NoTabBar. so need reset nodes.
					refresh_gui_docking = 0;
					MaximiseWindow();
				}
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Allows you to move and dock/undock the various level editor windows (this feature is experimental)");

			/*
			// not stable, leave it disabled
			bTmp = pref.iDisableObjectLibraryViewport;
			if (ImGui::Checkbox("Disable Multi-Viewport", &bTmp)) {
				pref.iDisableObjectLibraryViewport = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Don't allow windows to be moved to another monitor or viewport");
			*/

			if (g_iDevToolsOpen != 0)
			{
				//ImGui::PushItemWidth(-10);
				ImGui::Text("");
				ImGui::Indent(-10);
				ImGui::Text("Developer Mode Tools");
				ImGui::Indent(10);
				//ImGui::Text("");
				
				//ImGui::PopItemWidth();
				//ImGui::NextColumn();
				//ImGui::Text("");
				//ImGui::Text("");
				//ImGui::NextColumn();

				float save_gadget_size = ImGui::GetFontSize()*10.0;
				float w = ImGui::GetWindowContentRegionWidth();

				/*
				w = ImGui::GetContentRegionAvailWidth();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (save_gadget_size*0.5), 0.0f));
				if (ImGui::StyleButton("Save Standalone", ImVec2(save_gadget_size, 0))) {
					CloseAllOpenTools();
					int iRet;
					iRet = AskSaveBeforeNewAction();
					if (iRet != 2)
					{
						bExport_Standalone_Window = true;
					}
					bPreferences_Window = false;
				}
				ImGui::Text("");
				ImGui::NextColumn();
				*/

				/* now in the marketplace proper
				if (g.includeassetstore == 1)
				{
					w = ImGui::GetContentRegionAvailWidth();
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (save_gadget_size*0.5), 0.0f));
					if (ImGui::StyleButton("Download Store Items", ImVec2(save_gadget_size, 0))) 
					{
						CloseAllOpenTools();
						extern int iDownloadStoreProgress;
						extern bool bDownloadStoreError;
						extern char cDownloadStoreError[4096];
						iDownloadStoreProgress = 0;
						bDownloadStoreError = false;
						strcpy(cDownloadStoreError, "");
						bDownloadStore_Window = true;
						bPreferences_Window = false;
					}
					//ImGui::Text("");
					//ImGui::NextColumn();
				}
				*/

				/*
				w = ImGui::GetContentRegionAvailWidth();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (save_gadget_size*0.5), 0.0f));
				if (ImGui::StyleButton("Character Creator", ImVec2(save_gadget_size, 0))) {
					CloseAllOpenTools();
					g_bCharacterCreatorPlusActivated = true;
					bPreferences_Window = false;
				}
				ImGui::Text("");
				ImGui::NextColumn();
				*/
				
				w = ImGui::GetContentRegionAvailWidth();
				//ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (save_gadget_size*0.5), 0.0f));
				if (ImGui::StyleButton("Legacy Structure Editor", ImVec2(save_gadget_size*1.3, 0))) {
					CloseAllOpenTools();
					DeleteWaypointsAddedToCurrentCursor();
					//CheckTooltipObjectDelete();
					CloseDownEditorProperties();
					t.inputsys.constructselection = 0;
					t.inputsys.constructselection = 0;
#ifdef WICKEDENGINE
					iLastEntityOnCursor = 0;
#endif

					if (t.ebebank_s[1].Len() > 0)
					{
						t.addentityfile_s = t.ebebank_s[1].Get();
						if (t.addentityfile_s != "")
						{
							entity_adduniqueentity(false);
							t.tasset = t.entid;
							if (t.talreadyloaded == 0)
							{
								editor_filllibrary();
							}
						}
						iExtractMode = 0; //PE: Always start in find floor mode.
						t.inputsys.constructselection = t.tasset;
						t.gridentity = t.entid;
						t.inputsys.constructselection = t.entid;
						t.inputsys.domodeentity = 1;
						t.grideditselect = 5;
						editor_refresheditmarkers();

						//NewSite, make sure we are in entity mode.
						bForceKey = true;
						csForceKey = "o";
						bBuilder_Left_Window = true;
#ifdef USELEFTPANELSTRUCTUREEDITOR
						ImGui::SetWindowFocus("Structure Editor##LeftPanel");
#endif
					}
					bPreferences_Window = false;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Use the legacy structure editor within the Level Editor");
				//ImGui::Text("");
				//ImGui::NextColumn();

				/*
				w = ImGui::GetContentRegionAvailWidth();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (save_gadget_size*0.5), 0.0f));
				if (ImGui::StyleButton("Import Models", ImVec2(save_gadget_size, 0))) {
					CloseAllOpenTools();
					iLaunchAfterSync = 8; //Import model
					iSkibFramesBeforeLaunch = 5;
					bPreferences_Window = false;
				}
				ImGui::Text("");
				ImGui::NextColumn();
				*/

				w = ImGui::GetContentRegionAvailWidth();
				//ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (save_gadget_size*0.5), 0.0f));
				if (ImGui::StyleButton("Reset Auto Start Videos", ImVec2(save_gadget_size*1.3, 0))) {
					CloseAllOpenTools();
					pref.iResetAutoRunVideosOnNextStartup = 1;
					bPreferences_Window = false;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Reset introduction videos for each section (This feature is not yet available)");
				//ImGui::Text("");
				//ImGui::NextColumn();

#ifdef PETESTING
				static bool bDisplayDemo = false;
				ImGui::Checkbox("Display Demo", &bDisplayDemo);
				if (bDisplayDemo)
					ImGui::ShowDemoWindow();
#endif
			}

			ImGui::NextColumn();
			//ImGui::Text("");
			//ImGui::Text("");
			//ImGui::NextColumn();
			ImGui::Indent(10);

			//ImGui::Text("");
			ImGui::Text("Object Management Options");
			ImGui::Indent(10);
			bTmp = pref.iDragCameraMovement;
			if (ImGui::Checkbox("Use Drag Camera Movement", &bTmp)) 
			{
				pref.iDragCameraMovement = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Left click and drag the terrain to move the camera position around in the Level Editor");

			bTmp = pref.iEnableDragDropEntityMode;
			if (ImGui::Checkbox("Drag/Drop Entity Mode", &bTmp)) {
				pref.iEnableDragDropEntityMode = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "When ticked you can drag and drop objects, unticked you have to click to select an object then again to place it");

			if (pref.iEnableDragDropEntityMode)
			{
				ImGui::Indent(20);
				bTmp = pref.iEnableDragDropWidgetSelect;
				if (ImGui::Checkbox("Enable Widget When Needed", &bTmp)) {
					pref.iEnableDragDropWidgetSelect = bTmp;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show the 3D widget for movement, rotation and scaling");
				ImGui::Indent(-20);

				ImGui::Indent(20);
				bTmp = pref.iEnableDragDropStopSelectFromInside;
				if (ImGui::Checkbox("Stop object from being moved when camera is inside", &bTmp)) {
					pref.iEnableDragDropStopSelectFromInside = bTmp;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Tick this if you want to avoid selecting objects (eg buildings) when viewed inside of them");
				ImGui::Indent(-20);
			}

			bTmp = pref.iEnableEditorOutlineSelection;
			if (ImGui::Checkbox("Use Outline For Selected Editor Objects", &bTmp)) {
				pref.iEnableEditorOutlineSelection = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Add a yellow outline around the currently selected object");

			if (pref.iEnableEditorOutlineSelection)
			{
				//ImGui::SameLine();
				ImGui::Indent(20);
				ImGui::SliderFloat("##OutlineThicknessSmall", &pref.fHighLightThickness, 0.0, 6.0, "%.2f");
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set the outline's thickness with this slider");
				ImGui::Indent(-20);
			}

			ImGui::Text("");
			ImGui::Text("Other Developer Options");

			bTmp = pref.iEnableFpsMemMonitor;
			if (ImGui::Checkbox("Show Live FPS And Memory Stats", &bTmp)) {
				pref.iEnableFpsMemMonitor = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Show Live FPS And Memory Stats");

			bTmp = pref.iEnableAutoExposureInEditor;
			if (ImGui::Checkbox("Use Auto Exposure in Editor", &bTmp)) {
				if (!pref.iEnableAutoExposureInEditor)
				{
					//Set autoexposure on if first time. if set in visuals.
					master_renderer->setEyeAdaptionEnabled(t.visuals.bAutoExposure);
				}
				pref.iEnableAutoExposureInEditor = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("The auto exposure effect can be turned on and off during editing of a level");

			//pref.iEnableAutoExposureInEditor
			//pref.iEnableDeveloperProperties = false;
			
			bTmp = pref.iEnableDeveloperObjectTools;
			if (ImGui::Checkbox("Display Object Tools Developer Mode", &bTmp)) 
			{
				pref.iEnableDeveloperObjectTools = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Shows the developer section in the objects panel");
			
			bTmp = pref.iEnableDeveloperProperties;
			if (ImGui::Checkbox("Display AI Management in Test Level", &bTmp)) 
			{
				pref.iEnableDeveloperProperties = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Shows the AI management options and gives access to Behavior Editing");

			bTmp = pref.iDisableProjectAutoSave;
			if (ImGui::Checkbox("Disable Storyboard Auto Save", &bTmp)) {
				pref.iDisableProjectAutoSave = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Turn on and off the auto save system");

			#ifdef ENABLEAUTOLEVELSAVE
			bTmp = pref.iDisableLevelAutoSave;
			if (ImGui::Checkbox("Disable Level Auto Save", &bTmp)) {
				pref.iDisableLevelAutoSave = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Disable Level Auto Save");

			#endif

			#ifdef PROCEDURALTERRAINWINDOW
			if (g_iDevToolsOpen)
			{
				bTmp = pref.iTerrainDebugMode;
				if (ImGui::Checkbox("Display Terrain Debug Mode", &bTmp)) {
					pref.iTerrainDebugMode = bTmp;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Reveals the terrain debugging mode in the terrain panel in the level editor");
			}
			else
			{
				pref.iTerrainDebugMode = 0;
			}
			#endif

			
			ImGui::Indent(-10);
			ImGui::Columns(1);
			ImGui::EndTabItem();
		}


		ImGui::EndTabBar();
	}

	//ImGui::Separator();
	ImGui::Text("");
	if (strlen(cPreferencesMessage) > 0)
	{
		ImGui::SetWindowFontScale(1.25);
		ImGui::TextCenter(cPreferencesMessage);
		ImGui::SetWindowFontScale(1.0);
	}
	ImVec2 ws = ImGui::GetWindowSize();
	ImGui::Indent();
	if (ImGui::GetCursorPosY() < ws.y - (fs * 4))
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ws.y - (fs * 4) + ImGui::GetScrollY()));

	float save_gadget_size = ImGui::GetFontSize()*10.0;

	if (ImGui::StyleButton("Reset to Defaults", ImVec2(save_gadget_size,0.0f)) )
	{
		int iAction = askBoxCancel("This will change all your settings back to the defaults, are you sure?", "Confirmation"); //1==Yes 2=Cancel 0=No
		if (iAction == 1)
		{
			pref.current_style = 25; // 0

			pref.tint_style = ImVec4(1.0, 1.0, 1.0, 1.0);
			pref.shade_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			pref.title_style = ImVec4(0.0, 0.0, 0.0, 0.0);

			pref.iMaximized = 1;
			pref.bHideTutorials = false;
			pref.bMultiplyOpenHeaders = false;
			pref.bAutoClosePropertySections = true;
			pref.bAutoOpenMenuItems = true;
			pref.bDisableMultipleViewport = false;
			pref.iTurnOffUITransparent = false;
			pref.iEnableCustomColors = 0;
			pref.iEnableAdvancedSky = 0;
			pref.iEnableAdvancedWater = 0;
			pref.iEnableAdvancedPostProcessing = 0;
			pref.iEnableAdvancedShadows = 0;
			pref.iObjectEnableAdvanced = 0;
			pref.iEnableArcRelationshipLines = 1;
			pref.iAllowUndocking = 0;
			pref.iEnableAxisRotationShortcuts = 0;

			pref.iEnableDragDropWidgetSelect = 0;

			pref.iEnableEditorOutlineSelection = 1;
			pref.iEnableSingleRightPanelAdvanced = 0;

			pref.iEnableDragDropEntityMode = 1;

			strcpy(pref.cCustomWriteFolder, "");
			SetUpdaterWritePathFile(pref.cCustomWriteFolder);
			strcpy(pref.cDefaultImportPath, "");
			strcpy(pref.cDefaultStandalonePath, "");
			strcpy(pref.cRememberLastSearchObjects, "");

			for (int i = 0; i < 10; i++)
				pref.iCheckboxFilters[i] = 1;

			pref.iEnableDeveloperProperties = 0;
			pref.iEnableIdentityProperties = 1;
			pref.iDragCameraMovement = 1;

			pref.iGameCreaterStore = 0;
			pref.iFullscreenPreviewAdvanced = 0;
			pref.iDisplayWelcomeScreen = 1;
			pref.iDisplayIntroScreen = 1;
			pref.iImporterDome = 1;
			pref.iTerrainAdvanced = 0;
			pref.iTerrainDebugMode = 0;
			pref.iEnableAdvancedCharacterCreator = 0;
			pref.iStoryboardAdvanced = 0;
			pref.iDisableProjectAutoSave = 0;
			pref.iDisableLevelAutoSave = 0;

			pref.iSplashStartMessage = 0;
			pref.iTitleStartMessage = 0;
			pref.iLoadingStartMessage = 0;
			pref.iGameWonStartMessage = 0;
			pref.iGameOverStartMessage = 0;

			pref.iHideKeyboardShortcuts = 0;
			pref.iEnableDeveloperObjectTools = 0;
			pref.iEnableTerrainHeightmaps = 0;

			for (int il = 0;il < 16; il++)
			{
				pref.vSaved_Light_Palette_R[il] = 1.0f;
				pref.vSaved_Light_Palette_G[il] = 1.0f;
				pref.vSaved_Light_Palette_B[il] = 1.0f;
				pref.iSaved_Light_Type[il] = -1;
				pref.iSaved_Light_Range[il] = 0;
				pref.fSaved_Light_ProbeScale[il] = 1.0f;
				pref.iSaved_Light_Radius[il] = 45;
				pref.fSaved_Light_AngX[il] = 90;
				pref.fSaved_Light_AngY[il] = 0;
				pref.fSaved_Light_AngZ[il] = 0;
			}

			for (int il = 0;il < 16; il++)
			{
				strcpy(pref.Saved_Particle_Name[il], "");
				pref.Saved_bParticle_Preview[il] = true;
				pref.Saved_bParticle_Show_At_Start[il] = true;
				pref.Saved_bParticle_Looping_Animation[il] = true;
				pref.Saved_bParticle_Full_Screen[il] = false;
				pref.Saved_fParticle_Fullscreen_Duration[il] = 10.0f;
				pref.Saved_fParticle_Fullscreen_Fadein[il] = 1.0f;
				pref.Saved_fParticle_Fullscreen_Fadeout[il] = 1.0f;
				strcpy(pref.Saved_Particle_Fullscreen_Transition[il], "");
				pref.Saved_fParticle_Speed[il] = 1.0f;
				pref.Saved_fParticle_Opacity[il] = 1.0f;
			}

			pref.iEnableAdvancedEntityList = 0;
			pref.fHighLightThickness = 1.0;
			pref.iTurnOffEditboxTooltip = false;
			pref.iEnableAutoExposureInEditor = 0;
			pref.iSetColumnsEntityLib = 3;

			pref.iDisableObjectLibraryViewport = 1;
			strcpy(pref.cLastUsedStoryboardProject, "");

			pref.iEnableLevelEditorOpenAndNew = 0;
			pref.iDisplayTerrainGeneratorWelcome = 1;
			pref.iTestGameGraphicsQuality = 2;
			pref.iEnableAutoFlattenSystem = 1;

			pref.iEnableAdvancedGrass = 0;
			pref.iEnableFpsMemMonitor = 0;
			pref.iEnableAutoFlattenSystem = 1;
			pref.iProjectSortMode = 0;

			pref.iEnableDragDropStopSelectFromInside = 0;

			if (pref.current_style == 0 || pref.current_style >= 10 && pref.current_style != 25) {
				//myStyle2_colors_only();
				myStyle2(NULL);
			}
			if (pref.current_style == 1) {
				myDarkStyle(NULL);
			}
			if (pref.current_style == 3) {
				myLightStyle(NULL);
			}
			if (pref.current_style == 25) {
				myStyleBlue(NULL);
			}

			SetIconSet();

			refresh_gui_docking = 0;
			if (bProfilerEnable) {
				bProfilerEnable = false;
				wiProfiler::SetEnabled(bProfilerEnable);
			}
			MaximiseWindow();
		}
	}
	if (ImGui::IsItemHovered()) ImGui::SetTooltip("Reset everything to default values");

	vLastWindowSize = ImGui::GetWindowSize();
	fLastContentWidth = ImGui::GetContentRegionAvailWidth();

//	if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
//		//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
//		ImGui::Text("");
//		ImGui::Text("");
//	}

	bImGuiGotFocus = true;


	ImGui::End();
	if (bDigAHoleToHWND && bwindow)
		bwindow->DrawList->AddCallback((ImDrawCallback)11, NULL); //disable force render.

}
#endif

void CloseAllOpenTools(bool bTerrainTools)
{
	if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
	if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
	if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
	if (bEntity_Properties_Window) bEntity_Properties_Window = false;
	if (t.ebe.on == 1) ebe_hide();
	if (bTerrainTools)
	{
		if (bTerrain_Tools_Window) bTerrain_Tools_Window = false;
		//if (Visuals_Tools_Window) Visuals_Tools_Window = false; //PE: Now toggle.
	}
	#ifdef WICKEDENGINE
	if (Shooter_Tools_Window)
		Shooter_Tools_Window = false;
	#endif
}

void CloseAllOpenToolsThatNeedSave(void)
{
	if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
	if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
	if (t.ebe.on == 1) ebe_hide();
}

#ifdef WICKEDENGINE
void imgui_shooter_tools(void)
{
	if (ImGui::windowTabVisible())
	{
		Shooter_Tools_Window_Active = true;

		// globals
		#ifndef REMOVED_EARLYACCESS
		if (ImGui::StyleCollapsingHeader("Shooter Settings", ImGuiTreeNodeFlags_DefaultOpen))
		{
			ImGui::Indent(10);
			ImGui::TextCenter("Level Difficulty");
			if (ImGui::MaxSliderInputFloat("##ShooterfLevelDifficulty", &t.visuals.fLevelDifficulty, 0.0f, 100.0f, "Set Level Difficulty"))
			{
				t.gamevisuals.fLevelDifficulty = t.visuals.fLevelDifficulty;
			}
			ImGui::Indent(-10);
		}
		#endif

		// if have selection selected
		bool bRubberBand = false;
		bool bToolsOpen = false;
		int iEntID = 0;
		int iEntIndex = t.widget.pickedEntityIndex;
		if (!pref.iEnableRelationPopupWindow && bDotMiddleWindow && g_selected_middle_dot_pobject)
		{
			int iDotMiddleIndex = g_selected_middle_dot_pobject->dwObjectNumber - DOTMIDDLEOBJECTID;
			if (iDotMiddleIndex >= 0 && iDotMiddleIndex < MAXDOTMIDDLE)
			{
				if (ImGui::StyleCollapsingHeader("Shooter Connections", ImGuiTreeNodeFlags_DefaultOpen))
				{
					ImGui::Indent(10);
					DisplayRelationshipMenu(iDotMiddleIndex, 0);
					ImGui::Indent(-10);
				}
			}
		}
		else if (t.widget.pickedObject != 0)
		{
			if (iEntIndex > 0)
			{
				iEntID = t.entityelement[iEntIndex].bankindex;
				if (iEntID > 0)
					if (t.entityprofile[iEntID].ischaracter > 0)
						bToolsOpen = true;
			}
			// rubber band
			if (g.entityrubberbandlist.size() > 0)
			{
				bRubberBand = true;
				//Any chars selected.
				for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
				{
					int e = g.entityrubberbandlist[i].e;
					if (e > 0)
					{
						int tobj = t.entityelement[e].obj;
						if (t.entityprofile[t.entityelement[e].bankindex].ischaracter > 0)
						{
							bToolsOpen = true;
						}
					}
				}
			}
			if (!bRubberBand && iEntIndex <= 0)
				bToolsOpen = false;

			if (bToolsOpen)
			{
				// ZJ: Moved to character settings.
				/*
				//PE: A char is selected.
				//Character
				if (ImGui::StyleCollapsingHeader("Character Logic", ImGuiTreeNodeFlags_DefaultOpen))
				{
					ImGui::Indent(10);
					ImGui::TextCenter("Allegiance");
					ImGui::PushItemWidth(-10);
					if (!bRubberBand)
					{
						// ZJ: Moved to character settings.
						////PE: Single Char
						//const char* items_combo[] = { "Enemy", "Ally", "Neutral" };
						//if (ImGui::Combo("##ShooteriCharAlliance", &t.entityelement[iEntIndex].eleprof.iCharAlliance, items_combo, IM_ARRAYSIZE(items_combo)))
						//{
						//	//No function yet.
						//}
						//if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Set Character Alliance");

					}
					else
					{
						//PE: As we can have diffent results , start by displaying change all.
						const char* items_combo[] = { "... change all to ...", "Enemies", "Allies", "Neutrale" };
						
						int new_selection = t.entityelement[g.entityrubberbandlist[0].e].eleprof.iCharAlliance;
						bool bGotSameSelection = true;
						//Check if all selection are the same.
						for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
						{
							int e = g.entityrubberbandlist[i].e;
							if (e > 0 && t.entityprofile[t.entityelement[e].bankindex].ischaracter > 0)
							{
								if (t.entityelement[e].eleprof.iCharAlliance != new_selection)
								{
									bGotSameSelection = false;
									break;
								}
							}
						}
						if (bGotSameSelection)
							new_selection++;
						else
							new_selection = 0;
						
						if (ImGui::Combo("##ShooteriCharAlliancem", &new_selection, items_combo, IM_ARRAYSIZE(items_combo)))
						{
							if (new_selection > 0)
							{
								new_selection--;
								for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
								{
									int e = g.entityrubberbandlist[i].e;
									if (e > 0 && t.entityprofile[t.entityelement[e].bankindex].ischaracter > 0)
									{
										t.entityelement[e].eleprof.iCharAlliance = new_selection;
									}
								}
							}
						}
						if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Set Character Alliance");
					}
					ImGui::PopItemWidth();
					ImGui::Indent(-10);
				}
				*/

				#ifndef REMOVED_EARLYACCESS
				if (t.visuals.sFactionName[0] == "")
				{
					t.visuals.sFactionName[0] = "Faction 1";
					t.visuals.sFactionName[1] = "Faction 2";
					t.visuals.sFactionName[2] = "Faction 3";
					for (int iL = 0; iL < 16; iL++)
						bFactionWindow[iL] = false;
				}
				for (int iL = 0; iL < 16; iL++)
				{
					if (bFactionWindow[iL])
					{
						//Ask for a proper name of faction.
						ImGui::SetNextWindowSize(ImVec2(26 * ImGui::GetFontSize(), 8 * ImGui::GetFontSize()), ImGuiCond_Once);
						ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
						cstr sUniqueWinName = cstr("Faction Name##ttn") + cstr(iL);
						ImGui::Begin(sUniqueWinName.Get(), &bFactionWindow[iL], 0);
						ImGui::Indent(10);
						static char NewTextureName[256];
						cstr sUniqueInputName = cstr("##InputFactionName") + cstr(iL);
						ImGui::PushItemWidth(-10);
						ImGui::Text("Enter a name for faction:");

						if (ImGui::IsRootWindowOrAnyChildFocused() && !ImGui::IsAnyItemActive() && !ImGui::IsMouseClicked(0))
							ImGui::SetKeyboardFocusHere(0);

						if (t.visuals.sFactionName[iL] == " ")
							t.visuals.sFactionName[iL] = "";

						if (ImGui::InputText(sUniqueInputName.Get(), t.visuals.sFactionName[iL].Get(), 250, ImGuiInputTextFlags_EnterReturnsTrue)) {
							t.gamevisuals.sFactionName[iL] = t.visuals.sFactionName[iL];
							bFactionWindow[iL] = false;
						}
						if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

						if (t.visuals.sFactionName[iL] == "")
							t.visuals.sFactionName[iL] = " ";
						ImGui::PopItemWidth();
						ImGui::Indent(-10);
						if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0)
						{
							//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
							ImGui::Text("");
							ImGui::Text("");
						}
						bImGuiGotFocus = true;
						ImGui::End();
					}
				}

				if (t.entityelement[iEntIndex].eleprof.iCharAlliance == 1)
				{
					// only for an enemy do they have a faction
					ImGui::Indent(10);
					ImGui::TextCenter("Enemy Faction");
					//PE: New code support both rubberband and single changes.
					if (1)
					{
						int UseEntIndex = iEntIndex;

						if (bRubberBand)
							UseEntIndex = g.entityrubberbandlist[0].e;

						bool bGotSameSelection = true;

						int new_selection = t.entityelement[UseEntIndex].eleprof.iCharFaction;
						if (bRubberBand)
						{
							//Check if all selection are the same.
							for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
							{
								int e = g.entityrubberbandlist[i].e;
								if (e > 0 && t.entityprofile[t.entityelement[e].bankindex].ischaracter > 0)
								{
									if (t.entityelement[e].eleprof.iCharFaction != new_selection)
									{
										bGotSameSelection = false;
										break;
									}
								}
							}
						}
						cstr cFactionName = "";
						if (t.entityelement[UseEntIndex].eleprof.iCharFaction >= 0 && t.entityelement[UseEntIndex].eleprof.iCharFaction < 16)
							cFactionName = t.visuals.sFactionName[t.entityelement[UseEntIndex].eleprof.iCharFaction];

						if (bRubberBand && !bGotSameSelection)
						{
							cFactionName = "... change all to ...";
						}

						if (ImGui::BeginCombo("##SelectFactionName", cFactionName.Get()))
						{
							int iCountIndex = 0;
							for (int iL = 0; iL < 16; iL++)
							{
								if (t.visuals.sFactionName[iL] != "")
								{
									bool is_selected = false;
									if (t.entityelement[UseEntIndex].eleprof.iCharFaction == iCountIndex)
										is_selected = true;
									if (ImGui::Selectable(t.visuals.sFactionName[iL].Get(), is_selected))
									{
										t.entityelement[UseEntIndex].eleprof.iCharFaction = iCountIndex;
										if (bRubberBand)
										{
											for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
											{
												int e = g.entityrubberbandlist[i].e;
												if (e > 0 && t.entityprofile[t.entityelement[e].bankindex].ischaracter > 0)
												{
													t.entityelement[e].eleprof.iCharFaction = iCountIndex;
												}
											}
										}
									}
									if (is_selected)
										ImGui::SetItemDefaultFocus();

									ImVec2 cpos = ImGui::GetCursorPos();

									ImGui::SetItemAllowOverlap();
									ImGui::SetCursorPos(ImVec2(cpos.x + ImGui::GetContentRegionAvail().x - 30.0f, cpos.y - (ImGui::GetFontSize()*1.5) - 3.0));
									ImGui::PushID(99 + iL);
									if (ImGui::ImgBtn(TOOL_PENCIL, ImVec2(16, 16), ImColor(255, 255, 255, 0)))
									{
										bFactionWindow[iL] = true;
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Change Faction Name");
									ImGui::PopID();

									ImGui::SetCursorPos(cpos);

									iCountIndex++;
								}
							}

							//Find first free.
							for (int iL = 0; iL < 16; iL++)
							{
								if (t.visuals.sFactionName[iL] == "")
								{
									//Add new.
									bool is_selected = false;
									if (ImGui::Selectable("Add a New Faction", is_selected))
									{
										t.visuals.sFactionName[iL] = cstr("Faction") + cstr(iL);
										bFactionWindow[iL] = true;
									}
									break;
								}
							}

							ImGui::EndCombo();
						}
						if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Set Enemy Characters Faction (this feature is not yet complete)");
					}
					ImGui::Indent(-10);
				}
				#endif
			}
		}

		if (!pref.bHideTutorials)
		{
			#ifdef REMOVED_EARLYACCESS
			#else
			if (ImGui::StyleCollapsingHeader("Tutorial (this feature is incomplete)", ImGuiTreeNodeFlags_DefaultOpen))
			{
				ImGui::Indent(10);
				cstr cShowTutorial = "01 - Getting started";
				char* tutorial_combo_items[] = { "01 - Getting started", "02 - Creating terrain", "03 - Add character and set a path" };
				SmallTutorialVideo(cShowTutorial.Get(), tutorial_combo_items, ARRAYSIZE(tutorial_combo_items), SECTION_SHOOTERGENRE);
				float but_gadget_size = ImGui::GetFontSize()*12.0;
				float w = ImGui::GetWindowContentRegionWidth() - 20.0;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
				#ifdef INCLUDESTEPBYSTEP
				if (ImGui::StyleButton("View Step by Step Tutorial", ImVec2(but_gadget_size, 0)))
				{
					bHelp_Window = true;
					bHelpVideo_Window = true;
					extern bool bSetTutorialSectionLeft;
					bSetTutorialSectionLeft = false;
					strcpy(cForceTutorialName, cShowTutorial.Get());
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Start Step by Step Tutorial");
				#endif
				ImGui::Indent(-10);
			}
			#endif
		}
	}
	else
	{
		Shooter_Tools_Window_Active = false;
	}
}
#endif
#endif

//PE: This also fixed TW TASK "BETA 3 - When placing an Audio marker, an outline of another appeared off - screen.Not sure what I did and I can't seem to replicate it. I can't select the outline.".

void DeleteWaypointsAddedToCurrentCursor(void)
{
	//PE: Delete any waypoints added to current cursor.
	if (t.grideditselect == 5 && t.gridentity > 0 && t.grideleprof.trigger.waypointzoneindex > 0)
	{
		t.waypointindex = t.grideleprof.trigger.waypointzoneindex;
		if (t.waypointindex > 0)
		{
			t.w = t.waypoint[t.waypointindex].start;
			waypoint_delete();
		}
		t.grideleprof.trigger.waypointzoneindex = 0;
	}
}

// New Logic System - Visual Relational Lines
#ifdef WICKEDENGINE

std::multimap<std::int32_t, std::int32_t> arcs_relations;
struct NodeConnection
{
	std::int32_t from;
	std::int32_t to;
	std::int32_t nodeconnectionid;
	std::int32_t middle;
};
std::vector<NodeConnection> nodeconnections;
void AddDotObjectRelation(int sobj, int dobj);
void FindDotObjectRelation(int sobj, int dobj,int middle_index);
void GetMiddleEntityIdAndRelationshipId(int sobj, int dobj, int &Entid, int &ReleationshipId, int& NodeConnectionId, int* NodeConnectionIndex = nullptr);
//void DrawDotArcs(int from, int to,bool bDrawMiddleBut);
void DrawObjectRelation(int from, int to, bool bDrawMiddleBut, int forceVertUpdate = 0);
void CreateDotMiddleObject(int obj);
void deleterelationobjects();

float fHighlightCount = 0.0f;
int iTotalArcs = 0;
int iTotalRelationObjects = 0; // The first node connection object is reserved for editing with cursor movement.
int iTotalMiddle = 0;
int iLargestArcs = 0;
int iLargestMiddle = 0;
int iCurrentDotCount = 0;
float fRelationUVs[24] = { 0 };
float fRelationUVsStorage[24] = { 0 };
bool bUVsAlreadySet = false;
float fUVCounter = 0.0f;

int GenerateRelationshipUniqueLinkID (void)
{
	// search all current entities and relationship links to find unique ID not used
	int iUniqueID = 42000;
	for (int e = 1; e <= g.entityelementlist; e++)
	{
		int iBankIndex = t.entityelement[e].bankindex;
		if (iBankIndex > 0)
		{
			int iObj = t.entityelement[e].obj;
			if (iObj > 0)
			{
				int iLinkID = t.entityelement[e].eleprof.iObjectLinkID;
				if (iLinkID > iUniqueID) iUniqueID = iLinkID;
				for (int i = 0; i < 10; i++)
				{
					iLinkID = t.entityelement[e].eleprof.iObjectRelationships[i];
					if (iLinkID > iUniqueID) iUniqueID = iLinkID;
				}
			}
		}
	}
	iUniqueID += 1;
	return iUniqueID;
}

void GetRelationshipObject (int iFindLinkID, int* piEntityID, int* piObj)
{
	*piEntityID = 0;
	*piObj = 0;
	if (iFindLinkID > 0)
	{
		for (int e = 1; e <= g.entityelementlist; e++)
		{
			int iObj = t.entityelement[e].obj;
			if (iObj > 0)
			{
				int iLinkID = t.entityelement[e].eleprof.iObjectLinkID;
				if (iLinkID == iFindLinkID)
				{
					*piEntityID = e;
					*piObj = iObj;
					return;
				}
			}
		}
	}
}

//void DrawCharacterDots(bool bVisible)
//{
//	//PE: Use 110000 for dot objects.
//	//PE: Use 130000 for arcs.
//	if (iCursorDotObject <= 0)
//	{
//		//PE: No collision on this one.
//		WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_CURSOROBJECT);
//		CreateDotObject(DOTCURSOROBJECTID);
//		WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_NORMAL);
//		HideObject(DOTCURSOROBJECTID);
//		iCursorDotObject = DOTCURSOROBJECTID;
//	}
//
//	MoveSelectedDotObject();
//
//	iTotalArcs = 0;
//	iTotalMiddle = 0;
//
//	if (arcs_relations.size() > 0)
//	{
//		//Hide dot objects.
//		for (std::multimap<std::int32_t, std::int32_t>::iterator it = arcs_relations.begin(); it != arcs_relations.end(); ++it)
//		{
//			if (it->first > 0 && it->second > 0)
//			{
//				HideObject(it->first);
//				HideObject(it->second);
//			}
//		}
//	}
//
//	arcs_relations.clear();
//
//	//PE: Hide old arcs.
//	for (int i = 0; i < iLargestArcs;i++)
//	{
//		HideObject(DOTARCSOBJECTID + i);
//	}
//	for (int i = 0; i < iLargestMiddle;i++)
//	{
//		HideObject(DOTMIDDLEOBJECTID + i);
//	}
//	if (iLargestDotCount != iCurrentDotCount)
//	{
//		//Something has changed, cleanup.
//		iLargestDotCount = iCurrentDotCount;
//		int iKeepInMem = 1000; //PE: Always keep upto 1000, delete the rest.
//		int iStartObj = 70001;
//		for (int i = iStartObj; i < iStartObj + MAXDOTARCSOBJECTS; i++)
//		{
//			if (ObjectExist(i + DOTOBJECTIDADD))
//			{
//				if(iKeepInMem-- > 0)
//					HideObject(i + DOTOBJECTIDADD);
//				else
//					DeleteObject(i + DOTOBJECTIDADD);
//			}
//		}
//	}
//
//	int iCurrentLargestDotObjectID = 70001;
//	iCurrentDotCount = 0;
//
//	for (int iEntityID = 1; iEntityID <= g.entityelementlist; iEntityID++)
//	{
//		int iBankIndex = t.entityelement[iEntityID].bankindex;
//		int iMasterObject = g.entitybankoffset + t.entityelement[iEntityID].bankindex;
//		int iObjectLinkID = t.entityelement[iEntityID].eleprof.iObjectLinkID;
//		int iEntityObject = t.entityelement[iEntityID].obj;
//		if (iEntityObject > 0)
//		{
//			if (iEntityObject > iCurrentLargestDotObjectID)
//				iCurrentLargestDotObjectID = iEntityObject;
//			if (iEntityObject > iLargestDotObjectID)
//				iLargestDotObjectID = iEntityObject;
//			if (ObjectExist(iEntityObject) == 1)
//			{
//				iCurrentDotCount++;
//
//				bool bObjectNeedDot = false;
//				int iColorType = -1;
//				if (t.entityelement[iEntityID].staticflag == 0)
//				{
//					// only dynamic objects can interact and have dot!
//					if (t.entityprofile[iBankIndex].ischaracter == 1)
//					{
//						iColorType = 1;
//						bObjectNeedDot = true;
//					}
//					else if (t.entityprofile[iBankIndex].ismarker == 11) //Flags
//					{
//						iColorType = 2;
//						bObjectNeedDot = true;
//					}
//					else if (t.entityprofile[iBankIndex].ismarker == 3) //Trigger zone
//					{
//						iColorType = 3;
//						bObjectNeedDot = true;
//					}
//					else
//					{
//						//PE: Everything else is a object type.
//						//PE: Adding dots to these would be a problem , like stacked boxes ...
//						iColorType = 4;
//						bObjectNeedDot = true;
//					}
//				}
//
//				if (bObjectNeedDot)
//				{
//					CreateDotObject(iEntityObject + DOTOBJECTIDADD);
//					PositionDotObject(iEntityObject + DOTOBJECTIDADD);
//					if (bVisible) 
//					{
//						for (int i = 0; i < 10; i++)
//						{
//							if (t.entityelement[iEntityID].eleprof.iObjectRelationships[i] > 0)
//							{
//								int iRelationShipObject = 0, iRelationShipEntityID = 0;
//								GetRelationshipObject(t.entityelement[iEntityID].eleprof.iObjectRelationships[i], &iRelationShipEntityID, &iRelationShipObject);
//								int iRelationshipLinkID = t.entityelement[iEntityID].eleprof.iObjectRelationships[i];
//								if (iObjectLinkID != iRelationshipLinkID)
//								{
//									//PE: If we got a reverse already dont add to arcs list.
//									bool bAlreadyThere = false;
//									for (std::multimap<std::int32_t, std::int32_t>::iterator it = arcs_relations.begin(); it != arcs_relations.end(); ++it)
//									{
//										if (it->first == iRelationShipObject + DOTOBJECTIDADD && it->second == iEntityObject + DOTOBJECTIDADD)
//										{
//											bAlreadyThere = true;
//											break;
//										}
//									}
//									if (!bAlreadyThere) 
//									{
//										//Validate reverse relation.
//										int iEntIDd = 0;
//										int iRelationIDd = 0;
//										GetMiddleEntityIdAndRelationshipId(iRelationShipObject, iEntityObject, iEntIDd, iRelationIDd);
//										if (iEntIDd > 0)
//										{
//											//PE: ok
//											arcs_relations.insert(std::make_pair(iEntityObject + DOTOBJECTIDADD, iRelationShipObject + DOTOBJECTIDADD));
//										}
//										else 
//										{
//											//LB:should only be done when Delete Relationship
//											//Reverse not found , remove it.
//											//t.entityelement[iEntityID].eleprof.iObjectRelationships[i] = 0;
//										}
//									}
//								}
//							}
//						}
//						ShowObject(iEntityObject + DOTOBJECTIDADD);
//					}
//					else 
//					{
//						HideObject(iEntityObject + DOTOBJECTIDADD);
//					}
//				}
//			}
//		}
//	}
//
//	if (iLargestDotObjectID > iCurrentLargestDotObjectID)
//	{
//		//PE: We got a deleted object, make sure to release all not used dots.
//		for (int i = iCurrentLargestDotObjectID; i < iLargestDotObjectID; i++)
//		{
//			if (i >= 70001 && i <= 90000) //Secure range.
//			{
//				if (ObjectExist(i + DOTOBJECTIDADD))
//				{
//					DeleteObject(i + DOTOBJECTIDADD);
//				}
//			}
//		}
//		iLargestDotObjectID = iCurrentLargestDotObjectID;
//	}
//
//	if (arcs_relations.size() > 0)
//	{
//		//Draw arcs.
//		for (std::multimap<std::int32_t, std::int32_t>::iterator it = arcs_relations.begin(); it != arcs_relations.end(); ++it)
//		{
//			if (it->first > 0 && it->second > 0)
//			{
//				//PE: Draw.
//				//DrawDotArcs(it->first, it->second,true);
//				DrawObjectRelation(it->first, it->second, true);
//			}
//		}
//	}
//
//	if (bDrawDotCircle) 
//	{
//		if( Timer() - fDrawDotCircleTimer < 2500 )
//			DrawDotArcsCircle(fDrawDotCircleFrom, fDrawDotCircleRadius);
//		else 
//		{
//			fDrawDotCircleTimer = 0;
//			bDrawDotCircle = false;
//		}
//	}
//
//	if (g_source_dot_pobject && bDotObjectDragging)
//		DrawObjectRelation(g_source_dot_pobject->dwObjectNumber, DOTCURSOROBJECTID, false);
//}

void DrawLogicNodes(bool bVisible)
{
	//PE: Use 110000 for dot objects.
	//PE: Use 130000 for arcs.
	if (iCursorDotObject <= 0)
	{
		//PE: No collision on this one.
		WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_CURSOROBJECT);
		CreateDotObject(DOTCURSOROBJECTID);
		WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_NORMAL);
		HideObject(DOTCURSOROBJECTID);
		iCursorDotObject = DOTCURSOROBJECTID;
	}

	MoveSelectedDotObject();

	iTotalMiddle = 0;

	if (arcs_relations.size() > 0)
	{
		//Hide dot objects.
		for (std::multimap<std::int32_t, std::int32_t>::iterator it = arcs_relations.begin(); it != arcs_relations.end(); ++it)
		{
			if (it->first > 0 && it->second > 0)
			{
				HideObject(it->first);
				HideObject(it->second);
			}
		}
	}

	arcs_relations.clear();

	for (int i = 0; i < iLargestMiddle; i++)
	{
		HideObject(DOTMIDDLEOBJECTID + i);
		HideObject(RELATIONOBJECTID + i);
	}

	if (iLargestDotCount != iCurrentDotCount)
	{
		//Something has changed, cleanup.
		iLargestDotCount = iCurrentDotCount;
		int iKeepInMem = 1000; //PE: Always keep upto 1000, delete the rest.
		int iStartObj = 70001;
		for (int i = iStartObj; i < iStartObj + MAXDOTARCSOBJECTS; i++)
		{
			if (ObjectExist(i + DOTOBJECTIDADD))
			{
				if (iKeepInMem-- > 0)
					HideObject(i + DOTOBJECTIDADD);
				else
					DeleteObject(i + DOTOBJECTIDADD);
			}
		}
	}

	int iCurrentLargestDotObjectID = 70001;
	iCurrentDotCount = 0;

	for (int iEntityID = 1; iEntityID <= g.entityelementlist; iEntityID++)
	{
		int iBankIndex = t.entityelement[iEntityID].bankindex;
		int iMasterObject = g.entitybankoffset + t.entityelement[iEntityID].bankindex;
		int iObjectLinkID = t.entityelement[iEntityID].eleprof.iObjectLinkID;
		int iEntityObject = t.entityelement[iEntityID].obj;
		if (iEntityObject > 0)
		{
			if (iEntityObject > iCurrentLargestDotObjectID)
				iCurrentLargestDotObjectID = iEntityObject;
			if (iEntityObject > iLargestDotObjectID)
				iLargestDotObjectID = iEntityObject;
			if (ObjectExist(iEntityObject) == 1)
			{
				iCurrentDotCount++;

				bool bObjectNeedDot = false;
				int iColorType = -1;
				if (t.entityelement[iEntityID].staticflag == 0)
				{
					// only dynamic objects can interact and have dot!
					if (t.entityprofile[iBankIndex].ischaracter == 1)
					{
						iColorType = 1;
						bObjectNeedDot = true;
					}
					else if (t.entityprofile[iBankIndex].ismarker == 11) //Flags
					{
						iColorType = 2;
						bObjectNeedDot = true;
					}
					else if (t.entityprofile[iBankIndex].ismarker == 3) //Trigger zone
					{
						iColorType = 3;
						bObjectNeedDot = true;
					}
					else
					{
						//PE: Everything else is a object type.
						//PE: Adding dots to these would be a problem , like stacked boxes ...
						iColorType = 4;
						bObjectNeedDot = true;
					}
				}

				if (bObjectNeedDot)
				{
					CreateDotObject(iEntityObject + DOTOBJECTIDADD);
					PositionDotObject(iEntityObject + DOTOBJECTIDADD);
					if (bVisible)
					{
						int iConnectionsCount = 0;
						for (int i = 0; i < 10; i++)
						{
							if (t.entityelement[iEntityID].eleprof.iObjectRelationships[i] > 0)
							{
								int iRelationShipObject = 0, iRelationShipEntityID = 0;
								GetRelationshipObject(t.entityelement[iEntityID].eleprof.iObjectRelationships[i], &iRelationShipEntityID, &iRelationShipObject);
								int iRelationshipLinkID = t.entityelement[iEntityID].eleprof.iObjectRelationships[i];
								if (iObjectLinkID != iRelationshipLinkID)
								{
									//PE: If we got a reverse already dont add to arcs list.
									bool bAlreadyThere = false;
									for (std::multimap<std::int32_t, std::int32_t>::iterator it = arcs_relations.begin(); it != arcs_relations.end(); ++it)
									{
										if (it->first == iRelationShipObject + DOTOBJECTIDADD && it->second == iEntityObject + DOTOBJECTIDADD)
										{
											bAlreadyThere = true;
											break;
										}
									}
									if (!bAlreadyThere)
									{
										//Validate reverse relation.
										int iEntIDd = 0;
										int iRelationIDd = 0;
										int iNodeConnectionIDd = 0;
										GetMiddleEntityIdAndRelationshipId(iRelationShipObject, iEntityObject, iEntIDd, iRelationIDd, iNodeConnectionIDd);
										if (iEntIDd > 0)
										{
											//PE: ok
											arcs_relations.insert(std::make_pair(iEntityObject + DOTOBJECTIDADD, iRelationShipObject + DOTOBJECTIDADD));
										}
									}
								}
								iConnectionsCount++;
							}
						}
						ShowObject(iEntityObject + DOTOBJECTIDADD);
					}
					else
					{
						HideObject(iEntityObject + DOTOBJECTIDADD);
					}
				}
			}
		}
	}
	
	if (iLargestDotObjectID > iCurrentLargestDotObjectID)
	{
		//PE: We got a deleted object, make sure to release all not used dots.
		for (int i = iCurrentLargestDotObjectID; i < iLargestDotObjectID; i++)
		{
			if (i >= 70001 && i <= 90000) //Secure range.
			{
				if (ObjectExist(i + DOTOBJECTIDADD))
				{
					DeleteObject(i + DOTOBJECTIDADD);
				}
			}
		}
		iLargestDotObjectID = iCurrentLargestDotObjectID;
	}

	// Update the reference UVs for the node connection objects.
	if (fUVCounter >= 1.0f)
	{
		for (int i = 0; i < 24; i++)
		{
			fRelationUVs[i] = fRelationUVsStorage[i];
		}

		fUVCounter = 0.0f;
	}

	for (int i = 0; i < 24; i++)
	{
		if (i < 12)
			fRelationUVs[i] += (0.2f * ImGui::GetIO().DeltaTime);
		else
			fRelationUVs[i] -= (0.2f * ImGui::GetIO().DeltaTime);
	}

	fUVCounter += (0.2f * ImGui::GetIO().DeltaTime);

	if (arcs_relations.size() > 0)
	{
		// When an object gets deleted and another takes its place, it can have the same object number...
		// ...which can prevent the relation object vertices from being updated
		static int vertUpdateCounter = 0;
		vertUpdateCounter++;
		if (vertUpdateCounter > 30)
			vertUpdateCounter = 0;

		//Draw connections.
		for (std::multimap<std::int32_t, std::int32_t>::iterator it = arcs_relations.begin(); it != arcs_relations.end(); ++it)
		{
			if (it->first > 0 && it->second > 0)
			{	
				if (vertUpdateCounter < 30)
				{
					DrawObjectRelation(it->first, it->second, true);
				}
				else
				{
					// vertUpdateCounter forces all the verts to be updated.
					DrawObjectRelation(it->first, it->second, true, 1);
				}
			}
		}
	}

	// Hide any relation objects that are no longer used.
	if (arcs_relations.empty())
	{
		for (int i = 0; i < nodeconnections.size(); i++)
		{
			HideObject(RELATIONOBJECTID + iTotalMiddle + 1 + i);
		}
	}
	else if (arcs_relations.size() < nodeconnections.size())
	{
		for (int i = arcs_relations.size() - 1; i < nodeconnections.size(); i++)
		{
			// Hide any relation objects no longer used (but don't delete so they can be reused).
			HideObject(RELATIONOBJECTID + iTotalMiddle + 1 + i);
		}
	}

	if (g_source_dot_pobject && bDotObjectDragging && !bDraggingActive)
		DrawObjectRelation(g_source_dot_pobject->dwObjectNumber, DOTCURSOROBJECTID, false);
	else if (!bDotObjectDragging)
		HideObject(RELATIONOBJECTID);
}

void PositionDotObject(int obj)
{
	if (ObjectExist(obj))
	{
		int iRealObjID = obj - DOTOBJECTIDADD;
		if (ObjectExist(iRealObjID))
		{
			bool bRestoreDotTOObjectCenter = true;
			if (g_hovered_pobject)
			{
				if (iRealObjID == g_hovered_pobject->dwObjectNumber)
				{
					PositionObject(obj, fLastHitPosition[0], fLastHitPosition[1], fLastHitPosition[2]);
					bRestoreDotTOObjectCenter = false;
				}
			}
			else if (g_hovered_dot_pobject)
			{
				if (obj == g_hovered_dot_pobject->dwObjectNumber)
				{
					// instruction what to do 
					pastebitmapfontcenter("Connect To Create Logic", GetScreenX(obj), GetScreenY(obj) + 10, 2, 255);
					bRestoreDotTOObjectCenter = false;
				}
			}
			if (bRestoreDotTOObjectCenter == true )
			{
				PositionObject(obj, ObjectPositionX(iRealObjID) + GetObjectCollisionCenterX(iRealObjID), ObjectPositionY(iRealObjID) + GetObjectCollisionCenterY(iRealObjID), ObjectPositionZ(iRealObjID) + GetObjectCollisionCenterZ(iRealObjID));
			}
		}
	}
}

void CreateDotMiddleObject(int obj)
{
	if (ObjectExist(obj) == 0)
	{
		if (ObjectExist(g.gameplayparentobjects + 2) == 0)
		{
			//LoadObject("editors\\uiv3\\dotmiddleobject.dbo", g.gameplayparentobjects + 2);
			//LoadObject("editors\\uiv3\\brain_marker.dbo", g.gameplayparentobjects + 2);
			//ScaleObject(g.gameplayparentobjects + 2, 30, 30, 30);
			//MakeObjectSphere(g.gameplayparentobjects + 2, 10, 2, 4 );
			LoadObject("editors\\uiv3\\brain_logic_marker.dbo", g.gameplayparentobjects + 2);
			ScaleObject(g.gameplayparentobjects + 2, 25, 25, 25);
			HideObject(g.gameplayparentobjects + 2);
		}
		CloneObject(obj, g.gameplayparentobjects + 2);
		DisableObjectZRead(obj);
		HideObject(obj);
		SetObjectMask(obj, 1);
		SetObjectTransparency(obj, 6);
		SetObjectEffect (obj, g.decaleffectoffset);
		//DisableObjectZWrite(obj);
		DisableObjectZDepth (obj);
		SetObjectCull(obj, 0);
		TextureObject(obj, UI3D_DOTMIDDLEOBJECTS);
		sObject* pDotObject = GetObjectData(obj);
		if (pDotObject)
		{
			WickedCall_SetObjectCastShadows(pDotObject, false);
			WickedCall_SetObjectLightToUnlit(pDotObject, (int)wiScene::MaterialComponent::SHADERTYPE_UNLIT);
		}
	}
}

void CreateDotObject(int obj)
{
	if (ObjectExist(obj) == 0)
	{
		//float fSphereSize = 15.0f;
		//MakeObjectSphere(obj, fSphereSize);
		if (ObjectExist(g.gameplayparentobjects + 0) == 0)
		{
			//LoadObject("editors\\uiv3\\dotobject.dbo", g.gameplayparentobjects + 0);
			//ScaleObject(g.gameplayparentobjects + 0, 50, 50, 50);
			MakeObjectSphere(g.gameplayparentobjects + 0, 5, 5, 5);
			HideObject(g.gameplayparentobjects + 0); //PE: Hide object its visible on maps.
		}
		CloneObject(obj, g.gameplayparentobjects + 0);
		//SetAlphaMappingOn(obj, 25);
		//DisableObjectZRead(obj);
		HideObject(obj);
		SetObjectMask(obj, 1);
		SetObjectEffect(obj, g.guishadereffectindex);
		SetObjectMask(obj, 1);
		
		//SetObjectTransparency(obj, 6);

		//TextureObject(obj, UI3D_DOTOBJECTS);
		//DisableObjectZWrite(obj);
		DisableObjectZDepth (obj);
		SetObjectCull(obj, 0);
		TextureObject(obj, UI3D_DOTOBJECTS);// UI3D_DOTMIDDLEOBJECTS);

		sObject* pDotObject = GetObjectData(obj);
		if (pDotObject)
		{
			WickedCall_SetObjectCastShadows(pDotObject, false);
			WickedCall_SetObjectLightToUnlit(pDotObject, (int)wiScene::MaterialComponent::SHADERTYPE::SHADERTYPE_UNLIT);
		}
	}
}

void CreateDotArcObject(int obj)
{
	if (ObjectExist(obj) == 0)
	{
		float fSphereSize = 15.0f;
		WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_CURSOROBJECT);
		//MakeObjectBox(obj, 2.5f, 2.5f, 7.0f);
		if (ObjectExist(g.gameplayparentobjects + 1) == 0)
		{		
			//LoadObject("editors\\uiv3\\dotpipe.dbo", g.gameplayparentobjects + 1);
			LoadObject("editors\\uiv3\\dotobject.dbo", g.gameplayparentobjects + 1);
			ScaleObject(g.gameplayparentobjects + 1, 25, 25, 25);
			//RotateObject(g.gameplayparentobjects + 1, 0, 90, 0);
			//FixObjectPivot(g.gameplayparentobjects + 1);
		}
		CloneObject(obj, g.gameplayparentobjects + 1);
		WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_NORMAL);
		//DisableObjectZRead(obj);
		DisableObjectZDepth (obj);
		HideObject(obj);
		SetObjectMask(obj, 1);
		SetObjectEffect(obj, g.guishadereffectindex);
		//SetObjectDiffuseEx(obj, Rgb(255, 255, 0), 0);
		TextureObject(obj, UI3D_DOTOBJECTS);
		SetObjectMask(obj, 1);
		sObject* pDotObject = GetObjectData(obj);
		if (pDotObject)
		{
			WickedCall_SetObjectCastShadows(pDotObject, false);
		}
	}
}

int iLastEmmisiveObject = 0;
bool bReadyToClickDot = false;

void MoveSelectedDotObject(void)
{
	//	extern uint64_t g_hovered_dot_entity;
	//	extern sObject* g_hovered_dot_pobject;

	bool bMiddleDotActive = false;
	if (!bDotObjectDragging && g_hovered_dot_pobject && g_hovered_dot_pobject->dwObjectNumber >= DOTMIDDLEOBJECTID)
	{
		bMiddleDotActive = true;
	}
	if(bDotMiddleWindow && !pref.iEnableRelationPopupWindow)
	{
		if (t.inputsys.mclick == 0)
			bReadyToClickDot = true;
		if (bReadyToClickDot && t.inputsys.mclick == 1)
			bDotMiddleWindow = false;
	}

	if (t.onedragmode == 1 && t.onedrag > 0)
		return;
	if (t.widget.pickedObject > 0)
		return;
	if (g.entityrubberbandlist.size() > 0)
		return;
	if (t.inputsys.rubberbandmode != 0)
		return;

	if (bMiddleDotActive) 
	{
		if (t.inputsys.mclick == 1 && !bDotMiddleWindow)
		{
			if (g_selected_middle_dot_pobject != g_hovered_dot_pobject)
			{
				ImVec2 wpos = ImGui::GetWindowPos();
				ImVec2 mpos = ImGui::GetMousePos();
				vDotMiddleWindowPos = mpos + ImVec2(10, 10);
			}
			g_selected_middle_dot_pobject = g_hovered_dot_pobject;
			int iId = (g_selected_middle_dot_pobject->dwObjectNumber - DOTMIDDLEOBJECTID);
			if (iId >= 0 && iId < MAXDOTMIDDLE)
			{
				bDotMiddleWindow = true;
				bReadyToClickDot = false;
				if (pref.iEnableRelationPopupWindow)
				{
					ImGui::OpenPopup("Relation##DotMiddleWindowRelation");
				}
			}
		}
	}
	if (pref.iEnableRelationPopupWindow)
	{
		if (bDotMiddleWindow)
		{
			if (g_selected_middle_dot_pobject)
			{
				int iSelectedDotObj = g_selected_middle_dot_pobject->dwObjectNumber;
				ImVec2 v2DPos = Convert3DTo2D(ObjectPositionX(iSelectedDotObj), ObjectPositionY(iSelectedDotObj), ObjectPositionZ(iSelectedDotObj));
				//PE: Window is relative to viewport position.
				v2DPos += ImGui::GetMainViewport()->Pos;
				ImGui::SetNextWindowPos(ImVec2(v2DPos.x, v2DPos.y));
			}
			else
			{
				ImGui::SetNextWindowPos(vDotMiddleWindowPos);
			}
			ImGui::SetNextWindowSize(ImVec2(ImGui::GetFontSize()*16.0, 0));
		}
		if (ImGui::BeginPopup("Relation##DotMiddleWindowRelation", ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings)) //ImGuiWindowFlags_AlwaysAutoResize
		{
			bDotMiddleWindow = true;
			int iDotMiddleIndex = g_selected_middle_dot_pobject->dwObjectNumber - DOTMIDDLEOBJECTID;
			if (iDotMiddleIndex >= 0 && iDotMiddleIndex < MAXDOTMIDDLE)
			{
				DisplayRelationshipMenu(iDotMiddleIndex, 1);
				bImGuiGotFocus = true;
				ImGui::EndPopup();
			}
		}
		else 
		{
			bDotMiddleWindow = false;
		}
	}

	if (!bMiddleDotActive && (g_hovered_dot_pobject || bDotObjectDragging))
	{
		if (t.inputsys.mclick == 1 && !bDotObjectDragging) 
		{
			g_source_dot_pobject = g_hovered_dot_pobject;
			ShowObject(DOTCURSOROBJECTID);
		}
		if (t.inputsys.mclick == 1) 
		{
			bDotObjectDragging = true;
			if (g_hovered_dot_pobject)
			{
				int dobj = g_hovered_dot_pobject->dwObjectNumber;
				int sobj = g_source_dot_pobject->dwObjectNumber;
				if (dobj > 70000)
				{
					if (iLastEmmisiveObject != dobj) 
					{
						if (iLastEmmisiveObject > 0) 
						{
							SetObjectEmissive(iLastEmmisiveObject, Rgb(0, 0, 0));
							//sObject* pLastObj = GetObjectData(iLastEmmisiveObject);
							//WickedCall_SetObjectHighlightBlue(pLastObj, false);
							if (sobj > 0)
							{
								SetObjectEmissive(sobj, Rgb(0, 0, 0));
								//sObject* pSrcObj = GetObjectData(sobj);
								//WickedCall_SetObjectHighlightBlue(pSrcObj, false);
							}
						}

						// Turn the dots green when hovered over each other (unless dragging the object that the dot is attached to).
						if (!bDraggingActive)
						{
							SetObjectEmissive(dobj, Rgb(56, 110, 146));// 255, 0));
							//sObject* pDestObj = GetObjectData(dobj);
							//WickedCall_SetObjectHighlightBlue(pDestObj, true);
							if (sobj > 0)
							{
								SetObjectEmissive(sobj, Rgb(56, 110, 146));//255, 0));
								//sObject* pSrcObj = GetObjectData(sobj);
								//WickedCall_SetObjectHighlightBlue(pSrcObj, true);
							}
						}
					}
					iLastEmmisiveObject = dobj;
				}
			}
			else
			{
				if (iLastEmmisiveObject > 0)
				{
					SetObjectEmissive(iLastEmmisiveObject, Rgb(0, 0, 0));
					iLastEmmisiveObject = 0;
				}
			}
		}
		else 
		{
			//PE: Release
			if (bDotObjectDragging && g_hovered_dot_pobject)
			{
				if (g_source_dot_pobject != g_hovered_dot_pobject)
				{
					//PE: Connect to this.
					g_destination_dot_pobject = g_hovered_dot_pobject;
					AddDotObjectRelation(g_source_dot_pobject->dwObjectNumber, g_destination_dot_pobject->dwObjectNumber);
				}
			}
			if (iLastEmmisiveObject > 0)
			{
				SetObjectEmissive(iLastEmmisiveObject, Rgb(0, 0, 0));
				//sObject* pLastObj = GetObjectData(iLastEmmisiveObject);
				//WickedCall_SetObjectHighlightBlue(pLastObj, false);
				int sobj = g_source_dot_pobject->dwObjectNumber;
				if (sobj > 0)
				{
					SetObjectEmissive(sobj, Rgb(0, 0, 0));
					//sObject* pSrcObj = GetObjectData(sobj);
					//WickedCall_SetObjectHighlightBlue(pSrcObj, false);
				}
			}
			iLastEmmisiveObject = 0;

			if (bDotObjectDragging)
				HideObject(DOTCURSOROBJECTID);
			bDotObjectDragging = false;

			//Make sure action did not select anything.
			t.widget.pickedObject = 0;
			t.tentitytoselect = 0;
			gridedit_clearentityrubberbandlist();
		}
		PositionObject(DOTCURSOROBJECTID, fLastHitPosition[0], fLastHitPosition[1], fLastHitPosition[2]);
		PointObject(DOTCURSOROBJECTID, CameraPositionX(), CameraPositionY(), CameraPositionZ());
	}
	else
	{
		if(bDotObjectDragging)
			HideObject(DOTCURSOROBJECTID);
		if (iLastEmmisiveObject > 0)
		{
			SetObjectEmissive(iLastEmmisiveObject, Rgb(0, 0, 0));
			//sObject* pLastObj = GetObjectData(iLastEmmisiveObject);
			//WickedCall_SetObjectHighlightBlue(pLastObj, false);
		}
		iLastEmmisiveObject = 0;
		g_destination_dot_pobject = NULL;
		bDotObjectDragging = false;
	}
}

void DisplayRelationshipMenu(int iDotMiddleIndex, int mode)
{
	//PE: We can use both source and dest entity to find type.
	//iObjectRelationshipsType
	//1 = Character + Character
	//2 = Character + Flag
	//3 = Character + Zone
	//4 = Character + Object
	//5 = Flag + Flag
	//6 = Flag + Zone
	//7 = Flag + Object
	//8 = Zone + Zone
	//9 = Zone + Object
	//10= Object + Object: Show When Object Activated dropdown: Activate other object, Destroy other object

	// Display a brain icon next to the dropdown.
	ImVec2 cursorPos = ImGui::GetCursorPos();
	float fFontSize = ImGui::GetFontSize();
	ImGui::SetCursorPos(cursorPos + ImVec2(-fFontSize + 10, fFontSize));
	ImGui::ImgBtn(BRAIN_ICON, ImVec2(fFontSize * 2, fFontSize * 2), ImVec4(255, 255, 255, 0), ImVec4(255,255,255,255), ImVec4(255,255,255,255), ImVec4(255,255,255,255));
	ImGui::SetCursorPos(cursorPos + ImVec2(fFontSize + 10, 0));

	int sobj = iDotMiddleInfoSource[iDotMiddleIndex] - DOTOBJECTIDADD;
	int dobj = iDotMiddleInfoDestination[iDotMiddleIndex] - DOTOBJECTIDADD;
	int iEntID = 0;
	int iRelationID = 0;
	int iNodeConnectionID = 0;
	GetMiddleEntityIdAndRelationshipId(sobj, dobj, iEntID, iRelationID, iNodeConnectionID);
	if (iEntID > 0)
	{
		int iRelationType = t.entityelement[iEntID].eleprof.iObjectRelationshipsType[iRelationID];
		ImGui::Indent(10);
		//ImGui::PushItemWidth(-10);
		ImGui::PushItemWidth(-1.25f * fFontSize);
		
		// character v character
		if (iRelationType == 1)
		{
			ImGui::TextCenter("Character and Character");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize *2 , 0));
			const char* items_combo[] = { "Alert other character", "Stand-down other character", "Toggle alert of other character" };
			if (ImGui::Combo("##iCharRelationshipsDataAllies", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				//Reverse data.
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "One character can activate activity in another character when alerted");
		}

		// character v flag
		if (iRelationType == 2)
		{
			ImGui::TextCenter("Character and Flag");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			const char* items_combo[] = { "Reverse at End", "Loop Around At End", "Follow One Way", "Choose Random Flag" };
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				//PE: Also change chars Patrol settings.
				t.entityelement[iEntID].eleprof.iCharPatrolMode = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
					t.entityelement[iEntDID].eleprof.iCharPatrolMode = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1 && t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID] != 3)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set the characters patrol style when connected to a flag element");
		}

		// character v zone
		if (iRelationType == 3)
		{
			ImGui::TextCenter("Character and Zone");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			//const char* items_combo[] = { "Alert character", "Stand-down character", "Toggle alert the character", "Activate zone", "Deactivate zone", "Toggle zone" };
			const char* items_combo[] = { "Alert character", "Stand-down character", "Toggle alert the character" };
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Can alert character when zone activated, and activate zone when character alerted");
		}

		// character v object
		if (iRelationType == 4)
		{
			ImGui::TextCenter("Character and Object");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			const char* items_combo[] = { "Alert character", "Stand-down character", "Toggle alert the character" };
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Can activate object when character alerted, and alert character when object activated");
		}

		// flag v flag
		if (iRelationType == 5)
		{
			ImGui::TextCenter("Flag and Flag");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			const char* items_combo[] = { "Do Nothing" };
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Can set a suggested movement style for between these flags");
		}

		// flag v zone
		if (iRelationType == 6 || iRelationType == 7)
		{
			ImGui::TextCenter("Flag and Zone");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			const char* items_combo[] = { "Do Nothing" };// Activate flag", "Deactivate flag", "Toggle flag" ;
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Can set zone to enable or disable any flag element");
		}

		// zone v zone
		if (iRelationType == 8)
		{
			ImGui::TextCenter("Zone and Zone");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			const char* items_combo[] = { "Do Nothing" }; // Activate other zone", "Deactivate other zone", "Toggle other zone" ;
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Can activate or deactivate a zone from another zone");
		}

		// zone v object
		if (iRelationType == 9)
		{
			ImGui::TextCenter("Zone and Object");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			const char* items_combo[] = { "Activate object", "Deactivate object", "Toggle object" }; // "Activate zone", "Deactivate zone", "Toggle zone", "Activate object", "Deactivate object", "Toggle object" ;
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Can activate object from zone, or activate zone from object activation");
		}

		// object v object
		if (iRelationType == 10)
		{
			ImGui::TextCenter("Object and Object");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			const char* items_combo[] = { "Activate other object", "Deactivate other object", "Toggle other object" };
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Can activate the other object when the first object is activated");
		}

		// delete relationship button
		float but_gadget_size = ImGui::GetFontSize()*12.0;
		float w = ImGui::GetWindowContentRegionWidth() - 10.0;
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
		if (ImGui::StyleButton("Delete Relationship", ImVec2(but_gadget_size, 0)))
		{
			t.entityelement[iEntID].eleprof.iObjectRelationships[iRelationID] = 0;
			t.entityelement[iEntID].eleprof.iObjectRelationshipsType[iRelationID] = 0;
			t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID] = 0;
			int iEntIDd = 0;
			int iRelationIDd = 0;
			int iNodeConnectionID = 0;
			int iNodeConnectionIndex = -1;
			GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntIDd, iRelationIDd, iNodeConnectionID, &iNodeConnectionIndex);
			if (iEntIDd > 0)
			{
				t.entityelement[iEntIDd].eleprof.iObjectRelationships[iRelationIDd] = 0;
				t.entityelement[iEntIDd].eleprof.iObjectRelationshipsType[iRelationIDd] = 0;
				t.entityelement[iEntIDd].eleprof.iObjectRelationshipsData[iRelationIDd] = 0;

				// Delete the node connection object and remove from storage.
				if (ObjectExist(iNodeConnectionID))
				{
					DeleteObject(iNodeConnectionID);
					iTotalRelationObjects--;
				}

				if (iNodeConnectionIndex > -1)
					nodeconnections.erase(nodeconnections.begin() + iNodeConnectionIndex);
			}

			if (mode == 1)
				ImGui::CloseCurrentPopup();
		}
		if (mode == 1)
		{
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
			if (ImGui::StyleButton("Close", ImVec2(but_gadget_size, 0)))
			{
				ImGui::CloseCurrentPopup();
			}
		}
		ImGui::PopItemWidth();
		ImGui::Indent(-10);
	}
}

void AddDotObjectRelation(int sobj,int dobj)
{
	sobj -= DOTOBJECTIDADD;
	dobj -= DOTOBJECTIDADD;
	if (sobj < 70000 || dobj < 70000 || sobj > 90000 || dobj > 90000)
		return;

	//PE: Find real entity.
	bool bSourceSet = false;
	bool bDestSet = false;
	int iEntityIDSource = 0;
	int iEntityIDDest = 0;
	int iTypeSource = 0;
	int iTypeDest = 0;
	int iEntTypeSource = 0;
	int iEntTypeDest = 0;
	int iRelationIndexSource = -1;
	int iRelationIndexDest = -1;
	int iRelationshipLinkIDSource = 0;
	int iRelationshipLinkIDDest = 0;

	for (int iEntityID = 1; iEntityID <= g.entityelementlist; iEntityID++)
	{
		int iBankIndex = t.entityelement[iEntityID].bankindex;
		int iMasterObject = g.entitybankoffset + t.entityelement[iEntityID].bankindex;
		int iEntityObject = t.entityelement[iEntityID].obj;

		//PE: We make 2 ways relations , so no need to scan everything to find a relation.
		//PE: source get destobject.

		int iEntType = -1;
		if (t.entityprofile[iBankIndex].ischaracter == 1)
		{
			iEntType = 1;
		}
		else if (t.entityprofile[iBankIndex].ismarker == 11) //Flags
		{
			iEntType = 2;
		}
		else if (t.entityprofile[iBankIndex].ismarker == 1 || t.entityprofile[iBankIndex].ismarker == 3 || t.entityprofile[iBankIndex].ismarker == 6) //Player start, checkpoint or Trigger zone
		{
			iEntType = 3;
		}
		else 
		{
			//PE: Everything else is a object type.
			//PE: Adding dots to these could be a problem , like stacked boxes ...
			iEntType = 4;
		}

		if (sobj == iEntityObject)
		{
			int iFirstFree = -1;
			bool bAlreadyThere = false;
			iEntityIDSource = iEntityID;
			iEntTypeSource = iEntType;
			int iRelationShipObject = 0, iRelationShipEntityID = 0;
			for (int i = 0; i < 10; i++)
			{
				if (iFirstFree < 0 && t.entityelement[iEntityID].eleprof.iObjectRelationships[i] == 0)
					iFirstFree = i;
				GetRelationshipObject(t.entityelement[iEntityID].eleprof.iObjectRelationships[i], &iRelationShipEntityID, &iRelationShipObject);
				if (iRelationShipObject == dobj)
				{
					iRelationIndexSource = i;
					iRelationshipLinkIDSource = t.entityelement[iEntityID].eleprof.iObjectLinkID;
					bAlreadyThere = true;
					break;
				}
			}
			if (!bAlreadyThere && iFirstFree >= 0)
			{
				iRelationIndexSource = iFirstFree;
			}
			bSourceSet = true;
		}

		if (dobj == iEntityObject)
		{
			int iFirstFree = -1;
			bool bAlreadyThere = false;
			iEntityIDDest = iEntityID;
			iEntTypeDest = iEntType;
			int iRelationShipObject = 0, iRelationShipEntityID = 0;
			for (int i = 0; i < 10; i++)
			{
				if (iFirstFree < 0 && t.entityelement[iEntityID].eleprof.iObjectRelationships[i] == 0)
					iFirstFree = i;
				GetRelationshipObject(t.entityelement[iEntityID].eleprof.iObjectRelationships[i], &iRelationShipEntityID, &iRelationShipObject);
				if (iRelationShipObject == sobj)
				{
					iRelationIndexDest = i;
					iRelationshipLinkIDDest = t.entityelement[iEntityID].eleprof.iObjectLinkID;
					bAlreadyThere = true;
					break;
				}
			}
			if (!bAlreadyThere && iFirstFree >= 0)
			{
				iRelationIndexDest = iFirstFree;
			}
			bDestSet = true;
		}
	}

	// create unique links (if needed), then connect them
	if (iRelationshipLinkIDSource == 0)
	{
		if (t.entityelement[iEntityIDSource].eleprof.iObjectLinkID == 0)
		{
			iRelationshipLinkIDSource = GenerateRelationshipUniqueLinkID();
			t.entityelement[iEntityIDSource].eleprof.iObjectLinkID = iRelationshipLinkIDSource;
		}
		else
			iRelationshipLinkIDSource = t.entityelement[iEntityIDSource].eleprof.iObjectLinkID;
	}
	if (iRelationshipLinkIDDest == 0)
	{
		if (t.entityelement[iEntityIDDest].eleprof.iObjectLinkID == 0)
		{
			iRelationshipLinkIDDest = GenerateRelationshipUniqueLinkID();
			t.entityelement[iEntityIDDest].eleprof.iObjectLinkID = iRelationshipLinkIDDest;
		}
		else
			iRelationshipLinkIDDest = t.entityelement[iEntityIDDest].eleprof.iObjectLinkID;
	}
	if (bDestSet && bSourceSet && iRelationIndexDest >= 0 && iRelationIndexSource >= 0)
	{
		t.entityelement[iEntityIDSource].eleprof.iObjectRelationships[iRelationIndexSource] = iRelationshipLinkIDDest;
		t.entityelement[iEntityIDDest].eleprof.iObjectRelationships[iRelationIndexDest] = iRelationshipLinkIDSource;
	}

	if (bDestSet && bSourceSet && iRelationIndexDest >= 0 && iRelationIndexSource >= 0)
	{
		//Type: 1=Char, 2=Flag, 3=Zone , 4=Object.
		if (iEntTypeSource == 1 && iEntTypeDest == 1) 
		{ //Char,Char
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 1;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 1;
		}
		else if ((iEntTypeSource == 1 && iEntTypeDest == 2) || (iEntTypeSource == 2 && iEntTypeDest == 1)) 
		{ //Char,Flag
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 2;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 2;
		}
		else if ((iEntTypeSource == 1 && iEntTypeDest == 3) || (iEntTypeSource == 3 && iEntTypeDest == 1)) 
		{ //Char,zone
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 3;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 3;
		}
		else if ((iEntTypeSource == 1 && iEntTypeDest == 4) || (iEntTypeSource == 4 && iEntTypeDest == 1))
		{ //Char,Object
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 4;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 4;
		}
		else if (iEntTypeSource == 2 && iEntTypeDest == 2) { //Flag,Flag
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 5;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 5;
		}
		else if ((iEntTypeSource == 2 && iEntTypeDest == 3) || (iEntTypeSource == 3 && iEntTypeDest == 2)) 
		{ //flag,zone
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 6;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 6;
		}
		else if ((iEntTypeSource == 2 && iEntTypeDest == 4) || (iEntTypeSource == 4 && iEntTypeDest == 2)) 
		{ //flag,object
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 7;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 7;
		}
		else if (iEntTypeSource == 3 && iEntTypeDest == 3) 
		{ //zone,zone
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 8;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 8;
		}
		else if ((iEntTypeSource == 3 && iEntTypeDest == 4) || (iEntTypeSource == 4 && iEntTypeDest == 3)) 
		{ //zone,object
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 9;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 9;
		}
		else if (iEntTypeSource == 4 && iEntTypeDest == 4) 
		{ 
			//object,object
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 10;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 10;

			// objects toggle by default
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsData[iRelationIndexSource] = 2;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsData[iRelationIndexDest] = 2;
		}
	}
}

void GetMiddleEntityIdAndRelationshipId(int sobj, int dobj, int &Entid, int &ReleationshipId, int& NodeConnectionId, int* NodeConnectionIndex)
{
	if (sobj < 70000 || sobj > 90000 || dobj < 70000 || dobj > 90000)
		return;

	Entid = 0;
	ReleationshipId = 0;
	NodeConnectionId = 0;

	for (int iEntityID = 1; iEntityID <= g.entityelementlist; iEntityID++)
	{
		int iBankIndex = t.entityelement[iEntityID].bankindex;
		int iMasterObject = g.entitybankoffset + t.entityelement[iEntityID].bankindex;
		int iEntityObject = t.entityelement[iEntityID].obj;

		//PE: We make 2 ways relations , so no need to scan everything to find a relation.
		//PE: source get destobject.
		if (sobj == iEntityObject)
		{
			for (int i = 0; i < 10; i++)
			{
				int iRelationShipObject = 0, iRelationShipEntityID = 0;
				GetRelationshipObject(t.entityelement[iEntityID].eleprof.iObjectRelationships[i], &iRelationShipEntityID, &iRelationShipObject);
				if (iRelationShipObject == dobj)
				{
					Entid = iEntityID;
					ReleationshipId = i;

					for (int j = 0; j < nodeconnections.size(); j++)
					{
						if ((nodeconnections[j].from == sobj && nodeconnections[j].to == dobj) || (nodeconnections[j].from == dobj && nodeconnections[j].to == sobj))
						{
							NodeConnectionId = nodeconnections[j].nodeconnectionid;
							if (NodeConnectionIndex)
								*NodeConnectionIndex = j;
							break;
						}
					}
					return;
				}
			}
		}
	}
}

void FindDotObjectRelation(int sobj, int dobj,int middle_index)
{
	sobj -= DOTOBJECTIDADD;
	dobj -= DOTOBJECTIDADD;

	if (sobj < 70000 || dobj < 70000 || sobj > 90000 || dobj > 90000)
		return;

	//PE: Find real entity.
	for (int iEntityID = 1; iEntityID <= g.entityelementlist; iEntityID++)
	{
		int iBankIndex = t.entityelement[iEntityID].bankindex;
		int iMasterObject = g.entitybankoffset + t.entityelement[iEntityID].bankindex;
		int iEntityObject = t.entityelement[iEntityID].obj;

		if (sobj == iEntityObject)
		{
			//iDotMiddleInfoSourceType[middle_index] = from;
		}

		if (dobj == iEntityObject)
		{
			//iDotMiddleInfoDestinationType[middle_index] = from;
		}
	}
}

void DrawDotArcsCircle(int from, int radius)
{
	if (radius < 1)
		return;

	float ffromx = ObjectPositionX(from);
	float ffromy = ObjectPositionY(from);
	float ffromz = ObjectPositionZ(from);
	int AddDots = radius / 4;//8 8.0;
	if (AddDots < 8)
		AddDots = 8;
	float fStep = (3.14159265*2.0) / ((float)AddDots);
	DWORD dwNewColor = Rgb(255, 128, 0);
	int iColor = 199;
	int iPointObject = iTotalArcs;
	float sincount = 0;
	for (int i = 0;i < AddDots;i++)
	{
		CreateDotArcObject(DOTARCSOBJECTID + iTotalArcs);
		ShowObject(DOTARCSOBJECTID + iTotalArcs);

		float fnfromx = ffromx + (sin(sincount)*(float)radius);
		float fnfromy = ffromy;
		float fnfromz = ffromz + (cos(sincount)*(float)radius);;
		PositionObject(DOTARCSOBJECTID + iTotalArcs, fnfromx, fnfromy, fnfromz);

		sincount += fStep;

		if (i > 0) 
		{
			int iOldObj = DOTARCSOBJECTID + (iTotalArcs - 1);
			PointObject(DOTARCSOBJECTID + iTotalArcs, ObjectPositionX(iOldObj), ObjectPositionY(iOldObj), ObjectPositionZ(iOldObj));
		}

		if (iDotArceColor[iTotalArcs] != iColor)
		{
			iDotArceColor[iTotalArcs] = iColor;
			SetObjectDiffuseEx(DOTARCSOBJECTID + iTotalArcs, dwNewColor, 0);
		}

		if (iTotalArcs < MAXDOTARCSOBJECTS)
		{
			iTotalArcs++;
			if (iTotalArcs > iLargestArcs)
				iLargestArcs = iTotalArcs;
		}
	}
	int iOldObj = DOTARCSOBJECTID + iPointObject;
	PointObject(iOldObj, ObjectPositionX(iOldObj + 1), ObjectPositionY(iOldObj + 1), ObjectPositionZ(iOldObj + 1));
}

void AddVertToObjectRelation(float x, float y, float z, float texU, float texV, int v, int memblock)
{
	//  Position of vertex in memblock
	int pos = 12 + (v * 32);

	//  Set vertex position
	WriteMemblockFloat(memblock, pos + 0, x);
	WriteMemblockFloat(memblock, pos + 4, y);
	WriteMemblockFloat(memblock, pos + 8, z);
	WriteMemblockFloat(memblock, pos + 12, 0);
	WriteMemblockFloat(memblock, pos + 16, 0);
	WriteMemblockFloat(memblock, pos + 20, 0);
	WriteMemblockFloat(memblock, pos + 24, texU);
	WriteMemblockFloat(memblock, pos + 28, texV);
}

void CreateObjectRelationMesh(float fromx, float fromy, float fromz, float tox, float toy, float toz, DWORD color)
{
	// this gets the diffuse into the emissive for a glowier line for logic lines!
	WickedCall_PresetObjectPutInEmissive(1);

	// Find a free memblock.
	int iFound = 0;
	for (int i = 1; i <= 257; i++)
	{
		if (MemblockExist(i) == 0)
		{
			iFound = i;
			break;
		}
	}
	if (iFound == 0) return;

	// Find a free object slot.
	int obj = t.activerelationobjectid;
	if (ObjectExist(obj) == 1)
		return;

	iTotalRelationObjects++;

	int vertsize = 32;
	int iSizeBytes = 0;
	int vertexCount = 36;
	iSizeBytes = vertsize * vertexCount;
	iSizeBytes += 12; // Add header bytes.
	MakeMemblock(iFound, iSizeBytes);

	// Write the memblock header.
	// FVF format.
	WriteMemblockDWord(iFound, 0, GGFVF_XYZ | GGFVF_NORMAL | GGFVF_TEX1);
	// Size of single vertex - 3 x float: position, 3 x float: normal, 2 x float: tex coords = 32 bytes.
	WriteMemblockDWord(iFound, 4, 32);
	// Number of vertices in the mesh.
	WriteMemblockDWord(iFound, 8, vertexCount);

	// Corners of the prism.
	float x0, x1, x2, x3, x4, x5;
	float y0, y1, y2, y3, y4, y5;
	float z0, z1, z2, z3, z4, z5;
	// Midpoints to split the prism in two.
	float mx03, mx14, mx25;
	float my03, my14, my25;
	float mz03, mz14, mz25;

	int v = 0;
	float p0[3];
	float p1[3];
	float points[18];
	
	p0[0] = fromx; p0[1] = fromy; p0[2] = fromz;
	p1[0] = tox; p1[1] = toy; p1[2] = toz;

	physics_debug_make_prism_between_points(p0, p1, points, 0.5f);// 3);

	// Corners of the prism.
	x0 = points[0]; y0 = points[1]; z0 = points[2];
	x1 = points[3]; y1 = points[4]; z1 = points[5];
	x2 = points[6]; y2 = points[7]; z2 = points[8];
	x3 = points[9]; y3 = points[10]; z3 = points[11];
	x4 = points[12]; y4 = points[13]; z4 = points[14];
	x5 = points[15]; y5 = points[16]; z5 = points[17];

	// Midpoints.
	mx03 = (x0 + x3) / 2.0f; my03 = (y0 + y3) / 2.0f; mz03 = (z0 + z3) / 2.0f;
	mx14 = (x1 + x4) / 2.0f; my14 = (y1 + y4) / 2.0f; mz14 = (z1 + z4) / 2.0f;
	mx25 = (x2 + x5) / 2.0f; my25 = (y2 + y5) / 2.0f; mz25 = (z2 + z5) / 2.0f;
	
	// Tex Coords.
	if (!bUVsAlreadySet)
	{
		fRelationUVs[0] = 0; fRelationUVs[1] = 0;
		fRelationUVs[2] = 0; fRelationUVs[3] = 1;
		fRelationUVs[4] = 1; fRelationUVs[5] = 0;
		fRelationUVs[6] = 1; fRelationUVs[7] = 0;
		fRelationUVs[8] = 0; fRelationUVs[9] = 1;
		fRelationUVs[10] = 1; fRelationUVs[11] = 1;
		const float off = 0.16666667f;
		fRelationUVs[12] = 0 + off; fRelationUVs[13] = 0 + off;
		fRelationUVs[14] = 0 + off; fRelationUVs[15] = 1 + off;
		fRelationUVs[16] = 1 + off; fRelationUVs[17] = 0 + off;
		fRelationUVs[18] = 1 + off; fRelationUVs[19] = 0 + off;
		fRelationUVs[20] = 0 + off; fRelationUVs[21] = 1 + off;
		fRelationUVs[22] = 1 + off; fRelationUVs[23] = 1 + off;

		for (int i = 0; i < 24; i++)
		{
			fRelationUVsStorage[i] = fRelationUVs[i];
		}

		bUVsAlreadySet = true;
	}
	
	// TODO: Just make one face and point at camera.

	// Bottom face.
	AddVertToObjectRelation(x0, y0, z0, fRelationUVs[0], fRelationUVs[1], v++, iFound);
	AddVertToObjectRelation(x2, y2, z2, fRelationUVs[2], fRelationUVs[3], v++, iFound);
	AddVertToObjectRelation(mx03, my03, mz03, fRelationUVs[4], fRelationUVs[5], v++, iFound);
	AddVertToObjectRelation(mx03, my03, mz03, fRelationUVs[6], fRelationUVs[7], v++, iFound);
	AddVertToObjectRelation(x2, y2, z2, fRelationUVs[8], fRelationUVs[9], v++, iFound);
	AddVertToObjectRelation(mx25, my25, mz25, fRelationUVs[10], fRelationUVs[11], v++, iFound);
	AddVertToObjectRelation(mx03, my03, mz03, fRelationUVs[0], fRelationUVs[1], v++, iFound);
	AddVertToObjectRelation(mx25, my25, mz25, fRelationUVs[2], fRelationUVs[3], v++, iFound);
	AddVertToObjectRelation(x3, y3, z3, fRelationUVs[4], fRelationUVs[5], v++, iFound);
	AddVertToObjectRelation(x3, y3, z3, fRelationUVs[6], fRelationUVs[7], v++, iFound);
	AddVertToObjectRelation(mx25, my25, mz25, fRelationUVs[8], fRelationUVs[9], v++, iFound);
	AddVertToObjectRelation(x5, y5, z5, fRelationUVs[10], fRelationUVs[11], v++, iFound);

	// Right face.
	AddVertToObjectRelation(x1, y1, z1, fRelationUVs[0], fRelationUVs[1], v++, iFound);
	AddVertToObjectRelation(x0, y0, z0, fRelationUVs[2], fRelationUVs[3], v++, iFound);
	AddVertToObjectRelation(mx14, my14, mz14, fRelationUVs[4], fRelationUVs[5], v++, iFound);
	AddVertToObjectRelation(mx14, my14, mz14, fRelationUVs[6], fRelationUVs[7], v++, iFound);
	AddVertToObjectRelation(x0, y0, z0, fRelationUVs[8], fRelationUVs[9], v++, iFound);
	AddVertToObjectRelation(mx03, my03, mz03, fRelationUVs[10], fRelationUVs[11], v++, iFound);
	AddVertToObjectRelation(mx14, my14, mz14, fRelationUVs[0], fRelationUVs[1], v++, iFound);
	AddVertToObjectRelation(mx03, my03, mz03, fRelationUVs[2], fRelationUVs[3], v++, iFound);
	AddVertToObjectRelation(x4, y4, z4, fRelationUVs[4], fRelationUVs[5], v++, iFound);
	AddVertToObjectRelation(x4, y4, z4, fRelationUVs[6], fRelationUVs[7], v++, iFound);
	AddVertToObjectRelation(mx03, my03, mz03, fRelationUVs[8], fRelationUVs[9], v++, iFound);
	AddVertToObjectRelation(x3, y3, z3, fRelationUVs[10], fRelationUVs[11], v++, iFound);

	// Left face.
	AddVertToObjectRelation(x2, y2, z2, fRelationUVs[0], fRelationUVs[1], v++, iFound);
	AddVertToObjectRelation(x1, y1, z1, fRelationUVs[2], fRelationUVs[3], v++, iFound);
	AddVertToObjectRelation(mx25, my25, mz25, fRelationUVs[4], fRelationUVs[5], v++, iFound);
	AddVertToObjectRelation(mx25, my25, mz25, fRelationUVs[6], fRelationUVs[7], v++, iFound);
	AddVertToObjectRelation(x1, y1, z1, fRelationUVs[8], fRelationUVs[9], v++, iFound);
	AddVertToObjectRelation(mx14, my14, mz14, fRelationUVs[10], fRelationUVs[11], v++, iFound);
	AddVertToObjectRelation(mx25, my25, mz25, fRelationUVs[0], fRelationUVs[1], v++, iFound);
	AddVertToObjectRelation(mx14, my14, mz14, fRelationUVs[2], fRelationUVs[3], v++, iFound);
	AddVertToObjectRelation(x5, y5, z5, fRelationUVs[4], fRelationUVs[5], v++, iFound);
	AddVertToObjectRelation(x5, y5, z5, fRelationUVs[6], fRelationUVs[7], v++, iFound);
	AddVertToObjectRelation(mx14, my14, mz14, fRelationUVs[8], fRelationUVs[9], v++, iFound);
	AddVertToObjectRelation(x4, y4, z4, fRelationUVs[10], fRelationUVs[11], v++, iFound);

	CreateMeshFromMemblock(obj, iFound);
	MakeObject(obj, obj, 0);

	sObject* pObject = GetObjectData(obj);

	WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_CURSOROBJECT);
	WickedCall_RemoveObject(pObject);
	WickedCall_AddObject(pObject);
	
	if (ImageExist(g.visuallogicimageoffset) == 0)
		LoadImage("editors\\uiv3\\nodeconnection.png", g.visuallogicimageoffset);
	image_setlegacyimageloading(false);

	TextureObject(obj, g.visuallogicimageoffset);
	//TextureObject(obj, ABOUT_LOGO);
	
	WickedCall_SetObjectCastShadows(pObject, false);
	WickedCall_SetObjectLightToUnlit(pObject, (int)wiScene::MaterialComponent::SHADERTYPE::SHADERTYPE_UNLIT);

	WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_NORMAL);

	//SetObjectDiffuse(obj, color);
	SetObjectCull(obj, 0);

	//DisableObjectZRead(obj);
	//DisableObjectZDepth(obj);

	// Set alpha and transparency of this object
	//SetObjectTransparency(obj, 1);
	//SetAlphaMappingOn(obj, 35);

	DeleteMemblock(iFound);
	ShowObject(obj);

	WickedCall_PresetObjectPutInEmissive(0);
}

// Update the vertex positions of half the node connection mesh, used for one way movement.
void UpdateObjectRelationMeshHalf(float fromx, float fromy, float fromz, float tox, float toy, float toz)
{
	float x0, x1, x2, x3, x4, x5;
	float y0, y1, y2, y3, y4, y5;
	float z0, z1, z2, z3, z4, z5;
	int v = 0;
	float p0[3];
	float p1[3];
	float points[18];
	int id = RELATIONOBJECTID;
	sObject* pObject = GetObjectData(id);
	if (!pObject)
	{
		return;
	}

	sMesh* pMesh = pObject->ppMeshList[0];
	if (!pMesh)
	{
		return;
	}

	LockVertexDataForLimbCore(id, 0, 1);
	
	// Every 6 elements of data contain two points on the physics object.
	p0[0] = fromx; p0[1] = fromy; p0[2] = fromz;
	p1[0] = tox; p1[1] = toy; p1[2] = toz;

	physics_debug_make_prism_between_points(p0, p1, points, 0.5f);// 3);

	// Corners of the prism.
	x0 = points[0]; y0 = points[1]; z0 = points[2];
	x1 = points[3]; y1 = points[4]; z1 = points[5];
	x2 = points[6]; y2 = points[7]; z2 = points[8];
	x3 = points[9]; y3 = points[10]; z3 = points[11];
	x4 = points[12]; y4 = points[13]; z4 = points[14];
	x5 = points[15]; y5 = points[16]; z5 = points[17];

	// Make each face of the prism (two triangles per face).
	SetVertexDataUV(v, fRelationUVs[12], fRelationUVs[13]);
	SetVertexDataPosition(v++, x0, y0, z0);
	SetVertexDataUV(v, fRelationUVs[14], fRelationUVs[15]);
	SetVertexDataPosition(v++, x2, y2, z2);
	SetVertexDataUV(v, fRelationUVs[16], fRelationUVs[17]);
	SetVertexDataPosition(v++, x3, y3, z3);
	SetVertexDataUV(v, fRelationUVs[18], fRelationUVs[19]);
	SetVertexDataPosition(v++, x3, y3, z3);
	SetVertexDataUV(v, fRelationUVs[20], fRelationUVs[21]);
	SetVertexDataPosition(v++, x2, y2, z2);
	SetVertexDataUV(v, fRelationUVs[22], fRelationUVs[23]);
	SetVertexDataPosition(v++, x5, y5, z5);

	SetVertexDataUV(v, fRelationUVs[12], fRelationUVs[13]);
	SetVertexDataPosition(v++, x1, y1, z1);
	SetVertexDataUV(v, fRelationUVs[14], fRelationUVs[15]);
	SetVertexDataPosition(v++, x0, y0, z0);
	SetVertexDataUV(v, fRelationUVs[16], fRelationUVs[17]);
	SetVertexDataPosition(v++, x4, y4, z4);
	SetVertexDataUV(v, fRelationUVs[18], fRelationUVs[19]);
	SetVertexDataPosition(v++, x4, y4, z4);
	SetVertexDataUV(v, fRelationUVs[20], fRelationUVs[21]);
	SetVertexDataPosition(v++, x0, y0, z0);
	SetVertexDataUV(v, fRelationUVs[22], fRelationUVs[23]);
	SetVertexDataPosition(v++, x3, y3, z3);

	SetVertexDataUV(v, fRelationUVs[12], fRelationUVs[13]);
	SetVertexDataPosition(v++, x2, y2, z2);
	SetVertexDataUV(v, fRelationUVs[14], fRelationUVs[15]);
	SetVertexDataPosition(v++, x1, y1, z1);
	SetVertexDataUV(v, fRelationUVs[16], fRelationUVs[17]);
	SetVertexDataPosition(v++, x5, y5, z5);
	SetVertexDataUV(v, fRelationUVs[18], fRelationUVs[19]);
	SetVertexDataPosition(v++, x5, y5, z5);
	SetVertexDataUV(v, fRelationUVs[20], fRelationUVs[21]);
	SetVertexDataPosition(v++, x1, y1, z1);
	SetVertexDataUV(v, fRelationUVs[22], fRelationUVs[23]);
	SetVertexDataPosition(v++, x4, y4, z4);

	for (int i = 0; i < 18; i++)
		SetVertexDataPosition(v++, 0, 0, 0);

	UnlockVertexData();

	WickedCall_UpdateMeshVertexData(pMesh);
}

// Used when the user drags an object with an active relation, so need to update the node connection mesh.
void UpdateObjectRelationMesh(float fromx, float fromy, float fromz, float tox, float toy, float toz)
{
	float x0, x1, x2, x3, x4, x5;
	float y0, y1, y2, y3, y4, y5;
	float z0, z1, z2, z3, z4, z5;
	// Midpoints to split the prism in two.
	float mx03, mx14, mx25;
	float my03, my14, my25;
	float mz03, mz14, mz25;

	int v = 0;
	float p0[3];
	float p1[3];
	float points[18];
	int id = t.activerelationobjectid;
	sObject* pObject = GetObjectData(id);
	if (!pObject)
	{
		return;
	}

	sMesh* pMesh = pObject->ppMeshList[0];
	if (!pMesh)
	{
		return;
	}

	LockVertexDataForLimbCore(id, 0, 1);

	// Every 6 elements of data contain two points on the physics object.
	p0[0] = fromx; p0[1] = fromy; p0[2] = fromz;
	p1[0] = tox; p1[1] = toy; p1[2] = toz;

	physics_debug_make_prism_between_points(p0, p1, points, 0.5f);// 3);

	// Corners of the prism.
	x0 = points[0]; y0 = points[1]; z0 = points[2];
	x1 = points[3]; y1 = points[4]; z1 = points[5];
	x2 = points[6]; y2 = points[7]; z2 = points[8];
	x3 = points[9]; y3 = points[10]; z3 = points[11];
	x4 = points[12]; y4 = points[13]; z4 = points[14];
	x5 = points[15]; y5 = points[16]; z5 = points[17];
	// Midpoints.
	mx03 = (x0 + x3) / 2.0f; my03 = (y0 + y3) / 2.0f; mz03 = (z0 + z3) / 2.0f;
	mx14 = (x1 + x4) / 2.0f; my14 = (y1 + y4) / 2.0f; mz14 = (z1 + z4) / 2.0f;
	mx25 = (x2 + x5) / 2.0f; my25 = (y2 + y5) / 2.0f; mz25 = (z2 + z5) / 2.0f;

	// Make each face of the prism (two triangles per face).
	SetVertexDataUV(v, fRelationUVs[0], fRelationUVs[1]);
	SetVertexDataPosition(v++, x0, y0, z0);
	SetVertexDataUV(v, fRelationUVs[2], fRelationUVs[3]);
	SetVertexDataPosition(v++, x2, y2, z2);
	SetVertexDataUV(v, fRelationUVs[4], fRelationUVs[5]);
	SetVertexDataPosition(v++, mx03, my03, mz03);
	SetVertexDataUV(v, fRelationUVs[6], fRelationUVs[7]);
	SetVertexDataPosition(v++, mx03, my03, mz03);
	SetVertexDataUV(v, fRelationUVs[8], fRelationUVs[9]);
	SetVertexDataPosition(v++, x2, y2, z2);
	SetVertexDataUV(v, fRelationUVs[10], fRelationUVs[11]);
	SetVertexDataPosition(v++, mx25, my25, mz25);
	SetVertexDataUV(v, fRelationUVs[12], fRelationUVs[13]);
	SetVertexDataPosition(v++, mx03, my03, mz03);
	SetVertexDataUV(v, fRelationUVs[14], fRelationUVs[15]);
	SetVertexDataPosition(v++, mx25, my25, mz25);
	SetVertexDataUV(v, fRelationUVs[16], fRelationUVs[17]);
	SetVertexDataPosition(v++, x3, y3, z3);
	SetVertexDataUV(v, fRelationUVs[18], fRelationUVs[19]);
	SetVertexDataPosition(v++, x3, y3, z3);
	SetVertexDataUV(v, fRelationUVs[20], fRelationUVs[21]);
	SetVertexDataPosition(v++, mx25, my25, mz25);
	SetVertexDataUV(v, fRelationUVs[22], fRelationUVs[23]);
	SetVertexDataPosition(v++, x5, y5, z5);

	SetVertexDataUV(v, fRelationUVs[0], fRelationUVs[1]);
	SetVertexDataPosition(v++, x1, y1, z1);
	SetVertexDataUV(v, fRelationUVs[2], fRelationUVs[3]);
	SetVertexDataPosition(v++, x0, y0, z0);
	SetVertexDataUV(v, fRelationUVs[4], fRelationUVs[5]);
	SetVertexDataPosition(v++, mx14, my14, mz14);
	SetVertexDataUV(v, fRelationUVs[6], fRelationUVs[7]);
	SetVertexDataPosition(v++, mx14, my14, mz14);
	SetVertexDataUV(v, fRelationUVs[8], fRelationUVs[9]);
	SetVertexDataPosition(v++,x0 ,y0 ,z0 );
	SetVertexDataUV(v, fRelationUVs[10], fRelationUVs[11]);
	SetVertexDataPosition(v++, mx03, my03, mz03);
	SetVertexDataUV(v, fRelationUVs[12], fRelationUVs[13]);
	SetVertexDataPosition(v++, mx14, my14, mz14);
	SetVertexDataUV(v, fRelationUVs[14], fRelationUVs[15]);
	SetVertexDataPosition(v++, mx03, my03, mz03);
	SetVertexDataUV(v, fRelationUVs[16], fRelationUVs[17]);
	SetVertexDataPosition(v++, x4, y4, z4);
	SetVertexDataUV(v, fRelationUVs[18], fRelationUVs[19]);
	SetVertexDataPosition(v++, x4, y4, z4);
	SetVertexDataUV(v, fRelationUVs[20], fRelationUVs[21]);
	SetVertexDataPosition(v++, mx03, my03, mz03);
	SetVertexDataUV(v, fRelationUVs[22], fRelationUVs[23]);
	SetVertexDataPosition(v++, x3, y3, z3);

	SetVertexDataUV(v, fRelationUVs[0], fRelationUVs[1]);
	SetVertexDataPosition(v++, x2, y2, z2);
	SetVertexDataUV(v, fRelationUVs[2], fRelationUVs[3]);
	SetVertexDataPosition(v++, x1, y1, z1);
	SetVertexDataUV(v, fRelationUVs[4], fRelationUVs[5]);
	SetVertexDataPosition(v++, mx25, my25, mz25);
	SetVertexDataUV(v, fRelationUVs[6], fRelationUVs[7]);
	SetVertexDataPosition(v++, mx25, my25, mz25);
	SetVertexDataUV(v, fRelationUVs[8], fRelationUVs[9]);
	SetVertexDataPosition(v++, x1, y1, z1);
	SetVertexDataUV(v, fRelationUVs[10], fRelationUVs[11]);
	SetVertexDataPosition(v++, mx14, my14, mz14);
	SetVertexDataUV(v, fRelationUVs[12], fRelationUVs[13]);
	SetVertexDataPosition(v++, mx25, my25, mz25);
	SetVertexDataUV(v, fRelationUVs[14], fRelationUVs[15]);
	SetVertexDataPosition(v++, mx14, my14, mz14);
	SetVertexDataUV(v, fRelationUVs[16], fRelationUVs[17]);
	SetVertexDataPosition(v++, x5, y5, z5);
	SetVertexDataUV(v, fRelationUVs[18], fRelationUVs[19]);
	SetVertexDataPosition(v++, x5, y5, z5);
	SetVertexDataUV(v, fRelationUVs[20], fRelationUVs[21]);
	SetVertexDataPosition(v++, mx14, my14, mz14);
	SetVertexDataUV(v, fRelationUVs[22], fRelationUVs[23]);
	SetVertexDataPosition(v++, x4, y4, z4);

	UnlockVertexData();

	WickedCall_UpdateMeshVertexData(pMesh);
}

void UpdateObjectRelationUVs(int id)
{
	sObject* pObject = GetObjectData(id);
	if (!pObject)
	{
		return;
	}

	sMesh* pMesh = pObject->ppMeshList[0];
	if (!pMesh)
	{
		return;
	}

	int v = 0;

	LockVertexDataForLimbCore(id, 0, 1);

	for (int i = 0; i < 3; i++)
		for (int j = 0; j < 24; j+=2)
			SetVertexDataUV(v++, fRelationUVs[j], fRelationUVs[j+1]);

	UnlockVertexData();

	WickedCall_UpdateMeshVertexData(pMesh);
}

void DrawObjectRelation(int from, int to, bool bDrawMiddleBut, int forceVertUpdate)
{
	//Find relation colors.
	bool bHighlight = false;
	int iColor = -1;
	int sobj = from - DOTOBJECTIDADD;
	int dobj = to - DOTOBJECTIDADD;
	int iEntID = 0;
	int iRelationID = 0;
	int iNodeConnectionID = 0;
	//DWORD dwNewColor = Rgb(255, 255, 0);
	DWORD dwNewColor = Rgb(225, 225, 225);

	if (bDotMiddleWindow && g_selected_middle_dot_pobject && g_selected_middle_dot_pobject->dwObjectNumber == DOTMIDDLEOBJECTID + iTotalMiddle)
	{
		bHighlight = true;
	}

	if (bHighlight)
	{
		//dwNewColor = Rgb(255, 255, 32);
		dwNewColor = Rgb(255, 255, 255);
	}

	int iNodeConnectionIndex = -1;
	GetMiddleEntityIdAndRelationshipId(sobj, dobj, iEntID, iRelationID, iNodeConnectionID, &iNodeConnectionIndex);
	if (iEntID > 0)
	{
		int iRelationType = t.entityelement[iEntID].eleprof.iObjectRelationshipsType[iRelationID];
		if (iRelationType == 1) //Char,Char
		{
			//"Standard Alliances behavior", "Assist other when attacked", "Run away from other when attacked","Stay away from other","Meet other when in visual range"
			if (t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID] == 0)
			{
				iColor = 1; //Green Standard Alliances behavior
			}
			else if (t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID] == 1)
			{
				iColor = 2; //Red Assist other when attacked
			}
			else if (t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID] == 2)
			{
				iColor = 3; //Blue Run away from other when attacked
			}
			else if (t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID] == 3)
			{
				iColor = 3; //Blue Stay away from other
			}
			else if (t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID] == 4)
			{
				iColor = 1; //Green Meet other when in visual range
			}
		}

		int iColorAdd = 0;
		if (bHighlight)
			iColorAdd = 45;

		//dwNewColor = Rgb(6 + iColorAdd, 65 + iColorAdd, 100 + iColorAdd);

		/* cleaner light blue for EA
		if (iColor == 1)
			dwNewColor = Rgb(0 + iColorAdd, 255, 0 + iColorAdd);
		else if (iColor == 2)
			dwNewColor = Rgb(255, 0 + iColorAdd, 0 + iColorAdd);
		else if (iColor == 3)
			dwNewColor = Rgb(20 + iColorAdd, 100 + iColorAdd, 255);
		*/
	}

	if (bHighlight)
	{
		iColor += 99;
	}

	// when established connection, use centers of object
	float ffromx = ObjectPositionX(sobj) + GetObjectCollisionCenterX(sobj);
	float ffromy = ObjectPositionY(sobj) + GetObjectCollisionCenterY(sobj);
	float ffromz = ObjectPositionZ(sobj) + GetObjectCollisionCenterZ(sobj);
	float ftox = ObjectPositionX(dobj) + GetObjectCollisionCenterX(dobj);
	float ftoy = ObjectPositionY(dobj) + GetObjectCollisionCenterY(dobj);
	float ftoz = ObjectPositionZ(dobj) + GetObjectCollisionCenterZ(dobj);

	// cursor connect at click drag release sites
	if (to == DOTCURSOROBJECTID)
	{
		ftox = ObjectPositionX(to);
		ftoy = ObjectPositionY(to);
		ftoz = ObjectPositionZ(to);
	}

	float fdx = ffromx - ftox;
	float fdy = ffromy - ftoy;
	float fdz = ffromz - ftoz;

	float fDistance = sqrt((fdx * fdx) + (fdy * fdy) + (fdz * fdz));

	if (to == DOTCURSOROBJECTID)
	{
		// Drawing a new relation.
		t.activerelationobjectid = RELATIONOBJECTID;
		if (!ObjectExist(RELATIONOBJECTID))
			CreateObjectRelationMesh(ffromx, ffromy, ffromz, ftox, ftoy, ftoz, dwNewColor);
		else
			UpdateObjectRelationMeshHalf(ffromx, ffromy, ffromz, ftox, ftoy, ftoz);

		ShowObject(RELATIONOBJECTID);
	}

	if (bDrawMiddleBut)
	{
		// Make the button go green when selected.
		if (bHighlight && iNodeConnectionIndex >= 0 && !bDraggingActive)
		{
			//SetObjectDiffuse(nodeconnections[iNodeConnectionIndex].middle, Rgb(40, 140, 65));
			//SetObjectEmissive(nodeconnections[iNodeConnectionIndex].middle, Rgb(0, 255, 0));
			//ScaleObject(nodeconnections[iNodeConnectionIndex].middle, 130, 130, 130);
			ScaleObject(nodeconnections[iNodeConnectionIndex].middle, 35, 35, 35);
		}
		else if (iNodeConnectionIndex >= 0)
		{
			//SetObjectDiffuse(nodeconnections[iNodeConnectionIndex].middle, Rgb(255, 255, 255));
			//SetObjectEmissive(nodeconnections[iNodeConnectionIndex].middle, Rgb(0, 0, 0));
			//ScaleObject(nodeconnections[iNodeConnectionIndex].middle, 100, 100, 100);
			ScaleObject(nodeconnections[iNodeConnectionIndex].middle, 25, 25, 25);
		}

		if (iTotalMiddle < MAXDOTMIDDLE)
		{
			//PE: Middle add a dropdown gadget.
			CreateDotMiddleObject(DOTMIDDLEOBJECTID + iTotalMiddle);

			// Create/Update the lines that travel between the objects.
			t.activerelationobjectid = RELATIONOBJECTID + iTotalMiddle + 1;
			if (ObjectExist(RELATIONOBJECTID + iTotalMiddle + 1) == 0)
			{
				CreateObjectRelationMesh(ffromx, ffromy, ffromz, ftox, ftoy, ftoz, dwNewColor);
				NodeConnection connection;
				connection.from = sobj; connection.to = dobj; connection.nodeconnectionid = RELATIONOBJECTID + iTotalMiddle + 1;
				connection.middle = DOTMIDDLEOBJECTID + iTotalMiddle;
				nodeconnections.push_back(connection);
			}
			else
			{
				SetObjectDiffuse(t.activerelationobjectid, dwNewColor);

				if (nodeconnections[iTotalMiddle].from == sobj && nodeconnections[iTotalMiddle].to == dobj && forceVertUpdate == 0)
				{
					// No vertex update necessary.
					UpdateObjectRelationUVs(t.activerelationobjectid);
				}
				else
				{
					// Update verts and UVs.
					nodeconnections[iTotalMiddle].from = sobj;
					nodeconnections[iTotalMiddle].to = dobj;
					UpdateObjectRelationMesh(ffromx, ffromy, ffromz, ftox, ftoy, ftoz);
				}
				ShowObject(RELATIONOBJECTID + iTotalMiddle + 1);
			}
			//CreateDotMiddleObject(iTotalMiddle);
			ShowObject(DOTMIDDLEOBJECTID + iTotalMiddle);
			PositionObject(DOTMIDDLEOBJECTID + iTotalMiddle, ffromx, ffromy, ffromz);
			PointObject(DOTMIDDLEOBJECTID + iTotalMiddle, ftox, ftoy, ftoz);
			MoveObject(DOTMIDDLEOBJECTID + iTotalMiddle, fDistance*0.5);

			if (bDotMiddleWindow == false)
			{
				/* do not show labels
				// show label of relationship connection
				int thisobj = DOTMIDDLEOBJECTID + iTotalMiddle;
				LPSTR pRelationshipActivity = "";
				int iRelationType = t.entityelement[iEntID].eleprof.iObjectRelationshipsType[iRelationID];
				int iRelationshipsData = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				const char* items_combo1[] = { "Alert other character", "Stand-down other character", "Toggle alert of other character" };
				const char* items_combo2[] = { "Reverse at End", "Loop Around At End", "Follow One Way", "Choose Random Flag" };
				const char* items_combo3[] = { "Alert character", "Stand-down character", "Toggle alert the character" };
				const char* items_combo4[] = { "Alert character", "Stand-down character", "Toggle alert the character" };
				const char* items_combo9[] = { "Activate object", "Deactivate object", "Toggle object" }; // "Activate zone", "Deactivate zone", "Toggle zone", "Activate object", "Deactivate object", "Toggle object" ;
				const char* items_combo10[] = { "Activate other object", "Deactivate other object", "Toggle other object" };
				if (iRelationType == 1)	pRelationshipActivity = (LPSTR)items_combo1[iRelationshipsData];
				if (iRelationType == 2)	pRelationshipActivity = (LPSTR)items_combo2[iRelationshipsData];
				if (iRelationType == 3)	pRelationshipActivity = (LPSTR)items_combo3[iRelationshipsData];
				if (iRelationType == 4)	pRelationshipActivity = (LPSTR)items_combo4[iRelationshipsData];
				if (iRelationType == 9)	pRelationshipActivity = (LPSTR)items_combo9[iRelationshipsData];
				if (iRelationType == 10) pRelationshipActivity = (LPSTR)items_combo10[iRelationshipsData];
				if (GetInScreen(thisobj) == 1 && iRelationType !=5 && iRelationType != 6 && iRelationType != 7 && iRelationType != 8)
				{
					pastebitmapfontcenter(pRelationshipActivity, GetScreenX(thisobj), GetScreenY(thisobj), 1, 192);
				}
				*/
			}

			iDotMiddleInfoSource[iTotalMiddle] = from;
			iDotMiddleInfoDestination[iTotalMiddle] = to;
	
			iTotalMiddle++;
			if (iTotalMiddle > iLargestMiddle)
				iLargestMiddle = iTotalMiddle;
		}
	}
}

void deleterelationobjects()
{
	for (int i = RELATIONOBJECTID; i < RELATIONOBJECTID + RELATIONOBJECTMAX; i++)
	{
		if (ObjectExist(i))
			DeleteObject(i);
	}
}
#endif

///

float ImGuiGetMouseX( void )
{
#ifdef WICKEDENGINE
	RECT rect = { NULL };
	GetWindowRect(g_pGlob->hWnd, &rect);
	return(t.inputsys.xmouse - rect.left);
#else
	return(t.inputsys.xmouse);
#endif
}

float ImGuiGetMouseY(void)
{
#ifdef WICKEDENGINE
	RECT rect = { NULL };
	GetWindowRect(g_pGlob->hWnd, &rect);
	return(t.inputsys.ymouse - rect.top);
#else
	return(t.inputsys.ymouse);
#endif
}

#ifdef WICKEDENGINE

//PE:Turning 180 make artifacts in colors, and are hard to control. it get reflections/light from env.
//#define TURNBACKDROP180
//#define MOVEPROBETO_BLACK //Move probe to black area, for better control of colors. This make titanium objects black, without ambient control this will not work.

bool bBackdropSettingsSet = false;
bool old_g_bNoSwapchainPresent = false;
float composx;
float composy;
float composz;
float comangx;
float comangy;
float comangz;
int iFogChangedFramesBeforeRestore = 0;

void CreateBackdropObject(bool bForceRecreate,cstr newImageFile,cstr fpefile)
{
	if(cUseBackbufferCubemap.Len() > 0)
		RevertBackbufferCubemap();
	cUseBackbufferCubemap = "";
	
	if (newImageFile.Len() > 0)
	{
		if (cCurrentBackDropImageFile != newImageFile)
		{
			// this is the new current backdrop
			cCurrentBackDropImageFile = newImageFile;

			// delete if old one exists
			image_setlegacyimageloading(true);
			if (ImageExist(BACKDROPMAGE))
				DeleteImage(BACKDROPMAGE);
			image_setlegacyimageloading(false);

			// LB: Prefer DDS if available
			LPSTR pLoadThisBackdrop = cCurrentBackDropImageFile.Get();
			char pDDSVariantOfBackdropFile[MAX_PATH];
			strcpy ( pDDSVariantOfBackdropFile, cCurrentBackDropImageFile.Get());
			pDDSVariantOfBackdropFile[strlen(pDDSVariantOfBackdropFile) - 4] = 0;
			strcat (pDDSVariantOfBackdropFile, ".dds");
			if (FileExist(pDDSVariantOfBackdropFile) == 1)
				pLoadThisBackdrop = pDDSVariantOfBackdropFile;

			// load for IMGUI to display
			image_setlegacyimageloading(true);
			LoadImage(pLoadThisBackdrop, BACKDROPMAGE);
			image_setlegacyimageloading(false);
			bForceRecreate = true;
		}
	}

	//Simple Sky.
	if((!ImageExist(BACKDROPMAGE) || newImageFile == "None") && fpefile.Len() > 0)
	{
		if (pestrcasestr(fpefile.Get(), ".fpe"))
		{
			std::string sString = fpefile.Get();
			replaceAll(sString, ".fpe", "_fpe_cube.dds");
			cUseBackbufferCubemap = cstr("entitybank\\") + cstr( (char *) sString.c_str());
			// showcase\titanium_fpe_cube.dds
			if (FileExist(cUseBackbufferCubemap.Get()))
			{
				wiScene::WeatherComponent* weather = wiScene::GetScene().weathers.GetComponent(g_weatherEntityID);
				if (weather->skyMap != nullptr && weather->skyMapName.length() > 0)
				{
					//PE: Make sure to free any old resources.
					WickedCall_DeleteImage(weather->skyMapName);
				}
				weather->skyMapName = cUseBackbufferCubemap.Get();
				weather->skyMap = WickedCall_LoadImage(weather->skyMapName);
				weather->cloudiness = 0.0f;
				weather->cloudSpeed = 0.0f;

				// update cubes
				WickedCall_DisplayCubes(false);

				if (ObjectExist(t.terrain.terrainobjectindex) == 1)
				{
					HideObject(t.terrain.terrainobjectindex);
				}
				t.hardwareinfoglobals.noterrain = 1;

				float centerx = -1000, centery = 39000, centerz = -1000;
				WickedCall_MoveReflectionProbe(centerx, centery, centerz, "editorProbe", 500);
				WickedCall_UpdateProbes();
				bBackbufferCubemapActive = true;
			}
			else
			{
				cUseBackbufferCubemap = "";
			}
		}
	}

	int backdropobj = BACKDROPMAGE;
	if (bForceRecreate || (bUseBackDropImage && !ObjectExist(backdropobj)))
	{
		if (ObjectExist(backdropobj))
			DeleteObject(backdropobj);
		//float fDist = 6.5f;
		float fDist = 13.0f;
		MakeObjectPlane(backdropobj, 1920 * fDist, 1080 * fDist);
		//PE: No light.
		LockVertexDataForLimbCore(backdropobj, 0, 1);
		SetVertexDataNormals(0, 0, 1, 0);
		SetVertexDataNormals(1, 0, 1, 0);
		SetVertexDataNormals(2, 0, 1, 0);
		SetVertexDataNormals(3, 0, 1, 0);
		SetVertexDataNormals(4, 0, 1, 0);
		SetVertexDataNormals(5, 0, 1, 0);
		UnlockVertexData();
		#ifndef TURNBACKDROP180
		//Flip image.
		float U_f = 1.0f , V_f = 0.0f, D_f = -1.0f;
		LockVertexDataForLimb(backdropobj, 0);
		SetVertexDataUV(0, U_f, V_f);
		SetVertexDataUV(1, U_f + D_f, V_f);
		SetVertexDataUV(2, U_f + D_f, V_f + 1.0f);
		SetVertexDataUV(3, U_f + D_f, V_f + 1.0f);
		SetVertexDataUV(4, U_f, V_f + 1.0f);
		SetVertexDataUV(5, U_f, V_f);
		UnlockVertexData();
		#endif
		//SetObjectUVManually(backdropobj, 0, 1, 1);

		FixObjectPivot(backdropobj);
		SetObjectTransparency(backdropobj, 1);
		SetObjectCollisionOff(backdropobj);
		SetObjectTextureMode(backdropobj, 0, 0);
		SetObjectLight(backdropobj, 0);
		SetObjectMask(backdropobj, 1);
		if(cCurrentBackDropImageFile.Len() > 0 && ImageExist(BACKDROPMAGE))
			TextureObject(backdropobj, BACKDROPMAGE);
		SetObjectCull(backdropobj, 0);
		//DisableObjectZDepth(backdropobj);
		//DisableObjectZRead(backdropobj);
		sObject* pBackObject = GetObjectData(backdropobj);
		if (pBackObject)
		{
			//Make sure we flip UV , image is inverted in the x dir.
			if (pBackObject->ppMeshList)
			{
				sMesh* pMesh = pBackObject->ppMeshList[0];
				if (pMesh) WickedCall_UpdateMeshVertexData(pMesh);
			}

			WickedCall_SetObjectCastShadows(pBackObject, false);

			float fColorR,fColorG,fColorB;
			if (cCurrentBackDropImageFile.Len() > 0 && ImageExist(BACKDROPMAGE))
			{
				fColorR = 1.0f;
				fColorG = 1.0f;
				fColorB = 1.0f;
			}
			else
			{
				//Default thumb color , changed for unlit shader.
				fColorR = 0.32f;
				fColorG = 0.32f;
				fColorB = 0.32f;

			}

			for (int iMesh = 0; iMesh < pBackObject->iMeshCount; iMesh++)
			{
				sMesh* pMesh = pBackObject->ppMeshList[iMesh];
				if (pMesh)
				{
					//Boost colors. we are way out there in 3D space.
					#ifdef TURNBACKDROP180
					pMesh->mMaterial.Diffuse.r = fColorR * 2.0f;
					pMesh->mMaterial.Diffuse.g = fColorG * 2.0f;
					pMesh->mMaterial.Diffuse.b = fColorB * 2.0f;
					#else

					if (cCurrentBackDropImageFile.Len() > 0 && ImageExist(BACKDROPMAGE))
					{
						//Place above water level.
						pMesh->mMaterial.Diffuse.r = fColorR; // *1.0f;
						pMesh->mMaterial.Diffuse.g = fColorG; // *1.0f;
						pMesh->mMaterial.Diffuse.b = fColorB; // *1.0f;
					}
					else
					{
						//ENV-Probe placed at play area.
						pMesh->mMaterial.Diffuse.r = fColorR * 2.5f;
						pMesh->mMaterial.Diffuse.g = fColorG * 2.5f;
						pMesh->mMaterial.Diffuse.b = fColorB * 2.5f;
					}

					#endif
					pMesh->mMaterial.Diffuse.a = 1.0f;
					wiScene::MeshComponent* mesh = wiScene::GetScene().meshes.GetComponent(pMesh->wickedmeshindex);
					if (mesh)
					{
						uint64_t materialEntity = mesh->subsets[0].materialID;
						wiScene::MaterialComponent* pObjectMaterial = wiScene::GetScene().materials.GetComponent(materialEntity);
						if (pObjectMaterial)
						{
							pObjectMaterial->SetReflectance(0.0f);
							pObjectMaterial->shaderType = wiScene::MaterialComponent::SHADERTYPE_UNLIT; //PE: Yes 1:1 mapping and no light,env... :)
							//PE: Also ignoes all other material settings , so its perfect.
							pObjectMaterial->SetDirty(true);
						}
					}
					WickedCall_SetMeshMaterial(pMesh);
				}
			}
			WickedCall_SetObjectMetalness(pBackObject, 0.0f);
			WickedCall_SetObjectRoughness(pBackObject, 0.0f);
		}
	}
	if (ObjectExist(backdropobj))
		HideObject(backdropobj);
	WickedCall_DisplayCubes(false);

	if (!bRotateBackBuffer) {
		//Dont disable bloom when hover over , so the scene behind dont flash with bloom on / off.
		//WickedCall_SetSunDirection(45.0f, 270.0f, 0.0f);
		master_renderer->setBloomEnabled(false);
	}
	//PE: Always move probe, as terrain is now not grass.
	float centerx = -1000, centery = 190000000, centerz = -1000;
	//PE: This pos is black.
	#ifdef MOVEPROBETO_BLACK
	WickedCall_MoveReflectionProbe(centerx, centery, centerz, "editorProbe", 500);
	#endif

	//PE: Disable fog.
	float oldFogNear = t.visuals.FogNearest_f;
	float oldFogFar = t.visuals.FogDistance_f;
	//PE: Fog is now removed in wicked repo.
//	if (t.visuals.FogDistance_f < 30000.0f)
//	{
//		t.visuals.FogDistance_f = 1000000.0f; //Disable fog.
//		t.visuals.FogNearest_f = 960400;// 1000000.0f;
//		Wicked_Update_Visuals((void *)&t.visuals);
//		iFogChangedFramesBeforeRestore = 5;
//		t.visuals.FogDistance_f = oldFogFar;
//		t.visuals.FogNearest_f = oldFogNear;
//	}
	//Now always use thumb light.
	WickedCall_EnableThumbLight(true);

	extern bool g_bNoSwapchainPresent;
	old_g_bNoSwapchainPresent = g_bNoSwapchainPresent;

	composx = CameraPositionX(0);
	composy = CameraPositionY(0);
	composz = CameraPositionZ(0);
	comangx = CameraAngleX(0);
	comangy = CameraAngleY(0);
	comangz = CameraAngleZ(0);

	bBackdropSettingsSet = true;
}

extern Master master;

void StartForceRender(void)
{
	extern bool g_bNoGGUntilGameGuruMainCalled;
	//PE: Cant use forcerender until init is done.
	if (!g_bNoGGUntilGameGuruMainCalled) return;
	//bool renderstate = master.ForceRender(0);
	extern bool bSkipAllGameLogic;
	bSkipAllGameLogic = true;
	//PE: Empty messages , so windows dont think we are dead. ( perhaps remember QUIT ? )
	MSG msg = { 0 };
	while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	master.RunCustom();
	//Give some time for wicked to finish its jobs.
	Sleep(1);
	bSkipAllGameLogic = false;
	return;
}
int current_backbuffer_width = 0;
int current_backbuffer_height = 0;

void GrabBackBufferCopy(void)
{
	if (iFogChangedFramesBeforeRestore > 0)
	{
		if(iFogChangedFramesBeforeRestore == 1) Wicked_Update_Visuals((void *)&t.visuals);
		iFogChangedFramesBeforeRestore--;
	}
	if (!bImGuiInitDone)
		return;

	if ((BackBufferObjectID <= 0 && !BackBufferSnapShotMode && !BackBufferParticlesMode) || BackBufferImageID <= 0)
	{
		return;
	}
	if (BackBufferParticlesMode && iBackBufferParticlesTrigger > 0)
	{
		//Wait some frames before capture.
		iBackBufferParticlesTrigger--;
		return;
	}

	//PE: Restore 10 frames after last call.
	if (iFogChangedFramesBeforeRestore > 0)
		iFogChangedFramesBeforeRestore = 5;

	if (!BackBufferParticlesMode && BackBufferParticleEmitter != -1)
	{
		gpup_deleteEffect(BackBufferParticleEmitter);
		BackBufferParticleEmitter = -1;
	}

	extern int iLastResolutionWidth;
	extern int iLastResolutionHeight;

	if (!BitmapExist(99) || (iLastResolutionWidth != current_backbuffer_width || iLastResolutionHeight != current_backbuffer_height))
	{
		//PE: Make sure new rendertarget is the same as the backbuffer size.
		current_backbuffer_height = iLastResolutionHeight;
		current_backbuffer_width = iLastResolutionWidth;
		if (wiRenderer::GetDevice())
		{
			assert( 0 && "DX11 not in use" );
			/*
			void* pBackBuffer = wiRenderer::GetDevice()->GetBackBufferForGG( &master.swapChain );
			if (pBackBuffer)
			{
				GGSURFACE_DESC ddsd;
				pBackBuffer->GetDesc(&ddsd);
				//PE: Try fixed size.
				#ifdef USEFIXEDBACKBUFFERSIZE
				//PE: This is the resolution all current thumbs has used.
				if (bProceduralLevel || bFullScreenBackbuffer)
				{
					//Use current backbuffer size on this.
					MakeBitmap(99, ddsd.Width, ddsd.Height);
				}
				else
				{
					MakeBitmap(99, 1920, 1017);
				}
				#else
				MakeBitmap(99, ddsd.Width, ddsd.Height);
				#endif
			}
			*/
		}
	}

	//PE: Using a render target in g_DefaultGGFORMAT is way faster.
	LPGGRENDERTARGETVIEW rendertarget;
	rendertarget = (LPGGRENDERTARGETVIEW)GetBitmapRenderTarget(99);

	//wiRenderer::GetDevice()->WaitForGPU();

	if (!bBackdropSettingsSet || bSnapShotModeUseCamera || BackBufferParticlesMode)
	{
		composx = CameraPositionX(0);
		composy = CameraPositionY(0);
		composz = CameraPositionZ(0);
		comangx = CameraAngleX(0);
		comangy = CameraAngleY(0);
		comangz = CameraAngleZ(0);
	}

	bool bOldWater = t.visuals.bWaterEnable;
	//wiScene::WeatherComponent* weather = wiScene::GetScene().weathers.GetComponent(g_weatherEntityID);
	//weather->SetOceanEnabled(false); //PE: Ocean gets regenerated later so we cant just disable it like this.
	//t.visuals.bWaterEnable = false;
	//Wicked_Update_Visuals((void *)&t.visuals);

	float grabx = BackBufferSizeX;
	float graby = BackBufferSizeY;
	if (grabx <= 0 || graby <= 0)
	{
		grabx = 512;
		graby = 288;
	}

	int displayobj, entid;
	float fOldObjPosX, fOldObjAngX, fOldObjPosY, fOldObjAngY, fOldObjPosZ, fOldObjAngZ;
	bool bDisplayObjVisible = false;
	bool bWaterVisible = false;

	//PE: If we move the camera to far we get "black" flicking dots , so wicked got a bug somewhere (need double ?).
//	float centerx = -256000, centery = -256000, centerz = -256000;
	float centerx = -1000, centery = 39000, centerz = -1000;

	int backdropobj = BACKDROPMAGE;
	if (!BackBufferSnapShotMode && !BackBufferParticlesMode)
	{
		if (bUseBackDropImage && !ObjectExist(backdropobj))
		{
			CreateBackdropObject(false,"","");
		}
		if (bUseBackDropImage && ObjectExist(backdropobj))
		{
			if (BackBufferSizeX >= 1024)
				ScaleObject(backdropobj, 100, 100, 100);
			else if (BackBufferSizeX <= 512)
				ScaleObject(backdropobj, 50, 50, 50);
			ShowObject(backdropobj);
			if (cUseBackbufferCubemap.Len() > 0)
			{
				HideObject(backdropobj);
			}
		}

		//Place Object.
		displayobj = BackBufferObjectID; //g.entitybankoffset + BackBufferObjectID;
		entid = displayobj - g.entitybankoffset;
		fOldObjPosX = ObjectPositionX(displayobj); fOldObjPosY = ObjectPositionY(displayobj); fOldObjPosZ = ObjectPositionZ(displayobj);
		fOldObjAngX = ObjectAngleX(displayobj); fOldObjAngY = ObjectAngleY(displayobj); fOldObjAngZ = ObjectAngleZ(displayobj);

		if (g_ObjectList[displayobj] && g_ObjectList[displayobj]->bVisible)
			bDisplayObjVisible = true;

		float fOffsetX = 0.0f, fOffsetY = 0.0f, fOffsetZ = 0.0f;
		sObject* pObject = g_ObjectList[displayobj];
		if (pObject) { //&& t.entityprofile[entid].ischaracter != 1
			float fAdjustScaleX = 1.0, fAdjustScaleY = 1.0, fAdjustScaleZ = 1.0;
			if (pObject->pInstanceOfObject)
			{
				fAdjustScaleX = pObject->position.vecScale[0];
				fAdjustScaleY = pObject->position.vecScale[1];
				fAdjustScaleZ = pObject->position.vecScale[2];
				pObject = pObject->pInstanceOfObject;
			}
			float fValue;
			if (t.entityprofile[entid].ischaracter != 1)
			{
				fValue = (pObject->collision.vecMax[0] + pObject->collision.vecMin[0]);
				fValue = ApplyPivot(pObject, 0, GGVECTOR3(pObject->collision.vecMax - pObject->collision.vecMin), fValue);
				fValue = fValue * pObject->position.vecScale[0] * fAdjustScaleX;
				fOffsetX = fValue * 0.5f;

				fValue = (pObject->collision.vecMax[2] + pObject->collision.vecMin[2]);
				fValue = ApplyPivot(pObject, 2, GGVECTOR3(pObject->collision.vecMax - pObject->collision.vecMin), fValue);
				fValue = fValue * pObject->position.vecScale[2] * fAdjustScaleZ;
				fOffsetZ = fValue * 0.5f;
			}

			fValue = (pObject->collision.vecMax[1] + pObject->collision.vecMin[1]);
			fValue = ApplyPivot(pObject, 1, GGVECTOR3(pObject->collision.vecMax - pObject->collision.vecMin), fValue);
			fValue = fValue * pObject->position.vecScale[1] * fAdjustScaleY;
			fOffsetY = fValue * 0.5f;

			if (pObject->pFrame)
			{
				fOffsetX += -(pObject->pFrame->vecOffset.x * fAdjustScaleX);
				fOffsetY += -(pObject->pFrame->vecOffset.y * fAdjustScaleY);
				fOffsetZ += -(pObject->pFrame->vecOffset.z * fAdjustScaleZ);
			}

		}

		float fLargestY = ObjectSizeY(displayobj, 1);
		float fLargestX = ObjectSizeX(displayobj, 1);
		float fLargestZ = ObjectSizeZ(displayobj, 1);
		float fLargest = fLargestX;
		if (fLargestZ > fLargest)
			fLargest = fLargestZ;
		if (fLargestY > fLargest)
			fLargest = fLargestY;

		if (fLargest < 15.0) fLargest = 15.0; //Handle small objects.
		if (fLargest >= 2500.0) fLargest = 2500.0;

		PositionObject(displayobj, centerx, centery, centerz);

		if (t.entityprofile[entid].bIsDecal)
		{
			PositionObject(displayobj, centerx + (fLargestX*0.5), centery + (fLargestY*0.5), centerz);
		}

		if (t.entityprofile[entid].ismarker != 0 || t.entityprofile[entid].zdepth == 0)
		{
			SetObjectMask(displayobj, 1);
		}
		else
		{
			SetObjectMask(displayobj, 1 + (1 << 31));
		}

		ShowObject(displayobj);

		RotateObject(displayobj, fOldObjAngX, fOldObjAngY + 15, fOldObjAngZ);

		RotateCamera(0, 0, 0);
		PositionCamera(centerx, centery, centerz);
		PointCamera(centerx, centery, centerz);


		float fAdjustRange = 5.0;
		fAdjustRange -= (grabx + graby) / 512.0;
		if (fAdjustRange < 0.5)
			fAdjustRange = 0.5;
		if ((grabx + graby) <= 256)
			fAdjustRange += 2.0;
		if ((grabx + graby) >= 2048)
			fAdjustRange += 0.5;

		float fCamMove = fLargest * (fAdjustRange + 0.1); // PE: 512x288=3.5 - This really depend on the image size we capture to.
		MoveCamera(-(fCamMove));
		BackBufferCamMove = fCamMove * 2.0;

		//magnum: fCamMove=30.5 , fLargestY = 2.078 , fAdjustRange = 1.875 , fLargest = 15.43
		//fLargest != 15.0 , we need object to be bigger to increase hight.


		if (fLargest != 15.0 && fLargestY < 4.0) fLargestY += 200.0;
		if (fLargest != 15.0 &&fLargestY < 7.0) fLargestY += 100.0;
		if (fLargest != 15.0 && fLargestY < 40.0) fLargestY = 40.0;
		if (fLargestY < 10.0) fLargestY = 10.0;

		float fAdjustY = fAdjustRange * 0.5;

		if (fLargestY >= 2500.0) fLargestY = 2500.0;
		if (t.entityprofile[entid].isebe == 1)
		{
			fLargestY += 140.0;
		}
		PositionCamera(CameraPositionX(0), CameraPositionY(0) + (fLargestY*fAdjustY), CameraPositionZ(0));
		PointCamera(centerx + fOffsetX, centery + fOffsetY, centerz + fOffsetZ);

		bool bNeedZRotation = false;

		if (1)
		{
			float cangx = CameraAngleX();
			float cangy = CameraAngleY();
			float cangz = CameraAngleZ();
			if (cangx > 39 && cangx < 300 )
			{
				bNeedZRotation = true;
			}
		}


		if (bBackBufferRestoreCamera)
		{
			//Restore camera settings from FPE. Only trigger this one time.
			BackBufferRotateY = RestoreBackBufferRotateY;
			if (t.entityprofile[entid].ischaracter == 0) {
				BackBufferRotateX = RestoreBackBufferRotateX;
			}
			else
			{
				BackBufferRotateX = 0.0;
			}
			BackBufferCamUp = RestoreBackBufferCamUp;
			BackBufferCamLeft = RestoreBackBufferCamLeft;
			BackBufferZoom = RestoreBackBufferZoom;
			if (BackBufferSizeX < 1024)
			{
				//Adjust to new resolution.
				//BackBufferZoom *= 1.85f;
				//BackBufferCamUp *= 0.75f;
				//BackBufferCamLeft *= 0.85f;
				BackBufferZoom *= 1.7f;
				BackBufferCamUp *= 0.95f;
			}

		}

		MoveCamera(BackBufferZoom);

		MoveCameraLeft(0, BackBufferCamLeft);
		MoveCameraUp(0, BackBufferCamUp);

		if (bLoopBackBuffer || bBackBufferRestoreCamera)
		{
			if (0) // bRotateBackBuffer)
			{
				//@Lee Rotate on world y axis. is this correct ?
				float fMoveAngY = 3.0*g.timeelapsed_f;;
				float fMoveAngX = 0.0;
				float fOldZ = BackBufferRotateZ;
				GGQUATERNION quatRotationEvent = { 0,0,0,0 };
				GGQUATERNION QuatAroundX, QuatAroundY, QuatAroundZ;
				GGQuaternionRotationAxis(&QuatAroundX, &GGVECTOR3(1, 0, 0), GGToRadian(0));
				GGQuaternionRotationAxis(&QuatAroundY, &GGVECTOR3(0, 1, 0), GGToRadian(fMoveAngY));
				GGQuaternionRotationAxis(&QuatAroundZ, &GGVECTOR3(0, 0, 1), GGToRadian(0));
				quatRotationEvent = QuatAroundX * QuatAroundY * QuatAroundZ;
				GGQuaternionRotationAxis(&QuatAroundX, &GGVECTOR3(1, 0, 0), GGToRadian(BackBufferRotateX));
				GGQuaternionRotationAxis(&QuatAroundY, &GGVECTOR3(0, 1, 0), GGToRadian(BackBufferRotateY));
				GGQuaternionRotationAxis(&QuatAroundZ, &GGVECTOR3(0, 0, 1), GGToRadian(BackBufferRotateZ));
				GGQUATERNION quatCurrentOrientation = QuatAroundX * QuatAroundY * QuatAroundZ;
				GGQUATERNION quatNewOrientation;
				GGQuaternionMultiply(&quatNewOrientation, &quatCurrentOrientation, &quatRotationEvent);
				RotateObjectQuat(displayobj, quatNewOrientation.x, quatNewOrientation.y, quatNewOrientation.z, quatNewOrientation.w);

				//PE: Matrix to eular conversion is not really good. as it can get a gimbal lock and flip z 0=180, this can give strange eular values when doing this.
				BackBufferRotateX = ObjectAngleX(displayobj);
				BackBufferRotateY = ObjectAngleY(displayobj);
				BackBufferRotateZ = ObjectAngleZ(displayobj);
			}
			else
			{
				if (bBackBufferAnimated)
				{
					t.tanimspeed_f = t.entityprofile[BackBufferEntityID].animspeed;
					if (ObjectExist(BackBufferObjectID) == 1)
					{
						#ifdef WICKEDENGINE
						SetObjectSpeed(BackBufferObjectID, t.tanimspeed_f);
						#else
						SetObjectSpeed(BackBufferObjectID, g.timeelapsed_f*t.tanimspeed_f);
						#endif
					}
				}
				if (bRotateBackBuffer && !bBackBufferAnimated )
				{
					if (bNeedZRotation)
					{
						BackBufferRotateZ += 3.0*g.timeelapsed_f;
						if (BackBufferRotateZ > 360.0)
							BackBufferRotateZ -= 360.0;
					}
					else
					{
						BackBufferRotateY += 3.0*g.timeelapsed_f;
						if (BackBufferRotateY > 360.0)
							BackBufferRotateY -= 360.0;
					}
				}


				float ox = ObjectPositionX(displayobj);
				float oy = ObjectPositionY(displayobj);
				float oz = ObjectPositionZ(displayobj);
				float cx = CameraPositionX();
				float cy = CameraPositionY();
				float cz = CameraPositionZ();
				float dist = GetDistance(cx, cy, cz, ox, oy, oz);

				//WIP: Test Orbit around object.
				/*
				#define TESTORBIT
				int orbitobj = DOTARCSOBJECTID + 1234;
				CreateDotArcObject(orbitobj); //Test
				PositionObject(orbitobj, cx, cy, cz);
				PointObject(orbitobj, centerx + fOffsetX, centery + fOffsetY, centerz + fOffsetZ);
				MoveObject(orbitobj, dist*0.75);
				ShowObject(orbitobj);
				ox = centerx + fOffsetX;
				oy = centery + fOffsetY;
				oz = centerz + fOffsetZ;
				float movey = (BackBufferRotateY / 360.0) * PI*2.0;
				static float angletest = 50.0f;
				float ax, ay, az;
				GetAngleFromPoint(cx, cy, cz, ox, oy, oz, &ax, &ay, &az);
				float diffy = fabs(cy - oy);
				if (movey > PI*2.0) movey -= PI*2.0;
				ox = ox + (sin(movey) * dist*0.35);
				//WIP: Need y to match angle from camera ax.
				oy = oy + ( (sin((movey-ax)*PI/180.0f) ) * diffy);
				oz = oz + (cos(movey) * dist*0.35);
				PositionObject(orbitobj,ox,oy,oz);
				PointObject(displayobj, ox, oy, oz);
				*/

				#ifndef TESTORBIT
				RotateObject(displayobj, 0, 0, 0);
				if (pObject && pObject->position.bApplyPivot)
				{
					PitchObjectUpWorld(displayobj, BackBufferRotateX);
					TurnObjectRightWorld(displayobj, BackBufferRotateY);
					if(bNeedZRotation)
						RollObjectLeftWorld(displayobj, BackBufferRotateZ);
					//PitchObjectUp(displayobj, BackBufferRotateX);
					//TurnObjectRight(displayobj, BackBufferRotateY);
				}
				else
				{
					PitchObjectDownWorld(displayobj, BackBufferRotateX);
					TurnObjectRightWorld(displayobj, BackBufferRotateY);
					if (bNeedZRotation)
						RollObjectLeftWorld(displayobj, BackBufferRotateZ);
					//PitchObjectDown(displayobj, BackBufferRotateX);
					//TurnObjectRight(displayobj, BackBufferRotateY);
				}
				#endif
			}
			bBackBufferRestoreCamera = false;
		}

		if (bUseBackDropImage && ObjectExist(backdropobj))
		{
//			PositionObject(backdropobj, centerx, centery, centerz);
			MoveCamera(2.0f);
			PositionObject(backdropobj, CameraPositionX(), CameraPositionY(), CameraPositionZ());
			MoveCamera(-2.0f);
			PointObject(backdropobj, CameraPositionX(), CameraPositionY(), CameraPositionZ());
//			MoveObject(backdropobj, -10600.0f);
			//PE: We cant move it to far away, as backdrop pixel quality get lower the further it is away from the camera.
			MoveObject(backdropobj, -21200.0f); //Large objects get clipped, move further away.
			PointObject(backdropobj, CameraPositionX(), CameraPositionY(), CameraPositionZ());
			#ifdef TURNBACKDROP180
			TurnObjectLeft(backdropobj, 180);
			#endif
		}
		//PE: Switch away from editor light , so we dont interfere with the current light on the scene.
		extern wiECS::Entity g_entityThumbLight, g_entityThumbLight2;
		if (g_entityThumbLight)
		{
			wiScene::TransformComponent* transformLightCamera = wiScene::GetScene().transforms.GetComponent(g_entityThumbLight);
			transformLightCamera->ClearTransform();
			float fCamX = CameraPositionX(0);
			float fCamY = CameraPositionY(0);
			float fCamZ = CameraPositionZ(0);
			transformLightCamera->Translate(XMFLOAT3(fCamX, fCamY + 20.0f, fCamZ));
			transformLightCamera->SetDirty();
		}
		if (g_entityThumbLight2)
		{
			wiScene::TransformComponent* transformLightCamera = wiScene::GetScene().transforms.GetComponent(g_entityThumbLight2);
			transformLightCamera->ClearTransform();
			float fCamX = ObjectPositionX(displayobj) - (fLargestX*2.0);
			float fCamY = ObjectPositionY(displayobj);
			float fCamZ = ObjectPositionZ(displayobj) + (fLargestZ*2.0); // move behind object
			transformLightCamera->Translate(XMFLOAT3(fCamX, fCamY + 20.0f, fCamZ));
			transformLightCamera->SetDirty();
		}

	}
	else
	{
		//Snap shop mode.
		if (BackBufferParticlesMode)
		{
			RotateCamera(0, 0, 0);
			PositionCamera(centerx, centery, centerz);
			PointCamera(centerx, centery, centerz);
			MoveCamera(-BackBufferZoom);
			MoveCameraUp(0, BackBufferCamUp);
			PointCamera(centerx, centery, centerz);

			if (bUseBackDropImage && ObjectExist(backdropobj))
			{
				if (BackBufferSizeX >= 1024)
					ScaleObject(backdropobj, 100, 100, 100);
				else if (BackBufferSizeX <= 512)
					ScaleObject(backdropobj, 50, 50, 50);
				ShowObject(backdropobj);

				MoveCamera(2.0f);
				PositionObject(backdropobj, CameraPositionX(), CameraPositionY(), CameraPositionZ());
				MoveCamera(-2.0f);
				PointObject(backdropobj, CameraPositionX(), CameraPositionY(), CameraPositionZ());
				MoveObject(backdropobj, -21200.0f); //Large objects get clipped, move further away.
				PointObject(backdropobj, CameraPositionX(), CameraPositionY(), CameraPositionZ());
			}

		}
		if (bSnapShotModeUseCamera )
		{
			//Place camera.
			PositionCamera(fSnapShotModeCameraX, fSnapShotModeCameraY, fSnapShotModeCameraZ);
			RotateCamera(fSnapShotModeCameraAngX, fSnapShotModeCameraAngY, fSnapShotModeCameraAngZ);
		}
	}


	//Render.
	extern bool g_bNoSwapchainPresent;
	bool ioldstate = g_bNoSwapchainPresent;
	g_bNoSwapchainPresent = true;

	extern bool g_bNo2DRender;
	g_bNo2DRender = true;
	if(bSnapShotModeUse2D)
		g_bNo2DRender = false;

	extern bool g_bNoTerrainRender;
	bool bOldg_bNoTerrainRender = g_bNoTerrainRender;
	if (bProceduralLevel)
	{
		g_bNoTerrainRender = false;
	}
	else
	{
		g_bNoTerrainRender = true;
	}


	bool bIsWideScreen = false;
	float gpw = master.masterrenderer.GetWidth3D();
	float gph = master.masterrenderer.GetHeight3D();
	if (( (float)gpw / (float) gph) > 2.1 && gpw > 1920)
	{
		//PE: Use fov to adjust camera. so it fit fixed backbuffer.
		bIsWideScreen = true;
	}

	if (bIsWideScreen && !bFullScreenBackbuffer)
	{
		float fCameraFov = XM_PI / ((45.0) / 15.0f); //Fit fixed backbuffer and thumb resolution.
		wiScene::GetCamera().CreatePerspective( 1920.0f, 1017.0f, t.visuals.CameraNEAR_f, t.visuals.CameraFAR_f, fCameraFov);
		wiScene::GetCamera().SetDirty(true);
	}


	bool renderstate = master.ForceRender(rendertarget);

	if (bIsWideScreen && !bFullScreenBackbuffer)
	{
		float fCameraFov = XM_PI / ((t.visuals.CameraFOV_f) / 15.0f); //Fit GG settings.
		wiScene::GetCamera().CreatePerspective((float)master.masterrenderer.GetLogicalWidth(), (float)master.masterrenderer.GetLogicalHeight(), t.visuals.CameraNEAR_f, t.visuals.CameraFAR_f, fCameraFov);
		wiScene::GetCamera().SetDirty(true);
	}

	if (bProceduralLevel)
	{
		extern bool g_bNoTerrainRender;
		g_bNoTerrainRender = true;
	}
	else
	{
		g_bNoTerrainRender = bOldg_bNoTerrainRender;
	}
	g_bNo2DRender = false;

	//if (!bBackdropSettingsSet)
	//	g_bNoSwapchainPresent = ioldstate;
	//else
	//	g_bNoSwapchainPresent = old_g_bNoSwapchainPresent;

	//g_bNoSwapchainPresent = false;
	g_bNoSwapchainPresent = ioldstate;


	bBackdropSettingsSet = false;

	//weather->SetOceanEnabled(bOldWater);
	//t.visuals.bWaterEnable = bOldWater;
	//Wicked_Update_Visuals((void *)&t.visuals);

	//TEST END
	//wiJobSystem::context ctx;
	//wiJobSystem::Wait(ctx);

	if (!BackBufferSnapShotMode && !BackBufferParticlesMode)
	{
		if (bUseBackDropImage && ObjectExist(backdropobj))
		{
			HideObject(backdropobj);
			if (!bLoopBackBuffer)
			{
				RevertBackbufferCubemap();
				WickedCall_UpdateProbes();
			}
		}

		if (!bLoopBackBuffer)
		{
			WickedCall_SetSunDirection(t.visuals.SunAngleX, t.visuals.SunAngleY, t.visuals.SunAngleZ);
			master_renderer->setBloomEnabled(t.visuals.bBloomEnabled);
			WickedCall_MoveReflectionProbe(GGORIGIN_X, GGORIGIN_Y + 5000, GGORIGIN_Z, "editorProbe", 500);
			WickedCall_EnableThumbLight(false);
		}


		PositionCamera(composx, composy, composz);
		RotateCamera(comangx, comangy, comangz);

		PositionObject(displayobj, fOldObjPosX, fOldObjPosY, fOldObjPosZ);
		RotateObject(displayobj, fOldObjAngX, fOldObjAngY, fOldObjAngZ);
		if (bDisplayObjVisible)
			ShowObject(displayobj);
		else
			HideObject(displayobj);
	}
	else
	{

		if (bUseBackDropImage && ObjectExist(backdropobj))
		{
			HideObject(backdropobj);
		}

		if (bSnapShotModeUseCamera || BackBufferParticlesMode)
		{
			//Restore camera.
			PositionCamera(composx, composy, composz);
			RotateCamera(comangx, comangy, comangz);
		}

		//if BackBufferSnapShotMode
		if (t.widget.pickedEntityIndex > 0 && t.widget.activeObject > 0)
		{
			widget_show_widget();
		}
	}

	if (!renderstate)
	{
//		if(BackBufferSnapShotMode)
//			g.entityrubberbandlist.clear();
		BackBufferSnapShotMode = false;
		BackBufferParticlesMode = false;
		return;
	}

	static int loop = 0;

	if(loop++ % 2 == 0 || !bLoopBackBuffer || bLoopFullFPS || BackBufferSnapShotMode || BackBufferParticlesMode)
	{
		//int iPerEntityImageID = BACKBUFFERIMAGE;
		int iPerEntityImageID = BackBufferImageID;

		extern GlobStruct* g_pGlob;
		LPGGSURFACE	pTmpSurface = g_pGlob->pCurrentBitmapSurface;
		void *pBackBuffer = NULL;
		if (rendertarget)
		{
			pBackBuffer = GetBitmapTexture2D(99);
			if (!pBackBuffer)
			{
				assert( 0 && "Can't get backbuffer" );
				pBackBuffer = 0;//wiRenderer::GetDevice()->GetBackBufferForGG( &master.swapChain );
				return;
			}
		}
		else
		{
			assert( 0 && "Can't get backbuffer" );
			pBackBuffer = 0;//wiRenderer::GetDevice()->GetBackBufferForGG( &master.swapChain );
			return;
		}

		g_pGlob->pCurrentBitmapSurface = pBackBuffer;

		assert( 0 && "DX11 not in use" );
		/*
		GGSURFACE_DESC ddsd;
		pBackBuffer->GetDesc(&ddsd);

		SetGrabImageMode(1);
		if (graby > ddsd.Height)
			graby = ddsd.Height;
		if (grabx > ddsd.Width)
			grabx = ddsd.Width;

		float imgcx = (ddsd.Width*0.5) - (grabx*0.5);
		float imgcy = (ddsd.Height*0.5) - (graby*0.5);

		if (imgcy < 0) imgcy = 0;
		if (imgcx < 0) imgcx = 0;

		if (BackBufferSnapShotMode)
		{
			if (fLastRubberBandX2 > fLastRubberBandX1 && fLastRubberBandY2 > fLastRubberBandY1)
			{
				imgcx = fLastRubberBandX1;
				imgcy = fLastRubberBandY1;
				imgcy -= 10.0f; //Seams y is not precise.
				if (imgcx < 1.0f) imgcx = 1.0f;
				if (imgcy < 1.0f) imgcy = 1.0f;
				float fRatio = graby / grabx;
				if ((fLastRubberBandX2 - fLastRubberBandX1) > ((fLastRubberBandY2 - fLastRubberBandY1)*1.3)) //Y count more.
				{
					grabx = fLastRubberBandX2 - fLastRubberBandX1;
					graby = grabx * fRatio;
					float fObjectsHeight = fLastRubberBandY2 - fLastRubberBandY1;
					if (graby > fObjectsHeight)
						imgcy -= ((graby - fObjectsHeight)*0.5); //Center Y in image.
					if (imgcy < 0) imgcy = 0;
				}
				else
				{
					fRatio = grabx / graby;
					graby = fLastRubberBandY2 - fLastRubberBandY1;
					float fObjectsWidth = fLastRubberBandX2 - fLastRubberBandX1;
					grabx = graby * fRatio;
					if(grabx > fObjectsWidth)
						imgcx -= ((grabx-fObjectsWidth)*0.5); //Center X in image.
					if (imgcx < 0) imgcx = 0;
				}
			}
		}
		//Make sure we are not going outside image.
		if (imgcy + graby > ddsd.Height)
			graby = (ddsd.Height - imgcy) - 1.0f;
		if (imgcx + grabx > ddsd.Width)
			grabx = (ddsd.Width - imgcx) - 1.0f;

		if(graby > 0 && grabx > 0)
			GrabImage(iPerEntityImageID, imgcx, imgcy, imgcx+ grabx, imgcy+ graby, 3);
		SetGrabImageMode(0);

		g_pGlob->pCurrentBitmapSurface = pTmpSurface;
		*/

		//WickedCall_PresetObjectTextureFromImagePtr(false, 0);
	}

	if (!BackBufferSnapShotMode)
	{
		if (BackBufferSaveCacheName != "")
		{
			//PE: Save out to the cache.
			if (ImageExist(BackBufferImageID))
			{
				SaveImage(BackBufferSaveCacheName.Get(), BackBufferImageID);
			}
			BackBufferSaveCacheName = "";
		}
	}
	if (!bLoopBackBuffer)
	{
		BackBufferImageID = 0;
		if (BackBufferParticlesMode && BackBufferParticleEmitter != -1)
		{
			gpup_deleteEffect(BackBufferParticleEmitter);
			BackBufferParticleEmitter = -1;
		}
		if (BackBufferParticlesMode)
		{
			BackBufferZoom = 0.0f;
			BackBufferCamUp = 0.0f;
		}

	}
//	if (BackBufferSnapShotMode)
//		g.entityrubberbandlist.clear();

	BackBufferSnapShotMode = false;
	BackBufferParticlesMode = false;

}

void RevertBackbufferCubemap(void)
{
	if (bBackbufferCubemapActive && cUseBackbufferCubemap.Len() > 0)
	{
		sky_skyspec_init();
		WickedCall_DeleteImage(cUseBackbufferCubemap.Get());
		if (t.grideditselect == 0)
		{
			WickedCall_DisplayCubes(true);
		}
		if (ObjectExist(t.terrain.terrainobjectindex) == 1)
		{
			ShowObject(t.terrain.terrainobjectindex);
		}
		t.hardwareinfoglobals.noterrain = 0;
		WickedCall_SetSunDirection(t.visuals.SunAngleX, t.visuals.SunAngleY, t.visuals.SunAngleZ);
		master_renderer->setBloomEnabled(t.visuals.bBloomEnabled);
		WickedCall_MoveReflectionProbe(GGORIGIN_X, GGORIGIN_Y+5000, GGORIGIN_Z, "editorProbe", 500);
		WickedCall_EnableThumbLight(false);
		WickedCall_UpdateProbes();
		bBackbufferCubemapActive = false;
	}
}

bool CreateProjectCacheName(char *project_name,char *file)
{
	if (!project_name || !file) return false;
	if (strlen(project_name) <= 0) return false;

	char tmp[MAX_PATH];
	char project[MAX_PATH];
	strcpy(tmp, file);
	char *find = (char *)pestrcasestr(tmp, "thumbbank\\");
	if (find) find += 10;
	else find = &tmp[0];
	strcpy(project, "projectbank\\");
	strcat(project, project_name);
	strcat(project, "\\");
	strcat(project, find);
	ProjectCacheName = project; //PE: Should be relative.
	return(true);
}
bool CopyToProjectFolder(char *file)
{
	if (strlen(Storyboard.gamename) <= 0) return false;
	// D:\MAX-DocWrite\Files\thumbbank\mapbank_cool level 1 - copy.fpm512x288.jpg
	char tmp[MAX_PATH];
	char project[MAX_PATH];

	strcpy(tmp, file);
	char *find = (char *) pestrcasestr(tmp, "thumbbank\\");
	if (find) find += 10;
	else find = &tmp[0];

	strcpy(project, "projectbank\\");
	strcat(project, Storyboard.gamename);
	strcat(project, "\\");
	strcat(project, find);
	strcpy(tmp, project);
	GG_GetRealPath(project, 1); //Resolve name. need full path.
	bool bRet = CopyFileA( (LPSTR) file, project, FALSE);
	ProjectCacheName = tmp; //PE: Should be relative.
	return bRet;
}
bool CreateBackBufferCacheName(char *file,int width,int height)
{
	// returns true if have own thumb or a group that does not generate one
	bool bHasOwnLocalThumb = false;

	std::string cache_name = file;
	replaceAll(cache_name, ".fpe", "");
	replaceAll(cache_name, "entitybank\\", "");
	replaceAll(cache_name, "\\", "_");
	replaceAll(cache_name, "/", "_");
	replaceAll(cache_name, "\"", ""); //Got this when deleting a file in user, if fpe not found and already in list.
	std::string cache_final_name = cache_name;
	cache_final_name = g.mysystem.thumbbank_s.Get() + cache_final_name + std::to_string(width) + "x" + std::to_string(height) + ".jpg";
	BackBufferCacheName = cache_final_name.c_str();

	// LB: We have pre-generated all stock assets thumbs, so copy over if we have them to save time
	if (g_bThumbBankCopyMode == true)
	{
		if (FileExist(BackBufferCacheName.Get()) == 0)
		{
			// source from thumbnank in parent files
			std::string src_file = g.fpscrootdir_s.Get();
			src_file = src_file + "\\Files\\thumbbank\\";
			src_file = src_file + cache_name;
			src_file = src_file + std::to_string(width) + "x" + std::to_string(height) + ".jpg";
			LPSTR pSrcFile = (LPSTR)src_file.c_str();
			char pAssociatedThumb[MAX_PATH];
			if (FileExist(pSrcFile) == 0)
			{
				// any object that has a JPG of the same FPE name can force a custom thumb
				char pRelativePath[MAX_PATH];
				strcpy(pAssociatedThumb, file);
				strcpy(pRelativePath, pAssociatedThumb);
				GG_GetRealPath(pAssociatedThumb, 0);
				if (FileExist(pAssociatedThumb) == 0)
				{
					// sometimes the file path is passed in without the entitybank
					strcpy(pAssociatedThumb, "entitybank\\");
					strcat(pAssociatedThumb, file);
					strcpy(pRelativePath, pAssociatedThumb);
					GG_GetRealPath(pAssociatedThumb, 0);
				}
				if (FileExist(pAssociatedThumb) == 1)
				{
					// so as not to disrupt purchased and other thumbs generated, just tackle building editor for now
					if (strnicmp(pRelativePath, "entitybank\\user\\buildingeditor", 30) == NULL)
					{
						if (strnicmp(pAssociatedThumb + strlen(pAssociatedThumb) - 4, ".fpe", 4) == NULL)
						{
							pAssociatedThumb[strlen(pAssociatedThumb) - 4] = 0;
							strcat(pAssociatedThumb, ".jpg");
							GG_GetRealPath(pAssociatedThumb, 0);
							if (FileExist(pAssociatedThumb) == 0)
							{
								strcpy(pAssociatedThumb, g.fpscrootdir_s.Get());
								strcat(pAssociatedThumb, "\\Files\\editors\\uiv3\\filetype-object.jpg");
							}
							pSrcFile = pAssociatedThumb;
							bHasOwnLocalThumb = true;
						}
					}
				}
			}

			// file destination not exist, copy src to it to save time
			CopyFileA (pSrcFile, BackBufferCacheName.Get(), TRUE);
		}
	}

	// determined to have own thumb
	return bHasOwnLocalThumb;
}
#endif

#ifdef VRTECH

void process_entity_library(void)
{
	if (bExternal_Entities_Window)
	{
		ImGuiWindowFlags ex_window_flags = 0;
		ImGuiIO& io = ImGui::GetIO();

		static int uniqueId = 4000; //PE: Also used for imageID for previews.
		static int loaded_images = 0;
		static bool multi_selections = false;
		int multi_selections_count = 0;
		static int lf_multi_selections_count = 0;
		int olduniqueId = uniqueId;
		bool bReleaseIconsDynamic = false;
		uniqueId = 4000;
#ifdef DYNAMICLOADUNLOAD
		static int max_load_persync = 200; //First time only , changed later to 15
		bReleaseIconsDynamic = true;
#else
		int max_load_persync = 2000;
#endif

		int preview_count = 0;
		int media_icon_size = 64;
		int iColumnsWidth = 110;

		time_t tCurrentTimeSec;
		time(&tCurrentTimeSec);

		ImGui::Begin("Entity Library##ExternalWindow", &bExternal_Entities_Window, ex_window_flags);

		bool bAddSelectionToGame = false;
		bool bIsWeDocked = ImGui::IsWindowDocked();
		static int current_tab = -1;


		CheckTutorialAction("TABMARKERS", 54.0f); //Tutorial: check if we are waiting for this action
		if (current_tab == 1 && bTutorialCheckAction)
			TutorialNextAction(); //Clicked - selected the tab markers.
		CheckTutorialAction("TABENTITIES", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_tab == 0 && bTutorialCheckAction)
			TutorialNextAction(); //Clicked - selected the tab Entities.

		ImGui::SetItemAllowOverlap();
		if (ImGui::BeginTabBar("entlibtabbar"))
		{
			static int iCurrentFilter = 0;
			static char cSearchAllEntities[3][MAX_PATH] = { "\0","\0","\0" };

			for (int i = 0; i < 2; i++) {

				cStr sTabHeader;
				if (i == 0) sTabHeader = " Entities ";
				if (i == 1) sTabHeader = " Markers! ";


				if (ImGui::BeginTabItem(sTabHeader.Get()))
				{
					if (current_tab != i) {
						//Tab changed.
						//timestampactivity(0, "Entity Library Tab change");
						current_tab = i;
						iCurrentFilter = 0;
					}

					static char cAllFilters[10][MAX_PATH];
					char cFilter[MAX_PATH], cHeader[MAX_PATH];
					int splitsections = 1;

					if (i == 1) {
						splitsections = 5;
					}

					int control_wrap_width = 70;
					strcpy(cFilter, "");
					strcpy(cHeader, "");
					//PE: Debug dynamic icon load unload.
					//ImGui::Text("Entities: %ld , in memory: %ld", olduniqueId-4000, loaded_images);
					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3.0));
					ImGui::Text("Filter: ");
					ImGui::SameLine();
					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3.0));
					if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
						ImGui::Text(""); //NewLine
					bool rb_change = false;
					ImGui::RadioButton("All ", &iCurrentFilter, 0);
					ImGui::SameLine();
					if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
						ImGui::Text(""); //NewLine

					if (i == 0) {

						CheckTutorialAction("BUTCHARACTER", -28.0f); //Tutorial: check if we are waiting for this action
						if (ImGui::RadioButton("Characters ", &iCurrentFilter, 1)) {
							//On click remove search.
							strcpy(cSearchAllEntities[i], "");
							if (bTutorialCheckAction)
								TutorialNextAction(); //Clicked - on "Characters"
						}
						ImGui::SameLine();
						if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
							ImGui::Text(""); //NewLine

						CheckTutorialAction("BUTBUILDINGS", -28.0f); //Tutorial: check if we are waiting for this action
						if (ImGui::RadioButton("Buildings", &iCurrentFilter, 2)) {
							//On click remove search.
							strcpy(cSearchAllEntities[i], "");
							if (bTutorialCheckAction)
								TutorialNextAction(); //Clicked - on "Buildings"
						}
						ImGui::SameLine();

						if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
							ImGui::Text(""); //NewLine


						CheckTutorialAction("BUTOBJECTS", -28.0f); //Tutorial: check if we are waiting for this action
						if (ImGui::RadioButton("Objects", &iCurrentFilter, 6)) {
							//On click remove search.
							strcpy(cSearchAllEntities[i], "");
							if (bTutorialCheckAction)
								TutorialNextAction(); //Clicked - on "objects"
						}

						if (iCurrentFilter == 1) strcpy(cFilter, "Character");
						if (iCurrentFilter == 2) strcpy(cFilter, "Building");
						//								if (iCurrentFilter == 3) strcpy(cFilter, "Foliage");
						//								if (iCurrentFilter == 4) strcpy(cFilter, "Cartoon");
						//								if (iCurrentFilter == 5) strcpy(cFilter, "Fixtures");
						if (iCurrentFilter == 6) strcpy(cFilter, "*");

						strcpy(cAllFilters[0], "Character");
						strcpy(cAllFilters[1], "Building");
						//								strcpy(cAllFilters[2], "Foliage");
						//								strcpy(cAllFilters[3], "Cartoon");
						//								strcpy(cAllFilters[4], "Fixtures");

					}
					if (i == 1) {
						ImGui::RadioButton("Players ", &iCurrentFilter, 1);
						ImGui::SameLine();
						if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
							ImGui::Text(""); //NewLine
						ImGui::RadioButton("Zones", &iCurrentFilter, 2);
						ImGui::SameLine();
						if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
							ImGui::Text(""); //NewLine
						ImGui::RadioButton("Lights", &iCurrentFilter, 3);
						ImGui::SameLine();
						if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
							ImGui::Text(""); //NewLine
						ImGui::RadioButton("Spot Lights", &iCurrentFilter, 4);


						if (iCurrentFilter == 1) { strcpy(cFilter, "player"); strcpy(cHeader, "Player Positions"); }
						if (iCurrentFilter == 2) { strcpy(cFilter, "zone.fpe"); strcpy(cHeader, "Zones"); }
						if (iCurrentFilter == 3) { strcpy(cFilter, " light.fpe"); strcpy(cHeader, "Lights"); }
						if (iCurrentFilter == 4) { strcpy(cFilter, "spot.fpe"); strcpy(cHeader, "Spot Lights"); }
						if (iCurrentFilter > 0) splitsections = 1;
					}

					ImGui::SameLine();

					if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
						ImGui::Text(""); //NewLine

					float fXWidth = ImGui::GetFontSize()*1.5;
					if (i == 0)
						ImGui::PushItemWidth(-38 - fXWidth);
					else
						ImGui::PushItemWidth(-1 - fXWidth - 4.0);

					ImGui::Text(" Search: ");
					ImGui::SameLine();

					bEntityGotFocus = false;
					if (ImGui::InputText("##cSearchAllEntities", &cSearchAllEntities[i][0], MAX_PATH, ImGuiInputTextFlags_EnterReturnsTrue))
					{
						if (strlen(cSearchAllEntities[i]) > 1) {
							bool already_there = false;
							for (int l = 0; l < MAXSEARCHHISTORY; l++) {
								if (strcmp(cSearchAllEntities[i], pref.search_history[l]) == 0) {
									already_there = true;
									break;
								}
							}
							if (!already_there) {
								bool foundspot = false;
								for (int l = 0; l < MAXSEARCHHISTORY; l++) {
									if (strlen(pref.search_history[l]) <= 0) {
										strcpy(pref.search_history[l], cSearchAllEntities[i]);
										foundspot = true;
										break;
									}
								}
								if (!foundspot) {
									//Move entry list.
									for (int l = 0; l < MAXSEARCHHISTORY; l++) {
										strcpy(pref.search_history[l], pref.search_history[l + 1]);
									}
									strcpy(pref.search_history[MAXSEARCHHISTORY - 1], cSearchAllEntities[i]);
								}
							}
						}
					}
					ImGui::SameLine();
					if (ImGui::StyleButton("X##deletesearch"))
					{
						strcpy(cSearchAllEntities[i], "");
					}
					//}
					ImGui::PopItemWidth();


					//Combo dropdown. Use folder names as seach.
					if (i == 0) {
						ImGui::SameLine();
						static char * current_combo_entry = "\0";
						int comboflags = ImGuiComboFlags_NoPreview | ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge;
						ImGui::PushItemWidth(-24);
						if (ImGui::BeginCombo("##combolastsearch", current_combo_entry, comboflags))
						{

							//Do we have a search history.
							bool display_history = false;
							for (int l = 0; l < MAXSEARCHHISTORY; l++) {
								if (strlen(pref.search_history[l]) > 0) {
									display_history = true;
									break;
								}
							}
							if (display_history) {
								ImGui::Text("Search History:");
								ImGui::Indent(10);
								for (int l = 0; l < MAXSEARCHHISTORY; l++) {
									if (strlen(pref.search_history[l]) > 0) {
										bool is_selected = (current_combo_entry == pref.search_history[l]);
										if (ImGui::Selectable(pref.search_history[l], is_selected)) {
											current_combo_entry = (char *)pref.search_history[l];
											strcpy(cSearchAllEntities[i], pref.search_history[l]);
										}
										if (is_selected)
											ImGui::SetItemDefaultFocus();
									}
								}
								ImGui::Indent(-10);
							}
							cFolderItem *pNewFolder = &MainEntityList;
							pNewFolder = pNewFolder->m_pNext;
							if (pNewFolder) {

								ImGui::Text("Folders:");
								ImGui::Indent(10);

								cStr path_remove = pNewFolder->m_sFolderFullPath.Get();
								int ipath_remove_len = path_remove.Len();

								ImVec4* style_colors = ImGui::GetStyle().Colors;
								ImVec2 wsize = ImGui::GetWindowSize();

								int line_count = 0;
								while (pNewFolder)
								{
									cStr path = pNewFolder->m_sFolderFullPath.Get();
									bool bDoubleEntityBank = false;
									char *finde = (char *)pestrcasestr(path.Get(), "\\entitybank"); //Support entitybank inside entitybank.
									if (finde)
									{
										finde += 11;
										finde = (char *)pestrcasestr(finde, "\\entitybank");
										if (finde) bDoubleEntityBank = true;
									}
									if (!bDoubleEntityBank && path.Right(11) == "\\entitybank")
									{
										ipath_remove_len = path.Len();
									}
									else
									{
										char *final_name = path.Get();
										final_name += ipath_remove_len;
										if (*final_name == '\\')
											final_name++;

										std::string dir_name = final_name;
										replaceAll(dir_name, "\\", " - ");

										if (dir_name.length() > 0 && pNewFolder->m_pFirstFile && !pestrcasestr(dir_name.c_str(), "_markers"))
										{
											bool is_selected = (current_combo_entry == pNewFolder->m_sFolderFullPath.Get());
											if (ImGui::Selectable(dir_name.c_str(), is_selected))
											{
												current_combo_entry = (char *)pNewFolder->m_sFolderFullPath.Get();
												//Make a search entry.
												strcpy(cSearchAllEntities[i], dir_name.c_str());

											}
											if (is_selected)
												ImGui::SetItemDefaultFocus();
											line_count++;
										}
									}
									pNewFolder = pNewFolder->m_pNext;
								}
								ImGui::Indent(-10);
							}
							ImGui::EndCombo();
						}

						ImGui::PopItemWidth();
					}
					ImGui::Separator();

					if (strlen(cSearchAllEntities[i]) > 0 && i == 1) {
						iCurrentFilter = 0;
						splitsections = 1;
					}

					ImGui::BeginChild("##cSearchAllEntitiesBegin", ImVec2(0, 0),false, iGenralWindowsFlags);

					ImVec2 oldCursor = ImGui::GetCursorPos();
					std::string insert_text;
					ImVec2 insert_text_width;

					if (lf_multi_selections_count > 0) {
						//Display insert button.
						insert_text = " Add ";
						insert_text += std::to_string(lf_multi_selections_count);
						insert_text += " Objects to Level ";
						insert_text_width = ImGui::CalcTextSize(insert_text.c_str());
						ImGui::SetCursorPos(ImVec2(0, (ImGui::GetWindowSize().y + ImGui::GetScrollY()) - insert_text_width.y - 10.0f));

						ImGui::Spacing();
						ImGui::SameLine(ImGui::GetWindowContentRegionWidth() - (insert_text_width.x + 18.0f));

						ImGui::SetItemAllowOverlap();
						if (ImGui::StyleButton(insert_text.c_str())) {
							//Inset all selected items.
							bAddSelectionToGame = true;
						}
					}

					ImGui::SetCursorPos(oldCursor);
					if (i == 0)
						ImGui::TextCenter("Click to add an object to your level. Control+Click to select multiple items.");

					int iIconVisiblePosY = ImGui::GetWindowSize().y + ImGui::GetScrollY() + media_icon_size;

					bool bFirstShiftHasBeenSeen = false;
					bool bAnySelectedItemsAvailable = false;
					static cFolderItem::sFolderFiles * firstShiftFile = NULL;
					static cFolderItem::sFolderFiles * lastShiftFile = NULL;

					for (int splitloop = 0; splitloop < splitsections; splitloop++) {

						if (iCurrentFilter == 0) {
							if (i == 1) strcpy(cFilter, "");
							if (i == 1) strcpy(cHeader, "");
							if (i == 1 && splitloop == 0) { strcpy(cFilter, "player"); strcpy(cHeader, "Player Positions"); }
							if (i == 1 && splitloop == 1) { strcpy(cFilter, "zone.fpe"); strcpy(cHeader, "Zones"); }
							if (i == 1 && splitloop == 2) { strcpy(cFilter, " light.fpe"); strcpy(cHeader, "Lights"); }
							if (i == 1 && splitloop == 3) { strcpy(cFilter, "spot.fpe"); strcpy(cHeader, "Spot Lights"); }
							if (i == 1 && splitloop == 4) { strcpy(cFilter, "*"); strcpy(cHeader, "Others"); }
							if (i == 1) strcpy(cAllFilters[splitloop], cFilter);
							if (strlen(cSearchAllEntities[i]) > 0 && i == 1) {
								strcpy(cHeader, "");
							}
						}
						cFolderItem *pNewFolder = &MainEntityList;
						pNewFolder = pNewFolder->m_pNext;
						if (pNewFolder)
						{
							//We start at the "entitybank" entry that we use to parce the others.
							cStr path_remove = pNewFolder->m_sFolderFullPath.Get();
							int ipath_remove_len = path_remove.Len();
							pNewFolder = pNewFolder->m_pNext;
							while (pNewFolder)
							{
								//PE: Full path can now change in the middle of the list , so:
								cStr path = pNewFolder->m_sFolderFullPath.Get();
								LPSTR pPathSearch = path.Get();
								LPSTR pFind = "\\entitybank";
								for (int n = 0; n < strlen(pPathSearch); n++)
								{
									if (strnicmp(pPathSearch + n, pFind, strlen(pFind)) == NULL)
									{
										ipath_remove_len = n + strlen(pFind);
										break;
									}
								}

								if (1)
								{
									bool isMarkers = false;
									bool bDisplayEverythingHere = false;
									bool bHideEverythingHere = false;
									if (i == 0 && cFilter[0] == '*')
									{
										if (pestrcasestr(pNewFolder->m_sFolderFullPath.Get(), cAllFilters[0]))
											bHideEverythingHere = true;
										if (pestrcasestr(pNewFolder->m_sFolderFullPath.Get(), cAllFilters[1]))
											bHideEverythingHere = true;
									}
									else if (strlen(cFilter) > 0)
									{
										if (pestrcasestr(pNewFolder->m_sFolderFullPath.Get(), cFilter))
											bDisplayEverythingHere = true;
									}
									if (strlen(cSearchAllEntities[i]) > 0)
									{
										//When search disable fixed tags search.
										bDisplayEverythingHere = false;
										bHideEverythingHere = false;
									}
									char *final_name = path.Get();
									final_name += ipath_remove_len;
									if (*final_name == '\\')
										final_name++;

									std::string path_for_filename = final_name;
									std::string dir_name = final_name;
									replaceAll(dir_name, "\\", " - ");

									if (pestrcasestr(dir_name.c_str(), "_markers"))
										isMarkers = true;

									if (!isMarkers && i == 0 && !bDisplayEverythingHere && !bHideEverythingHere && strlen(cSearchAllEntities[i]) > 0) {
										if (pestrcasestr(pNewFolder->m_sFolderFullPath.Get(), cSearchAllEntities[i]))
											bDisplayEverythingHere = true;
										else if (pestrcasestr(dir_name.c_str(), cSearchAllEntities[i]))
											bDisplayEverythingHere = true;

									}

									//PE: Check here if we need to reload the folder, for new files.
									if (pNewFolder->m_fLastTimeUpdate < Timer())
									{
										pNewFolder->m_fLastTimeUpdate = Timer() + 4000; //Check every 4-6 sec.
										pNewFolder->m_fLastTimeUpdate += rand() % 2000; //Make sure we dont check folders in same cycle.
										struct stat sb;
										if (stat(pNewFolder->m_sFolderFullPath.Get(), &sb) == 0) 
										{
											if (sb.st_mtime != pNewFolder->m_tFolderModify) 
											{
												pNewFolder->m_tFolderModify = sb.st_mtime;
												RefreshEntityFolder(pNewFolder->m_sFolderFullPath.Get(), pNewFolder);
											}
										}
									}
									if (pNewFolder->m_pFirstFile)
									{

										bool bHeaderDisplayed = false;
										bool bDisplayText = true;
										float fWinWidth = ImGui::GetWindowSize().x - 10.0; // Flicker - ImGui::GetCurrentWindow()->ScrollbarSizes.x;
										if (iColumnsWidth >= fWinWidth && fWinWidth > media_icon_size)
										{
											iColumnsWidth = fWinWidth;
										}
										int iColumns = (int)(ImGui::GetWindowSize().x / (iColumnsWidth));
										if (iColumns <= 1)
											iColumns = 1;

										cFolderItem::sFolderFiles * myfiles = pNewFolder->m_pFirstFile->m_pNext;
										while (myfiles)
										{
											std::string sFinal = Left(myfiles->m_sName.Get(), Len(myfiles->m_sName.Get()) - 4);

											if (splitloop == 0 && myfiles->iFlags == 1)
												multi_selections_count++;

											bool bIsVisible = true;
											if (i == 0 && isMarkers) bIsVisible = false;
											if (i == 1 && !isMarkers) bIsVisible = false;

											if (bIsVisible && strlen(cSearchAllEntities[i]) > 0) {
												if (!pestrcasestr(myfiles->m_sName.Get(), cSearchAllEntities[i]))
													bIsVisible = false;
											}
											else if (i == 1 && cFilter[0] == '*') {
												//Others not already displayed.
												for (int fl = 0; fl < splitloop; fl++) {
													if (pestrcasestr(myfiles->m_sName.Get(), cAllFilters[fl]))
														bIsVisible = false;
												}
											}
											else if (strlen(cFilter) > 0 && cFilter[0] != '*') {
												if (!pestrcasestr(myfiles->m_sName.Get(), cFilter))
													bIsVisible = false;
											}


											if (bDisplayEverythingHere)
												bIsVisible = true;
											if (bHideEverythingHere)
												bIsVisible = false;

											ImGui::PushID(uniqueId + preview_count);
											if (splitloop == 0)
												uniqueId++;

											int textureId = 0;
											if (myfiles->iPreview <= 0)
											{
												//Only Visible.
												int gcpy = ImGui::GetCursorPosY();
												if (!bReleaseIconsDynamic || (splitloop == 0 && (bIsVisible || isMarkers) && (gcpy < iIconVisiblePosY && gcpy >= ImGui::GetScrollY() - media_icon_size || isMarkers)))
												{
													myfiles->last_used = (long)tCurrentTimeSec;
													if (max_load_persync-- >= 0)
													{
														//Load preview.
														std::string sImgName = myfiles->m_sPath.Get();
														sImgName = sImgName + "\\" + Left(myfiles->m_sName.Get(), Len(myfiles->m_sName.Get()) - 4);
														sImgName += ".bmp";
														myfiles->iPreview = uniqueId; //TOOL_ENTITY; //Just for testing.
														SetMipmapNum(1); //PE: mipmaps not needed.
														image_setlegacyimageloading(true);
														LoadImage((char *)sImgName.c_str(), myfiles->iPreview);
														image_setlegacyimageloading(false);
														SetMipmapNum(-1);
														if (!GetImageExistEx(myfiles->iPreview))
														{
															myfiles->iPreview = TOOL_ENTITY;
															textureId = TOOL_ENTITY;
														}
														else {
															loaded_images++;
															textureId = myfiles->iPreview;
														}
													}
													else
														textureId = TOOL_ENTITY;
												}
												else {
													textureId = TOOL_ENTITY;
												}
											}
											else
											{
												//PE: Only delete in first run. so we dont delete a image that has already been sent to rendering.
												if (splitloop == 0 && bReleaseIconsDynamic) {
													//Only NOT Visible with a preview image..
													int gcpy = ImGui::GetCursorPosY();
													if (!isMarkers && (!(gcpy < iIconVisiblePosY && gcpy >= ImGui::GetScrollY() - media_icon_size) || !bIsVisible)) {

														if ((long)tCurrentTimeSec - myfiles->last_used > 20) {
															//Delete Image not visible for 20 sec.
															if (GetImageExistEx(myfiles->iPreview) && myfiles->iPreview >= 4000 && myfiles->iPreview < UIV3IMAGES) { //PE: Need to protect system images after tool img range has changed. (myfiles->iPreview can be a system icon)
																image_setlegacyimageloading(true);
																DeleteImage(myfiles->iPreview);
																image_setlegacyimageloading(false);
																myfiles->iPreview = 0;
																loaded_images--;
															}
															textureId = TOOL_ENTITY;
														}
														else
															textureId = myfiles->iPreview;
													}
													else {
														//Still visible update time.
														if (bIsVisible || isMarkers)
															myfiles->last_used = (long)tCurrentTimeSec;
														textureId = myfiles->iPreview;
													}
												}
												else
													textureId = myfiles->iPreview;
											}

											//Is object visible
											if (bIsVisible) 
											{
												if (myfiles->iPreview > 0 && !GetImageExistEx(myfiles->iPreview)) 
												{
													myfiles->iPreview = 0;
													textureId = TOOL_ENTITY;
												}

												if (!bHeaderDisplayed) {

													if (!isMarkers && i == 0)
													{
														ImGui::SetWindowFontScale(1.25);
														LPSTR pFinalHeaderTitle = (LPSTR)dir_name.c_str();
														if (stricmp(pFinalHeaderTitle, "user") == NULL) pFinalHeaderTitle = "Custom Assets";
														if (stricmp(pFinalHeaderTitle, "user - charactercreatorplus") == NULL) pFinalHeaderTitle = "Custom Characters";
														if (stricmp(pFinalHeaderTitle, "user - ebestructures") == NULL) pFinalHeaderTitle = "Custom Structures";
														ImGui::Text("%s", pFinalHeaderTitle);
														ImGui::Spacing();
													}
													else if (strlen(cHeader) > 0)
													{
														ImGui::SetWindowFontScale(1.25);
														ImGui::Text("%s", cHeader);
														ImGui::Spacing();
													}

													ImGui::Columns(iColumns, "filescolumns4entities", false);  //false no border
													bHeaderDisplayed = true;
												}
												ImGui::SetWindowFontScale(SMALLFONTSIZE);

												float fFramePadding = (iColumnsWidth - media_icon_size)*0.5;
												float fCenterX = iColumnsWidth * 0.5;

												ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(fFramePadding, 2.0f));

												if (myfiles->iFlags == 1) 
												{
													ImVec4 bg_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram]; // { 0.0, 0.0, 0.0, 1.0 };
													ImVec2 padding = { 6.0, 6.0 };
													ImGuiWindow* window = ImGui::GetCurrentWindow();
													const ImRect image_bb((window->DC.CursorPos - padding) + ImVec2(fFramePadding, 2.0f), window->DC.CursorPos + padding + ImVec2(fFramePadding, 2.0f) + ImVec2(media_icon_size, media_icon_size));
													window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(bg_col), 0.0f, 15, 3.0f);
													bAnySelectedItemsAvailable = true;
												}

												CheckTutorialAction(sFinal.c_str(), 13.0f); //Tutorial: check if we are waiting for this action

												//PE: Support Shift fo selecting may items.
												if (!io.KeyShift) 
												{
													//firstShiftFile = NULL;
													lastShiftFile = NULL;
												}

												extern bool g_bFreeTrialVersion;
												if (firstShiftFile && lastShiftFile)
												{
													if (myfiles == firstShiftFile)
														bFirstShiftHasBeenSeen = true;
													if (!bFirstShiftHasBeenSeen && myfiles == lastShiftFile)
													{
														//Swap around, last is first.
														cFolderItem::sFolderFiles * tmpShiftFile = lastShiftFile;
														lastShiftFile = firstShiftFile;
														firstShiftFile = tmpShiftFile;
														bFirstShiftHasBeenSeen = true;
													}

													static bool bStartShiftActive = false;
													myfiles->iFlags = 0;
													if (myfiles == firstShiftFile) 
													{
														bStartShiftActive = true;
														if(g_bFreeTrialVersion == false || (g_bFreeTrialVersion==true && myfiles->bAvailableInFreeTrial==true) )
															myfiles->iFlags = 1;
													}
													if (myfiles == lastShiftFile) 
													{
														bStartShiftActive = false;
														if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
															myfiles->iFlags = 1;
													}
													if (bStartShiftActive)
													{
														if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
															myfiles->iFlags = 1;
													}
												}

												if (ImGui::ImgBtn(textureId, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true))
												{

													if (bTutorialCheckAction) TutorialNextAction(); //Clicked get next tutorial action.

													//If ctrl , just mark them.

													if (io.KeyShift) 
													{
														if (firstShiftFile)
														{
															lastShiftFile = myfiles;
														}
														else
														{
															firstShiftFile = myfiles;
															multi_selections = true;
															if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
																myfiles->iFlags = 1;
														}
													}
													else if (io.KeyCtrl) 
													{
														//Mark object.
														multi_selections = true;
														if (myfiles->iFlags == 0) 
														{
															if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
																myfiles->iFlags = 1;
															firstShiftFile = myfiles;
														}
														else
														{
															myfiles->iFlags = 0;
														}
													}
													else
													{
														if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
														if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
														if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;

														//Make sure we are in entity mode.
														bForceKey = true;
														csForceKey = "e";

														DeleteWaypointsAddedToCurrentCursor();
														CheckTooltipObjectDelete();
														CloseDownEditorProperties();
														#ifdef WICKEDENGINE
														iLastEntityOnCursor = 0;
														#endif

														std::string sFpeName = path_for_filename.c_str();
														sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
														t.addentityfile_s = sFpeName.c_str();
														if (t.addentityfile_s != "")
														{
															entity_adduniqueentity(false);
															t.tasset = t.entid;
															if (t.talreadyloaded == 0)
															{
																editor_filllibrary();
															}
														}
														#ifdef WICKEDENGINE
														iExtractMode = 0; //PE: Always start in find floor mode.
														#endif
														t.inputsys.constructselection = t.tasset;

														t.gridentity = t.entid;
														t.inputsys.constructselection = t.entid;
														t.inputsys.domodeentity = 1;
														t.grideditselect = 5;
														#ifdef WICKEDENGINE
														//Make sure we use a fresh t.grideleprof
														entity_fillgrideleproffromprofile();
														#endif

														editor_refresheditmarkers();
														//PE: Close window for now.
														bCheckForClosing = true;
													}
												}

												if (!bEntity_Properties_Window && !g_bCharacterCreatorPlusActivated && !bImporter_Window && i == 0 && ImGui::IsItemHovered()) {

													iTooltipHoveredTimer = Timer();
													static void* additionalcheck = NULL;

													if (iLastTooltipSelection != textureId || (additionalcheck != myfiles)) {

														//Check if we need to delete a old tooltip object.
														if (iTooltipLastObjectId > 0 && iTooltipLastObjectId != textureId) {
															CheckTooltipObjectDelete();
														}
														additionalcheck = myfiles;
														iTooltipTimer = iTooltipHoveredTimer;
														iLastTooltipSelection = textureId;
														iTooltipObjectReady = false;

													}
													else {
														if (iTooltipHoveredTimer - iTooltipTimer > 2000) { // 2 sec before starting.
															if (iTooltipObjectReady) {
																if (iTooltipLastObjectId > 0) {

																	if (GetImageExistEx(g.importermenuimageoffset + 50)) {
																		float TooltipImageSize = 320.0f;
																		float ImgX = ImageWidth(g.importermenuimageoffset + 50);
																		float ImgY = ImageHeight(g.importermenuimageoffset + 50);
																		float Ratio = TooltipImageSize / ImgX;
																		ImgY *= Ratio;
																		ImVec2 cursor_pos = ImGui::GetIO().MousePos;
																		ImVec2 tooltip_offset(10.0f, ImGui::GetFontSize()*1.5);
																		ImVec2 tooltip_position = cursor_pos;
																		if (tooltip_position.x + TooltipImageSize > GetDesktopWidth())
																			tooltip_position.x -= TooltipImageSize;
																		if (tooltip_position.y + TooltipImageSize > GetDesktopHeight())
																			tooltip_position.y -= (TooltipImageSize + ImGui::GetFontSize()*3.0);
																		tooltip_position.x += tooltip_offset.x;
																		tooltip_position.y += tooltip_offset.y;
																		ImGui::SetNextWindowPos(tooltip_position);
																		ImGui::SetNextWindowContentWidth(TooltipImageSize);
																		ImGui::BeginTooltip();
																		float icon_ratio;
																		ImGui::ImgBtn(g.importermenuimageoffset + 50, ImVec2(TooltipImageSize, ImgY), ImVec4(0.0, 0.0, 0.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false);
																		//char hchar[MAX_PATH];
																		//ImGui::Text("%s", hchar);
																		ImGui::EndTooltip();

																	}
																	else
																		ImGui::SetTooltip("%s", sFinal.c_str());
																}
															}
															else {
																//Generate Thumbnail of object.
																std::string sFpeName = path_for_filename.c_str();
																sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
																t.addentityfile_s = sFpeName.c_str();

																#ifdef WICKEDENGINE
																CreateBackBufferCacheName(t.addentityfile_s.Get(), 512, 512);
																BackBufferSaveCacheName = BackBufferCacheName;
																if (FileExist(BackBufferCacheName.Get()))
																{
																	SetMipmapNum(1); //PE: mipmaps not needed.
																	image_setlegacyimageloading(true);
																	if (ImageExist(g.importermenuimageoffset + 50))
																		DeleteImage(g.importermenuimageoffset + 50);
																	LoadImage((char *)BackBufferCacheName.Get(), g.importermenuimageoffset + 50);
																	image_setlegacyimageloading(false);
																	SetMipmapNum(-1);
																	iTooltipObjectReady = true;
																	iTooltipLastObjectId = t.entid;
																}
																else
																{
																#endif

																	t.entdir_s = "entitybank\\";
																	if (cstr(Lower(Left(t.addentityfile_s.Get(), 11))) == "entitybank\\")
																	{
																		t.addentityfile_s = Right(t.addentityfile_s.Get(), Len(t.addentityfile_s.Get()) - 11);
																	}
																	if (cstr(Lower(Left(t.addentityfile_s.Get(), 8))) == "ebebank\\")
																	{
																		t.entdir_s = "";
																	}

																	t.talreadyloaded = 0;
																	for (t.t = 1; t.t <= g.entidmaster; t.t++)
																	{
																		if (t.entitybank_s[t.t] == t.addentityfile_s) { t.talreadyloaded = 1; t.entid = t.t; }
																	}
																	if (t.talreadyloaded == 0)
																	{

																		//  Allocate one more entity item in array
																		if (g.entidmaster > g.entitybankmax - 4)
																		{
																			Dim(t.tempentitybank_s, g.entitybankmax);
																			for (t.t = 0; t.t <= g.entitybankmax; t.t++) t.tempentitybank_s[t.t] = t.entitybank_s[t.t];
																			++g.entitybankmax;
																			UnDim(t.entitybank_s);
																			Dim(t.entitybank_s, g.entitybankmax);
																			for (t.t = 0; t.t <= g.entitybankmax - 1; t.t++) t.entitybank_s[t.t] = t.tempentitybank_s[t.t];
																		}

																		//  Add entity to bank
																		++g.entidmaster; entity_validatearraysize();
																		t.entitybank_s[g.entidmaster] = t.addentityfile_s;

																		if (ObjectExist(g.entitybankoffset + g.entidmaster)) {
																			DeleteObject(g.entitybankoffset + g.entidmaster);
																		}

																		//  Load extra entity
																		t.entid = g.entidmaster;
																		t.ent_s = t.entitybank_s[t.entid];
																		t.entpath_s = getpath(t.ent_s.Get());

																		extern bool g_bGracefulWarningAboutOldXFiles;
																		g_bGracefulWarningAboutOldXFiles = true;
																		entity_load();
																		g_bGracefulWarningAboutOldXFiles = false;
																		HideObject(g.entitybankoffset + g.entidmaster);
																		if (t.entityprofile[g.entidmaster].ischaracter == 1) {
																			RotateObject(g.entitybankoffset + g.entidmaster, 0, 180, 0);
																		}
																		g.entidmaster--; //Dont actual add it.

																		//entity_load can change folder by creating a dbo , so update timestamp without refresh.
																		struct stat sb;
																		if (stat(pNewFolder->m_sFolderFullPath.Get(), &sb) == 0) 
																		{
																			if (sb.st_mtime != pNewFolder->m_tFolderModify) 
																			{
																				pNewFolder->m_tFolderModify = sb.st_mtime;
																			}
																		}
																		//Create a new thumbnail.
																	}

																	iTooltipLastObjectId = t.entid;
																	iTooltipAlreadyLoaded = t.talreadyloaded;
																	iTooltipObjectReady = true;
#ifdef WICKEDENGINE
																	BackBufferObjectID = g.entitybankoffset + t.entid;
																	BackBufferImageID = g.importermenuimageoffset + 50;
																	BackBufferSizeX = 512;
																	BackBufferSizeY = 512;
																	BackBufferSaveCacheName = ""; //Dont save for now.
#else
																	iLaunchAfterSync = 30; //Generate the thumb.
#endif
#ifdef WICKEDENGINE
																}
#endif
															}
														}
													}
												}

												if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
												{

													CheckTooltipObjectDelete();
													CloseDownEditorProperties();
													t.inputsys.constructselection = 0;

													myfiles->m_dropptr = myfiles;

													std::string sFpeName = path_for_filename.c_str();
													sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();

													myfiles->m_sFolder = sFpeName.c_str();
													ImGui::SetDragDropPayload("DND_MODEL_DROP_TARGET", myfiles, sizeof(void *));
													ImGui::ImgBtn(textureId, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, true);
													//ImGui::Text("%s", myfiles->m_sName.Get());
													ImGui::SetCursorPos(oldCursor);
													pDragDropFile = myfiles;
													ImGui::EndDragDropSource();
												}

												ImGui::PopStyleVar();

												if (bDisplayText) {
													int iTextWidth = ImGui::CalcTextSize(sFinal.c_str()).x;
													if (iTextWidth < iColumnsWidth)
														ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + (fCenterX - (iTextWidth*0.5)), ImGui::GetCursorPosY()));
													ImGui::TextWrapped("%s", sFinal.c_str());
												}

												ImGui::NextColumn();
											}
											ImGui::PopID();
											preview_count++;

											myfiles = myfiles->m_pNext;
										}

										ImGui::Columns(1);

										ImGui::SetWindowFontScale(1.0);
									}
								}
								pNewFolder = pNewFolder->m_pNext;
							}

						}
					}

					if (!bAnySelectedItemsAvailable) {
						//PE: We got no selections , we can reset first shift seen.
						if (!io.KeyShift) {
							firstShiftFile = NULL;
						}
					}
					ImGui::SetWindowFontScale(1.0);

					ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
					if (ImGui::IsMouseHoveringRect(bbwin.Min, bbwin.Max))
					{
						bImGuiGotFocus = true;
						bEntityGotFocus = true;
					}
					if (ImGui::IsAnyItemFocused()) {
						bImGuiGotFocus = true;
						bEntityGotFocus = true;
					}


					if (lf_multi_selections_count > 0) {
						ImGui::SetCursorPos(ImVec2(0, (ImGui::GetWindowSize().y + ImGui::GetScrollY()) - insert_text_width.y - 10.0f));
						ImGui::Spacing();
						ImGui::SameLine(ImGui::GetWindowContentRegionWidth() - (insert_text_width.x + 18.0f));
						ImGui::SetItemAllowOverlap();
						if (ImGui::StyleButton(insert_text.c_str())) {
							bAddSelectionToGame = true;
						}

					}

					ImGui::EndChild();

					ImGui::EndTabItem();
				}

				ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
				if (ImGui::IsMouseHoveringRect(bbwin.Min, bbwin.Max))
				{
					bImGuiGotFocus = true;
					bEntityGotFocus = true;
				}
				if (ImGui::IsAnyItemFocused()) {
					bImGuiGotFocus = true;
					bEntityGotFocus = true;
				}

			}
		}

#ifdef DYNAMICLOADUNLOAD
		max_load_persync = 10; // 15 to slow try 10
#endif
		lf_multi_selections_count = multi_selections_count; //Use last frames count.

		ImGui::EndTabBar();


		if (bAddSelectionToGame) {

			DeleteWaypointsAddedToCurrentCursor();
			CheckTooltipObjectDelete();
			CloseDownEditorProperties();

			//Remove any selections.
			t.inputsys.constructselection = 0;
			if (t.gridentityobj > 0)
			{
				DeleteObject(t.gridentityobj);
				t.gridentityobj = 0;
			}
			t.refreshgrideditcursor = 1;
			t.gridentity = 0;
			t.gridentityposoffground = 0;
			t.gridentityusingsoftauto = 0;
			editor_refresheditmarkers();

			cFolderItem *pSearchFolder = &MainEntityList;
			pSearchFolder = pSearchFolder->m_pNext;
			cStr path_remove;
			int ipath_remove_len;
			if (pSearchFolder) {
				path_remove = pSearchFolder->m_sFolderFullPath.Get();
				ipath_remove_len = path_remove.Len();
			}
			while (pSearchFolder) {

				cStr path = pSearchFolder->m_sFolderFullPath.Get();
				bool bDoubleEntityBank = false;
				char *finde = (char *)pestrcasestr(path.Get(), "\\entitybank"); //Support entitybank inside entitybank.
				if (finde)
				{
					finde += 11;
					finde = (char *)pestrcasestr(finde, "\\entitybank");
					if (finde) bDoubleEntityBank = true;
				}

				if (!bDoubleEntityBank && path.Right(11) == "\\entitybank") {
					ipath_remove_len = path.Len();
				}
				else
				{
					if (pSearchFolder->m_pFirstFile) {

						cFolderItem::sFolderFiles * searchfiles = pSearchFolder->m_pFirstFile->m_pNext;
						while (searchfiles) 
						{
							if (searchfiles->iFlags == 1) 
							{
								if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
								if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
								if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;

								//Insert.
								cStr path = pSearchFolder->m_sFolderFullPath.Get();
								char *final_name = path.Get();
								final_name += ipath_remove_len;
								if (*final_name == '\\')
									final_name++;
								std::string path_for_filename = final_name;

								std::string sFpeName = path_for_filename.c_str();
								sFpeName = sFpeName + "\\" + searchfiles->m_sName.Get();
								#ifdef WICKEDENGINE
								iLastEntityOnCursor = 0;
								#endif

								t.addentityfile_s = sFpeName.c_str();
								if (t.addentityfile_s != "")
								{
									entity_adduniqueentity(false);
									t.tasset = t.entid;
									if (t.talreadyloaded == 0)
									{
										editor_filllibrary();
									}
								}

								searchfiles->iFlags = 0;
							}
							searchfiles = searchfiles->m_pNext;
						}
					}
				}
				pSearchFolder = pSearchFolder->m_pNext;
			}
			bCheckForClosing = true;
		}

		bool bAreWeOverLapping = false;
		if (!bIsWeDocked) {
			//If we are over the rendertarget hide window.
			float itmpmousex = ImGui::GetWindowPos().x;
			float itmpmousey = ImGui::GetWindowPos().y;
			int iSecureZone = 4;
			if (bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x + iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmpmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmpmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
			itmpmousex = ImGui::GetWindowPos().x + ImGui::GetWindowSize().x;
			itmpmousey = ImGui::GetWindowPos().y + ImGui::GetWindowSize().y;
			if (bExternal_Entities_Window && bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x + iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmpmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmpmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
			itmpmousex = ImGui::GetWindowPos().x + ImGui::GetWindowSize().x;
			itmpmousey = ImGui::GetWindowPos().y;
			if (bExternal_Entities_Window && bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x + iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmpmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmpmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
			itmpmousex = ImGui::GetWindowPos().x;
			itmpmousey = ImGui::GetWindowPos().y + ImGui::GetWindowSize().y;
			if (bExternal_Entities_Window && bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x + iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmpmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmpmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
		}
		if (!bIsWeDocked && bCheckForClosing) {
			if (bAreWeOverLapping)
				bExternal_Entities_Window = false;
		}

		//Remove window on right click if we are overlapping.
		if (bAreWeOverLapping && t.inputsys.mclick == 2)
			bExternal_Entities_Window = false;


		bCheckForClosing = false;

		CheckMinimumDockSpaceSize(250.0f);

		ImGui::End();

	}

}

#ifdef WICKEDENGINE

void FormatLUAFilenameToTitle(LPSTR cDisplayName)
{
	char cRemoveUnderscores[MAX_PATH];
	strcpy (cRemoveUnderscores, "");
	LPSTR pRemoveUnderscores = cRemoveUnderscores;
	bool bFirstLetterOfWord = true;
	for (int n = 0; n < strlen(cDisplayName); n++)
	{
		if (cDisplayName[n] != '_')
		{
			if (bFirstLetterOfWord == true)
			{
				if (cDisplayName[n] >= 'a' && cDisplayName[n] <= 'z')
				{
					char pUpper[2];
					pUpper[0] = cDisplayName[n];
					pUpper[1] = 0;
					strupr(pUpper);
					*(pRemoveUnderscores++) = pUpper[0];
				}
				else
					*(pRemoveUnderscores++) = cDisplayName[n];

				bFirstLetterOfWord = false;
			}
			else
			{
				*(pRemoveUnderscores++) = cDisplayName[n];
			}
		}
		else
		{
			bFirstLetterOfWord = true;
		}
	}
	*(pRemoveUnderscores++) = 0;

	// Now prepare spaces
	char cNewDisplayName[MAX_PATH];
	strcpy (cNewDisplayName, "");
	LPSTR pNewDisPtr = cNewDisplayName;
	for (int n = 0; n < strlen(cRemoveUnderscores); n++)
	{
		// no .LUA extension in title
		if (cRemoveUnderscores[n] == '.')
		{
			break;
		}

		// construct new title, adding spaces between capitalised words
		if (n > 0 && cRemoveUnderscores[n] >= 'A' && cRemoveUnderscores[n] <= 'Z')
		{
			*(pNewDisPtr++) = ' ';
		}
		*(pNewDisPtr++) = cRemoveUnderscores[n];
	}
	*(pNewDisPtr++) = 0;
	strcpy (cDisplayName, cNewDisplayName);
}


struct folder_info
{
	int level;
	int type;
	int id;
	int parentid;
	int folders;
	bool bPinned;
	bool bUsed;
	char real_name[260];
	char show_name[260];
	cFolderItem *pFolder;
};

std::map<std::string, folder_info *> root_folders;
int seleted_tree_item = -1;
bool bViewAllFolders = true;
bool bViewShowcase = false;
bool bViewPurchased = false;
char cSearchAllEntities[3][MAX_PATH] = { "\0","\0","\0" };
bool bUpdateSearchSorting = false;
bool bUpdateSearchScrollbar = false;
bool bUpdateSearchSortingNextFrame = false;
bool bTreeViewInitInNextFrame = false;

bool DoTreeNode(int parentid, char *ignore, char *ignore2, char *selectfolder = NULL)
{
	for (auto it = root_folders.begin(); it != root_folders.end(); ++it)
	{
		bool bValid = true;
		int iCompareType = iDisplayLibraryType;
		if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1) iCompareType = 6; // Select only animation files when subtype=1
		if (it->second->type == iCompareType && (it->second->parentid == parentid || (it->second->bPinned && parentid == 0)))
		{
			//Pinned level 0 display as is.
			ImGuiTreeNodeFlags node_flags = ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_OpenOnArrow;
			if (it->second->folders <= 0)
				node_flags = ImGuiTreeNodeFlags_Leaf;
			if (seleted_tree_item == it->second->id)
				node_flags |= ImGuiTreeNodeFlags_Selected;
			else
				node_flags &= ~ImGuiTreeNodeFlags_Selected;

			ImGui::PushItemWidth(-20.0);

			std::string treename = it->second->show_name;

			if (parentid != 0) bValid = true;
			if (parentid == 0 && ignore && treename == ignore) bValid = false;
			if (parentid == 0 && ignore2 && treename == ignore2) bValid = false;
			if (parentid == 0 && ignore2==NULL)
			{
				// special extended filters for specific types
				if (ignore && ignore == "AllNoneBehaviorFolders")
				{
					if (treename == "Ai") bValid = false;
					if (treename == "Weather") bValid = false;
					if (treename == "Gfx") bValid = false;
					if (treename == "Images") bValid = false;
					if (treename == "Purchased") bValid = false;
				}
			}
			if (bValid)
			{
				if (it->second->bPinned)
				{
					treename = it->second->real_name;
					treename[0] = toupper(treename[0]);
				}
				bool TreeNodeOpen = ImGui::TreeNodeEx((void*)(intptr_t)it->second->id, node_flags, treename.c_str());
				ImGui::PopItemWidth();
				//PE: Default category select.
				if (selectfolder != NULL && seleted_tree_item == -1 && _stricmp(selectfolder, it->second->real_name) == 0)
				{
					//Select category.
					seleted_tree_item = it->second->id;
				}
				//PE: Select on mouse release.
				if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(0))
				{
					seleted_tree_item = it->second->id;
					strcpy(cSearchAllEntities[0], it->second->real_name);
					bUpdateSearchSorting = true;
					bUpdateSearchScrollbar = true;
				}
				ImGui::SameLine();
				ImGui::SetItemAllowOverlap();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(ImGui::GetContentRegionAvailWidth() - 18.0, -4.0));
				ImGui::PushID(it->second->id + 80000);
				ImVec4 back = ImGui::GetStyleColorVec4(ImGuiCol_WindowBg);

				if (it->second->bPinned)
				{
					if (ImGui::ImgBtn(MEDIA_UNPIN, ImVec2(15, 15), back, ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 128), drawCol_Down, -1, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
					{
						//PE: Delete pinned category.
						extern std::vector<std::string> files_pinned_categories;
						char tmp[2];
						tmp[0] = it->second->type + '0';
						tmp[1] = 0;
						cstr namelower = cstr(Lower(it->second->real_name)) + cstr(tmp);
						for (int i = 0; i < files_pinned_categories.size(); i++)
						{
							cstr check = cstr((char *)files_pinned_categories[i].c_str()).Lower();
							if (namelower == check)
							{
								files_pinned_categories.erase(files_pinned_categories.begin() + i);
							}
						}
						saveVectorFileContent("pinnedlist.ini", files_pinned_categories);
						it->second->bPinned = false;
						bTreeViewInitInNextFrame = true;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Unpin Category");
				}
				else
				{
					if (ImGui::ImgBtn(MEDIA_PIN, ImVec2(15, 15), back, ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 128), drawCol_Down, -1, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
					{
						//PE Save pinned category.
						extern std::vector<std::string> files_pinned_categories;
						char tmp[2];
						tmp[0] = it->second->type + '0';
						tmp[1] = 0;
						cstr name = cstr(it->second->real_name) + cstr(tmp);
						files_pinned_categories.push_back(name.Get());
						saveVectorFileContent("pinnedlist.ini", files_pinned_categories);
						it->second->bPinned = true;
						bTreeViewInitInNextFrame = true;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Pin Category");
				}
				ImGui::PopID();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0, -8.0));

				if (TreeNodeOpen) 
				{
					ImGui::Indent(-5);
					if (parentid != it->second->id)	DoTreeNode(it->second->id, ignore, ignore2);
					ImGui::Indent(5);
					ImGui::TreePop();
				}
			}
		}
	}
	return(0);
}

bool DoTreeNodeSearch(int parentid, char *lookup)
{
	for (auto it = root_folders.begin(); it != root_folders.end(); ++it)
	{
		bool bValid = false;
		it->second->bUsed = false;

		int iCompareType = iDisplayLibraryType;
		if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1) iCompareType = 6; // Select only animation files when subtype=1
		if (it->second->type == iCompareType && (it->second->parentid == parentid || (it->second->bPinned && parentid == 0)))
		{
			//Pinned level 0 display as is.

			ImGuiTreeNodeFlags node_flags = ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_OpenOnArrow;
			if (it->second->folders <= 0)
				node_flags = ImGuiTreeNodeFlags_Leaf;
			if (seleted_tree_item == it->second->id)
				node_flags |= ImGuiTreeNodeFlags_Selected;
			else
				node_flags &= ~ImGuiTreeNodeFlags_Selected;

			//ImRect frame_bb = ImRect(ImGui::GetWindowPos()+ImGui::GetCursorPos(), ImGui::GetWindowPos() + ImGui::GetCursorPos() + ImVec2(ImGui::GetContentRegionAvailWidth(), ImGui::GetFontSize()) );
			ImGui::PushItemWidth(-20.0);

			std::string treename = it->second->show_name;

			if (parentid != 0) bValid = true;
			if (parentid == 0 && lookup && treename == lookup) bValid = true;

			if (bValid)
			{
				it->second->bUsed = true;

				if (it->second->bPinned)
				{
					treename = it->second->real_name;
					treename[0] = toupper(treename[0]);
				}
				bool TreeNodeOpen = ImGui::TreeNodeEx((void*)(intptr_t)it->second->id, node_flags, treename.c_str());
				ImGui::PopItemWidth();
				//PE: Select on mouse release.
				if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(0))
				{
					seleted_tree_item = it->second->id;
					strcpy(cSearchAllEntities[0], it->second->real_name);
					bUpdateSearchSorting = true;
					bUpdateSearchScrollbar = true;
				}

				if (TreeNodeOpen) 
				{
					ImGui::Indent(-5);
					if (parentid != it->second->id)
						DoTreeNodeSearch(it->second->id, lookup);
					ImGui::Indent(5);
					ImGui::TreePop();
				}
			}
		}
	}
	return(0);
}

bool bDisplayFavorite = false;

void process_gotopurchaedandrefreshtopurchases ( void )
{
	seleted_tree_item = -1;
	strcpy(cSearchAllEntities[0], "Purchased");
	bDisplayFavorite = false;
	bViewAllFolders = false;
	bViewShowcase = false;
	bViewPurchased = true;
	bUpdateSearchSorting = true;
	bUpdateSearchScrollbar = true;
}

bool bPopModalOpenEntity = false;
void process_entity_library_v2(void)
{


	static int iStopVideoInNextFrame = 0;
	static int iStartVideoInNextFrame = 0;
	static int iVideoGetFirstFrame = 0;
	static int iVideoThumbID = 0;
	static cstr sVideoLoadName = "";

	if (iStopVideoInNextFrame > 0 && iVideoGetFirstFrame == 0)
	{
		if (AnimationExist(iStopVideoInNextFrame))
		{
			StopAnimation(iStopVideoInNextFrame);
			DeleteAnimation(iStopVideoInNextFrame);
		}
		SetVideoVolume(100.0);
		iStopVideoInNextFrame = 0;
	}

	if (iStartVideoInNextFrame && iVideoGetFirstFrame == 0)
	{
		iVideoThumbID = 0;

		for (int itl = 1; itl <= 32; itl++)
		{
			if (AnimationExist(itl) == 0) { iVideoThumbID = itl; break; }
		}
		if (LoadAnimation((char *)sVideoLoadName.Get(), iVideoThumbID, g.videoprecacheframes, 0, 1) == false)
		{
			iVideoThumbID = -999;
		}
		if (iVideoThumbID > 0)
		{
			PlaceAnimation(iVideoThumbID, -1, -1, -1, -1);
			//Try to get first frame.
			StopAnimation(iVideoThumbID);
			SetVideoVolume(100.0);
			PlayAnimation(iVideoThumbID);
			SetRenderAnimToImage(iVideoThumbID, true);

			UpdateAllAnimation();
			Sleep(50); //Sleep so we get a video texture in the next call.
			UpdateAllAnimation();
			iStartVideoInNextFrame = 0;
			PlayAnimation(iVideoThumbID);
			SetVideoVolume(100.0);
		}
	}

	static bool bLargePreview = false;
	bool bCheckGotoPreview = false;

	if (sGotoPreviewWithFile != "")
	{
		if (!bLargePreview)
		{
			bExternal_Entities_Window = true;
			iDisplayLibraryType = 0;
			iDisplayLibrarySubType = 0;
			bCheckGotoPreview = true;
		}
	}


	if (bExternal_Entities_Window)
	{
		/*if (!g_bPreviewLighting)
		{
			visualsdatastoragetype desiredVisuals;
			set_temp_visuals(t.editorvisuals, t.visualsStorage, desiredVisuals);
			set_temp_visuals(t.visuals, t.visualsStorage, desiredVisuals);
			g_bPreviewLighting = true;
		}*/
	
		//PE:As we can switch type on the fly, make sure to free object images when we switch.
		static int iOldDisplayLibraryType = -1;
		static int iOldDisplayLibrarySubType = -1;
		if (iDisplayLibraryType != iOldDisplayLibraryType || iDisplayLibrarySubType != iOldDisplayLibrarySubType)
		{
			iOldDisplayLibraryType = iDisplayLibraryType;
			iOldDisplayLibrarySubType = iDisplayLibrarySubType;
			FreeTempImageList();
			iRestoreEntidMaster = g.entidmaster; //Start over.
			bUpdateSearchSorting = true;
		}
		if (g_TempimageList.size() == 0)
		{
			g_TempimageList = g_imageList;
			iRestoreEntidMaster = g.entidmaster; //PE: Mark where we are.
		}
		//PE: Make sure we dont use all memory.
		//PE: 03-18-2021: Decreased from 50 to 20 as some users reported it used all there memory.
		if (!bLoopBackBuffer && g_imageList.size() > g_TempimageList.size() + 20)
		{
			//PE: After we cached 50 textures free all so we dont run out of mem. We might auto generate 1000 thumbs :)
			//PE: This is like allowing around 15 fpe with objects textures to be cached.
			FreeTempImageList();
			iRestoreEntidMaster = g.entidmaster; //Start over.
		}


		ImGuiWindowFlags ex_window_flags = ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking;
		ImGuiIO& io = ImGui::GetIO();

		static bool bDoneOneThumbPerSync;
		static int iDeleteInNextUpdate = 0;
		static int uniqueId = 4000; //PE: Also used for imageID for previews.
		static int loaded_images = 0;
		static bool multi_selections = false;
		int multi_selections_count = 0;
		static int lf_multi_selections_count = 0;
		int olduniqueId = uniqueId;
		bool bReleaseIconsDynamic = false;

		//uniqueId (imageid) range goes from 4000-43000 MAX.
		uniqueId = 4000;
		if (iDisplayLibraryType == 2)
		{
			uniqueId += 6000;
		}
		if (iDisplayLibraryType == 1)
		{
			uniqueId += 12000;
		}
		if (iDisplayLibraryType == 3)
		{
			uniqueId += 18000;
		}
		if (iDisplayLibraryType == 4)
		{
			uniqueId += 24000;
		}
		if (iDisplayLibraryType == 5)
		{
			uniqueId += 30000;
		}

#ifdef DYNAMICLOADUNLOAD
		static int max_load_persync = 200; //First time only , changed later to 15
		bReleaseIconsDynamic = true;
#else
		int max_load_persync = 2000;
#endif

		if (iDisplayLibraryType == 3)
		{
			//Generating of video preview, could take some time so one per frame.
			max_load_persync = 1;
		}
		else if (iDisplayLibraryType == 2)
		{
			//Loading images takes to long, max one per sync. perhaps use preloader here ?
			max_load_persync = 1;
		}
		else if (iDisplayLibraryType == 4)
		{
			//Only Loading thumbs.
			max_load_persync = 10;
		}
		else if (iDisplayLibraryType == 5)
		{
			//Only Loading thumbs.
			max_load_persync = 10;
		}
		else
		{
			if (max_load_persync != 200)
				max_load_persync = 10;
		}

		int preview_count = 0;
		int media_icon_size = 64;
		int media_icon_size_y = 32;
		int thumb_x = 512;
		int thumb_y = 288;
		int iColumnsWidth = 110;

		bDoneOneThumbPerSync = false;

		if (iDeleteInNextUpdate > 0)
		{
			image_setlegacyimageloading(true);
			DeleteImage(iDeleteInNextUpdate);
			image_setlegacyimageloading(false);
			iDeleteInNextUpdate = 0;
		}

		time_t tCurrentTimeSec;
		time(&tCurrentTimeSec);

		static int iLargePreviewImageID = false;
		static cFolderItem::sFolderFiles * pPreviewFile = NULL;
		static bool bStartAnimation = false;
		static int iAnimationSet = 0;
		static bool bAnimationAll = true;
		static bool bLoopAnim = true;
		static int iGetTriangles = 0;
		static int iGetVertex = 0;
		static int iGetLodLevels = 0;
		static cstr cGetTextureSize;
		static int iLowestAnimFrame = 0, iHigestAnimFrame = 0;
		static cstr cCurrentBackDrop = "None";
		bool bImagesStillInImGuiQueue = false;

		//bUpdateSearchSorting = false; // cleared later so other funcs can set this to trigger
		static int current_sortby = 1;

		static cFolderItem::sFolderFiles * firstvisiblefile = NULL;
		static cFolderItem::sFolderFiles * scrolltofile = NULL;
		static cFolderItem::sFolderFiles * secondscrolltofile = NULL;
		static bool bScrollInNextFrame = false;
		firstvisiblefile = NULL;

		bool bAdvancedFPEFeatures = true;
		static bool bUpdateSearchAfterFPEScan = false;
		if (fpe_thread_in_progress())
		{
			bAdvancedFPEFeatures = false;
			bUpdateSearchAfterFPEScan = true;
		}
		else
		{
			if (bUpdateSearchAfterFPEScan)
			{
				bUpdateSearchAfterFPEScan = false;
				bUpdateSearchSorting = true;
			}
		}

		static char cCheckboxFilters[5][MAX_PATH];
		static bool bCheckboxFilters[5] = { true,true,true,true,true };

		//When changing media type , always refresh search results.

		if (iLastDisplayLibraryType != iDisplayLibraryType)
		{
			//Reset search
			iLastDisplayLibraryType = iDisplayLibraryType;
			bUpdateSearchSorting = true;
			bUpdateSearchScrollbar = true;
			strcpy(cSearchAllEntities[0], "");
			strcpy(cSearchAllEntities[1], "");
			strcpy(cSearchAllEntities[2], "");

			static bool bRestoreSearchOnLaunch = true;

			//PE: sStartLibrarySearchString can overwrite cRememberLastSearchObjects.
			if (iDisplayLibraryType == 0)
			{
				if (bRestoreSearchOnLaunch)
				{
					if(strlen(pref.cRememberLastSearchObjects) >  0)
						strcpy(cSearchAllEntities[0], pref.cRememberLastSearchObjects);
					for (int i = 0; i < 5; i++)
						bCheckboxFilters[i] = pref.iCheckboxFilters[i];

					bRestoreSearchOnLaunch = false;
				}
			}

			if (sStartLibrarySearchString != "")
			{
				strcpy(cSearchAllEntities[0], sStartLibrarySearchString.Get());
				sTriggerCategorySelect = sStartLibrarySearchString;
				seleted_tree_item = -1;
				sStartLibrarySearchString = "";
				bDisplayFavorite = false; //Disable favorite. so we see real search list.
			}
		}
		else
		{
			if (iDisplayLibraryType == 2)
			{
				//if image always use sStartLibrarySearchString.
				if (sStartLibrarySearchString != "")
				{
					strcpy(cSearchAllEntities[0], sStartLibrarySearchString.Get());
					sTriggerCategorySelect = sStartLibrarySearchString;
					seleted_tree_item = -1;
					sStartLibrarySearchString = "";
					bDisplayFavorite = false; //Disable favorite. so we see real search list.
				}
			}
		}

		//#########################################
		//#### Large preview window of objects ####
		//#########################################

		if (bLargePreview)
		{
			bImGuiGotFocus = true;
			bool bIsCCPObject = false;

			if (!bPopModalOpenEntity)
			{
				ImGui::OpenPopup("##Preview##DisModalMode");
				ImGui::SetNextWindowSize(ImVec2(1320.0f, 0), ImGuiCond_Always);
				bStartAnimation = false;
				bAnimationAll = true;
				iAnimationSet = 0;
				iGetTriangles = 0;
				iGetVertex = 0;
				iGetLodLevels = 0;
				sObject* pObject = g_ObjectList[BackBufferObjectID];
				if (ObjectExist(BackBufferObjectID))
				{
					iGetTriangles = GetObjectPolygonCount(BackBufferObjectID);
					iGetVertex = GetObjectTotalVertexCount(BackBufferObjectID);
					iGetLodLevels = GetLodLevels(BackBufferObjectID);

					//Get texture plate size from wicked.
					cGetTextureSize = "Texture Plate Size: ";

					if (pObject)
					{
						// Ensure that the characters created are rendered with double siced hair:
						if (sGotoPreviewWithFile != "")
						{
							if (strstr(sGotoPreviewWithFile.Get(), "entitybank\\user"))
							{
								if (FileOpen(1) == 1) CloseFile(1);

								OpenToRead(1, sGotoPreviewWithFile.Get());
								while (FileEnd(1) == 0)
								{
									t.tline_s = ReadString(1);
									t.tcciStat_s = Lower(FirstToken(t.tline_s.Get(), " "));
									if (t.tcciStat_s == "ccpassembly")
									{
										bIsCCPObject = true;

										t.entityprofile[BackBufferEntityID].thumbnailbackdrop = "Blue spotlight.dds";
									
										// this is a character creator creation!!
										for (int i = 0; i < pObject->iFrameCount; i++)
										{
											if (strstr(pObject->ppFrameList[i]->szName, "hair"))
											{
												wiScene::MeshComponent* mesh = wiScene::GetScene().meshes.GetComponent(pObject->ppFrameList[i]->pMesh->wickedmeshindex);
												if (mesh)
												{
													// Set the meshes double sided so that the hair renders correctly.
													mesh->SetDoubleSided(true);
												}
											}
										}
										break;
									}
								}
								CloseFile(1);
							}
						}
						
						sMesh* pMesh = NULL;
						for (int i = 0; i < pObject->iFrameCount; i++)
						{
							if (pObject->ppFrameList[i]->pMesh && pObject->ppFrameList[i]->pMesh->wickedmeshindex > 0)
							{
								pMesh = pObject->ppFrameList[i]->pMesh;
								break;
							}
						}
						if (pMesh)
						{
							wiScene::MeshComponent* mesh = wiScene::GetScene().meshes.GetComponent(pMesh->wickedmeshindex);
							if (mesh)
							{
								uint64_t materialEntity = mesh->subsets[0].materialID;
								wiScene::MaterialComponent* pObjectMaterial = wiScene::GetScene().materials.GetComponent(materialEntity);
								if (pObjectMaterial)
								{
									if (pObjectMaterial->textures[0].resource) // MaterialComponent::BASECOLORMAP].resource)
									{
										wiGraphics::Texture* texture;
										//texture = (wiGraphics::Texture*) &pObjectMaterial->textures[0].resource;// pObjectMaterial->GetBaseColorMap();
										texture = (wiGraphics::Texture*) pObjectMaterial->textures[0].GetGPUResource();
										if (texture)
										{
											int width, height;
											width = (int)texture->GetDesc().Width;
											height = (int)texture->GetDesc().Height;
											cGetTextureSize = cGetTextureSize + cstr(width) + "x" + cstr(height);
										}
									}
								}
							}
						}
					}
				}
				if (ObjectExist(BackBufferObjectID) && GetNumberOfFrames(BackBufferObjectID) > 0 && t.entityprofile[BackBufferEntityID].animmax > 0)
				{
					//PE: Stop any running animations.
					SetObjectFrame(BackBufferObjectID, 0);
					StopObject(BackBufferObjectID);
					iHigestAnimFrame = 0;
					for (int n = 0; n < t.entityprofile[BackBufferEntityID].startofaianim; n++)
					{
						if (t.entityanim[BackBufferEntityID][n].finish > iHigestAnimFrame)
							iHigestAnimFrame = t.entityanim[BackBufferEntityID][n].finish;
					}
					//PE: Lowest in wicked is always 0 , some fpe have -1, always assume 0 as start for ALLAnimations.
					iLowestAnimFrame = 0;
				}

				fpe_current_loaded_script = -1; //Make sure dlua is loaded in next call to DisplayFPEBehavior.
				if (pObject)
				{
					Wicked_Copy_Material_To_Grideleprof((void*)pObject, 0);
					Wicked_Set_Material_From_grideleprof((void*)pObject, 0); //Set default selected mesh , for material.
				}

				cCurrentBackDrop = "None";
				
				t.addentityfile_s = t.entitybank_s[BackBufferEntityID];
				cFolderItem *pNewFolder = &MainEntityList;
				pNewFolder = pNewFolder->m_pNext;
				pNewFolder = pNewFolder->m_pNext;
				bool bGetOut = false;
				while (pNewFolder)
				{
					if (pNewFolder->m_pFirstFile)
					{
						cFolderItem::sFolderFiles * myfiles = NULL;
						myfiles = pNewFolder->m_pFirstFile->m_pNext;
						while (myfiles)
						{
							if (myfiles->iPreview > 0)
							{
								cstr check = myfiles->m_sPath + cstr("\\") + myfiles->m_sName;
								//if (myfiles->m_sPath == t.addentityfile_s)
								if (pestrcasestr(check.Get(), t.addentityfile_s.Get()))
								{
									//Set default backdrop.
									if (myfiles->m_Backdrop.Len() > 0 && myfiles->m_Backdrop != "None")
									{
										CreateBackdropObject(false, cstr("texturebank\\backdrops\\") + myfiles->m_Backdrop, t.addentityfile_s); //PE: We need a extra frame, as we set the material dirty in this call.
										cCurrentBackDrop = myfiles->m_Backdrop;
										cstr importer_getfilenameonly(LPSTR pFileAndPossiblePath);
										cCurrentBackDrop = importer_getfilenameonly(cCurrentBackDrop.Get());
									}
									else
									{
										//CreateBackdropObject(false, "Blue spotlight.dds", t.addentityfile_s);
										//cCurrentBackDrop = "Blue spotlight.dds";
										CreateBackdropObject(false, "None", t.addentityfile_s);
										cCurrentBackDrop = "None";
									}
									bGetOut = true;
								}
							}
							if (bGetOut) break;
							myfiles = myfiles->m_pNext;
						}
					}
					if (bGetOut) break;
					pNewFolder = pNewFolder->m_pNext;
				}

				if (!(t.entityprofile[BackBufferEntityID].BackBufferZoom == -1.0f && t.entityprofile[BackBufferEntityID].BackBufferCamLeft == -1.0f && t.entityprofile[BackBufferEntityID].BackBufferRotateX == -1.0f))
				{
					//Found settings, set restore.
					RestoreBackBufferZoom = t.entityprofile[BackBufferEntityID].BackBufferZoom;
					RestoreBackBufferCamLeft = t.entityprofile[BackBufferEntityID].BackBufferCamLeft;
					RestoreBackBufferCamUp = t.entityprofile[BackBufferEntityID].BackBufferCamUp;
					RestoreBackBufferRotateX = t.entityprofile[BackBufferEntityID].BackBufferRotateX;
					RestoreBackBufferRotateY = t.entityprofile[BackBufferEntityID].BackBufferRotateY;
					bBackBufferRestoreCamera = true; //Restore from fpe settings in next call.
				}

				//Check if we can default to animset 1 and set pose.
				if (ObjectExist(BackBufferObjectID) && GetNumberOfFrames(BackBufferObjectID) > 0 && t.entityprofile[BackBufferEntityID].animmax > 0)
				{
					iAnimationSet = 0;
					bAnimationAll = false;
					//Set pose dont start anim.
					int iFrameStart = t.entityanim[BackBufferEntityID][iAnimationSet].start;
					SetObjectFrame(BackBufferObjectID, iFrameStart);
				}
				if (ObjectExist(BackBufferObjectID) && GetNumberOfFrames(BackBufferObjectID) > 0 && t.entityprofile[BackBufferEntityID].animmax > 0)
				{
					if (t.entityprofile[BackBufferEntityID].iThumbnailAnimset >= 0 && t.entityprofile[BackBufferEntityID].iThumbnailAnimset < t.entityprofile[BackBufferEntityID].startofaianim)
					{
						// new method uses name instead of fixed values
						if (t.entityprofile[BackBufferEntityID].playanimineditor == -1)
						{
							// uses name instead of index, the negative is the ordinal into the animset
							extern void entity_loop_using_negative_playanimineditor(int e, int obj, cstr animname);
							entity_loop_using_negative_playanimineditor(0, BackBufferObjectID, t.entityprofile[BackBufferEntityID].playanimineditor_name);
						}
						else
						{
							iAnimationSet = t.entityprofile[BackBufferEntityID].iThumbnailAnimset;
							bAnimationAll = false;
							int iFrameStart = t.entityanim[BackBufferEntityID][iAnimationSet].start;
							int iFrameEnd = t.entityanim[BackBufferEntityID][iAnimationSet].finish;
							SetObjectFrame(BackBufferObjectID, iFrameStart);
							//Start selected animation
							LoopObject(BackBufferObjectID, iFrameStart, iFrameEnd);
						}
						bStartAnimation = true;
					}
					if (bStartAnimation == true)
					{
						if (t.entityprofile[BackBufferEntityID].animspeed > 0)
						{
							SetObjectSpeed(BackBufferObjectID, t.entityprofile[BackBufferEntityID].animspeed);
						}
					}
				}

				if (cCurrentBackDrop == "None" && t.entityprofile[BackBufferEntityID].thumbnailbackdrop.Len() > 0 && t.entityprofile[BackBufferEntityID].thumbnailbackdrop != "None")
				{
					cCurrentBackDrop = t.entityprofile[BackBufferEntityID].thumbnailbackdrop;
					CreateBackdropObject(false, cstr("texturebank\\backdrops\\") + cCurrentBackDrop, t.addentityfile_s);
				}

			}

			static bool bTriggerResize = false;
			if (bTriggerResize)
			{
				ImGui::SetNextWindowSize(ImVec2(1320.0f, 612.0f), ImGuiCond_Always);
				bTriggerResize = false;
			}
			//ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse |
			int addflags = 0;
			if (sGotoPreviewWithFile != "")
			{
				addflags = ImGuiWindowFlags_NoTitleBar;
			}
			bPopModalOpenEntity = ImGui::BeginPopupModal("##Preview##DisModalMode", &bLargePreview, ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize | addflags);
			if (bPopModalOpenEntity)
			{
				if (addflags == ImGuiWindowFlags_NoTitleBar)
				{
					ImGui::Text("");
				}
				ImVec2 cur_size = ImGui::GetWindowSize();
				if (cur_size.y < 200.0f)
				{
					//Trigger resize.
					bTriggerResize = true;
				}
				grideleprof_uniqui_id = 45000; //Always use unique IDs.
				float fPreviewImgSize = 1024.0f;

				//// Load the importer back up with the last imported model.
				//if (!bIsCCPObject)
				//{
				//	ImGui::SetCursorPos(ImVec2(15, 2));
				//	int icon_size = ImGui::GetFontSize()*2;
				//	ImVec2 VIconSize = { (float)icon_size, (float)icon_size };
				//	ImVec2 cursor = ImGui::GetCursorPos();

				//	if (ImGui::ImgBtn(TOOL_GOBACK, VIconSize, ImVec4(0, 0, 0, 0), ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(1.0f, 1.0f, 1.0f, 0.5f),
				//		ImVec4(0.5f, 0.5f, 0.5f, 0.5f), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
				//	{
				//		bExternal_Entities_Window = false;
				//		bLargePreview = false;
				//		sGotoPreviewWithFile = "";
				//		bImporter_Window = true;
				//		extern void importer_quit_for_reload(LPSTR pOptionalCopyModelFile);
				//		iLaunchAfterSync = 8;
				//		extern sImportedObjectData g_Data;
				//		cstr file = cstr(g_Data.cImportPath) + t.tSourceName_s;
				//		strcpy(pLaunchAfterSyncPreSelectModel, file.Get());
				//		strcpy(pLaunchAfterSyncPreSelectModel, pLaunchAfterSyncLastImportedModel);
				//		importer_quit_for_reload(pLaunchAfterSyncPreSelectModel);
				//		/*importer_quit_for_reload(file.Get());*/
				//		//extern char pLaunchAfterSyncLastImportedModel[MAX_PATH];
				//		//strcpy(pOptionalCopyModelFile, pLaunchAfterSyncLastImportedModel);
				//		
				//	}
				//	if (ImGui::IsItemHovered()) ImGui::SetTooltip("Back to Importer");
				//}

				ImGui::Columns(2, "PreviewColumns", false);  //false no border
				ImGui::SetColumnOffset(0, 0.0f);
				ImGui::SetColumnOffset(1, fPreviewImgSize);

				if (ImageExist(iLargePreviewImageID))
				{
					bLoopFullFPS = false;
					float fMoveSpeed = 512.0f;
					float ImgX = ImageWidth(iLargePreviewImageID);
					float ImgY = ImageHeight(iLargePreviewImageID);
					float Ratio = fPreviewImgSize / ImgX;
					ImgY *= Ratio;
					ImGui::ImgBtn(iLargePreviewImageID, ImVec2(fPreviewImgSize, ImgY), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), 0, 0, 0, 0, false);
					if (ImGui::IsItemActive() && ImGui::IsMouseDown(0) && ImGui::IsMouseDragging(0))
					{
						//PE: Some object rotate inverted Pivot ?
						BackBufferRotateY -= ImGui::GetIO().MouseDelta.x / fMoveSpeed * (360.0f*g.timeelapsed_f);
						if (BackBufferRotateY < 0) BackBufferRotateY += 360.0;
						if (BackBufferRotateY > 360.0) BackBufferRotateY -= 360.0;

						if (t.entityprofile[BackBufferEntityID].ischaracter == 0) {
							BackBufferRotateX -= ImGui::GetIO().MouseDelta.y / fMoveSpeed * (360.0f*g.timeelapsed_f);
							if (BackBufferRotateX < 0) BackBufferRotateX += 360.0;
							if (BackBufferRotateX > 360.0) BackBufferRotateX -= 360.0;
						}
						bLoopFullFPS = true;
					}

					static float fMoveBackbufferToLeft = 0.0f, fMoveBackbufferToUp = 0.0f;
					static float BackBufferCamLeftOld = 0.0f, BackBufferCamUpOld = 0.0f;
					float fCamDistance = BackBufferCamMove * 0.5 - BackBufferZoom;
					//fCamDistance *= 0.475; //
					fCamDistance *= (0.70*g.timeelapsed_f);
					if (fCamDistance < 50.0f) fCamDistance = 50.0f;

					if (ImGui::IsMouseDown(1) && ImGui::IsItemHovered() && ImGui::IsMouseDragging(1))
					{
						//BackBufferCamLeft += ImGui::GetIO().MouseDelta.x / fMoveSpeed * 160.0f;
						//BackBufferCamUp += ImGui::GetIO().MouseDelta.y / fMoveSpeed * 160.0f;

						//PE: Use inertia slerp
						fMoveBackbufferToLeft = fMoveBackbufferToLeft + ImGui::GetIO().MouseDelta.x / fMoveSpeed * fCamDistance;
						BackBufferCamLeft = ImLerp(fMoveBackbufferToLeft, BackBufferCamLeftOld, 0.85);
						BackBufferCamLeftOld = BackBufferCamLeft;

						fMoveBackbufferToUp = fMoveBackbufferToUp + ImGui::GetIO().MouseDelta.y / fMoveSpeed * fCamDistance;
						BackBufferCamUp = ImLerp(fMoveBackbufferToUp, BackBufferCamUpOld, 0.85);
						BackBufferCamUpOld = BackBufferCamUp;

						bLoopFullFPS = true;
						ImGui::SetMouseCursor(ImGuiMouseCursor_Pan);
					}
					else {
						fMoveBackbufferToLeft = BackBufferCamLeftOld = BackBufferCamLeft;
						fMoveBackbufferToUp = BackBufferCamUpOld = BackBufferCamUp;
					}

					if (ImGui::IsItemHovered() && ImGui::GetIO().MouseWheel != 0)
					{
						float speed = BackBufferCamMove / 30.0f; //Depent on object size. Now faster (/ 50.0f)
						if (io.KeyShift)
							speed *= 2.0; //Faster when using shift.
						speed *= g.timeelapsed_f;
						BackBufferZoom += ImGui::GetIO().MouseWheel*speed;
						bLoopFullFPS = true;
					}
					//ImGui::Text("fCamDistance: %f", fCamDistance);
					//ImGui::Text("g.timeelapsed_f: %f", g.timeelapsed_f);

				}

				ImGui::Spacing();

				ImGui::NextColumn();

				ImGui::BeginChild("##ChildNewFPEPropertiesPanel", ImVec2(0, 0), false, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoNavInputs); //ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar
				
				std::string sString;
				
				if (ImGui::StyleCollapsingHeader("Backdrop", ImGuiTreeNodeFlags_DefaultOpen))
				{
					GetFilesListForLibrary("texturebank\\backdrops\\", true);
					ImGui::Indent(10);
					ImGui::TextCenter("Static Image");
					ImGui::PushItemWidth(-10);
					//cstr cRet = ListboxFilesListForLibrary(cCurrentBackDrop.Get());
					cstr cRet = ComboFilesListForLibrary(cCurrentBackDrop.Get(), 6, 120, true);
					if (cRet != cCurrentBackDrop)
					{
						t.addentityfile_s = t.entitybank_s[BackBufferEntityID];
						cCurrentBackDrop = cRet;
						CreateBackdropObject(true, cstr("texturebank\\backdrops\\") + cCurrentBackDrop, t.addentityfile_s);
						if (!ImageExist(BACKDROPMAGE))
						{
							cCurrentBackDrop = "None";
						}
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select static image for object backdrop");

					if (bBackbufferCubemapActive)
					{
						t.addentityfile_s = t.entitybank_s[BackBufferEntityID];
						sString = t.addentityfile_s.Get();
						replaceAll(sString, ".fpe", "_fpe_cube.dds");
					}
					else
						sString = "";

					//#### Keywords ####
					cstr cTmp = t.entityprofile[BackBufferEntityID].keywords_s;
					cTmp = imgui_setpropertystring2_v2(0, cTmp.Get(), "Keywords", "Enter additional keywords, separated by commas.", false);
					if (cTmp != t.entityprofile[BackBufferEntityID].keywords_s)
					{
						t.entityprofile[BackBufferEntityID].keywords_s = cTmp;
					}

					ImGui::PopItemWidth();
					ImGui::Indent(-10);
					ImGui::Text("");
				}

				if (ObjectExist(BackBufferObjectID) && GetNumberOfFrames(BackBufferObjectID) > 0 && t.entityprofile[BackBufferEntityID].animmax > 0)
				{
					//PE: Make sure we set anim speed. we only use parent object in this system.
					t.tanimspeed_f = t.entityprofile[BackBufferEntityID].animspeed;
					if (ObjectExist(BackBufferObjectID) == 1)
					{
						SetObjectSpeed(BackBufferObjectID, t.tanimspeed_f);
					}

					if (strstr(sGotoPreviewWithFile.Get(), "charactercreatorplus"))
						bIsCCPObject = true;
				
					if (!bIsCCPObject)
					{
						if (t.entityprofile[BackBufferEntityID].playanimineditor == -1)
						{
							// if object has a named animation, no control allowed, it will play!
							//extern void entity_loop_using_negative_playanimineditor(int e, int obj, cstr animname);
							//entity_loop_using_negative_playanimineditor(0, BackBufferObjectID, t.entityprofile[BackBufferEntityID].playanimineditor_name);
						}
						else
						{
							if (ImGui::StyleCollapsingHeader("Animations", ImGuiTreeNodeFlags_DefaultOpen))
							{
								ImGui::Indent(10);

								static int iFrameCurrent = 0;
								float fFontSize = ImGui::GetFontSize();
								int iFrameStart = t.entityanim[BackBufferEntityID][iAnimationSet].start;
								int iFrameEnd = t.entityanim[BackBufferEntityID][iAnimationSet].finish;
								if (bAnimationAll)
								{
									iFrameStart = iLowestAnimFrame;
									iFrameEnd = iHigestAnimFrame;
								}

								cstr sComboName = cstr("Animation ") + cstr(iAnimationSet) + " (" + cstr(iFrameStart) + "," + cstr(iFrameEnd) + ")";
								cstr sComboNameAll = cstr("All Animations ") + " (" + cstr(iLowestAnimFrame) + "," + cstr(iHigestAnimFrame) + ")";
								if (bAnimationAll)
									sComboName = sComboNameAll;

								ImGui::PushItemWidth(-10 - fFontSize - 8.0f);
								if (ImGui::BeginCombo("##animcomboselection", sComboName.Get())) // The second parameter is the label previewed before opening the combo.
								{
									if (ImGui::Selectable(sComboNameAll.Get(), bAnimationAll))
									{
										iFrameStart = iLowestAnimFrame;
										iFrameEnd = iHigestAnimFrame;
										bAnimationAll = true;
										SetObjectFrame(BackBufferObjectID, iLowestAnimFrame);
										if (bStartAnimation)
										{
											LoopObject(BackBufferObjectID, iLowestAnimFrame, iHigestAnimFrame);
										}
									}
									for (int n = 0; n < t.entityprofile[BackBufferEntityID].startofaianim; n++)
									{
										cstr sComboName = cstr("Animation ") + cstr(n) + " (" + cstr(t.entityanim[BackBufferEntityID][n].start) + "," + cstr(t.entityanim[BackBufferEntityID][n].finish) + ")";
										bool is_selected = (!bAnimationAll && iAnimationSet == n);
										if (ImGui::Selectable(sComboName.Get(), is_selected))
										{
											iAnimationSet = n;
											bAnimationAll = false;
											iFrameStart = t.entityanim[BackBufferEntityID][iAnimationSet].start;
											iFrameEnd = t.entityanim[BackBufferEntityID][iAnimationSet].finish;
											SetObjectFrame(BackBufferObjectID, iFrameStart);
											if (bStartAnimation)
											{
												//Start any animation
												LoopObject(BackBufferObjectID, iFrameStart, iFrameEnd);
											}
										}
										if (is_selected)
											ImGui::SetItemDefaultFocus();   // You may set the initial focus when opening the combo (scrolling + for keyboard navigation support)
									}
									ImGui::EndCombo();
								}
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Animation");
								ImGui::PopItemWidth();

								ImGui::SameLine();

								if (!bStartAnimation)
								{
									if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(fFontSize, fFontSize), ImColor(255, 255, 255, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 128), drawCol_Down, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
									{
										//SetObjectFrame(BackBufferObjectID, iFrameStart);
										SetObjectFrame(BackBufferObjectID, iFrameCurrent);
										LoopObject(BackBufferObjectID, iFrameStart, iFrameEnd);

										bStartAnimation = true;
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("Play Animation");

								}
								else
								{
									if (ImGui::ImgBtn(MEDIA_PAUSE, ImVec2(fFontSize, fFontSize), ImColor(255, 255, 255, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 128), drawCol_Down, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
									{
										//SetObjectFrame(BackBufferObjectID, iFrameStart);
										//LoopObject(BackBufferObjectID);
										StopObject(BackBufferObjectID);
										SetObjectFrame(BackBufferObjectID, iFrameCurrent);
										bStartAnimation = false;
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("Pause Animation");
								}


								//PE: Wicked dont stop animation by itself so.
								sObject* pObject = g_ObjectList[BackBufferObjectID];
								WickedCall_CheckAnimationDone(pObject);

								iFrameCurrent = WickedCall_GetObjectFrame(pObject);
								ImGui::TextCenter("Current Animation Frame");
								if (bStartAnimation)
								{
									ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
									ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
								}
								ImGui::PushItemWidth(-10);

								if (ImGui::MaxSliderInputInt("##AnimFrame", &iFrameCurrent, iFrameStart, iFrameEnd, "Display Current Animation Frame"))
								{
									//If changed stop anim and display directly.
									StopObject(BackBufferObjectID);
									SetObjectFrame(BackBufferObjectID, iFrameCurrent);
									bStartAnimation = false;
								}

								ImGui::PopItemWidth();
								if (bStartAnimation)
								{
									ImGui::PopItemFlag();
									ImGui::PopStyleVar();
								}

								ImGui::Indent(-10);
								ImGui::Text("");
							}
						}
					}
				}

				//ImGui::TextCenter("Properties");
				entityeleproftype backup_grideleprof = t.grideleprof;
				int backup_entid = t.entid;
				int backup_gridentity = t.gridentity;

				t.entid = BackBufferEntityID;
				t.gridentity = BackBufferEntityID;

				entity_fillgrideleproffromprofile();
				imgui_set_openproperty_flags(t.gridentity);
				//ZJ: Removed following Rick's model importer feedback.
				//if (ImGui::StyleCollapsingHeader("Behavior", ImGuiTreeNodeFlags_DefaultOpen))
				//{
				//	ImGui::Indent(10);
				//	DisplayFPEBehavior(true, BackBufferEntityID);
				//	ImGui::Indent(-10);
				//}
				
				//PE: Only if active.
				if (t.entityprofile[BackBufferEntityID].ismarker == 0 && t.entityprofile[BackBufferEntityID].islightmarker == 0)
				{
					//ZJ: Removed following Rick's importer feedback.
					//if (ImGui::StyleCollapsingHeader("Physics", ImGuiTreeNodeFlags_DefaultOpen))
					//{
					//	ImGui::Indent(10);
					//	DisplayFPEPhysics(true, BackBufferEntityID);
					//	ImGui::Indent(-10);
					//}
				}
				//PE: Only if active.
				if (t.grideleprof.soundset_s.Len() > 0 || t.grideleprof.soundset1_s.Len() > 0 || t.grideleprof.soundset2_s.Len() > 0 || t.grideleprof.soundset3_s.Len() > 0)
				{
					if (!bIsCCPObject)
					{
						if (ImGui::StyleCollapsingHeader("Object's Media", ImGuiTreeNodeFlags_DefaultOpen))
						{
							ImGui::Indent(10);
							DisplayFPEMedia(true, BackBufferEntityID);
							ImGui::Indent(-10);
						}
					}
				}
				t.grideleprof = backup_grideleprof;
				t.gridentity = backup_gridentity;
				t.entid = backup_entid;

				// insert a keyboard shortcut component into panel
				UniversalKeyboardShortcut(eKST_ObjectLibrary);

				if (!bIsCCPObject)
				{
					ControlAdvancedSetting(pref.iFullscreenPreviewAdvanced, "advanced object library preview details", &bLargePreview);
					ImGui::Text("");
					if (pref.iFullscreenPreviewAdvanced)
					{
						cstr cTmp, cOrg = (char *)sString.c_str();
						cTmp = imgui_setpropertyfile2_v2(t.group, cOrg.Get(), "Cubemap Image", "Select a cube map texture file for use as the object backdrop", "\\", false);
						if (cTmp != cOrg)
						{
							// change cube map
							t.addentityfile_s = cstr("entitybank\\") + t.entitybank_s[BackBufferEntityID];
							std::string sDestination = t.addentityfile_s.Get();
							replaceAll(sDestination, ".fpe", "_fpe_cube.dds");
							if (FileExist(cTmp.Get()))
							{
								char pDestinationFile[10240];
								strcpy(pDestinationFile, sDestination.c_str());
								GG_GetRealPath(pDestinationFile, 1);
								extern char szWriteDir[MAX_PATH];
								if (!pestrcasestr(pDestinationFile, szWriteDir))
								{
									//This is not the DocWrite folder ?
								}
								else
								{
									if (FileExist(pDestinationFile))
									{
										//make backup - LB: commented out to avoid file bloat!
										//cstr backup = pDestinationFile;
										//backup = backup + ".bak";
										//bool bret = CopyFileA(&dest[0], backup.Get(), false);
									}

									//Wicked dont support DX10 but only DXT1 so try to convert cubemap.
									//PE: Did not work, still DX10 after save.
									/*
									image_setlegacyimageloading(true);
									SetMipmapNum(1); //PE: mipmaps not needed.
									LoadImage(cTmp.Get(), BACKDROPMAGE-1);
									SaveImage(dest, BACKDROPMAGE-1,1); //1=DTX1
									SetMipmapNum(-1);
									image_setlegacyimageloading(false);
									if (!FileExist(dest))
									{
										//Did not work , just copy.
										bool bret = CopyFileA(cTmp.Get(), &dest[0], false);
									}
									*/

									// copy chosen cube map to the new entity texture _cube.dds 
									bool bret = CopyFileA(cTmp.Get(), &pDestinationFile[0], false);

									// reload new textures
									cCurrentBackDrop = "None";
									t.addentityfile_s = t.entitybank_s[BackBufferEntityID];
									CreateBackdropObject(true, "None", t.addentityfile_s);
								}
							}
						}

						if (ImGui::StyleCollapsingHeader("Attributes", ImGuiTreeNodeFlags_DefaultOpen))
						{
							ImGui::Indent(10);
							{
								ImGui::Text("Triangles: %d", iGetTriangles);
								ImGui::Text("Vertices: %d", iGetVertex);
								ImGui::Text("LODs: %d", iGetLodLevels + 1);
								ImGui::Text("%s", cGetTextureSize.Get());
							}
							ImGui::Indent(-10);
						}

						sObject* pObject = g_ObjectList[BackBufferObjectID];
						if (pObject)
						{
							if (ImGui::StyleCollapsingHeader("Textures", ImGuiTreeNodeFlags_DefaultOpen))
							{
								ImGui::Indent(10);
								{
									Wicked_Copy_Material_To_Grideleprof((void*)pObject, 0);
									t.grideleprof.WEMaterial.MaterialActive = true;
									Wicked_Change_Object_Material((void*)pObject, 5);
								}
								ImGui::Indent(-10);
							}
						}
					}
				}
					//if (!pref.iFullscreenPreviewAdvanced && !bIsCCPObject)
				//{
				//	ImVec2 label_size = ImGui::CalcTextSize("Advanced Settings", NULL, true) + ImVec2(8.0f, 0.0f);
				//	ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvailWidth()*0.5) - (label_size.x*0.5), 0.0f));
				//	if (ImGui::HyberlinkButton("Advanced Settings##2", ImVec2(label_size.x, 0)))
				//	{
				//		extern int iSetSettingsFocusTab;
				//		extern bool bPreferences_Window;
				//		iSetSettingsFocusTab = 2;
				//		bPreferences_Window = true;
				//		//This is a modal window, so we need to close it to see the settings window.
				//		bLargePreview = false;
				//	}
				//	ImGui::Text("");
				//}

				// Update/Add To Library Button
				cstr sButLabel = "Update Thumbnail";
				if (sGotoPreviewWithFile != "")
				{
					// iGotoPreviewType : 1=CCP
					// ZJ: Updated labels because they imply that this stage is related to the importer.
					sButLabel = "Add to Object Library";
				}
				sButLabel += "##ObjectLibPreview";
				static int iUpdateFPESettings = 0;
				if (ImGui::StyleButton(sButLabel.Get(), ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					iUpdateFPESettings = 1;
					#ifdef WICKEDENGINE
					//PE: Need to solve reused objects/images before this, or we could crash :)
					//if (bImporter_Window)
					//{
					//	// ZJ: added a back button to the object library preview when coming from the importer, so trigger the quit here instead.
					//	extern int iDelayedExecute;
					//	iDelayedExecute = 2;
					//	imgui_importer_loop();
					//}
					#endif
				}

				if (iUpdateFPESettings > 0)
				{
					if (iUpdateFPESettings == 1)
					{
						//Write out t.entityprofile[BackBufferEntityID].keywords_s;
						//Start spell check
						iUpdateFPESettings++;
					}
					if (iUpdateFPESettings == 2)
					{
						//Spellcheck done ?
						//Read in spell checked t.entityprofile[BackBufferEntityID].keywords_s;
						iUpdateFPESettings++;
					}
					if (iUpdateFPESettings == 3)
					{
						//Update the actual FPE file.
						iUpdateFPESettings = 0;
						if (BackBufferIsGroup == true)
						{
							t.addentityfile_s = g_LastGroupSaved_s;
						}
						else
						{
							t.addentityfile_s = t.entitybank_s[BackBufferEntityID];
						}

						CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
						bool bGetOut = false;

						// delete old thumb image and give chance for new one to be saved (g_bThumbBankCopyMode)
						if (FileExist(BackBufferCacheName.Get()))
						{
							DeleteAFile(BackBufferCacheName.Get());
							g_bThumbBankCopyMode = false;
						}

						cFolderItem *pDontRefreshFolder = NULL;
						cFolderItem::sFolderFiles * updatefiles = NULL;
						cFolderItem *pNewFolder = &MainEntityList;
						if (pNewFolder) pNewFolder = pNewFolder->m_pNext;
						if (pNewFolder) pNewFolder = pNewFolder->m_pNext;
						while (pNewFolder)
						{
							if (pNewFolder->m_pFirstFile)
							{
								cFolderItem::sFolderFiles * myfiles = NULL;
								myfiles = pNewFolder->m_pFirstFile->m_pNext;
								while (myfiles)
								{
									//if (myfiles->iPreview > 0)
									//{
									cstr check = myfiles->m_sPath + cstr("\\") + myfiles->m_sName;
									//if (myfiles->m_sPath == t.addentityfile_s)
									if (pestrcasestr(check.Get(), t.addentityfile_s.Get()))
									{
										if (myfiles->iPreview > 0 && GetImageExistEx(myfiles->iPreview) && myfiles->iPreview >= 4000 && myfiles->iPreview < UIV3IMAGES) { //PE: Need to protect system images after tool img range has changed. (myfiles->iPreview can be a system icon)
											iDeleteInNextUpdate = myfiles->iPreview;
										}
										myfiles->iPreview = 0;
										myfiles->iBigPreview = 0;
										myfiles->m_Backdrop = cCurrentBackDrop;
										t.entityprofile[BackBufferEntityID].thumbnailbackdrop = cCurrentBackDrop;
										myfiles->m_sFPEKeywords = t.entityprofile[BackBufferEntityID].keywords_s;
										updatefiles = myfiles;
										bGetOut = true;
									}
									//}
									if (bGetOut) break;
									myfiles = myfiles->m_pNext;
								}
							}
							if (bGetOut) {
								pDontRefreshFolder = pNewFolder;
								break;
							}
							pNewFolder = pNewFolder->m_pNext;
						}

						//Update FPE file.
						std::vector<std::string> fpe_file;
						cstr c_fpefile = cstr("entitybank\\") + t.addentityfile_s;
						getVectorFileContent(c_fpefile.Get(), fpe_file, true);
						if (fpe_file.size() > 0)
						{
							RemoveStrStrFromVectorFile("thumbnailbackdrop=", fpe_file, true);
							RemoveStrStrFromVectorFile("thumbnailzoom=", fpe_file, true);
							RemoveStrStrFromVectorFile("thumbnailcamleft=", fpe_file, true);
							RemoveStrStrFromVectorFile("thumbnailcamup=", fpe_file, true);
							RemoveStrStrFromVectorFile("thumbnailrotatex=", fpe_file, true);
							RemoveStrStrFromVectorFile("thumbnailrotatey=", fpe_file, true);
							RemoveStrStrFromVectorFile("thumbnailanimset=", fpe_file, true);
							RemoveStrStrFromVectorFile("keywords=", fpe_file, true);
							RemoveStrStrFromVectorFile(";thumbnail", fpe_file, true);

							std::string add = ";thumbnail";
							fpe_file.push_back(add);
							add = std::string("thumbnailbackdrop = ") + std::string(cCurrentBackDrop.Get());
							fpe_file.push_back(add);
							add = std::string("thumbnailzoom = ") + std::to_string(BackBufferZoom);
							fpe_file.push_back(add);
							add = std::string("thumbnailcamleft = ") + std::to_string(BackBufferCamLeft);
							fpe_file.push_back(add);
							add = std::string("thumbnailcamup = ") + std::to_string(BackBufferCamUp);
							fpe_file.push_back(add);
							add = std::string("thumbnailrotatex = ") + std::to_string(BackBufferRotateX);
							fpe_file.push_back(add);
							add = std::string("thumbnailrotatey = ") + std::to_string(BackBufferRotateY);
							fpe_file.push_back(add);

							if (ObjectExist(BackBufferObjectID) && GetNumberOfFrames(BackBufferObjectID) > 0 && t.entityprofile[BackBufferEntityID].animmax > 0)
							{
								if (!bAnimationAll)
								{
									//We have animations.
									add = std::string("thumbnailanimset = ") + std::to_string(iAnimationSet);
									fpe_file.push_back(add);

								}
							}
							if (t.entityprofile[BackBufferEntityID].keywords_s.Len() > 0)
							{
								add = std::string("keywords = ") + t.entityprofile[BackBufferEntityID].keywords_s.Get();
								fpe_file.push_back(add);
							}

							saveVectorFileContent(c_fpefile.Get(), fpe_file);
						}

						if (sGotoPreviewWithFile != "")
						{
							bLargePreview = false;
							sGotoPreviewWithFile = "";
						}
						cCurrentBackDropImageFile = ""; //make sure to reload when doing new thumb.

						//Also update current loaded entityprofile.
						t.entityprofile[BackBufferEntityID].BackBufferZoom = BackBufferZoom;
						t.entityprofile[BackBufferEntityID].BackBufferCamLeft = BackBufferCamLeft;
						t.entityprofile[BackBufferEntityID].BackBufferCamUp = BackBufferCamUp;
						t.entityprofile[BackBufferEntityID].BackBufferRotateX = BackBufferRotateX;
						t.entityprofile[BackBufferEntityID].BackBufferRotateY = BackBufferRotateY;
						if (!bAnimationAll)
							t.entityprofile[BackBufferEntityID].iThumbnailAnimset = iAnimationSet;
						else
							t.entityprofile[BackBufferEntityID].iThumbnailAnimset = -1;

						if (pDontRefreshFolder)
						{
							cstr path = pDontRefreshFolder->m_sFolderFullPath.Lower();
							char *findpath = (char *)pestrcasestr(path.Get(), "entitybank\\");
							if (findpath) path = findpath;

							cFolderItem *pNewFolder = &MainEntityList;
							if (pNewFolder) pNewFolder = pNewFolder->m_pNext;
							if (pNewFolder) pNewFolder = pNewFolder->m_pNext;
							while (pNewFolder)
							{
								cstr pathcheck = pNewFolder->m_sFolderFullPath.Lower();
								char *findpath = (char *)pestrcasestr(pathcheck.Get(), "entitybank\\");
								if (findpath) pathcheck = findpath;
								if (pathcheck == path)
								{
									//PE: as we save a new fpe in a new folder DocWrite, dont refresh folder. we already have the old fpe that are updated.
									struct stat sb;
									if (stat(pNewFolder->m_sFolderFullPath.Get(), &sb) == 0)
									{
										if (sb.st_mtime != pNewFolder->m_tFolderModify)
										{
											pNewFolder->m_tFolderModify = sb.st_mtime;

											if (updatefiles && updatefiles->bFavorite)
											{
												//PE: This is the new folder, if old was fav., add to favorite in new folder.
												cstr file = pNewFolder->m_sFolderFullPath;
												file = file + "\\" + updatefiles->m_sName.Get();
												extern std::vector<std::string> files_favorite;
												files_favorite.push_back(file.Get());
												saveVectorFileContent("favoritelist.ini", files_favorite);
											}
										}
									}
								}
								pNewFolder = pNewFolder->m_pNext;
							}
						}
					}
				}
				char* tooltip = "Finish Setting the Object Library Preview";
				if (ImGui::IsItemHovered()) ImGui::SetTooltip(tooltip);

				// Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0)
				{
					ImGui::Text("");
					ImGui::Text("");
				}

				ImGui::EndChild();

				//When popup open , make sure we update the backbuffer all the time.
				bLoopBackBuffer = true;
				WickedCall_EnableThumbLight(true);
				ImGui::Columns(1);

				// Load the importer back up with the last imported model.
				//if (!bIsCCPObject)//
				extern sImportedObjectData g_Data;
				char previewName[MAX_PATH] = { 0 };
				if (pPreviewFile)
				{
					strcpy(previewName, pPreviewFile->m_sNameFinal.Get());
				}
				if(strcmp(g_Data.cName, previewName) == 0)
				{
					ImGui::SetCursorPos(ImVec2(5, 1));
					int icon_size = ImGui::GetFontSize() * 1.75;
					ImVec2 VIconSize = { (float)icon_size, (float)icon_size };
					ImVec2 cursor = ImGui::GetCursorPos();

					if (ImGui::ImgBtn(TOOL_GOBACK, VIconSize, ImVec4(0, 0, 0, 0), ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(1.0f, 1.0f, 1.0f, 0.5f),
						ImVec4(0.5f, 0.5f, 0.5f, 0.5f), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
					{
						bExternal_Entities_Window = false;
						bLargePreview = false;
						sGotoPreviewWithFile = "";
						bImporter_Window = true;
						extern void importer_quit_for_reload(LPSTR pOptionalCopyModelFile);
						iLaunchAfterSync = 8;
						
						cstr file = cstr(g_Data.cImportPath) + t.tSourceName_s;
						strcpy(pLaunchAfterSyncPreSelectModel, file.Get());
						strcpy(pLaunchAfterSyncPreSelectModel, pLaunchAfterSyncLastImportedModel);
						importer_quit_for_reload(pLaunchAfterSyncPreSelectModel);
						/*importer_quit_for_reload(file.Get());*/
						//extern char pLaunchAfterSyncLastImportedModel[MAX_PATH];
						//strcpy(pOptionalCopyModelFile, pLaunchAfterSyncLastImportedModel);

					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Back to Importer");
				}

				//Render titlebar centered.
				cstr title = " Object Library Preview";
				if (pPreviewFile)
				{
					title = pPreviewFile->m_sNameFinal + title;
				}
				if (bIsCCPObject)
					title = "Choose your character's library thumbnail";

				float fTextSize = ImGui::CalcTextSize(title.Get()).x;
				float xcenter = (ImGui::GetWindowSize().x*0.5) - (fTextSize*0.5);
				ImVec2 titlebar_pos = ImGui::GetWindowPos() + ImVec2(xcenter, 4);
				ImGuiWindow* window = ImGui::GetCurrentWindow();

				ImGui::EndPopup();

				//Render title bar after End. end fill titlebar.
				ImGuiContext& g = *GImGui;
				window->DrawList->AddText(g.Font, g.FontSize, titlebar_pos, ImGui::GetColorU32(ImGuiCol_Text), title.Get());
			}

			if (!bLargePreview)
			{
				//Close down modal popup.
				BackBufferSaveCacheName = "";
				BackBufferObjectID = 0;
				BackBufferImageID = 0;
				bLoopBackBuffer = false;
				RevertBackbufferCubemap();
				WickedCall_SetSunDirection(t.visuals.SunAngleX, t.visuals.SunAngleY, t.visuals.SunAngleZ);
				master_renderer->setBloomEnabled(t.visuals.bBloomEnabled);
				WickedCall_MoveReflectionProbe(GGORIGIN_X, GGORIGIN_Y + 5000, GGORIGIN_Z, "editorProbe", 500);
				//WickedCall_EnableCameraLight(bEditorLight);
				WickedCall_EnableThumbLight(false);
				if (pPreviewFile)
					pPreviewFile->iPreview = 0;

				bImagesStillInImGuiQueue = true;
			}

		}
		else
		{
			bPopModalOpenEntity = false;
		}

		//############################
		//#### END Large preview. ####
		//############################

		//MIN 600 width
		static float fLastContentWidth = 0;
		static ImVec2 vLastWindowSize = ImVec2(0, 0);
		if (refresh_gui_docking != 0 && !bResetObjectLibrarySize)
		{
			if (fLastContentWidth > 0 && fLastContentWidth < 600.0f && vLastWindowSize.y > 0)
			{
				ImGui::SetNextWindowSize(ImVec2(600.0f, vLastWindowSize.y), ImGuiCond_Always); //full screen.
			}
		}

		//PE: Moved here , so modal window above dont rely on this window for center position.
		if (refresh_gui_docking != 0 && !bResetObjectLibrarySize)
		{
			imgui_AddMinMaxButton(0, true); //check min max state.

			if (imgui_GetMinMaxButtonState(0))
			{
				//Fullscreen
				ex_window_flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
			}

			static int lastminstate = -1;
			if (lastminstate != imgui_GetMinMaxButtonState(0))
			{
				init_Left_Categories_Column_Width = 3;
				lastminstate = imgui_GetMinMaxButtonState(0);
			}
		}


		static cFolderItem::sFolderFiles * playingiles = NULL;
		static cFolderItem::sFolderFiles * selectedmediafile = NULL;

		if (pref.iDisableObjectLibraryViewport)
		{
			ImGuiViewport* viewport = ImGui::GetMainViewport();
			ImGui::SetNextWindowViewport(viewport->ID);
		}

		ImGui::Begin("##Object Library ExternalWindow", &bExternal_Entities_Window, ex_window_flags | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse);

		static float fScaleIcons = 1.0;
		//static int iSetColumns = 3; //Use Columns (scale) for now, scaling icons can give some huger borders and it dont look good.

		//PE: If user exit in fullscreen (it get saved) make sure to restore to default size.
		static bool bCheckFullScreenOnStartup = true;
		bResetObjectLibrarySize = false;

		if (bCheckFullScreenOnStartup)
		{
			if (imgui_CheckMinMaxStartupState(0))
			{
				//PE: Was set fullscreen, adjust columns width
				init_Left_Categories_Column_Width = 3;
			}
			bCheckFullScreenOnStartup = false;
		}

		vLastWindowSize = ImGui::GetWindowSize();

		float cwidth = ImGui::GetContentRegionAvailWidth();
		fLastContentWidth = cwidth;

		//if (cwidth < 1000)
		//{
		//	iColumnsWidth = cwidth / 3.0;
		//}
		//else
		//{
		//	iColumnsWidth = cwidth / 4.0;
		//}
		//iColumnsWidth -= 12.0; //padding



		static bool bAddNewSelectionToGame = false;
		static int iAddSelectionStep = 0;
		bool bIsWeDocked = ImGui::IsWindowDocked();
		static int current_tab = -1;


//		CheckTutorialAction("TABMARKERS", 54.0f); //Tutorial: check if we are waiting for this action
//		if (current_tab == 1 && bTutorialCheckAction)
//			TutorialNextAction(); //Clicked - selected the tab markers.
//		CheckTutorialAction("TABENTITIES", -10.0f); //Tutorial: check if we are waiting for this action
//		if (current_tab == 0 && bTutorialCheckAction)
//			TutorialNextAction(); //Clicked - selected the tab Entities.
//		ImGui::SetItemAllowOverlap();

		//static int iCurrentFilter = 0;

		int i = 0;

		static char cAllFilters[10][MAX_PATH];
		char cHeader[MAX_PATH];

		int control_wrap_width = 90;
		strcpy(cHeader, "");

		//PE: Debug dynamic icon load unload.
		//ImGui::Text("Entities: %ld , in memory: %ld", olduniqueId-4000, loaded_images);

		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX()-2.0f, ImGui::GetCursorPosY() + 6.0));
		ImGui::Text(""); //"Filter: ");
		ImGui::SameLine();

		void* lpTexture = NULL;

//		lpTexture = GetImagePointer(TOOL_ENT_FILTER);
//		if (lpTexture)
//		{
//			ImVec2 vImagePos = ImGui::GetCursorPos();
//			ImGuiWindow* window = ImGui::GetCurrentWindow();
//			ImVec2 search_icon_pos = ImGui::GetWindowPos() + vImagePos + ImVec2(-5.0, -2.0);
//			window->DrawList->AddImage((ImTextureID)lpTexture, search_icon_pos, search_icon_pos + ImVec2(20, 20), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
//			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + 19.0, ImGui::GetCursorPosY()));
//		}
//		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3.0));
//		if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
//		ImGui::Text(""); //NewLine

		bool rb_change = false;
		static bool bDLUAOnly = true;

		strcpy(cAllFilters[0], "HUD Assets");
		strcpy(cAllFilters[1], "Character");
		strcpy(cAllFilters[2], "Objects");
		strcpy(cAllFilters[3], "Weapons");
		strcpy(cAllFilters[4], "User");
		if (iDisplayLibraryType == 1) strcpy(cAllFilters[0], "OGG"); //Not active
		if (iDisplayLibraryType == 2) strcpy(cAllFilters[0], "DDS"); //Not active
		if (iDisplayLibraryType == 3) strcpy(cAllFilters[0], "MP4"); //Not active
		if (iDisplayLibraryType == 4) strcpy(cAllFilters[0], "LUA"); //Not active
		if (iDisplayLibraryType == 5) strcpy(cAllFilters[0], "ARX"); //Not active


		/*
		############################################################################
		PE: Removed in latest design, moved down as icons, can be removed when done!
		############################################################################

		if (iDisplayLibraryType == 0) //Depend on type.
		{

			strcpy(cAllFilters[0], "HUD Assets"); //"Showcase");
			strcpy(cAllFilters[1], "Character");
			strcpy(cAllFilters[2], "Objects"); //"Scene"
			strcpy(cAllFilters[3], "Weapons");
			strcpy(cAllFilters[4], "User");

			float fComboWidth = 150.0f;
			ImGui::PushItemWidth(fComboWidth);
			cstr ComboName = "Categories";
			ImVec2 vCSize = ImVec2(fComboWidth, ImGui::GetFontSize()*11.0);
			ImGui::SetNextWindowSizeConstraints(vCSize, vCSize);
			if (ImGui::BeginCombo("##comboCategoriesv2", ComboName.Get(), ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightRegular))
			{
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY()+6.0));
				ImGui::Indent(4);
				float fComboCheckLeftPos = 30.0f;
				ImGui::PushItemWidth(fComboWidth - fComboCheckLeftPos);

				cstr sLabel = "Characters";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[1]) bCheckboxFilters[1] = false; else bCheckboxFilters[1] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Characters", &bCheckboxFilters[1]))
					bUpdateSearchSorting = true;


				sLabel = "Scenery";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[2]) bCheckboxFilters[2] = false; else bCheckboxFilters[2] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Scenery", &bCheckboxFilters[2]))
					bUpdateSearchSorting = true;


				sLabel = "Elements";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[3]) bCheckboxFilters[3] = false; else bCheckboxFilters[3] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Elements", &bCheckboxFilters[3]))
					bUpdateSearchSorting = true;

				sLabel = "HUD Assets";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[0]) bCheckboxFilters[0] = false; else bCheckboxFilters[0] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##HUD Assets", &bCheckboxFilters[0]))
					bUpdateSearchSorting = true;

				sLabel = "User Generated";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[4]) bCheckboxFilters[4] = false; else bCheckboxFilters[4] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##User Generated", &bCheckboxFilters[4]))
				{
					bUpdateSearchSorting = true;
				}

				sLabel = "Favourite";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bDisplayFavorite) bDisplayFavorite = false; else bDisplayFavorite = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Favourite", &bDisplayFavorite))
				{
					bUpdateSearchSorting = true;
				}

				ImGui::Indent(-4);
				ImGui::PopItemWidth();
				ImGui::EndCombo();
			}
			ImGui::PopItemWidth();
		}

		//###############
		//#### Music ####
		//###############

		if (iDisplayLibraryType == 1) //Music
		{

			//PE: For now follow the same folder setup like entitybank but in audiobank.
			strcpy(cAllFilters[0], "OGG");
			strcpy(cAllFilters[1], "Character");
			strcpy(cAllFilters[2], "Objects"); //+ Weapons
			strcpy(cAllFilters[3], "Weapons"); //Elements
			strcpy(cAllFilters[4], "User");
			
			bCheckboxFilters[0] = false; //Filer 0 not active yet.

			float fComboWidth = 150.0f;
			ImGui::PushItemWidth(fComboWidth);
			cstr ComboName = "Categories";
			ImVec2 vCSize = ImVec2(fComboWidth, ImGui::GetFontSize()*11.0);
			ImGui::SetNextWindowSizeConstraints(vCSize, vCSize);
			if (ImGui::BeginCombo("##comboCategoriesv2", ComboName.Get(), ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightRegular))
			{
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 6.0));
				ImGui::Indent(4);
				float fComboCheckLeftPos = 30.0f;
				ImGui::PushItemWidth(fComboWidth - fComboCheckLeftPos);

				cstr sLabel = "Characters";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[1]) bCheckboxFilters[1] = false; else bCheckboxFilters[1] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Characters", &bCheckboxFilters[1]))
					bUpdateSearchSorting = true;


				sLabel = "Scenery";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[2]) bCheckboxFilters[2] = false; else bCheckboxFilters[2] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Scenery", &bCheckboxFilters[2]))
					bUpdateSearchSorting = true;


				sLabel = "Elements";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[3]) bCheckboxFilters[3] = false; else bCheckboxFilters[3] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Elements", &bCheckboxFilters[3]))
					bUpdateSearchSorting = true;

				sLabel = "User Generated";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[4]) bCheckboxFilters[4] = false; else bCheckboxFilters[4] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##User Generated", &bCheckboxFilters[4]))
				{
					bUpdateSearchSorting = true;
				}

				sLabel = "Favourite";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bDisplayFavorite) bDisplayFavorite = false; else bDisplayFavorite = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Favourite", &bDisplayFavorite))
				{
					bUpdateSearchSorting = true;
				}

				ImGui::Indent(-4);
				ImGui::PopItemWidth();
				ImGui::EndCombo();
			}
			ImGui::PopItemWidth();
		}


		//###############
		//#### Image ####
		//###############

		if (iDisplayLibraryType == 2) //Image
		{

			//PE: For now follow the same folder setup like entitybank but in audiobank.
			strcpy(cAllFilters[0], "DDS"); //Not active
			strcpy(cAllFilters[1], "Character");
			strcpy(cAllFilters[2], "Objects"); //+ Weapons
			strcpy(cAllFilters[3], "Weapons"); //Elements
			strcpy(cAllFilters[4], "User");

			bCheckboxFilters[0] = false; //Filer 0 not active yet.

			float fComboWidth = 150.0f;
			ImGui::PushItemWidth(fComboWidth);
			cstr ComboName = "Categories";
			ImVec2 vCSize = ImVec2(fComboWidth, ImGui::GetFontSize()*11.0);
			ImGui::SetNextWindowSizeConstraints(vCSize, vCSize);
			if (ImGui::BeginCombo("##comboCategoriesv2", ComboName.Get(), ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightRegular))
			{
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 6.0));
				ImGui::Indent(4);
				float fComboCheckLeftPos = 30.0f;
				ImGui::PushItemWidth(fComboWidth - fComboCheckLeftPos);

				cstr sLabel = "Characters";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[1]) bCheckboxFilters[1] = false; else bCheckboxFilters[1] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Characters", &bCheckboxFilters[1]))
					bUpdateSearchSorting = true;


				sLabel = "Scenery";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[2]) bCheckboxFilters[2] = false; else bCheckboxFilters[2] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Scenery", &bCheckboxFilters[2]))
					bUpdateSearchSorting = true;


				sLabel = "Elements";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[3]) bCheckboxFilters[3] = false; else bCheckboxFilters[3] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Elements", &bCheckboxFilters[3]))
					bUpdateSearchSorting = true;

				sLabel = "User Generated";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[4]) bCheckboxFilters[4] = false; else bCheckboxFilters[4] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##User Generated", &bCheckboxFilters[4]))
				{
					bUpdateSearchSorting = true;
				}

				sLabel = "Favourite";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bDisplayFavorite) bDisplayFavorite = false; else bDisplayFavorite = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Favourite", &bDisplayFavorite))
				{
					bUpdateSearchSorting = true;
				}

				ImGui::Indent(-4);
				ImGui::PopItemWidth();
				ImGui::EndCombo();
			}
			ImGui::PopItemWidth();
		}



		//###############
		//#### Video ####
		//###############

		if (iDisplayLibraryType == 3)
		{

			//PE: For now follow the same folder setup like entitybank but in audiobank.
			strcpy(cAllFilters[0], "MP4"); //Not active
			strcpy(cAllFilters[1], "Character");
			strcpy(cAllFilters[2], "Objects"); //+ Weapons
			strcpy(cAllFilters[3], "Weapons"); //Elements
			strcpy(cAllFilters[4], "User");

			bCheckboxFilters[0] = false; //Filer 0 not active yet.

			float fComboWidth = 150.0f;
			ImGui::PushItemWidth(fComboWidth);
			cstr ComboName = "Categories";
			ImVec2 vCSize = ImVec2(fComboWidth, ImGui::GetFontSize()*11.0);
			ImGui::SetNextWindowSizeConstraints(vCSize, vCSize);
			if (ImGui::BeginCombo("##comboCategoriesv2", ComboName.Get(), ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightRegular))
			{
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 6.0));
				ImGui::Indent(4);
				float fComboCheckLeftPos = 30.0f;
				ImGui::PushItemWidth(fComboWidth - fComboCheckLeftPos);

				cstr sLabel = "Characters";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[1]) bCheckboxFilters[1] = false; else bCheckboxFilters[1] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Characters", &bCheckboxFilters[1]))
					bUpdateSearchSorting = true;


				sLabel = "Scenery";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[2]) bCheckboxFilters[2] = false; else bCheckboxFilters[2] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Scenery", &bCheckboxFilters[2]))
					bUpdateSearchSorting = true;


				sLabel = "Elements";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[3]) bCheckboxFilters[3] = false; else bCheckboxFilters[3] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Elements", &bCheckboxFilters[3]))
					bUpdateSearchSorting = true;

				sLabel = "User Generated";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[4]) bCheckboxFilters[4] = false; else bCheckboxFilters[4] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##User Generated", &bCheckboxFilters[4]))
				{
					bUpdateSearchSorting = true;
				}

				sLabel = "Favourite";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bDisplayFavorite) bDisplayFavorite = false; else bDisplayFavorite = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Favourite", &bDisplayFavorite))
				{
					bUpdateSearchSorting = true;
				}

				ImGui::Indent(-4);
				ImGui::PopItemWidth();
				ImGui::EndCombo();
			}
			ImGui::PopItemWidth();
		}

		//################
		//#### Script ####
		//################

		if (iDisplayLibraryType == 4)
		{

			//PE: For now follow the same folder setup like entitybank but in audiobank.
			strcpy(cAllFilters[0], "LUA"); //Not active
			strcpy(cAllFilters[1], "Character");
			strcpy(cAllFilters[2], "Objects"); //+ Weapons
			strcpy(cAllFilters[3], "Weapons"); //Elements
			strcpy(cAllFilters[4], "User");

			bCheckboxFilters[0] = false; //Filer 0 not active yet.

			float fComboWidth = 150.0f;
			ImGui::PushItemWidth(fComboWidth);
			cstr ComboName = "Categories";
			ImVec2 vCSize = ImVec2(fComboWidth, ImGui::GetFontSize()*11.0);
			ImGui::SetNextWindowSizeConstraints(vCSize, vCSize);
			if (ImGui::BeginCombo("##comboCategoriesv2", ComboName.Get(), ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightRegular))
			{
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 6.0));
				ImGui::Indent(4);
				float fComboCheckLeftPos = 30.0f;
				ImGui::PushItemWidth(fComboWidth - fComboCheckLeftPos);

				cstr sLabel = "Characters";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[1]) bCheckboxFilters[1] = false; else bCheckboxFilters[1] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Characters", &bCheckboxFilters[1]))
					bUpdateSearchSorting = true;


				sLabel = "Scenery";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[2]) bCheckboxFilters[2] = false; else bCheckboxFilters[2] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Scenery", &bCheckboxFilters[2]))
					bUpdateSearchSorting = true;


				sLabel = "Elements";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[3]) bCheckboxFilters[3] = false; else bCheckboxFilters[3] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Elements", &bCheckboxFilters[3]))
					bUpdateSearchSorting = true;

				sLabel = "User Generated";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[4]) bCheckboxFilters[4] = false; else bCheckboxFilters[4] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##User Generated", &bCheckboxFilters[4]))
				{
					bUpdateSearchSorting = true;
				}

				sLabel = "Favourite";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bDisplayFavorite) bDisplayFavorite = false; else bDisplayFavorite = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Favourite", &bDisplayFavorite))
				{
					bUpdateSearchSorting = true;
				}

				sLabel = "Dynamic Scripts";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bDLUAOnly) bDLUAOnly = false; else bDLUAOnly = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				ImGui::Checkbox("##DynamicLUAOnly", &bDLUAOnly);


				ImGui::Indent(-4);
				ImGui::PopItemWidth();
				ImGui::EndCombo();
			}
			ImGui::PopItemWidth();
		}


		//###################
		//#### Particles ####
		//###################

		if (iDisplayLibraryType == 5)
		{

			//PE: For now follow the same folder setup like entitybank but in audiobank.
			strcpy(cAllFilters[0], "ARX"); //Not active
			strcpy(cAllFilters[1], "Character");
			strcpy(cAllFilters[2], "Objects"); //+ Weapons
			strcpy(cAllFilters[3], "Weapons"); //Elements
			strcpy(cAllFilters[4], "User");

			bCheckboxFilters[0] = false; //Filer 0 not active yet.

			float fComboWidth = 150.0f;
			ImGui::PushItemWidth(fComboWidth);
			cstr ComboName = "Categories";
			ImVec2 vCSize = ImVec2(fComboWidth, ImGui::GetFontSize()*11.0);
			ImGui::SetNextWindowSizeConstraints(vCSize, vCSize);
			if (ImGui::BeginCombo("##comboCategoriesv2", ComboName.Get(), ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightRegular))
			{
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 6.0));
				ImGui::Indent(4);
				float fComboCheckLeftPos = 30.0f;
				ImGui::PushItemWidth(fComboWidth - fComboCheckLeftPos);

				cstr sLabel = "Characters";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[1]) bCheckboxFilters[1] = false; else bCheckboxFilters[1] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Characters", &bCheckboxFilters[1]))
					bUpdateSearchSorting = true;


				sLabel = "Scenery";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[2]) bCheckboxFilters[2] = false; else bCheckboxFilters[2] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Scenery", &bCheckboxFilters[2]))
					bUpdateSearchSorting = true;


				sLabel = "Elements";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[3]) bCheckboxFilters[3] = false; else bCheckboxFilters[3] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Elements", &bCheckboxFilters[3]))
					bUpdateSearchSorting = true;

				sLabel = "User Generated";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bCheckboxFilters[4]) bCheckboxFilters[4] = false; else bCheckboxFilters[4] = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##User Generated", &bCheckboxFilters[4]))
				{
					bUpdateSearchSorting = true;
				}

				sLabel = "Favourite";
				if (ImGui::Selectable(sLabel.Get(), false, ImGuiSelectableFlags_DontClosePopups))
				{
					if (bDisplayFavorite) bDisplayFavorite = false; else bDisplayFavorite = true;
					bUpdateSearchSorting = true;
				}
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(fComboWidth - fComboCheckLeftPos, ImGui::GetCursorPosY() - 3.0));
				if (ImGui::Checkbox("##Favourite", &bDisplayFavorite))
				{
					bUpdateSearchSorting = true;
				}

				ImGui::Indent(-4);
				ImGui::PopItemWidth();
				ImGui::EndCombo();
			}
			ImGui::PopItemWidth();
		}

		*/

		int sortby_combo_width = 130;
		bool bLastEntityGotFocus = bEntityGotFocus;
		if (1) //Searchbar
		{
			ImGui::SameLine();

			if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
			{
				ImGui::Text(""); //NewLine
			}

			float fXWidth = ImGui::GetFontSize()*1.5;

			fXWidth += sortby_combo_width;

			ImGui::PushItemWidth(-10 - fXWidth); //-38 - fXWidth

			ImGui::Text(""); //" Search: ");
			ImGui::SameLine();

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() - 8.0, ImGui::GetCursorPosY()));
			
			bEntityGotFocus = false;
			ImGuiStyle& style = ImGui::GetStyle();
			float fOldSpacing = style.FramePadding.x;
			style.FramePadding.x = 22.0; //Make room for search icon.
			ImVec2 vSearchPos = ImGui::GetCursorPos();
			static cstr sOldSearch = &cSearchAllEntities[i][0];
			static std::string phonetic_find = "";

			// Force the keyboard focus to the input text field when the user presses the close button (below).
			static bool bStealKeyboardFocus = false;
			if (bStealKeyboardFocus)
			{
				ImGui::SetKeyboardFocusHere(0);
				bStealKeyboardFocus = false;
			}

			if (ImGui::InputText("##cSearchAllEntities", &cSearchAllEntities[i][0], MAX_PATH, ImGuiInputTextFlags_EnterReturnsTrue))
			{
				bUpdateSearchSorting = true;
				phonetic_find = soundexall(cSearchAllEntities[i]);

				if (strlen(cSearchAllEntities[i]) > 1)
				{
					bool already_there = false;
					for (int l = 0; l < MAXSEARCHHISTORY; l++)
					{
						if (strcmp(cSearchAllEntities[i], pref.search_history[l]) == 0)
						{
							already_there = true;
							break;
						}
					}
					if (!already_there)
					{
						bool foundspot = false;
						for (int l = 0; l < MAXSEARCHHISTORY; l++)
						{
							if (strlen(pref.search_history[l]) <= 0)
							{
								strcpy(pref.search_history[l], cSearchAllEntities[i]);
								foundspot = true;
								break;
							}
						}
						if (!foundspot)
						{
							//Move entry list.
							for (int l = 0; l < MAXSEARCHHISTORY; l++)
							{
								strcpy(pref.search_history[l], pref.search_history[l + 1]);
							}
							strcpy(pref.search_history[MAXSEARCHHISTORY - 1], cSearchAllEntities[i]);
						}
					}
				}
			}
			if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Type here to search for an object in your library");

			cstr sNewSearch = &cSearchAllEntities[i][0];
			if (sOldSearch != sNewSearch)
			{
				sOldSearch = sNewSearch;
				phonetic_find = soundexall(cSearchAllEntities[i]);
				bUpdateSearchSorting = true;
				bUpdateSearchScrollbar = true;
			}
			style.FramePadding.x = fOldSpacing;
			lpTexture = GetImagePointer(TOOL_ENT_SEARCH);
			if (lpTexture)
			{
				ImGuiWindow* window = ImGui::GetCurrentWindow();
				ImVec2 search_icon_pos = ImGui::GetWindowPos() + vSearchPos + ImVec2(3.0, 3.0);
				window->DrawList->AddImage((ImTextureID)lpTexture, search_icon_pos, search_icon_pos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
			}
			ImGui::SameLine();
			ImGui::SetItemAllowOverlap();
			if (ImGui::CloseButton(ImGui::GetCurrentWindow()->GetID("#ClearSearch"), ImGui::GetWindowPos() + ImGui::GetCursorPos() + ImVec2(-30, 0)))
			{
				bUpdateSearchSorting = true;
				bUpdateSearchScrollbar = true;
				strcpy(cSearchAllEntities[i], "");
				bStealKeyboardFocus = true;
			}
			if (ImGui::IsItemHovered())
			{
				//mouse
				ImGui::SetMouseCursor(ImGuiMouseCursor_Arrow);
				ImGui::SetTooltip("Clear search");
			}

			ImGui::PopItemWidth();

		}
					
		if (1) //Combo dropdowns. Use folder names as seach.
		{
			ImGui::SameLine();
			static char * current_combo_entry = "\0";
			int comboflags = ImGuiComboFlags_NoPreview | ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge;

			ImGui::PushItemWidth(-sortby_combo_width - 14); //- 24

			if (ImGui::BeginCombo("##combolastsearch", current_combo_entry, comboflags))
			{

				//Do we have a search history.
				bool display_history = false;
				for (int l = 0; l < MAXSEARCHHISTORY; l++) {
					if (strlen(pref.search_history[l]) > 0) {
						display_history = true;
						break;
					}
				}
				if (display_history) {
					ImGui::Text("Search History:");
					ImGui::Indent(10);
					for (int l = 0; l < MAXSEARCHHISTORY; l++) {
						if (strlen(pref.search_history[l]) > 0) {
							bool is_selected = (current_combo_entry == pref.search_history[l]);
							cstr sSelName = pref.search_history[l];
							sSelName = sSelName + "##Hist";
							if (ImGui::Selectable(sSelName.Get(), is_selected)) {
								bUpdateSearchSorting = true;
								bUpdateSearchScrollbar = true;
								current_combo_entry = (char *)pref.search_history[l];
								strcpy(cSearchAllEntities[i], pref.search_history[l]);
							}
							if (is_selected)
								ImGui::SetItemDefaultFocus();
						}
					}
					ImGui::Indent(-10);
				}
				ImGui::EndCombo();
			}
			ImGui::PopItemWidth();

			ImGui::SameLine();

			ImGui::PushItemWidth(-6);

			//const char* sortby_modes[] = { "Showcase" , "Category Order", "Name A-Z", "Name Z-A", "Created Old-New", "Created New-Old", "Number of Polygons Low-", "Number of Polygons High-" };
			const char* sortby_modes[] = { "Category Order", "Name A-Z", "Name Z-A", "Created Old-New", "Created New-Old", "Number of Polygons Low-", "Number of Polygons High-" };
			int iComboItems = IM_ARRAYSIZE(sortby_modes);
			if (iDisplayLibraryType == 0)
			{
				#ifdef INCLUDEPOLYGONSORT
				if (!bAdvancedFPEFeatures)
					iComboItems -= 2;
				#else
				iComboItems -= 2;
				#endif
			}
			else
			{
				iComboItems -= 2;
			}

			if (ImGui::Combo("##combostaticIssuesFilter", &current_sortby, sortby_modes, iComboItems))
			{
				bUpdateSearchSorting = true;
				bUpdateSearchScrollbar = true;
				// set sortby mode = current_sortby
				// 0 = showcase
				// 1 = no sorting, category order and files A-Z inside each category. 0
				// 2 = A-Z 1
				// 3 = Z-A 2
				// 4 = Date Old-New 5
				// 5 = Date New-Old 6
				// 6 = Poly low 7
				// 7 = Poly high 8
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set Sorting");
			ImGui::PopItemWidth();

			ImGui::Separator();
		}

		static int total_files_displayed_in_library = 0;
		if (1) //Display what is searched for.
		{

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + 10.0, ImGui::GetCursorPosY() + 3));

			cstr cViewing = "";
			bool bSearchAll = false;
			if (strlen(cSearchAllEntities[i]) > 0)
			{
				if (iDisplayLibraryType == 0)
				{
					if(iDisplayLibrarySubType==1)
						cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Animations from \"All\" categories using search term \"") + cstr(cSearchAllEntities[i]) + cstr("\"");
					else
						cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Objects from \"All\" categories using search term \"") + cstr(cSearchAllEntities[i]) + cstr("\"");
				}
				else
				{
					cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Items from \"All\" categories using search term \"") + cstr(cSearchAllEntities[i]) + cstr("\"");
				}

				//cViewing = cstr("Viewing \"") + cstr(cSearchAllEntities[i]) + cstr("\" from \"All\" categories");
				bSearchAll = true;
			}
			if (bDisplayFavorite)
			{
				//cViewing = cstr("Viewing \"Favourite\" from \"All\" categories");
				cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Objects from \"Favourite\" using \"All\" categories");
				bSearchAll = true;
			}

			if (!bSearchAll)
			{
				cViewing = "Viewing ";
				if (iDisplayLibraryType == 0)
				{
					if (iDisplayLibrarySubType == 1)
						cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Animations from ");
					else
						cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Objects from ");
				}
				else
				{
					cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Items from ");
				}

				int iCategories = 0;
				if (iDisplayLibraryType == 2 && bCheckboxFilters[1] && bCheckboxFilters[2] && bCheckboxFilters[3] && bCheckboxFilters[4])
				{
					cViewing = cViewing + cstr("\"All\" Categories");
				}
				else if (iDisplayLibraryType == 1 && bCheckboxFilters[1] && bCheckboxFilters[2] && bCheckboxFilters[3] && bCheckboxFilters[4])
				{
					cViewing = cViewing + cstr("\"All\" Categories");
				}
				else if (iDisplayLibraryType == 3 && bCheckboxFilters[1] && bCheckboxFilters[2] && bCheckboxFilters[3] && bCheckboxFilters[4])
				{
					cViewing = cViewing + cstr("\"All\" Categories");
				}
				else if (iDisplayLibraryType == 4 && bCheckboxFilters[1] && bCheckboxFilters[2] && bCheckboxFilters[3] && bCheckboxFilters[4])
				{
					cViewing = cViewing + cstr("\"All\" Categories");
				}
				else if (iDisplayLibraryType == 5 && bCheckboxFilters[1] && bCheckboxFilters[2] && bCheckboxFilters[3] && bCheckboxFilters[4])
				{
					cViewing = cViewing + cstr("\"All\" Categories");
				}
				else if (bCheckboxFilters[0] && bCheckboxFilters[1] && bCheckboxFilters[2] && bCheckboxFilters[3] && bCheckboxFilters[4])
				{
					cViewing = cViewing + cstr("\"All\" Categories");
				}
				else
				{
					if (bCheckboxFilters[1])
					{
						if (iCategories == 0)
							cViewing = cViewing + cstr("\"");
						if (iCategories++ > 0)
							cViewing = cViewing + cstr(", ");
						cViewing = cViewing + cstr("Characters");
					}
					if (bCheckboxFilters[2])
					{
						if (iCategories == 0)
							cViewing = cViewing + cstr("\"");
						if (iCategories++ > 0)
							cViewing = cViewing + cstr(", ");
						cViewing = cViewing + cstr("Scenery");
					}
					if (bCheckboxFilters[3])
					{
						if (iCategories == 0)
							cViewing = cViewing + cstr("\"");
						if (iCategories++ > 0)
							cViewing = cViewing + cstr(", ");
						cViewing = cViewing + cstr("Elements");
					}

					if (iDisplayLibraryType == 0 && bCheckboxFilters[0])
					{
						if (iCategories == 0)
							cViewing = cViewing + cstr("\"");
						if (iCategories++ > 0)
							cViewing = cViewing + cstr(", ");
						cViewing = cViewing + cstr("HUD Assets");
					}
					if (iDisplayLibraryType == 1 && bCheckboxFilters[0])
					{
						if (iCategories == 0)
							cViewing = cViewing + cstr("\"");
						if (iCategories++ > 0)
							cViewing = cViewing + cstr(", ");
						cViewing = cViewing + cstr("OGG");
					}

					if (bCheckboxFilters[4])
					{
						if (iCategories == 0)
							cViewing = cViewing + cstr("\"");
						if (iCategories++ > 0)
							cViewing = cViewing + cstr(", ");
						cViewing = cViewing + cstr("User Generated");
					}

					if (iCategories == 0)
						cViewing = "";
					else if (iCategories == 1)
					{
						cViewing = cViewing + cstr("\" Category");
					}
					else if (iCategories > 1)
					{
						cViewing = cViewing + cstr("\" Categories");
					}
				}
			}
			if (cViewing == "" && current_sortby == 1 && total_files_displayed_in_library > 0 )
			{
				if (iDisplayLibraryType == 0)
				{
					if (iDisplayLibrarySubType == 1)
						cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Animations from \"Showcase\"");
					else
						cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Objects from \"Showcase\"");
				}
				else
				{
					cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Items from \"Showcase\"");
				}
			}
			//order
			if (cViewing != "")
			{
				if (current_sortby == 1)
					cViewing = cViewing + " in A-Z order";
				else if (current_sortby == 0)
					cViewing = cViewing + " in category order";
				else if (current_sortby == 2)
					cViewing = cViewing + " in Z-A order";
				else if (current_sortby == 3)
					cViewing = cViewing + " in Old-New order";
				else if (current_sortby == 4)
					cViewing = cViewing + " in New-Old order";
			}
			ImGui::SetWindowFontScale(1.25);
			ImGui::TextCenter(cViewing.Get());
			ImGui::SetWindowFontScale(1.0);

			//----------------
			ImGui::Separator();
		}
		total_files_displayed_in_library = 0;

		//PE: Generate folder view.
		static int updates = 0;
		static bool bTreeViewInit = false;
		if (!bTreeViewInit || bTreeViewInitInNextFrame )
		{
			bTreeViewInitInNextFrame = false;
			//UNPIN
			extern std::vector<std::string> files_pinned_categories;
			files_pinned_categories.clear();
			getVectorFileContent("pinnedlist.ini", files_pinned_categories);

			static folder_info * mem_list[5000];
			static int mem_list_count = 0;

			cFolderItem *pNewFolder = &MainEntityList;
			pNewFolder = pNewFolder->m_pNext;

			//Free old structures.
			for (int i = 0; i < mem_list_count; i++)
			{
				if (mem_list[i])
				{
					delete mem_list[i];
					mem_list[i] = 0;
				}
			}
			mem_list_count = 0;
			root_folders.clear();
			updates++;

			if (pNewFolder)
			{
				cStr path_remove = pNewFolder->m_sFolderFullPath.Get();
				int ipath_remove_len = path_remove.Len();
				int count = 0;
				while (pNewFolder)
				{

					cStr path = pNewFolder->m_sFolderFullPath.Get();
					int itype = pNewFolder->iType;
					bool bDoubleEntityBank = false;
					cstr DoubleSearchName = "\\entitybank";
					if (itype == 1)
						DoubleSearchName = "\\audiobank";
					if (itype == 2)
						DoubleSearchName = "\\imagebank";
					if (itype == 3)
						DoubleSearchName = "\\videobank";
					if (itype == 4)
						DoubleSearchName = "\\scriptbank";
					if (itype == 5)
						DoubleSearchName = "\\particlesbank";
					if (itype == 6)
						DoubleSearchName = "\\charactercreatorplus\\animations";
					int DoubleSearchNameLen = DoubleSearchName.Len();

					char *finde = (char *)pestrcasestr(path.Get(), DoubleSearchName.Get()); //Support entitybank inside entitybank.
					if (finde)
					{
						finde += DoubleSearchNameLen;
						finde = (char *)pestrcasestr(finde, DoubleSearchName.Get());
						if (finde) bDoubleEntityBank = true;
					}

					if (!bDoubleEntityBank && path.Right(DoubleSearchNameLen) == DoubleSearchName)
					{
						ipath_remove_len = path.Len();
					}
					else
					{
						//char *final_name = path.Get();
						char *final_name = (char *)pestrcasestr(path.Get(), DoubleSearchName.Get()); //Support entitybank inside entitybank.

						//final_name += ipath_remove_len;
						final_name += DoubleSearchNameLen;
						if (*final_name == '\\')
							final_name++;

						bool bVisible = true;
						std::string dir_name = final_name;
						replaceAll(dir_name, "/", "\\");
						replaceAll(dir_name, ";", ""); //We will use ; for tokens later.
						int level = std::count(dir_name.begin(), dir_name.end(), '\\');
						replaceAll(dir_name, "\\", " - ");

						//PE: Hide showcase.
						if (!pestrcasestr(dir_name.c_str(), " - "))
						{
							if (pestrcasestr(dir_name.c_str(), "showcase"))
								bVisible = false;

							if (pestrcasestr(dir_name.c_str(), "_markers"))
								dir_name = "Game Elements";
						}

						if (dir_name.length() == 0)
							__debugbreak();

						int is = root_folders.size();
						if (mem_list_count < 5000 && dir_name.length() < 256 && dir_name.length() > 0 )
						{
							folder_info *fi = new folder_info;
							if (fi)
							{
								mem_list[mem_list_count++] = fi;
								fi->level = level;
								fi->type = pNewFolder->iType;
								strcpy(fi->real_name, dir_name.c_str());
								strcpy(fi->show_name, dir_name.c_str());
								
								fi->show_name[0] = toupper(fi->show_name[0]);
								fi->id = count++;
								fi->parentid = 0;
								fi->folders = 0;
								fi->pFolder = pNewFolder;
								fi->bPinned = false;
								fi->bUsed = false;
								std::transform(dir_name.begin(), dir_name.end(), dir_name.begin(), [](unsigned char c) { return tolower(c); });
								char tmp[2];
								tmp[0] = fi->type + '0';
								tmp[1] = 0;
								std::string realname = fi->real_name;
								realname = realname + tmp;
								for (std::vector<std::string>::iterator itf = files_pinned_categories.begin(); itf != files_pinned_categories.end(); ++itf)
								{
									if (itf->size() > 0)
									{
										if (strcmp(itf->c_str(), realname.c_str() ) == 0)
										{
											fi->bPinned = true;
											//Place it at the top.
											dir_name = "!" + dir_name;
											break;
										}
									}
								}

								dir_name = dir_name + tmp; //Only uniq for each folder type.
								replaceAll(dir_name, " - ", ";"); //Make it more easy to parse later.
								root_folders.insert(std::make_pair(dir_name, fi));
								if (is == root_folders.size())
									bVisible = false;
								if (!bVisible)
								{
									//
								}
							}
						}
					}
					pNewFolder = pNewFolder->m_pNext;
				}
			}

			//PE: Find all parentID's
			for (auto it = root_folders.begin(); it != root_folders.end(); ++it) {
				std::string folder = it->first;
				if (it->second->bPinned)
				{
					//Remove '!' infront.
					folder = folder.substr(1);
				}
				if (it->second->level > 0)
				{
					int itype = it->second->type;
					folder = folder.substr(0, folder.length() - 1);
					char * pch;
					char cTmp[512];
					strcpy(cTmp, folder.c_str());
					pch = strtok(cTmp, ";");
					int current_level = 1;
					std::string parent = cTmp;
					std::string search = parent;
					while (pch != NULL)
					{
						pch = strtok(NULL, ";"); //Here as we skip the first.

						if (pch)
						{
							char tmp[2];
							tmp[0] = itype + '0';
							tmp[1] = 0;
							std::string tmpsearch = search + tmp; //Only uniq for each folder type.

							//Find token in level-1.
							for (auto it2 = root_folders.begin(); it2 != root_folders.end(); ++it2)
							{
								if (it2->second->level == current_level - 1)
								{
									if (it2->second->type == itype)
									{
										std::string check = it2->first;
										if (it2->second->bPinned)
										{
											check = check.substr(1);
										}

										if (tmpsearch == check)
										{
											it->second->parentid = it2->second->id;
											it2->second->folders++;

											strcpy(it->second->show_name, pch);
											it->second->show_name[0] = toupper(it->second->show_name[0]);
										}
									}
								}
							}
						}

						search = search + ';';
						if (pch)
							search = search + pch;

						current_level++;
					}
				}
			}
			bTreeViewInit = true;
		}

		///ImGui::Columns(2);
		ImGui::BeginColumns("##myleftcategoripanel",2, ImGuiColumnsFlags_None);
		if (init_Left_Categories_Column_Width > 0)
		{
			//PE: Must match 230 for defaults to match the exact icons on screen.
			//PE: Perhaps add the percent adjustment later.
			//float fWinX = ImGui::GetWindowSize().x;
			//float fRatio = 0.2323232323232323;
			//float fNewColW = floor(fWinX * fRatio);
			//ImGui::SetColumnWidth(0, fNewColW);
			ImGui::SetColumnWidth(0, 230.0f);
			init_Left_Categories_Column_Width--;
		}
		ImVec2 vWindowSize = ImGui::GetContentRegionAvail();


		//Display view all and favorites.
		if (seleted_tree_item >= 0)
		{
			bViewAllFolders = false;
			bDisplayFavorite = false;
		}
		if (bViewAllFolders)
			bDisplayFavorite = false;

		//if (sMakeDefaultSelecting != "")


		if (ImGui::Selectable("View All", bViewAllFolders) || bSelectLibraryViewAll )
		{
			bSelectLibraryViewAll = false;
			seleted_tree_item = -1;
			strcpy(cSearchAllEntities[0], "");
			//Enable all filters.
			bCheckboxFilters[0] = true;
			bCheckboxFilters[1] = true;
			bCheckboxFilters[2] = true;
			bCheckboxFilters[3] = true;
			bCheckboxFilters[4] = true;
			bDisplayFavorite = false;
			bViewShowcase = false;
			bViewPurchased = false;
			bViewAllFolders = true;
			bUpdateSearchSorting = true;
			bUpdateSearchScrollbar = true;
		}

		// only show SHOWCASE and PURCHASED as relating to objects (for now)
		if (iDisplayLibraryType == 0)
		{
			if (iDisplayLibrarySubType == 1)
			{
				// no showcase or purchased for animations for now
			}
			else
			{
				if (stricmp(cSearchAllEntities[0], "Showcase") != 0) bViewShowcase = false;
				if (ImGui::Selectable("Showcase", &bViewShowcase, 0))
				{
					seleted_tree_item = -1;
					strcpy(cSearchAllEntities[0], "Showcase");
					bDisplayFavorite = false;
					bViewAllFolders = false;
					bViewShowcase = true;
					bViewPurchased = false;
					bUpdateSearchSorting = true;
					bUpdateSearchScrollbar = true;
				}
				if (stricmp(cSearchAllEntities[0], "Purchased") != 0) bViewPurchased = false;
				if (ImGui::Selectable("Purchased", &bViewPurchased, 0))
				{
					// force library to purchased view, and refresh too
					process_gotopurchaedandrefreshtopurchases();
				}
			}
		}
		else
		{
			// behavior has purchased option (from asset store)
			if (iDisplayLibraryType == 4)
			{
				if (stricmp(cSearchAllEntities[0], "Purchased") != 0) bViewPurchased = false;
				if (ImGui::Selectable("Purchased", &bViewPurchased, 0))
				{
					// force library to purchased view, and refresh too
					process_gotopurchaedandrefreshtopurchases();
				}
			}
		}

		if (ImGui::Selectable("Favorites", &bDisplayFavorite, 0))
		{
			seleted_tree_item = -1;
			strcpy(cSearchAllEntities[0], "");
			bDisplayFavorite = true;
			bViewAllFolders = false;
			bViewShowcase = false;
			bUpdateSearchSorting = true;
			bUpdateSearchScrollbar = true;
		}

		ImGui::BeginChild("##LeftPanelCategories", ImVec2(0, vWindowSize.y - 67.0f), false, iGenralWindowsFlags);

		if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1)
		{
			// animations
			DoTreeNode(0, "Noncharacter", "Purchased", sTriggerCategorySelect.Get());
		}
		else
		{
			if (iDisplayLibraryType == 4)
			{
				// behaviors
				DoTreeNode(0, "AllNoneBehaviorFolders", NULL, sTriggerCategorySelect.Get());
			}
			else
			{
				// the rest
				DoTreeNode(0, "Showcase", "Purchased", sTriggerCategorySelect.Get());
			}
		}

		sTriggerCategorySelect = "";

		ImGui::EndChild();
		ImGui::NextColumn();

		//PE: Begin child window.
		ImVec2 vWinSize = ImGui::GetContentRegionAvail();
		ImGui::BeginChild("##cSearchAllEntitiesBegin", ImVec2(0, vWinSize.y - 84.0f), false, iGenralWindowsFlags); //- 68.0f

		ImVec2 oldCursor = ImGui::GetCursorPos();

		int iIconVisiblePosY = ImGui::GetWindowSize().y + ImGui::GetScrollY() + media_icon_size;

		bool bFirstShiftHasBeenSeen = false;
		bool bAnySelectedItemsAvailable = false;
		static cFolderItem::sFolderFiles * firstShiftFile = NULL;
		static cFolderItem::sFolderFiles * lastShiftFile = NULL;
		static bool bInContextThumb;
		bInContextThumb = false;


		if (1) //
		{

			static std::vector< std::pair<std::string, cFolderItem::sFolderFiles *>> sorted_files;
			if (sorted_files.size() == 0)
				bUpdateSearchSorting = true;

			cFolderItem *pNewFolder = &MainEntityList;

			static std::vector<cFolderItem *> all_folders;
			//Check if we got new files.
			if (all_folders.size() > 0)
			{
				for (int l = 0; l < all_folders.size(); l++)
				{
					pNewFolder = all_folders[l];
					if (pNewFolder)
					{
						//PE: Check here if we need to reload the folder, for new files.
						if (pNewFolder->m_fLastTimeUpdate < Timer())
						{
							pNewFolder->m_fLastTimeUpdate = Timer() + 4000; //Check every 4-6 sec.
							pNewFolder->m_fLastTimeUpdate += rand() % 2000; //Make sure we dont check folders in same cycle.
							struct stat sb;
							if (stat(pNewFolder->m_sFolderFullPath.Get(), &sb) == 0) 
							{
								if (sb.st_mtime != pNewFolder->m_tFolderModify) 
								{
									pNewFolder->m_tFolderModify = sb.st_mtime;
									RefreshEntityFolder(pNewFolder->m_sFolderFullPath.Get(), pNewFolder);
									bUpdateSearchSorting = true;
								}
							}
						}

					}
				}
			}


			bool bDoBackbufferUpdate = false;

			//####################################################
			//#### Check if we need to update search results. ####
			//####################################################

			pNewFolder = &MainEntityList;
			pNewFolder = pNewFolder->m_pNext;
			if ((bCheckGotoPreview || bUpdateSearchSorting || bUpdateSearchSortingNextFrame) && pNewFolder)
			{
				sorted_files.clear();
				pNewFolder = pNewFolder->m_pNext;

				cStr path_remove = pNewFolder->m_sFolderFullPath.Get();
				int ipath_remove_len = path_remove.Len();

				if (iDisplayLibraryType == 0) //Object only remember last search.
				{
					if (strlen(cSearchAllEntities[i]) < 256)
					{
						strcpy(pref.cRememberLastSearchObjects, cSearchAllEntities[0]);
					}
					for (int i = 0; i < 5; i++)
						pref.iCheckboxFilters[i] = bCheckboxFilters[i];

					//bCheckboxFilters[0] - 5 and 9=fav.
				}

				while (pNewFolder)
				{
					int iCompareType = iDisplayLibraryType;
					if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1) iCompareType = 6;
					if (pNewFolder->iType == iCompareType)
					{
						//PE: Full path can now change in the middle of the list , so:
						cStr path = pNewFolder->m_sFolderFullPath.Get();

						if (pNewFolder->m_iEntityOffset > 0)
							ipath_remove_len = pNewFolder->m_iEntityOffset;


						bool isMarkers = false;
						bool bDisplayEverythingHere = false;
						bool bHideEverythingHere = false;
						bool bSentToTopOfList = false;
						if (i == 0 && strlen(cSearchAllEntities[i]) > 0)
						{
							//When search disable fixed tags search.
							bDisplayEverythingHere = false;
							bHideEverythingHere = false;
						}
						if (i == 1 && strlen(cSearchAllEntities[i]) > 0)
						{
							//When search disable fixed tags search.
							bDisplayEverythingHere = false;
							bHideEverythingHere = false;
						}

						//PE: Search only inside selected category did not work so good, if you type "box" you want all boxes.
						//PE: So here a searchterm overwrite the category checkbox selections.
						if (strlen(cSearchAllEntities[i]) == 0)
						{
							cstr cIgnoreFrom = "entitybank\\";
							if (iDisplayLibraryType == 1)
								cIgnoreFrom = "audiobank\\";
							if (iDisplayLibraryType == 2)
								cIgnoreFrom = "imagebank\\";
							if (iDisplayLibraryType == 3)
								cIgnoreFrom = "videobank\\";
							if (iDisplayLibraryType == 4)
								cIgnoreFrom = "scriptbank\\";
							if (iDisplayLibraryType == 5)
								cIgnoreFrom = "particlesbank\\";
							if (iDisplayLibraryType == 0 && iDisplayLibrarySubType==1)
								cIgnoreFrom = "charactercreatorplus\\animations\\";
							int iIgnoreLen = cIgnoreFrom.Len();

							char *find = (char *)pestrcasestr(pNewFolder->m_sFolderFullPath.Get(), cIgnoreFrom.Get());
							if (find) find += iIgnoreLen;
							else find = pNewFolder->m_sFolderFullPath.Get();

							if (find)
							{
								if (i == 0 && bCheckboxFilters[0]) //"showcase"
								{
									//if (pestrcasestr(find, "showcase"))
									//	bDisplayEverythingHere = true;
									if (pestrcasestr(find, "hud assets"))
										bDisplayEverythingHere = true;
								}
								if (i == 0 && bCheckboxFilters[1]) //"Character"
								{
									if (pestrcasestr(find, "Character"))
										bDisplayEverythingHere = true;
									if (iDisplayLibraryType == 1)
									{
										if (pestrcasestr(find, "voices"))
											bDisplayEverythingHere = true;
									}
									if (iDisplayLibraryType == 4)
									{
										if (pestrcasestr(find, "people"))
										{
											if (!pestrcasestr(find, "people\\ai"))
												bDisplayEverythingHere = true;
										}
									}
								}
								if (i == 0 && bCheckboxFilters[2]) //"Scene"
								{
									if (pestrcasestr(find, "Objects"))
										bDisplayEverythingHere = true;
									if (pestrcasestr(find, "Weapons"))
										bDisplayEverythingHere = true;
									if (iDisplayLibraryType == 1)
									{
										//For now.
										if (pestrcasestr(find, "cellar"))
											bDisplayEverythingHere = true;
										if (pestrcasestr(find, "misc"))
											bDisplayEverythingHere = true;
									}
								}
								if (i == 0 && bCheckboxFilters[4]) //"User Generated"
								{
									if (pestrcasestr(find, "User"))
										bDisplayEverythingHere = true;
									if (iDisplayLibraryType == 1)
									{
										if (pestrcasestr(find, "recordings"))
											bDisplayEverythingHere = true;
									}
								}

								if (i == 0 && bCheckboxFilters[3]) //"elements"
								{
									bHideEverythingHere = false;
									if (!bDisplayEverythingHere)
									{
										bDisplayEverythingHere = true;
										if (pestrcasestr(find, cAllFilters[0]))
											bHideEverythingHere = true;
										if (pestrcasestr(find, cAllFilters[1]))
											bHideEverythingHere = true;
										if (pestrcasestr(find, cAllFilters[2]))
											bHideEverythingHere = true;
										if (pestrcasestr(find, cAllFilters[3]))
											bHideEverythingHere = true;
										if (pestrcasestr(find, cAllFilters[4]))
											bHideEverythingHere = true;
										if (iDisplayLibraryType == 1)
										{
											if (pestrcasestr(find, "voices"))
												bHideEverythingHere = true;
											if (pestrcasestr(find, "recordings")) //"Scene"
												bHideEverythingHere = true;
											//For now.
											if (pestrcasestr(find, "cellar"))
												bHideEverythingHere = true;
											if (pestrcasestr(find, "misc"))
												bHideEverythingHere = true;
										}
									}
								}

								if (current_sortby == 1) //0 a-z now also showcase showcase
								{
									if (pestrcasestr(find, "showcase"))
									{
										bDisplayEverythingHere = true;
										bSentToTopOfList = true;
									}
								}
								else
								{
									if (!bDisplayFavorite)
									{
										if (pestrcasestr(find, "showcase"))
										{
											bHideEverythingHere = true;
										}
									}
								}
							}
						}

						if (bDisplayFavorite)
						{
							//Favorite display from all folders.
							bDisplayEverythingHere = true;
						}

						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;

						std::string path_for_filename = final_name;
						std::string dir_name = final_name;
						replaceAll(dir_name, "\\", " - ");

						bool bSearchGameElements = false;
						if (pestrcasestr(dir_name.c_str(), "_markers"))
							bSearchGameElements = true;

						if (!isMarkers && i == 0 && !bDisplayEverythingHere && !bHideEverythingHere && strlen(cSearchAllEntities[i]) > 0) 
						{
							if (iDisplayLibraryType > 0) //Other media types only search sub folder names.
							{
								if (pestrcasestr(dir_name.c_str(), cSearchAllEntities[i]))
									bDisplayEverythingHere = true;
							}
							else
							{
								if (pestrcasestr(pNewFolder->m_sFolderFullPath.Get(), cSearchAllEntities[i]))
									bDisplayEverythingHere = true;
								else if (pestrcasestr(dir_name.c_str(), cSearchAllEntities[i]))
									bDisplayEverythingHere = true;
							}
						}

						//PE: Check here if we need to reload the folder, for new files.
						if (pNewFolder->m_fLastTimeUpdate < Timer())
						{
							pNewFolder->m_fLastTimeUpdate = Timer() + 4000; //Check every 4-6 sec.
							pNewFolder->m_fLastTimeUpdate += rand() % 2000; //Make sure we dont check folders in same cycle.
							struct stat sb;
							if (stat(pNewFolder->m_sFolderFullPath.Get(), &sb) == 0) 
							{
								if (sb.st_mtime != pNewFolder->m_tFolderModify) 
								{
									pNewFolder->m_tFolderModify = sb.st_mtime;
									RefreshEntityFolder(pNewFolder->m_sFolderFullPath.Get(), pNewFolder);
								}
							}
						}

						if (pNewFolder->m_pFirstFile)
						{
							bool bDisplayText = true;

							cFolderItem::sFolderFiles * myfiles = NULL;

							myfiles = pNewFolder->m_pFirstFile->m_pNext;

							while (myfiles)
							{
								bool bIsVisible = true;
								bool bForceVisible = false;
								bool bIsPhonetic = false;
								int iPhoneticDistance = 999;
								if (i == 0 && isMarkers) bIsVisible = false;
								if (i == 1 && !isMarkers) bIsVisible = false;
								if (i == 0) bIsVisible = false; //Default to not visible.

								//PE: Clear any selection when updating list.
								myfiles->iFlags = 0;

								if (!bLargePreview && bCheckGotoPreview && sGotoPreviewWithFile != "")
								{
									cstr test = pNewFolder->m_sFolderFullPath + "\\" + myfiles->m_sName;
									if (pestrcasestr(test.Get(), sGotoPreviewWithFile.Get()))
									{
										// ZJ: Following importer feedback, user folder should be displayed in the object library...
										// ...instead of just searching for the imported object.
										////Found it.
										//sStartLibrarySearchString = myfiles->m_sName;
										//if(sStartLibrarySearchString.Len() > 4)
										//	sStartLibrarySearchString = Left(sStartLibrarySearchString.Get(), sStartLibrarySearchString.Len() - 4);
										//std::string sString = sStartLibrarySearchString.Get();
										//replaceAll(sString, "_", " ");
										//replaceAll(sString, "-", " ");
										//sStartLibrarySearchString = sString.c_str();

										sStartLibrarySearchString = "user";

										iLastDisplayLibraryType = -1;
										//Refresh with new search.
										//Load dbo and display large preview.
										pPreviewFile = myfiles;
										bLargePreview = true;
										bDoBackbufferUpdate = true;
										bIsVisible = true;
										bForceVisible = true;
									}
								}

								if (i == 0 && strlen(cSearchAllEntities[i]) > 0) {

									if (pestrcasestr(myfiles->m_sBetterSearch.Get(), cSearchAllEntities[i]))
										bIsVisible = true;
									if (!bIsVisible) // else current_sortby == 4)
									{
										if (bAdvancedFPEFeatures && myfiles->m_sFPEKeywords.Len() > 0)
										{
											if (pestrcasestr(myfiles->m_sFPEKeywords.Get(), cSearchAllEntities[i]))
												bIsVisible = true;
										}
#ifdef PHONETICSEARCH
										if (!bIsVisible) // else current_sortby == 4)
										{
											if (phonetic_find.length() > 0)
											{
												if (char * dist = (char *)pestrcasestr(myfiles->m_sPhoneticSearch.Get(), phonetic_find.c_str()))
												{
													bIsVisible = true;
													bIsPhonetic = true;
													if (dist)
													{
														iPhoneticDistance = dist - myfiles->m_sPhoneticSearch.Get();
													}
												}
											}
										}
#endif
									}

									if (!bIsVisible && bSearchGameElements)
									{
										if (pestrcasestr(cSearchAllEntities[i], "Game Elements"))
											bIsVisible = true;
									}

								}

								if (bDisplayEverythingHere)
									bIsVisible = true;
								if (bHideEverythingHere)
									bIsVisible = false;

								if (bDisplayFavorite && !myfiles->bFavorite)
								{
									bIsVisible = false;
								}

								uniqueId++;

								if (bAdvancedFPEFeatures && current_sortby == 5 || current_sortby == 6)
								{
									//Hide files that do not "yet" have a DBO and then no poly count.
									if (myfiles->m_iFPEDBOFileSize <= 0)
										bIsVisible = false;
								}

								// always hide files ending with "_smartchild", they are only useful to the smart objects construction
								// and no good on their own for the vast majority of cases
								if (strnicmp(myfiles->m_sNameFinal.Get() + strlen(myfiles->m_sNameFinal.Get()) - 11, "_smartchild", 11) == NULL)
								{
									bIsVisible = false;
									bForceVisible = false;
								}

								if (bIsVisible || bForceVisible)
								{
									// set sortby mode = current_sortby
									// 0 = showcase
									// 1 = no sorting, category order and files A-Z inside each category. 0
									// 2 = A-Z 1
									// 3 = Z-A 2
									// 4 = Date Old-New 5
									// 5 = Date New-Old 6
									// 6 = Poly low 7
									// 7 = Poly high 8

									//Push files entry into a sort list.
									std::string SortBy = Lower(myfiles->m_sName.Get());

									if (current_sortby == 0) //|| current_sortby == 1
									{
										//Showcase and category display.
										SortBy = dir_name + ":" + SortBy;
									}
									if (seleted_tree_item >= 0 && pestrcasestr(cSearchAllEntities[i], dir_name.c_str()))
									{
										//PE: This search is from a click on a category, sort normally.
										//SortBy = dir_name + ":" + SortBy;
									}
									else if (strlen(cSearchAllEntities[i]) > 0) // && current_sortby == 3 || current_sortby == 4
									{
										std::string AddToSort = "";
										std::string SortSearch = Lower(cSearchAllEntities[i]);
										char * dist = (char *)pestrcasestr(myfiles->m_sBetterSearch.Get(), cSearchAllEntities[i]);
										int iDist = 99;
										if (dist)
										{
											iDist = dist - myfiles->m_sBetterSearch.Get();
										}
										if (iDist < 10)
											AddToSort = "0";
										AddToSort = AddToSort + std::to_string(iDist);
										SortBy = AddToSort + SortBy;
									}

									if (current_sortby == 3 || current_sortby == 4)
									{
										char buffer[80];
										struct tm * timeinfo = localtime(&myfiles->m_tFileModify);
										strftime(buffer, 80, "%F%H%M", timeinfo);
										SortBy = buffer;
									}

#ifdef PHONETICSEARCH
									if (bIsPhonetic) // && current_sortby == 4
									{
										//Put in bottom of results.
										std::string AddToSort = "";
										if (iPhoneticDistance < 10)
											AddToSort = "0";
										AddToSort = AddToSort + std::to_string(iPhoneticDistance);
										SortBy = "ZZZZ" + AddToSort + SortBy;
									}
#endif

									if (bSentToTopOfList)
									{
										SortBy = "0000" + SortBy;
									}


									if (bAdvancedFPEFeatures && current_sortby == 5 || current_sortby == 6)
									{
										//Sort by poly count.
										int iSize = myfiles->m_iFPEDBOFileSize;
										if (iSize > 0)
										{
											std::string AddToSort = "";
											if (iSize < 10)
												AddToSort = "0000000";
											else if (iSize < 100)
												AddToSort = "000000";
											else if (iSize < 1000)
												AddToSort = "00000";
											else if (iSize < 10000)
												AddToSort = "0000";
											else if (iSize < 100000)
												AddToSort = "000";
											else if (iSize < 1000000)
												AddToSort = "00";
											else if (iSize < 10000000)
												AddToSort = "0";
											AddToSort = AddToSort + std::to_string(iSize);
											SortBy = AddToSort + SortBy;
										}
									}

									sorted_files.push_back(std::make_pair(SortBy, myfiles));
									//Map pNewFolder to files entry.
									myfiles->pNewFolder = pNewFolder;
									//myfiles->bLoadedInNewFormat = bLoadedInNewFormat;
									//myfiles->textureId = textureId;
									myfiles->uniqueId = uniqueId;
								}

								myfiles = myfiles->m_pNext;

							}
						}
					}
					pNewFolder = pNewFolder->m_pNext;

				} // while folders.

			} //bUpdateSearchSorting

			if ((bUpdateSearchSorting || bUpdateSearchSortingNextFrame) && sorted_files.size() > 0)
			{
				// set sortby mode = current_sortby
				// 0 = showcase
				// 1 = no sorting, category order and files A-Z inside each category. 0
				// 2 = A-Z 1
				// 3 = Z-A 2
				// 4 = Date Old-New 5
				// 5 = Date New-Old 6
				// 6 = Poly low 7
				// 7 = Poly high 8

				if (current_sortby >= 0)
				{
					std::sort(sorted_files.begin(), sorted_files.end());
					if (current_sortby == 4 || current_sortby == 2 || current_sortby == 6)
						std::reverse(sorted_files.begin(), sorted_files.end());
				}
			}

			bUpdateSearchSortingNextFrame = false;
			bUpdateSearchSorting = false;

			//#####################################################
			//#### Start the actual display of the object list ####
			//#####################################################

			cwidth = ImGui::GetContentRegionAvailWidth();
			iColumnsWidth = cwidth / pref.iSetColumnsEntityLib;
			iColumnsWidth -= 8.0; //padding

			if (iColumnsWidth < 100)
				iColumnsWidth = 100;
			media_icon_size = iColumnsWidth - 6.0;
			media_icon_size_y = media_icon_size * 0.5625f; //PE: 1920x1080 ratio.


			//float fWinWidth = ImGui::GetWindowSize().x - 10.0; // Flicker - ImGui::GetCurrentWindow()->ScrollbarSizes.x;
			float fWinWidth = ImGui::GetContentRegionAvailWidth() - 10.0; // Flicker - ImGui::GetCurrentWindow()->ScrollbarSizes.x;
			if (iColumnsWidth >= fWinWidth && fWinWidth > media_icon_size)
			{
				iColumnsWidth = fWinWidth;
			}
			//int iColumns = (int)(ImGui::GetWindowSize().x / (iColumnsWidth));
			int iColumns = (int)(ImGui::GetContentRegionAvailWidth() / (iColumnsWidth));
			if (iColumns <= 1)
				iColumns = 1;

			ImGui::BeginColumns("##filescolumns4entities", iColumns, ImGuiColumnsFlags_NoBorder);
			//ImGui::Columns(iColumns, "filescolumns4entities", false);  //false no border

			if (bUpdateSearchScrollbar)
			{
				ImGui::SetScrollY(0);
				bUpdateSearchScrollbar = false;
			}

			//PE: Control scrollbar here.
			static bool bTriggerAnotherEndKey = false;
			if (bTriggerAnotherEndKey)
			{
				ImGui::SetScrollY(ImGui::GetScrollMaxY() * 2.0);
				bTriggerAnotherEndKey = false;
			}
			if (bLastEntityGotFocus)
			{
				//PE: https://github.com/TheGameCreators/GameGuruRepo/issues/1239

				if (!io.KeyShift)
				{
					if (!io.KeyCtrl) // CTRL+A
					{
						bool bChanged = false;
						float sy = ImGui::GetScrollY();

						//if (ImGui::IsKeyReleased(38)) //use for single no repeat.

						if(	ImGui::IsKeyPressed(38, true) ) //UP
						{
							if (sy > 0) sy = sy - ImGui::GetFontSize();
							bChanged = true;
						}
						if (ImGui::IsKeyPressed(40, true)) //Down
						{
							if (sy < ImGui::GetScrollMaxY()) sy = sy + ImGui::GetFontSize();
							bChanged = true;
						}
						if (ImGui::IsKeyPressed(33, true)) //PGUP
						{
							if (sy > 0) sy = sy - (ImGui::GetContentRegionAvail().y + 9.0);
							bChanged = true;
						}
						if (ImGui::IsKeyPressed(34, true)) //PGDOWN
						{
							if (sy < ImGui::GetScrollMaxY()) sy = sy + (ImGui::GetContentRegionAvail().y + 9.0);
							bChanged = true;
						}
						if (ImGui::IsKeyPressed(36, true)) //HOME
						{
							sy = 0;
							bChanged = true;
						}
						if (ImGui::IsKeyPressed(35, true)) //END
						{
							sy = ImGui::GetScrollMaxY() * 2.0;
							bChanged = true;
							bTriggerAnotherEndKey = true; //PE: Needed.
						}

						if (bChanged)
						{
							if (sy < 0) sy = 0;
							ImGui::SetScrollY(sy);
						}
					}
				}
			}


			//PE: Create a list of all selected objects.
			selected_library_fpe.clear();

			//#####################################
			//#### Created selected files list ####
			//#####################################

			static int all_folders_check = 20;
			if (all_folders_check-- < 0) all_folders_check = 20;
			all_folders.clear();
			for (int iLoop = 0; iLoop < sorted_files.size(); iLoop++)
			{
				//if (myfiles->iFlags == 1)
				if (sorted_files[iLoop].second)
				{
					cFolderItem::sFolderFiles * myfiles = NULL;
					myfiles = sorted_files[iLoop].second;
					if (all_folders_check == 0 && myfiles && sorted_files[iLoop].second->pNewFolder)
					{
						if (std::find(all_folders.begin(), all_folders.end(), sorted_files[iLoop].second->pNewFolder) == all_folders.end()) {
							all_folders.push_back(sorted_files[iLoop].second->pNewFolder);
						}
					}

					if (myfiles && myfiles->iFlags == 1)
					{

						pNewFolder = sorted_files[iLoop].second->pNewFolder;
						int ipath_remove_len = pNewFolder->m_sFolderFullPath.Len();

						cStr path = pNewFolder->m_sFolderFullPath.Get();

						if (pNewFolder->m_iEntityOffset > 0)
							ipath_remove_len = pNewFolder->m_iEntityOffset;

						//
						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;

						std::string path_for_filename = final_name;

						std::string sFpeName = path_for_filename.c_str();
						sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
						t.addentityfile_s = sFpeName.c_str();
						selected_library_fpe.insert(std::make_pair(t.addentityfile_s.Get(), 0));
					}
				}
			}


			static bool bAddAllVisibleTriggerMessage = false;
			if (bAddAllVisibleTriggerMessage && selected_library_fpe.size() >= 100)
			{
				//Check if we need to triggerr a warning.
				if (MessageBoxA(NULL, "You have selected more then 100 object, are you sure you want to continue ?", "Warning", MB_YESNO | MB_TOPMOST) != IDYES)
				{
					//Clear all flags again.
					for (int iLoop = 0; iLoop < sorted_files.size(); iLoop++)
					{
						if (sorted_files[iLoop].second)
						{
							cFolderItem::sFolderFiles * myfiles = NULL;
							myfiles = sorted_files[iLoop].second;
							if (myfiles && myfiles->iFlags == 1)
								myfiles->iFlags = 0;
						}
					}
				}
			}

			bAddAllVisibleTriggerMessage = false;

			int ipath_remove_len = 0;
			pNewFolder = NULL;
			static bool bAddAllVisible = false;
			bAddAllVisible = false;

			static int iVideoPreviewThumbID = 0;
			static int iVideoGenerateImageID = 0;
			static cFolderItem::sFolderFiles * pVideoGeneratingFile = NULL;
			static cstr sVideoSaveName = "";

			//Check if we are generating a video preview.
			if (iDisplayLibraryType == 3 && iVideoGetFirstFrame > 0)
			{

				if (iVideoGetFirstFrame > 0) {

					UpdateAllAnimation();
					SetVideoVolume(0.1);

					if (iVideoGetFirstFrame == 1) {

						PauseAnim(iVideoPreviewThumbID);
						SetVideoVolume(100.0); //Turn back volume.
						//UpdateAllAnimation();
						//Capture frame.
						LPGGSURFACE lpVideoTexture = GetAnimPointerTexture(iVideoPreviewThumbID);

						float fVideoW = GetAnimWidth(iVideoPreviewThumbID);
						float fVideoH = GetAnimHeight(iVideoPreviewThumbID);

						//Save image do not work on some image sizes ?
						//int rounftofour = fVideoW / 32;
						//fVideoW = rounftofour * 32;
						//rounftofour = fVideoH / 32;
						//fVideoH = rounftofour * 32;

						if (iVideoPreviewThumbID > 0 && lpVideoTexture && iVideoGenerateImageID > 0) {
							float fRatio = 1.0f / (fVideoW / fVideoH);

							LPGGSURFACE pOldBackBuffer = g_pGlob->pCurrentBitmapSurface;
							 g_pGlob->pCurrentBitmapSurface = lpVideoTexture;
							SetGrabImageMode(1);
							// delete previous thumbnail
							if (GetImageExistEx(iVideoGenerateImageID))
							{
								DeleteImage(iVideoGenerateImageID);
							}

							GrabImage(iVideoGenerateImageID, 0, 0, fVideoW, fVideoH, 0);
							SetGrabImageMode(0);
							g_pGlob->pCurrentBitmapSurface = pOldBackBuffer;

							if (GetImageExistEx(iVideoGenerateImageID))
							{
								//The thumb name will include 512x288 but we can scale it to the actual size when we know its a video.
								SaveImage(sVideoSaveName.Get(), iVideoGenerateImageID);
								pVideoGeneratingFile->iPreview = iVideoGenerateImageID;
								pVideoGeneratingFile->iBigPreview = iVideoGenerateImageID;
							}
						}

						if (AnimationExist(iVideoPreviewThumbID)) {
							if (AnimationPlaying(iVideoPreviewThumbID))
								StopAnimation(iVideoPreviewThumbID);
							DeleteAnimation(iVideoPreviewThumbID);
						}
						iVideoPreviewThumbID = 0;
						iVideoGenerateImageID = 0;
					}
					iVideoGetFirstFrame--;
				}

			}

			static int iWaitFramesBeforeProceed = 0;
			if (iDisplayLibraryType == 5 && iWaitFramesBeforeProceed > 0)
			{
				iWaitFramesBeforeProceed--;
			}

			//###################
			//#### MAIN LOOP ####
			//###################

			static bool bSecondScrollActive = false;
			bSecondScrollActive = true;

			total_files_displayed_in_library = 0;
			for (int iLoop = 0; iLoop < sorted_files.size(); iLoop++)
			{
				bool bValid = false;

				if (sorted_files.size() > 0)
				{
					if (sorted_files[iLoop].second)
					{
						pNewFolder = sorted_files[iLoop].second->pNewFolder;
						ipath_remove_len = pNewFolder->m_sFolderFullPath.Len();
						bValid = true;
					}
				}

				if (bValid)
				{

					//PE: Full path can now change in the middle of the list , so:
					cStr path = pNewFolder->m_sFolderFullPath.Get();

					if (pNewFolder->m_iEntityOffset > 0)
						ipath_remove_len = pNewFolder->m_iEntityOffset;

					bool isMarkers = false;


					char *final_name = path.Get();
					final_name += ipath_remove_len;
					if (*final_name == '\\')
						final_name++;

					std::string path_for_filename = final_name;
					std::string dir_name = final_name;
					replaceAll(dir_name, "\\", " - ");

					//if (pestrcasestr(dir_name.c_str(), "_markers"))
					//	isMarkers = true;



					bool bDisplayText = true;

					cFolderItem::sFolderFiles * myfiles = NULL;

					myfiles = sorted_files[iLoop].second;
					if (myfiles)
					{

						if (myfiles->iFlags == 1)
							multi_selections_count++;

						bool bIsVisible = true;

						uniqueId = myfiles->uniqueId;
						ImGui::PushID(uniqueId); //Already unique: +preview_count);

						bool bLoadedInNewFormat = true;
						int iDefaultTexture = TOOL_ENTITY;
						int textureId = 0;

						{
							if (iDisplayLibraryType > 0)
							{
								if (iDisplayLibraryType == 2)
								{
									//PE: Need default image if we cant load the image.
									iDefaultTexture = ABOUT_TGC;
								}
								if (iDisplayLibraryType == 1)
								{
									iDefaultTexture = FILETYPE_MP3;
									//TODO: Support loading custom thumbs for music ?
									if (pestrcasestr(myfiles->m_sName.Get(), ".ogg"))
									{
										iDefaultTexture = FILETYPE_OGG;
									}
									else if (pestrcasestr(myfiles->m_sName.Get(), ".wav"))
									{
										iDefaultTexture = FILETYPE_WAV;
									}
								}
								if (iDisplayLibraryType == 3) //Video
								{
									//PE: Need default image before we generate a video preview.
									iDefaultTexture = FILETYPE_VIDEO;
								}
								if (iDisplayLibraryType == 4) //Script
								{
									//PE: Need default image before we generate a video preview.
									iDefaultTexture = FILETYPE_SCRIPT;
								}
								if (iDisplayLibraryType == 5) //Particles
								{
									//PE: Need default image before we generate a video preview.
									iDefaultTexture = FILETYPE_PARTICLE;

								}
							}
							//FPE Files.
							bool bCheckForNewPreviewImage = true;

							//Dont check any new ones before the first is done. just use default in this case.
							if (iDisplayLibraryType == 3 )
							{
								if (iVideoGenerateImageID > 0)
								{
									bCheckForNewPreviewImage = false;
									textureId = iDefaultTexture;
								}
							}

							if (iDisplayLibraryType == 5 && BackBufferParticlesMode)
							{
								bCheckForNewPreviewImage = false;
								textureId = iDefaultTexture;
								iWaitFramesBeforeProceed = 3;
							}
							
							//PE: Make sure to init all dlua descriptions.
							if (iDisplayLibraryType == 4 && myfiles->m_sDLuaDescription == "##na##")
							{
								//Load in DLUA description.
								std::string sScriptName = myfiles->m_sPath.Get();
								sScriptName = sScriptName + "\\" + myfiles->m_sName.Get();
								entityeleproftype dluaload;
								ParseLuaScript(&dluaload, (char *)sScriptName.c_str());
								myfiles->m_sDLuaDescription = "";
								if (dluaload.PropertiesVariableActive == 1)
								{
									//Build string
									char pCaptureAnyScriptDesc[8192 + 4096];
									strcpy(pCaptureAnyScriptDesc, "");
									for (int i = 0; i < dluaload.PropertiesVariable.iVariables; i++)
									{
										if (strlen(pCaptureAnyScriptDesc) < 8192)
										{
											strcat(pCaptureAnyScriptDesc, dluaload.PropertiesVariable.VariableSectionDescription[i]);
											if (dluaload.PropertiesVariable.Variable[i] && strlen(dluaload.PropertiesVariable.Variable[i]) > 0)
											{
												//Split into segments.
												strcat(pCaptureAnyScriptDesc, "[");
												strcat(pCaptureAnyScriptDesc, dluaload.PropertiesVariable.Variable[i]);
												strcat(pCaptureAnyScriptDesc, "]");
											}
											if (dluaload.PropertiesVariable.VariableSectionEndDescription[i] && strlen(dluaload.PropertiesVariable.VariableSectionEndDescription[i]) > 0)
											{
												strcat(pCaptureAnyScriptDesc, dluaload.PropertiesVariable.VariableSectionEndDescription[i]);
											}
										}
									}
									myfiles->m_sDLuaDescription = pCaptureAnyScriptDesc;
								}
								else
								{
									if (dluaload.PropertiesVariable.VariableDescription.Len() > 0)
									{
										myfiles->m_sDLuaDescription = dluaload.PropertiesVariable.VariableDescription;
									}
								}
							}

							if (myfiles->iPreview <= 0 && bCheckForNewPreviewImage)
							{
								bool bDontTouchThisID = false;
								//Only Visible.
								int gcpy = ImGui::GetCursorPosY();
								if (!bReleaseIconsDynamic || ((bIsVisible || isMarkers) && (gcpy < iIconVisiblePosY && gcpy >= ImGui::GetScrollY() - media_icon_size || isMarkers)))
								{
									myfiles->last_used = (long)tCurrentTimeSec;
									if (!bImagesStillInImGuiQueue && !bLargePreview && max_load_persync-- > 0)
									{
										//Load preview.
										std::string sImgName = myfiles->m_sPath.Get();
										if (iDisplayLibraryType == 2)
										{
											//PE: Use image directly.
											sImgName = sImgName + "\\" + myfiles->m_sName.Get();
											//__debugbreak(); //Test file.
										}
										else if (iDisplayLibraryType > 0)
										{
											//Use .jpg as thumbs for other media. 512x288 format.
											sImgName = sImgName + "\\" + Left(myfiles->m_sName.Get(), Len(myfiles->m_sName.Get()) - 4);
											if (iDisplayLibraryType == 4) //Script
											{
												if (pref.current_style == 25 || pref.current_style == 3)
													sImgName += ".png";
												else
													sImgName += "2.png";
											}
											else
												sImgName += ".jpg";
										}
										else
										{
											sImgName = sImgName + "\\" + Left(myfiles->m_sName.Get(), Len(myfiles->m_sName.Get()) - 4);
											sImgName += ".bmp";
										}
										myfiles->iPreview = uniqueId;
										SetMipmapNum(1); //PE: mipmaps not needed.

										//PE: Check if we got a cached thumb in correct format.
										std::string sFpeName = path_for_filename.c_str();
										sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
										t.addentityfile_s = sFpeName.c_str();
										if (iDisplayLibraryType == 5)
										{
											//PE: Changed to support subfolders.
											sFpeName = "particlesbank\\";
											sFpeName = sFpeName + path_for_filename.c_str();
											sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
											replaceAll(sFpeName, "\\\\", "\\");
											t.addentityfile_s = sFpeName.c_str();
										}
										CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
										image_setlegacyimageloading(true);
										if (FileExist(BackBufferCacheName.Get()))
										{
											LoadImage((char *)BackBufferCacheName.Get(), myfiles->iPreview);
											if (!ImageExist(myfiles->iPreview))
											{
												LoadImage((char *)sImgName.c_str(), myfiles->iPreview);
											}
											else
											{
												//PE: Mark as ok in new format.
												myfiles->iBigPreview = iDefaultTexture;
											}
										}
										else 
										{
											//PE: Try to make a thumb here.
											if (iDisplayLibraryType == 3)
											{
												//Try custom image.
												LoadImage((char *)sImgName.c_str(), myfiles->iPreview);
												if (!ImageExist(myfiles->iPreview))
												{
													if (iVideoThumbID > 0 && AnimationExist(iVideoThumbID) && AnimationPlaying(iVideoThumbID))
													{
														//We cant do this if a video is already playing. perhaps stop in next run ?
														iStopVideoInNextFrame = iVideoThumbID;
														bDontTouchThisID = true;
													}
													else
													{
														//Only if we are not already generating a preview of video.

														std::string sVideoName = myfiles->m_sPath.Get();
														sVideoName = sVideoName + "\\" + myfiles->m_sName.Get();

														if (iVideoGetFirstFrame == 0)
														{

															if (iVideoPreviewThumbID > 0) {
																if (AnimationExist(iVideoPreviewThumbID)) {
																	if (AnimationPlaying(iVideoPreviewThumbID))
																		StopAnimation(iVideoPreviewThumbID);
																	DeleteAnimation(iVideoPreviewThumbID);
																	iVideoPreviewThumbID = 0;
																}
															}

															iVideoPreviewThumbID = 0;

															for (int itl = 1; itl <= 32; itl++)
															{
																if (AnimationExist(itl) == 0) { iVideoPreviewThumbID = itl; break; }
															}
															if (LoadAnimation((char *)sVideoName.c_str(), iVideoPreviewThumbID, g.videoprecacheframes, 0, 1) == false)
															{
																//Failed to load mark as ok using default thumb.
																myfiles->iPreview = iDefaultTexture;
																myfiles->iBigPreview = iDefaultTexture;
																textureId = iDefaultTexture;
																iVideoPreviewThumbID = -999;
															}

															if (iVideoPreviewThumbID > 0) {
																PlaceAnimation(iVideoPreviewThumbID, -1, -1, -1, -1);
																SetRenderAnimToImage(iVideoPreviewThumbID, true);
																//Try to get first frame.
																StopAnimation(iVideoPreviewThumbID);
																PlayAnimation(iVideoPreviewThumbID);
																void SetVideoPosition(float seconds);
																SetVideoPosition(1.0f);
																PlayAnimation(iVideoPreviewThumbID);
																//UpdateAllAnimation();
																SetRenderAnimToImage(iVideoPreviewThumbID, true);

																UpdateAllAnimation();
																Sleep(50); //Sleep so we get a video texture in the next call.
																UpdateAllAnimation();
																SetVideoVolume(0.1);
																iVideoGetFirstFrame = 8;
																iVideoGenerateImageID = myfiles->iPreview;
																pVideoGeneratingFile = myfiles;
																sVideoSaveName = BackBufferCacheName;
															}

														}
													}
												}
											}
											else if (iDisplayLibraryType == 5)
											{
												//Create particle thumb here.
												BackBufferIsGroup = false;
												BackBufferEntityID = 0;
												BackBufferObjectID = 0;
												BackBufferImageID = myfiles->iPreview;
												BackBufferSizeX = 512;
												BackBufferSizeY = 288;
												BackBufferCamLeft = 0.0f;
												bRotateBackBuffer = false;
												bBackBufferAnimated = false;
												bLoopBackBuffer = false;
												BackBufferSaveCacheName = ""; //No saving for now
												//Dont fit snapshot to rubber band.
												fLastRubberBandX1 = fLastRubberBandX2 = fLastRubberBandY1 = fLastRubberBandY2 = 0.0f;
												bSnapShotModeUseCamera = false;
												BackBufferParticlesMode = true;
												bDontTouchThisID = true;
												CreateBackdropObject(false, cstr("texturebank\\backdrops\\Black backdrop.dds"), t.addentityfile_s); //PE: We need a extra frame, as we set the material dirty in this call.

												BackBufferZoom = 800.0f;
												BackBufferCamUp = 400.0f;

												//Test
												float centerx = -1000, centery = 39000, centerz = -1000;
												//PositionObject(50001, centerx, centery, centerz);
												//ShowObject(50001);

												std::string sParticleName = myfiles->m_sPath.Get();
												char cTmp[MAX_PATH];
												cstr savename = myfiles->m_sPath + "\\" + myfiles->m_sName;
												strcpy(cTmp, savename.Get());
												char *find = (char *) pestrcasestr(cTmp, "\\particlesbank");
												if (find)
												{
													strcpy(cTmp, find + 1);
												}
												else
												{
													strcpy(cTmp, "particlesbank\\");
													strcat(cTmp, myfiles->m_sName.Get());
												}
												CreateBackBufferCacheName(cTmp, thumb_x, thumb_y);
												BackBufferSaveCacheName = BackBufferCacheName;

												sParticleName = sParticleName + "\\" + Left(myfiles->m_sName.Get(), Len(myfiles->m_sName.Get()) - 4);

												if (BackBufferParticleEmitter != -1)
												{
													gpup_deleteEffect(BackBufferParticleEmitter);
													BackBufferParticleEmitter = -1;
												}

												if (BackBufferParticleEmitter == -1)
												{
													BackBufferParticleEmitter = gpup_loadEffect(sParticleName.c_str(), 0, 0, 0, 1.0);
													gpup_setGlobalScale(BackBufferParticleEmitter, 100.0f);
													gpup_emitterActive(BackBufferParticleEmitter, 0);
												}
												float fLive = 10.0f;
												if (BackBufferParticleEmitter != -1)
												{
													gpup_setGlobalPosition(BackBufferParticleEmitter, centerx, centery - 30.0f, centerz);
													gpup_resetLocalPosition(BackBufferParticleEmitter);
													gpup_setGlobalScale(BackBufferParticleEmitter, 100.0f);
													gpup_emitterActive(BackBufferParticleEmitter, 1);
													gpup_setEffectAnimationSpeed(BackBufferParticleEmitter, 1.0f);
													gpup_setEffectOpacity(BackBufferParticleEmitter, 1.0f);

													fLive = gpup_getEffectLifespan(BackBufferParticleEmitter);
													//gpup_emitter[enr].lifespan * 60 * 10
												}
												//We need to delay the thumb as we cant fast forward the particles.
												if (fLive < 100.0f)
													iBackBufferParticlesTrigger = 25;
												else if (fLive < 200.0f)
													iBackBufferParticlesTrigger = 110;
												else if (fLive < 300.0f)
													iBackBufferParticlesTrigger = 150;
												else
													iBackBufferParticlesTrigger = 160; //Max

												iWaitFramesBeforeProceed = 3;
											}
											else
											{
												bLoadedInNewFormat = false;
												LoadImage((char *)sImgName.c_str(), myfiles->iPreview);
											}
										}
										image_setlegacyimageloading(false);
										SetMipmapNum(-1);

										//##na##
										if (iDisplayLibraryType == 4)
										{
											//Load in DLUA description.
											std::string sScriptName = myfiles->m_sPath.Get();
											sScriptName = sScriptName + "\\" + myfiles->m_sName.Get();
											entityeleproftype dluaload;
											ParseLuaScript(&dluaload, (char *) sScriptName.c_str());
											myfiles->m_sDLuaDescription = "";
											if (dluaload.PropertiesVariableActive == 1)
											{
												//Build string
												char pCaptureAnyScriptDesc[8192+4096];
												strcpy(pCaptureAnyScriptDesc, "");
												for (int i = 0; i < dluaload.PropertiesVariable.iVariables; i++)
												{
													if (strlen(pCaptureAnyScriptDesc) < 8192)
													{
														strcat(pCaptureAnyScriptDesc, dluaload.PropertiesVariable.VariableSectionDescription[i]);
														if (dluaload.PropertiesVariable.Variable[i] && strlen(dluaload.PropertiesVariable.Variable[i]) > 0)
														{
															//Split into segments.
															strcat(pCaptureAnyScriptDesc, "[");
															strcat(pCaptureAnyScriptDesc, dluaload.PropertiesVariable.Variable[i]);
															strcat(pCaptureAnyScriptDesc, "]");
														}
														if (dluaload.PropertiesVariable.VariableSectionEndDescription[i] && strlen(dluaload.PropertiesVariable.VariableSectionEndDescription[i]) > 0)
														{
															strcat(pCaptureAnyScriptDesc, dluaload.PropertiesVariable.VariableSectionEndDescription[i]);
														}
													}
												}
												myfiles->m_sDLuaDescription = pCaptureAnyScriptDesc;
											}
											else
											{
												if (dluaload.PropertiesVariable.VariableDescription.Len() > 0)
												{
													myfiles->m_sDLuaDescription = dluaload.PropertiesVariable.VariableDescription;
												}
											}


										}


										if (!GetImageExistEx(myfiles->iPreview))
										{
											if (!bDontTouchThisID)
											{
												myfiles->iPreview = iDefaultTexture;
												textureId = iDefaultTexture;
											}
											else
											{
												textureId = iDefaultTexture;
											}
										}
										else {
											loaded_images++;
											textureId = myfiles->iPreview;
										}
									}
									else
									{
										textureId = iDefaultTexture;
									}
								}
								else
								{
									textureId = iDefaultTexture;
								}
							}
							else
							{
								//PE: Only delete in first run. so we dont delete a image that has already been sent to rendering.
								if (bReleaseIconsDynamic && myfiles->iPreview > 0 ) {
									//Only NOT Visible with a preview image..
									int gcpy = ImGui::GetCursorPosY();
									if (!isMarkers && (!(gcpy < iIconVisiblePosY && gcpy >= ImGui::GetScrollY() - media_icon_size) || !bIsVisible)) {

										if ((long)tCurrentTimeSec - myfiles->last_used > 20) {
											//Delete Image not visible for 20 sec.
											if (GetImageExistEx(myfiles->iPreview) && myfiles->iPreview >= 4000 && myfiles->iPreview < UIV3IMAGES) { //PE: Need to protect system images after tool img range has changed. (myfiles->iPreview can be a system icon)
												image_setlegacyimageloading(true);
												DeleteImage(myfiles->iPreview);
												image_setlegacyimageloading(false);
												myfiles->iPreview = 0;
												loaded_images--;
											}
											textureId = iDefaultTexture;
										}
										else
											textureId = myfiles->iPreview;
									}
									else {
										//Still visible update time.
										if (bIsVisible || isMarkers)
											myfiles->last_used = (long)tCurrentTimeSec;
										textureId = myfiles->iPreview;
									}
								}
								else
									textureId = myfiles->iPreview;
							}
						}

						if (textureId == 0)
						{
							textureId = iDefaultTexture;
						}

						if (iDisplayLibraryType == 4 && bDLUAOnly)
						{
							//PE: We now preload all dlua descriptions, so just process everything.
							//if (myfiles->iPreview > 0)
							if(1)
							{
								if (myfiles->m_sDLuaDescription.Len() <= 0)
								{
									bIsVisible = false;
								}
								else
								{
									if( pestrcasestr(myfiles->m_sDLuaDescription.Get(),"do not assign to an entity") )
										bIsVisible = false;
									else if (pestrcasestr(myfiles->m_sDLuaDescription.Get(), "do not use this script"))
										bIsVisible = false;

								}
							}
						}

						//Is object visible
						// or bCheckGotoPreview
						if (bIsVisible || bCheckGotoPreview)
						{

							if (!firstvisiblefile)
							{
								if (!scrolltofile)
								{
									int gcpy = ImGui::GetCursorPosY();
									float fSPos = ImGui::GetScrollY() - (media_icon_size);
									if (fSPos < 0.0f) fSPos = 0.0f;
									if (gcpy >= fSPos)
									{
										firstvisiblefile = myfiles;
									}
								}
							}
							if (myfiles->iPreview > 0 && !GetImageExistEx(myfiles->iPreview))
							{
								myfiles->iPreview = 0;
								textureId = TOOL_ENTITY;
							}

							if (!isMarkers && i == 0)
							{
								LPSTR pFinalHeaderTitle = (LPSTR)dir_name.c_str();
								if (stricmp(pFinalHeaderTitle, "user") == NULL) pFinalHeaderTitle = "Custom Assets";
								if (stricmp(pFinalHeaderTitle, "user - charactercreatorplus") == NULL) pFinalHeaderTitle = "Custom Characters";
								if (stricmp(pFinalHeaderTitle, "user - ebestructures") == NULL) pFinalHeaderTitle = "Custom Structures";

								if (pestrcasestr(dir_name.c_str(), "_markers"))
									pFinalHeaderTitle = "Game Elements";

								strcpy(cHeader, pFinalHeaderTitle);
							}

							if (pref.iSetColumnsEntityLib <= 4)
								ImGui::SetWindowFontScale(1.0);
							else
								ImGui::SetWindowFontScale(SMALLFONTSIZE);

							float fFramePadding = (iColumnsWidth - media_icon_size)*0.5;
							float fCenterX = iColumnsWidth * 0.5;

							ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(fFramePadding, 2.0f));

							if (iDisplayLibraryType == 0) //Only FPE for now.
							{
								if (iDisplayLibrarySubType == 0)
								{
									if (!io.KeyShift)
									{
										if (io.KeyCtrl) // CTRL+A
										{
											if (ImGui::IsKeyReleased(65)) //A
											{
												bAddAllVisible = true;
												bAddAllVisibleTriggerMessage = true;
											}
										}
									}
									if (bAddAllVisible)
									{
										//int gcpy = ImGui::GetCursorPosY();
										//PE: Only include visible objects.
										//if (bIsVisible && gcpy < (iIconVisiblePosY - (media_icon_size*1.1)) && gcpy >= (ImGui::GetScrollY() - (media_icon_size*0.5)))
										//PE: Include All.
										if (bIsVisible)
										{
											extern bool g_bFreeTrialVersion;
											if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
												myfiles->iFlags = 1;
										}
									}
								}
							}
							ImRect selection_bb;
							bool bVisibleOnScreen = false;
							//sMakeDefaultSelecting
							if (sMakeDefaultSelecting != "")
							{
								std::string sMediaName = "";
								if (iDisplayLibraryType == 1) sMediaName = "audiobank\\";
								if (iDisplayLibraryType == 2) sMediaName = "imagebank\\";
								if (iDisplayLibraryType == 3) sMediaName = "videobank\\";
								//if (iDisplayLibraryType == 4) sMediaName = "scriptbank\\";
								if (iDisplayLibraryType == 5) sMediaName = "particlesbank\\";
								if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1) sMediaName = "charactercreatorplus\\animations\\";
								sMediaName = sMediaName + path_for_filename.c_str();
								if (path_for_filename.length() == 0)
									sMediaName = sMediaName + myfiles->m_sName.Get();
								else
									sMediaName = sMediaName + "\\" + myfiles->m_sName.Get();
								if (stricmp(sMakeDefaultSelecting.Get(),sMediaName.c_str()) == 0)
								{
									selectedmediafile = myfiles;
									scrolltofile = myfiles;
									bScrollInNextFrame = true;
									sMakeDefaultSelecting = "";
								}
							}
							if (myfiles->iFlags == 1 || selectedmediafile == myfiles )
							{
								//ImVec4 bg_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram]; // { 0.0, 0.0, 0.0, 1.0 };

								int gcpy = ImGui::GetCursorPosY();
								if (bIsVisible && gcpy < (iIconVisiblePosY ) && gcpy >= (ImGui::GetScrollY() - (media_icon_size*0.5)))
								{

									ImVec2 padding = { 0.0, 0.0 };
									ImGuiWindow* window = ImGui::GetCurrentWindow();
									float cw = ImGui::GetContentRegionAvailWidth();
									if (iDisplayLibraryType == 0)
									{
										selection_bb.Min = (window->DC.CursorPos - padding) + ImVec2(fFramePadding, 2.0f);
										if (pref.iSetColumnsEntityLib == 1)
											selection_bb.Max = (window->DC.CursorPos + padding) + ImVec2(cw - 1.0f, media_icon_size_y + 2.0f);
										else
											selection_bb.Max = (window->DC.CursorPos + padding) + ImVec2(cw + 6.0f, media_icon_size_y + 2.0f);
										if(bDisplayText)
											selection_bb.Max.y += ImGui::GetFontSize() + 8.0f;
									}
									else
									{
										selection_bb.Min = (window->DC.CursorPos - padding) + ImVec2(fFramePadding, 2.0f);
										if (pref.iSetColumnsEntityLib == 1)
											selection_bb.Max = (window->DC.CursorPos + padding) + ImVec2(cw - 1.0f, media_icon_size_y + 2.0f);
										else
											selection_bb.Max = (window->DC.CursorPos + padding) + ImVec2(cw + 6.0f, media_icon_size_y + 2.0f);
									}
									bAnySelectedItemsAvailable = true;
									bVisibleOnScreen = true;
								}
							}

							//std::string sFinal = Left(myfiles->m_sName.Get(), Len(myfiles->m_sName.Get()) - 4);
							std::string sFinal = myfiles->m_sNameFinal.Get(); //PE: For speed.

							CheckTutorialAction(sFinal.c_str(), 13.0f); //Tutorial: check if we are waiting for this action

							//PE: Support Shift for selecting many items.
							if (iDisplayLibraryType == 0) //Currently only for fpe.
							{
								if (!io.KeyShift)
								{
									//firstShiftFile = NULL;
									lastShiftFile = NULL;
								}

								if (firstShiftFile && lastShiftFile) {

									if (myfiles == firstShiftFile)
										bFirstShiftHasBeenSeen = true;
									if (!bFirstShiftHasBeenSeen && myfiles == lastShiftFile)
									{
										//Swap around, last is first.
										cFolderItem::sFolderFiles * tmpShiftFile = lastShiftFile;
										lastShiftFile = firstShiftFile;
										firstShiftFile = tmpShiftFile;
										bFirstShiftHasBeenSeen = true;
									}

									extern bool g_bFreeTrialVersion;

									static bool bStartShiftActive = false;
									myfiles->iFlags = 0;
									if (myfiles == firstShiftFile) 
									{
										bStartShiftActive = true;
										if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
											myfiles->iFlags = 1;
									}
									if (myfiles == lastShiftFile) 
									{
										bStartShiftActive = false;
										if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
											myfiles->iFlags = 1;
									}
									if (bStartShiftActive)
									{
										if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
											myfiles->iFlags = 1;
									}
								}
							}


							bool bBlockBackBufferUpdating = false;
							if (bLargePreview || bImagesStillInImGuiQueue) bBlockBackBufferUpdating = true;
							if (iDisplayLibraryType != 0) bBlockBackBufferUpdating = true;

							ImGui::SetItemAllowOverlap();
							static void* iDelayedClickFile = NULL;
							static int iDelayedImgClick = 0;
							if (iDelayedClickFile == myfiles && iDelayedImgClick > 0) iDelayedImgClick--;

							ImVec2 imgsize = ImVec2(media_icon_size, media_icon_size_y);
							ImVec2 DirectPosition = ImGui::GetCursorPos();

							if (iDisplayLibraryType == 2)
							{
								float imgw = ImageWidth(textureId);
								float imgh = ImageHeight(textureId);
								if (imgh > imgw)
								{
									float fRatio = media_icon_size_y / imgh;
									imgsize = ImVec2(imgw*fRatio, imgh*fRatio);
									if (imgsize.x > media_icon_size)
									{
										//Reverse
										float fRatio = media_icon_size / imgw;
										imgsize = ImVec2(imgw*fRatio, imgh*fRatio);
									}
								} 
								else
								{
									float fRatio = media_icon_size / imgw;
									imgsize = ImVec2(imgw*fRatio, imgh*fRatio);
									if (imgsize.y > media_icon_size_y)
									{
										//Reverse.
										float fRatio = media_icon_size_y / imgh;
										imgsize = ImVec2(imgw*fRatio, imgh*fRatio);
									}
								}
								//Clip.
								if (imgsize.y > media_icon_size_y)
									imgsize.y = media_icon_size_y;
								if (imgsize.x > media_icon_size)
									imgsize.x = media_icon_size;
								//Make room for background borders.
								imgsize.x -= 8.0f;
								imgsize.y -= 8.0f;
								//Center and use direct position.
								float fOffsetX = (media_icon_size*0.5) - (imgsize.x*0.5);
								float fOffsetY = (media_icon_size_y*0.5) - (imgsize.y*0.5);
								fOffsetX -= 2.5f; //Fit borders.
								fOffsetY -= 2.0f; //Fit borders.
								//Add filler.
								ImGuiWindow* window = ImGui::GetCurrentWindow();
								//AddRectFilled faster ?
								ImVec2 vDrawPos = { ImGui::GetCursorScreenPos().x ,ImGui::GetCursorScreenPos().y };
								window->DrawList->AddRectFilled(vDrawPos, vDrawPos + ImVec2(media_icon_size, media_icon_size_y), ImGui::GetColorU32(ImVec4(0, 0, 0, 0.3)), 6.0f, 15);

								ImGui::SetCursorPos(DirectPosition + ImVec2(fOffsetX, fOffsetY));
							}
							
							bool bOverLayVideo = false;
							ImVec2 vVideoPos = ImGui::GetCursorPos();
							if( iDisplayLibraryType == 3 && playingiles == myfiles && iVideoThumbID > 0)
							{
								//Display video thumb.
								bOverLayVideo = true;
							}

							total_files_displayed_in_library++;
							if ((iDelayedImgClick == 1 && iDelayedClickFile == myfiles) || ImGui::ImgBtn(textureId, imgsize, drawCol_black, ImVec4(1, 1, 1, 1), ImVec4(1, 1, 1, 1), drawCol_Down, -1, 0, 0, 0, false))
							{
								iDelayedClickFile = myfiles;

								if (iDelayedImgClick == 1)
								{
									iDelayedImgClick = 0;

									if (iDisplayLibraryType == 1 || iDisplayLibraryType == 2 || iDisplayLibraryType == 3 || iDisplayLibraryType == 4 || iDisplayLibraryType == 5) //Music. , reuse selectedmediafile for images
									{
										selectedmediafile = myfiles;
									}
									else
									{
										bool bAllowSelection = true;
										extern bool g_bFreeTrialVersion;
										if (g_bFreeTrialVersion == true)
										{
											if (myfiles->bAvailableInFreeTrial == false)
											{
												bAllowSelection = false;
											}
										}
										if(bAllowSelection==true)
										{
											if (bTutorialCheckAction) TutorialNextAction(); //Clicked get next tutorial action.

											if (iDisplayLibrarySubType == 1)
											{
												// Animation Library selection simply returns choice as file path
												selectedmediafile = myfiles;
											}
											else
											{
												//If ctrl , just mark them.
												if (io.KeyShift)
												{
													if (firstShiftFile)
													{
														lastShiftFile = myfiles;
													}
													else
													{
														firstShiftFile = myfiles;
														multi_selections = true;
														if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
															myfiles->iFlags = 1;
													}
												}
												else if (io.KeyCtrl)
												{
													//Mark object.
													multi_selections = true;
													if (myfiles->iFlags == 0)
													{
														if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
															myfiles->iFlags = 1;
														firstShiftFile = myfiles;
													}
													else
														myfiles->iFlags = 0;
												}
												else
												{
													if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
													if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
													if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;

													//Make sure we are in entity mode.
													bForceKey = true;
													csForceKey = "o";

													bBlockBackBufferUpdating = true;
													DeleteWaypointsAddedToCurrentCursor();
													//CheckTooltipObjectDelete();
													CloseDownEditorProperties();
													FreeTempImageList(); //PE: Make sure we free all not used textures before adding new objects.
													#ifdef WICKEDENGINE
													iLastEntityOnCursor = 0;
													#endif

													std::string sFpeName = path_for_filename.c_str();
													sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
													t.addentityfile_s = sFpeName.c_str();
													if (t.addentityfile_s != "")
													{
														// Special group detection system
														entity_adduniqueentity(false);
														t.tasset = t.entid;
														if (t.talreadyloaded == 0)
														{
															editor_filllibrary();
														}
													}

													iExtractMode = 0; //PE: Always start in find floor mode.

													t.inputsys.constructselection = t.tasset;

													t.gridentity = t.entid;
													t.inputsys.constructselection = t.entid;
													t.inputsys.domodeentity = 1;
													t.grideditselect = 5;

													//Make sure we use a fresh t.grideleprof
													entity_fillgrideleproffromprofile();

													editor_refresheditmarkers();
													//PE: Close window for now.
													bCheckForClosing = true;
													bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.
													bDraggingActive = false;

													//PE: we loose status somewhere, so force it off after adding a entity to map.
													extern bool bCubesVisible;
													if (bCubesVisible == false) bCubesVisible = true; //Force.
												}
											}
										}
									}
								}
								else
								{
									iDelayedImgClick = 14;
								}
							}
							bool bThumbHovered = ImGui::IsItemHovered();
							
							// if free trial and object not on list
							extern bool g_bFreeTrialVersion;
							if (g_bFreeTrialVersion == true)
							{
								if (myfiles->bAvailableInFreeTrial == false)
								{
									// place grey layer on thumb to show object not available
									ImVec2 vOldPos = ImGui::GetCursorPos();
									ImGui::SetCursorPos(DirectPosition);
									ImGui::SetItemAllowOverlap();
									ImGui::ImgBtn(FREETRIAL_NOTAVAILABLE, imgsize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors);
									ImGui::SetCursorPos(vOldPos);
								}
							}

							if (iDisplayLibraryType == 2)
							{
								//PE: Add padding ?
								float paddingy = 10.0f;
								ImGui::SetCursorPos(DirectPosition + ImVec2(0, media_icon_size_y + paddingy));
							}

							if (bWaitOnMouseRelease)
							{
								if (!ImGui::IsMouseDown(0))
									bWaitOnMouseRelease = false;
							}

							if (iDisplayLibraryType > 0 || (iDisplayLibraryType==0 && iDisplayLibrarySubType == 1))
							{
								// Drag drop from other media types - no
							}
							else
							{
								bool bAllowSelection = true;
								extern bool g_bFreeTrialVersion;
								if (g_bFreeTrialVersion == true)
								{
									if (myfiles->bAvailableInFreeTrial == false)
									{
										bAllowSelection = false;
									}
								}
								if (bAllowSelection == true)
								{
									if (!bImagesStillInImGuiQueue && !bWaitOnMouseRelease && !bLargePreview && t.gridentity == 0 && t.gridentityobj == 0 && ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
									{
										CloseDownEditorProperties();
										t.inputsys.constructselection = 0;

										myfiles->m_dropptr = myfiles;

										std::string sFpeName = path_for_filename.c_str();
										sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();

										myfiles->m_sFolder = sFpeName.c_str();

										//PE: Special add all selected. for drag drop.
										myfiles->iAnimationFrom = 0;
										if (selected_library_fpe.size() > 0)
										{
											myfiles->iAnimationFrom = 200000;
										}

										ImGui::SetDragDropPayload("DND_MODEL_DROP_TARGET", myfiles, sizeof(void *));
										ImGui::ImgBtn(textureId, ImVec2(media_icon_size, media_icon_size_y), drawCol_black, drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false);
										ImGui::SetCursorPos(oldCursor);
										pDragDropFile = myfiles;
										ImGui::EndDragDropSource();
										bReadyToDropEntity = false;
										iDragDropActive = 50;
										bDraggingActive = true;
										bDraggingActiveInitial = true;
										// LB: these can be uninitialised, but we need these filled so the plane can be under the cursor initially
										t.gridentityposx_f = t.inputsys.localx_f;
										t.gridentityposy_f = t.inputsys.localcurrentterrainheight_f;
										t.gridentityposz_f = t.inputsys.localy_f;
									}
								}
							}
							ImGui::PopID();
							ImGui::PushID(uniqueId + 20000);

							//---
							if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1)
							{
								if (bThumbHovered && ImGui::IsMouseClicked(0))
								{
									std::string sMediaName = "charactercreatorplus\\animations\\";
									sMediaName = sMediaName + path_for_filename.c_str();
									if (path_for_filename.length() == 0)
										sMediaName = sMediaName + myfiles->m_sName.Get();
									else
										sMediaName = sMediaName + "\\" + myfiles->m_sName.Get();
									sSelectedLibrarySting = sMediaName.c_str();
									iSelectedLibraryStingReturnID = iLibraryStingReturnToID;
									bBlockBackBufferUpdating = true;
									bCheckForClosing = true;
									bImGuiRenderTargetFocus = true;
								}
							}

							//---
							if (iDisplayLibraryType > 0)
							{
								if (bThumbHovered && ImGui::IsMouseDoubleClicked(0))
								{
									//Sent selection to imgui ID that have last requested a media file.
									selectedmediafile = NULL;
									playingiles = NULL;
									if(iDisplayLibraryType == 3) iStopVideoInNextFrame = iVideoThumbID;
									//Stop anything playing.
									if (SoundExist(g.temppreviewsoundoffset) == 1)
									{
										StopSound(g.temppreviewsoundoffset);
										DeleteSound(g.temppreviewsoundoffset);
									}

									std::string sMediaName = "";
									if (iDisplayLibraryType == 1) sMediaName = "audiobank\\";
									if (iDisplayLibraryType == 2) sMediaName = "imagebank\\";
									if (iDisplayLibraryType == 3) sMediaName = "videobank\\";
									//if (iDisplayLibraryType == 4) sMediaName = "scriptbank\\";
									if (iDisplayLibraryType == 5) sMediaName = "particlesbank\\";
									if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1) sMediaName = "charactercreatorplus\\animations\\";
									sMediaName = sMediaName + path_for_filename.c_str();
									if(path_for_filename.length() == 0)
										sMediaName = sMediaName + myfiles->m_sName.Get();
									else
										sMediaName = sMediaName + "\\" + myfiles->m_sName.Get();
									if (sMediaName != "")
									{
										sSelectedLibrarySting = sMediaName.c_str();
										iSelectedLibraryStingReturnID = iLibraryStingReturnToID;
									}
									bBlockBackBufferUpdating = true;
									bCheckForClosing = true;
									bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.
								}

								if (bOverLayVideo && iStopVideoInNextFrame == 0)
								{
									ImVec2 vOldPos = ImGui::GetCursorPos();
									ImGui::SetCursorPos(vVideoPos);

									if (AnimationExist(iVideoThumbID) && AnimationPlaying(iVideoThumbID))
									{
										//imgsize
										void* lpVideoTexture = GetAnimPointerTexture(iVideoThumbID);
										float fVideoW = GetAnimWidth(iVideoThumbID);
										float fVideoH = GetAnimHeight(iVideoThumbID);
										if (lpVideoTexture)
										{
											//float fRatio = 1.0f / (fVideoW / fVideoH);
											//float videoboxheight = (ImGui::GetContentRegionAvail().x - 10.0) * fRatio;
											ImGuiWindow* window = ImGui::GetCurrentWindow();
											ImRect image_bb(window->DC.CursorPos + ImVec2(3, 2), window->DC.CursorPos + ImVec2(3, 2) + imgsize);
											float animU = GetAnimU(iVideoThumbID);
											float animV = GetAnimV(iVideoThumbID);
											ImVec2 uv0 = ImVec2(0, 0);
											ImVec2 uv1 = ImVec2(animU, animV);
											window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));
										}
									}
									ImGui::SetCursorPos(vOldPos);
								}

								//Not while generating thumbs.
								if (iDisplayLibraryType == 3 && iVideoGenerateImageID == 0 )
								{
									//Play Video.
									int iImageSize = 24;
									ImVec2 opos = ImGui::GetCursorPos();
									ImGui::SetCursorPos(ImVec2((opos.x + media_icon_size) - iImageSize - 2.0f, opos.y - 14.0f - iImageSize));
									ImGui::SetItemAllowOverlap();

									if (playingiles == myfiles)
									{
										//float pos = GetSoundPosition(g.temppreviewsoundoffset);

										if (iVideoThumbID > 0 && AnimationExist(iVideoThumbID) && AnimationPlaying(iVideoThumbID))
										{
											float progress = GetAnimPercentDone(iVideoThumbID) / 100.0f;
											if (progress == 0.0f)
											{
												iStopVideoInNextFrame = iVideoThumbID;
												playingiles = NULL;
											}
										}

										if (ImGui::ImgBtn(MEDIA_PAUSE, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
										{
											selectedmediafile = myfiles;
											playingiles = NULL;
											//PLAY music file.
											iStopVideoInNextFrame = iVideoThumbID;
										}
										if (!bThumbHovered)
											bThumbHovered = ImGui::IsItemHovered();
										if (ImGui::IsItemHovered()) ImGui::SetTooltip("Stop Playing Video");

										if (iVideoThumbID > 0 && AnimationExist(iVideoThumbID) && AnimationPlaying(iVideoThumbID))
										{
											float progress = GetAnimPercentDone(iVideoThumbID) / 100.0f;
											if (progress < 0.0f) progress = 0.0f;
											if (progress > 1.0f) progress = 1.0f;
											ImVec2 opos = ImGui::GetCursorPos();
											ImVec4 backImGuiCol_PlotHistogram = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
											ImVec4 backImGuiCol_Border = ImGui::GetStyle().Colors[ImGuiCol_Border];
											ImVec4 backImGuiCol_BorderShadow = ImGui::GetStyle().Colors[ImGuiCol_BorderShadow];
											ImVec4 backImGuiCol_FrameBg = ImGui::GetStyle().Colors[ImGuiCol_FrameBg];
											//ImVec4 newBlue = ImVec4(56.0 / 255.0, 110.0 / 255.0, 145.0 / 255.0, 1);
											ImVec4 newBlue = ImVec4(0.8f, 0.8f, 0.8f, 0.6f);
											ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram] = newBlue;
											ImGui::GetStyle().Colors[ImGuiCol_Border] = ImVec4(0, 0, 0, 0);
											ImGui::GetStyle().Colors[ImGuiCol_BorderShadow] = ImVec4(0, 0, 0, 0);
											ImGui::GetStyle().Colors[ImGuiCol_FrameBg] = ImVec4(0, 0, 0, 0);
											float padding = 30.0f;
											ImGui::SetCursorPos(ImVec2(opos.x + 4.0f + padding, opos.y - 16.0f - 10.0f));
											ImGui::ProgressBar(progress, ImVec2(media_icon_size - padding - padding, 16.0f), " ");
											ImGui::SetCursorPos(opos);
											ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram] = backImGuiCol_PlotHistogram;
											ImGui::GetStyle().Colors[ImGuiCol_Border] = backImGuiCol_Border;
											ImGui::GetStyle().Colors[ImGuiCol_BorderShadow] = backImGuiCol_BorderShadow;
											ImGui::GetStyle().Colors[ImGuiCol_FrameBg] = backImGuiCol_FrameBg;
										}
									}
									else if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
									{
										//PLAY video file.
										selectedmediafile = myfiles;
										playingiles = NULL;

										if (iVideoThumbID > 0 && AnimationExist(iVideoThumbID))
										{
											iStopVideoInNextFrame = iVideoThumbID;
										}

										std::string sVideoName = myfiles->m_sPath.Get();
										sVideoName = sVideoName + "\\" + myfiles->m_sName.Get();

										sVideoLoadName = sVideoName.c_str();
										iStartVideoInNextFrame = 1;
										playingiles = myfiles;

									}
									ImGui::SetCursorPos(opos);
									if (!bThumbHovered)
										bThumbHovered = ImGui::IsItemHovered();
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("Play Video");

								}

								if (iDisplayLibraryType == 1) //Music
								{
									//Play music.
									int iImageSize = 24;
									ImVec2 opos = ImGui::GetCursorPos();
									ImGui::SetCursorPos(ImVec2((opos.x + media_icon_size) - iImageSize - 2.0f, opos.y - 14.0f - iImageSize));
									ImGui::SetItemAllowOverlap();

									if (playingiles == myfiles)
									{

										//isoundplaying
										float pos = GetSoundPosition(g.temppreviewsoundoffset);

										if (SoundExist(g.temppreviewsoundoffset) == 1 && SoundPlaying(g.temppreviewsoundoffset) == 0)
										{
											//Not playing.
											StopSound(g.temppreviewsoundoffset);
											playingiles = NULL;
										}
										if (ImGui::ImgBtn(MEDIA_PAUSE, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
										{
											selectedmediafile = myfiles;
											playingiles = NULL;
											//PLAY music file.
											if (SoundExist(g.temppreviewsoundoffset) == 1)
											{
												StopSound(g.temppreviewsoundoffset);
												DeleteSound(g.temppreviewsoundoffset);
											}
										}
										if (!bThumbHovered)
											bThumbHovered = ImGui::IsItemHovered();
										if (ImGui::IsItemHovered()) ImGui::SetTooltip("Stop Playing Music");

										//PE: Draw progress bar end
										float progress = pos / 100.0f;
										if (progress < 0.0) progress = 0.0;
										if (progress > 1.0) progress = 1.0;
										ImVec2 opos = ImGui::GetCursorPos();
										ImVec4 backImGuiCol_PlotHistogram = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
										ImVec4 backImGuiCol_Border = ImGui::GetStyle().Colors[ImGuiCol_Border];
										ImVec4 backImGuiCol_BorderShadow = ImGui::GetStyle().Colors[ImGuiCol_BorderShadow];
										ImVec4 backImGuiCol_FrameBg = ImGui::GetStyle().Colors[ImGuiCol_FrameBg];

										//ImVec4 newBlue = ImVec4(56.0 / 255.0, 110.0 / 255.0, 145.0 / 255.0, 1);
										ImVec4 newBlue = ImVec4(0.8f, 0.8f, 0.8f, 0.6f );
										ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram] = newBlue;
										ImGui::GetStyle().Colors[ImGuiCol_Border] = ImVec4(0, 0, 0, 0);
										ImGui::GetStyle().Colors[ImGuiCol_BorderShadow] = ImVec4(0, 0, 0, 0);
										ImGui::GetStyle().Colors[ImGuiCol_FrameBg] = ImVec4(0, 0, 0, 0);
										float padding = 30.0f;
										ImGui::SetCursorPos(ImVec2(opos.x + 4.0f + padding, opos.y - 16.0f - 10.0f));
										ImGui::ProgressBar(progress, ImVec2(media_icon_size - padding - padding, 16.0f), " ");
										ImGui::SetCursorPos(opos);

										ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram] = backImGuiCol_PlotHistogram;
										ImGui::GetStyle().Colors[ImGuiCol_Border] = backImGuiCol_Border;
										ImGui::GetStyle().Colors[ImGuiCol_BorderShadow] = backImGuiCol_BorderShadow;
										ImGui::GetStyle().Colors[ImGuiCol_FrameBg] = backImGuiCol_FrameBg;

									}
									else if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
									{
										//PLAY music file.
										selectedmediafile = myfiles;
										playingiles = NULL;
										if (SoundExist(g.temppreviewsoundoffset) == 1)
										{
											StopSound(g.temppreviewsoundoffset);
											DeleteSound(g.temppreviewsoundoffset);
										}
										std::string sSoundName = "audiobank\\";
										sSoundName = sSoundName + path_for_filename.c_str();
										sSoundName = sSoundName + "\\" + myfiles->m_sName.Get();
										LoadSound((char *) sSoundName.c_str(), g.temppreviewsoundoffset);
										if (SoundExist(g.temppreviewsoundoffset) == 1)
										{
											playingiles = myfiles;
											PlaySound(g.temppreviewsoundoffset);
											SetSoundVolume(g.temppreviewsoundoffset, 100.0);
											//soundtruevolume(100) returns 0 ?
										}
									}
									ImGui::SetCursorPos(opos);
									if (!bThumbHovered)
										bThumbHovered = ImGui::IsItemHovered();
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("Play Music");
								}
							}
							else
							{
								bool bShowPreviewButton = true;
								if (myfiles->m_bIsGroupObject == true)
								{
									// do not show preview button for smart objects, no easy way to construct the preview - too many moving parts
									bShowPreviewButton = false;
								}
								if (bShowPreviewButton)
								{
									int iImageSize = 24;
									ImVec2 opos = ImGui::GetCursorPos();
									ImGui::SetCursorPos(ImVec2((opos.x + media_icon_size) - iImageSize - 2.0f, opos.y - 14.0f - iImageSize));
									ImGui::SetItemAllowOverlap();

									if (ImGui::ImgBtn(KEY_MAXIMIZE, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
									{
										pPreviewFile = myfiles;
										bLargePreview = true;
										bDoBackbufferUpdate = true;
									}
									ImGui::SetCursorPos(opos);
									if (!bThumbHovered)
										bThumbHovered = ImGui::IsItemHovered();
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("Fullscreen Preview");

									if (bThumbHovered && ImGui::IsMouseDoubleClicked(0))
									{
										pPreviewFile = myfiles;
										bLargePreview = true;
										bDoBackbufferUpdate = true;
										iDelayedImgClick = 0; //Cancel last btn click.
									}
								}
							}
							//---

							// hovering over an object library item
							static void* additionalcheck = NULL;
							static cstr preload_fpe_file = "";
							static bool preload_fpe_file_started = false;
							if (iDisplayLibraryType > 0)
							{
								//Hover other media.
								static bool bTriggerTimer = false;
								if (iWaitFramesBeforeProceed == 0) //No hover while generating thumbs.
								{
									if (iDisplayLibraryType == 5 && bThumbHovered)
									{
										//Enable rotation
										iTooltipHoveredTimer = Timer();
										if (!bTriggerTimer)
										{
											iTooltipTimer = iTooltipHoveredTimer;
											bTriggerTimer = true;

										}
										//Need a little timer so old images can reload before we start another.
										if (bTriggerTimer && iTooltipHoveredTimer - iTooltipTimer > 200)
										{
											//End any old.
											if (additionalcheck && additionalcheck != myfiles)
											{
												//Must reload old icon.
												cFolderItem::sFolderFiles * tmp = (cFolderItem::sFolderFiles *) additionalcheck;
												tmp->iPreview = 0;
												additionalcheck = 0;
												BackBufferSaveCacheName = "";
												BackBufferObjectID = 0;
												BackBufferImageID = 0;
												BackBufferZoom = 0.0f;
												BackBufferCamUp = 0.0f;
												bSnapShotModeUseCamera = false;
												BackBufferParticlesMode = false;
												bLoopBackBuffer = false;
											}
										}
										if (bTriggerTimer && iTooltipHoveredTimer - iTooltipTimer > 500)
										{
											if (additionalcheck != myfiles)
											{
												additionalcheck = myfiles;
												iTooltipTimer = iTooltipHoveredTimer;

												//Create particle thumb here.
												BackBufferIsGroup = false;
												BackBufferEntityID = 0;
												BackBufferObjectID = 0;
												BackBufferImageID = myfiles->iPreview;
												BackBufferSizeX = 512;
												BackBufferSizeY = 288;
												BackBufferCamLeft = 0.0f;
												bRotateBackBuffer = false;
												bBackBufferAnimated = false;
												BackBufferSaveCacheName = ""; //No saving
												//Dont fit snapshot to rubber band.
												fLastRubberBandX1 = fLastRubberBandX2 = fLastRubberBandY1 = fLastRubberBandY2 = 0.0f;
												CreateBackdropObject(false, cstr("texturebank\\backdrops\\Black backdrop.dds"), t.addentityfile_s); //PE: We need a extra frame, as we set the material dirty in this call.

												BackBufferZoom = 800.0f;
												BackBufferCamUp = 400.0f;
												bSnapShotModeUseCamera = false;
												BackBufferParticlesMode = true;
												bLoopBackBuffer = true;

												float centerx = -1000, centery = 39000, centerz = -1000;
												std::string sParticleName = myfiles->m_sPath.Get();
												sParticleName = sParticleName + "\\" + Left(myfiles->m_sName.Get(), Len(myfiles->m_sName.Get()) - 4);

												if (BackBufferParticleEmitter != -1)
												{
													gpup_deleteEffect(BackBufferParticleEmitter);
													BackBufferParticleEmitter = -1;
												}

												if (BackBufferParticleEmitter == -1)
												{
													BackBufferParticleEmitter = gpup_loadEffect(sParticleName.c_str(), 0, 0, 0, 1.0);
													gpup_setGlobalScale(BackBufferParticleEmitter, 100.0f);
													gpup_emitterActive(BackBufferParticleEmitter, 0);
												}
												float fLive = 10.0f;
												if (BackBufferParticleEmitter != -1)
												{
													gpup_setGlobalPosition(BackBufferParticleEmitter, centerx, centery - 30.0f, centerz);
													gpup_resetLocalPosition(BackBufferParticleEmitter);
													gpup_setGlobalScale(BackBufferParticleEmitter, 100.0f);
													gpup_emitterActive(BackBufferParticleEmitter, 1);

													gpup_setEffectAnimationSpeed(BackBufferParticleEmitter, 1.0f);
													gpup_setEffectOpacity(BackBufferParticleEmitter, 1.0f);

												}

											}
											else
											{
												//We are running
												BackBufferZoom = 700.0f;
												BackBufferCamUp = 250.0f;
												bSnapShotModeUseCamera = false;
												BackBufferParticlesMode = true;
												bLoopBackBuffer = true;
											}
										}
									}
									else if (iDisplayLibraryType == 5 && !ImGui::IsItemHovered())
									{
										if (additionalcheck == myfiles)
										{
											bTriggerTimer = false;
											if (bLoopBackBuffer)
											{
												//Disable rotation
												BackBufferSaveCacheName = "";
												BackBufferObjectID = 0;
												BackBufferImageID = 0;
												BackBufferZoom = 0.0f;
												BackBufferCamUp = 0.0f;
												bSnapShotModeUseCamera = false;
												BackBufferParticlesMode = false;
												bLoopBackBuffer = false;
												myfiles->iPreview = 0; //Reload old thumb.
												additionalcheck = NULL;
												if (BackBufferParticleEmitter != -1)
												{
													gpup_deleteEffect(BackBufferParticleEmitter);
													BackBufferParticleEmitter = -1;
												}
											}
										}
									}
								}

								if (bThumbHovered)
								{
									if (iDisplayLibraryType == 1)
									{
										//ImGui::SetTooltip("Music Media");
									}
									if (iDisplayLibraryType == 2)
									{
										//PE: Show large image preview.

										float imgw = ImageWidth(textureId);
										float imgh = ImageHeight(textureId);
										float fWidth = 500.0f;
										float fRatio = fWidth / imgw;
										if (imgw < fWidth) fRatio = 1.0f;
										ImVec2 imgsize = ImVec2(imgw*fRatio, imgh*fRatio);

										ImGui::BeginTooltip();
										float icon_ratio;
										ImGui::ImgBtn(textureId, imgsize, ImVec4(0.0, 0.0, 0.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false);
										//char hchar[MAX_PATH];
										//ImGui::Text("%s", hchar);
										ImGui::EndTooltip();

										//ImGui::SetTooltip("Image Media");
									}
									
									if (iDisplayLibraryType == 3)
									{
										//ImGui::SetTooltip("Video");
									}
									if (iDisplayLibraryType == 4)
									{
										//ImGui::SetTooltip("Script");
									}
									if (iDisplayLibraryType == 5)
									{
										//ImGui::SetTooltip("Particles");

										if (!BackBufferParticlesMode)
										{
											//Animate particle.
										}
									}

								}
							}
							else
							{
								bool bHoverGroupActive = true;
								//if (bAdvancedFPEFeatures && myfiles->m_bIsGroupObject) bHoverGroupActive = false;
								if ( myfiles->m_bIsGroupObject) bHoverGroupActive = false; // do not allow smarts to load/generate thumbs - performance hit!
								if (bHoverGroupActive && !bImagesStillInImGuiQueue && !bLargePreview && !bBlockBackBufferUpdating && !bEntity_Properties_Window && !g_bCharacterCreatorPlusActivated && !bImporter_Window && i == 0 && bThumbHovered)
								{
									iTooltipHoveredTimer = Timer();
									if (iLastTooltipSelection != textureId || (additionalcheck != myfiles))
									{
										// new thumbnail to create
										additionalcheck = myfiles;
										iTooltipTimer = iTooltipHoveredTimer;
										iLastTooltipSelection = textureId;
										iTooltipObjectReady = false;

										// object FPE name
										std::string sFpeName = path_for_filename.c_str();
										sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
										t.addentityfile_s = sFpeName.c_str();

										// if we already have it, can show right away!
										t.talreadyloaded = 0;
										for (t.t = 1; t.t <= g.entidmaster; t.t++)
										{
											if (t.entitybank_s[t.t] == t.addentityfile_s) { t.talreadyloaded = 1; t.entid = t.t; }
										}
										if (t.talreadyloaded)
										{
											//Start rotate instant.
											CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
											BackBufferSaveCacheName = BackBufferCacheName;
											bDoBackbufferUpdate = true;
											iTooltipTimer = iTooltipHoveredTimer - 750;
											iTooltipObjectReady = true;
											preload_fpe_file = "";
										}
										else
										{
											// Preload DBO and textures shortly
											preload_fpe_file = t.addentityfile_s;
											preload_fpe_file_started = false;
										}
									}
									else
									{
										if (strlen(preload_fpe_file.Get()) == 0)
										{
											if (iTooltipObjectReady)
											{
												// showing it
											}
											else
											{
												// Generate Thumbnail of object.
												std::string sFpeName = path_for_filename.c_str();
												sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
												t.addentityfile_s = sFpeName.c_str();
												CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
												BackBufferSaveCacheName = BackBufferCacheName;
												bDoBackbufferUpdate = true;
											}
										}
										else
										{
											#ifdef PRELOAD_OBJECTS_ON_HOVER
											// wait long enough to ignore incidental scrolling past the object
											if (iTooltipHoveredTimer - iTooltipTimer > 100)
											{
												if (preload_fpe_file.Len() > 0)
												{
													// trigger this object to preload its resources, ready for the actual DBO and DDS loading
													if (preload_fpe_file_started == false)
													{
														if (object_preload_files_in_progress() == false && image_preload_files_in_progress() == false)
														{
															if (entity_load_thread_prepare(preload_fpe_file.Get()) == false)
															{
																// this file do not have a dbo version, do not preload
															}
														}
														preload_fpe_file_started = true;
													}

													// only when waited full span of progress bar do we release preload_fpe_file to start thumbn generation (small delay due to Wicked)
													if (iTooltipHoveredTimer - iTooltipTimer > 750)
													{
														preload_fpe_file = "";
													}
												}
											}
											#else
											preload_fpe_file = "";
											#endif
											if (!bInContextThumb)
											{
												//PE: Draw progress bar end
												int iVal = iTooltipHoveredTimer - iTooltipTimer;
												float progress = (float)iVal / 750;// 300;//quicker 2000.0f;
												if (progress < 0.0) progress = 0.0;
												if (progress > 1.0) progress = 1.0;
												ImVec2 opos = ImGui::GetCursorPos();
												ImVec4 backImGuiCol_PlotHistogram = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
												ImVec4 backImGuiCol_Border = ImGui::GetStyle().Colors[ImGuiCol_Border];
												ImVec4 backImGuiCol_BorderShadow = ImGui::GetStyle().Colors[ImGuiCol_BorderShadow];
												ImVec4 backImGuiCol_FrameBg = ImGui::GetStyle().Colors[ImGuiCol_FrameBg];

												ImVec4 newBlue = ImVec4(56.0 / 255.0, 110.0 / 255.0, 145.0 / 255.0, 1);
												ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram] = newBlue;
												ImGui::GetStyle().Colors[ImGuiCol_Border] = ImVec4(0, 0, 0, 0);
												ImGui::GetStyle().Colors[ImGuiCol_BorderShadow] = ImVec4(0, 0, 0, 0);
												ImGui::GetStyle().Colors[ImGuiCol_FrameBg] = ImVec4(0, 0, 0, 0);

												ImGui::SetCursorPos(ImVec2(opos.x + 4.0f, opos.y - 16.0f));
												ImGui::ProgressBar(progress, ImVec2(media_icon_size - 4.0f, 6.0f), " ");
												ImGui::SetCursorPos(opos);

												ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram] = backImGuiCol_PlotHistogram;
												ImGui::GetStyle().Colors[ImGuiCol_Border] = backImGuiCol_Border;
												ImGui::GetStyle().Colors[ImGuiCol_BorderShadow] = backImGuiCol_BorderShadow;
												ImGui::GetStyle().Colors[ImGuiCol_FrameBg] = backImGuiCol_FrameBg;
											}
										}
									}
								}
								else
								{
									if (!ImGui::IsItemHovered() && !bLargePreview && !bImagesStillInImGuiQueue)
									{
										if (textureId >= 4000 && textureId < UIV3IMAGES && BackBufferImageID == textureId)
										{
											//Disable rotation
											BackBufferSaveCacheName = "";
											BackBufferObjectID = 0;
											BackBufferImageID = 0;
											bLoopBackBuffer = false;
											RevertBackbufferCubemap();
										
											WickedCall_SetSunDirection(t.visuals.SunAngleX, t.visuals.SunAngleY, t.visuals.SunAngleZ);
											master_renderer->setBloomEnabled(t.visuals.bBloomEnabled);
											WickedCall_MoveReflectionProbe(GGORIGIN_X, GGORIGIN_Y+5000, GGORIGIN_Z, "editorProbe", 500);
											WickedCall_EnableThumbLight(false);
											myfiles->iPreview = 0;
											additionalcheck = NULL;
										}
									}
								}
							} // if (iDisplayLibraryType > 0) - else.
							//PE: Check if we need to generate a thumb or rotate a object in the thumb view.
							bool bForceUpdate = false;
							if (bCheckGotoPreview && pPreviewFile == myfiles)
								bForceUpdate = true;

							if (!bBlockBackBufferUpdating || bForceUpdate)
							{
								if (!bDoneOneThumbPerSync && bLoadedInNewFormat)
								{
									//PE: Should we try to update old thumb to new format ?
									if (myfiles->iBigPreview == 0)
									{
										//PE: Only if it is side visible area.
										int gcpy = ImGui::GetCursorPosY();
										if (gcpy < iIconVisiblePosY && gcpy >= ImGui::GetScrollY() - media_icon_size)
										{
											std::string sFpeName = path_for_filename.c_str();
											sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
											t.addentityfile_s = sFpeName.c_str();
											CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
											if (!FileExist(BackBufferCacheName.Get()))
											{
												bLoadedInNewFormat = false; //Try it.
											}
										}
									}
								}
								if ((bDoBackbufferUpdate || !bLoadedInNewFormat) && !bDoneOneThumbPerSync)
								{
									std::string sFpeName = path_for_filename.c_str();
									sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
									t.addentityfile_s = sFpeName.c_str();

									// LB: delay actual entity_load (takes >1s due to Wicked obj setup in scene!)
									bool update = true;
									if (preload_fpe_file.Len() > 0)
									{
										//PE: This ruins thumb updating we must always have update so...
										if (!bDoBackbufferUpdate && bLoadedInNewFormat)
										{
											update = false;
											if (iTooltipHoveredTimer - iTooltipTimer > 750)
											{
												// this extension allows user to hover and click without getting the freeze
												update = true;
											}
										}
									}

									if (!bDoBackbufferUpdate && !bLoadedInNewFormat)
									{
										CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
										BackBufferSaveCacheName = BackBufferCacheName;
										//PE: Triggered auto.
										if (myfiles->iBigPreview == 0)
										{
											myfiles->iBigPreview = TOOL_ENTITY;
											//PE: Update image in next run.
											if (myfiles->iPreview > 0)
											{
												if (GetImageExistEx(myfiles->iPreview) && myfiles->iPreview >= 4000 && myfiles->iPreview < UIV3IMAGES) { //PE: Need to protect system images after tool img range has changed. (myfiles->iPreview can be a system icon)
													iDeleteInNextUpdate = myfiles->iPreview;
												}
											}
											myfiles->iPreview = 0;
										}
										else
										{
											update = false;
										}
									}
									if (update)
									{
										int iEntIDWas = 0;
										bool bIsGroup = false;
										cstr EntWas_s = t.addentityfile_s;
										if (iDisplayLibrarySubType == 1)
										{
											// Animations
											t.entdir_s = "charactercreatorplus\\animations\\";
										}
										else
										{
											// Objects
											t.entdir_s = "entitybank\\";
											if (cstr(Lower(Left(t.addentityfile_s.Get(), 11))) == "entitybank\\")
											{
												t.addentityfile_s = Right(t.addentityfile_s.Get(), Len(t.addentityfile_s.Get()) - 11);
											}
											if (cstr(Lower(Left(t.addentityfile_s.Get(), 8))) == "ebebank\\")
											{
												t.entdir_s = "";
											}
										}

										t.talreadyloaded = 0;
										for (t.t = 1; t.t <= g.entidmaster; t.t++)
										{
											if (t.entitybank_s[t.t] == t.addentityfile_s) { t.talreadyloaded = 1; t.entid = t.t; }
										}
										if (t.talreadyloaded == 1)
										{
											//PE: Check ,if group.
											if (t.entityprofile[t.entid].model_s == "group" && t.entityprofile[t.entid].groupreference >= 0)
											{
												cstr tmp = cstr("entitybank\\") + t.addentityfile_s;
												extern int GetGroupIndexFromName(cstr sLookFor);
												int groupID = GetGroupIndexFromName(tmp);
												if (groupID >= 0 && groupID < MAXGROUPSLISTS)
												{
													bIsGroup = true;
													g_LastGroupSaved_s = t.entitybank_s[t.entid];
													iEntIDWas = t.entid;


													for (int i = 0; i < vEntityGroupList[groupID].size(); i++)
													{
														// first update object from final entity element data
														int e = vEntityGroupList[groupID][i].e;
														int entid = t.entityelement[e].bankindex;
														if (t.entityprofile[entid].ismarker == 0)
														{
															// use this one!
															t.entid = entid;
															break;
														}
													}
													if (!bLargePreview)
													{
														//PE: Drop rotate if we already got the original group thumb.
														CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
														if (FileExist(BackBufferCacheName.Get()))
														{
															update = false;
														}
													}
												}
											}
										}
											
										if (t.talreadyloaded == 0)
										{
											// Allocate one more entity item in array
											if (g.entidmaster > g.entitybankmax - 4)
											{
												Dim(t.tempentitybank_s, g.entitybankmax);
												for (t.t = 0; t.t <= g.entitybankmax; t.t++) t.tempentitybank_s[t.t] = t.entitybank_s[t.t];
												++g.entitybankmax;
												UnDim(t.entitybank_s);
												Dim(t.entitybank_s, g.entitybankmax);
												for (t.t = 0; t.t <= g.entitybankmax - 1; t.t++) t.entitybank_s[t.t] = t.tempentitybank_s[t.t];
											}

											bool bAutoGenerateThumb = false;
											if (!bDoBackbufferUpdate)
											{
												bAutoGenerateThumb = true;
											}

											//  Add entity to bank
											if (!bAutoGenerateThumb)
												++g.entidmaster;

											entity_validatearraysize();

											//  Load extra entity
											t.entid = g.entidmaster;

											//PE: Try to use index 0 on all auto generated thumbs.
											if (bAutoGenerateThumb)
												t.entid = 0;

											t.entitybank_s[t.entid] = t.addentityfile_s;
											iEntIDWas = t.entid;

											if (ObjectExist(g.entitybankoffset + t.entid)) 
											{
												//PE: We use a before/after list to free all used textures later.
												DeleteObject(g.entitybankoffset + t.entid);
											}

											t.ent_s = t.entitybank_s[t.entid];
											t.entpath_s = getpath(t.ent_s.Get());

											extern bool g_bGracefulWarningAboutOldXFiles;
											extern bool g_bDisplayWarnings;
											g_bGracefulWarningAboutOldXFiles = true;
											g_bDisplayWarnings = false;
											extern cstr g_sTempGroupForThumbnail;
											if (g_sTempGroupForThumbnail.Len() > 0)
											{
												extern int GetGroupIndexFromName (cstr sLookFor);
												current_selected_group = GetGroupIndexFromName(g_sTempGroupForThumbnail);
												UnGroupSelected(true);
												gridedit_deleteentityrubberbandfrommap();
												gridedit_clearentityrubberbandlist();
												g_sTempGroupForThumbnail = "";
											}
											extern int g_iAbortedAsEntityIsGroupFileMode;
											g_iAbortedAsEntityIsGroupFileMode = 1;
											extern int thumb_selected_group;
											thumb_selected_group = -1;
											g.thumbentityrubberbandlist.clear();
											
											bool bcalledfromlibrary = true; 
											if(bLargePreview) bcalledfromlibrary = false;

											if (entity_load(bcalledfromlibrary) == false)
											{
												// entity was a group object (smart object)
												if (thumb_selected_group >= 0)
													g_sTempGroupForThumbnail = sEntityGroupListName[thumb_selected_group];
												else
													g_sTempGroupForThumbnail = "";
												bIsGroup = true;

												g_LastGroupSaved_s = t.entitybank_s[iEntIDWas];

												// undo entry, it is NOT an entity of its own!
												t.entitybank_s[iEntIDWas] = "";

												// so scan group loaded and find first object that is not a marker (to display in preview)
												for (int i = 0; i < g.thumbentityrubberbandlist.size(); i++)
												{
													// first update object from final entity element data
													int e = g.thumbentityrubberbandlist[i].e;
													int entid = t.entityelement[e].bankindex;
													if (t.entityprofile[entid].ismarker == 0)
													{
														// use this one!
														t.entid = entid;
														break;
													}
												}

												if (!bLargePreview)
												{
													//PE: Drop rotate if we already got the original group thumb.
													CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
													if (FileExist(BackBufferCacheName.Get()))
													{
														update = false;
													}
												}
											}
											g_bDisplayWarnings = true;
											g_bGracefulWarningAboutOldXFiles = false;

											HideObject(g.entitybankoffset + t.entid);
											if (t.entityprofile[t.entid].ischaracter == 1) 
											{
												RotateObject(g.entitybankoffset + t.entid, 0, 180, 0);
											}

											//entity_load can change folder by creating a dbo , so update timestamp without refresh.
											struct stat sb;
											if (stat(pNewFolder->m_sFolderFullPath.Get(), &sb) == 0) 
											{
												if (sb.st_mtime != pNewFolder->m_tFolderModify) 
												{
													pNewFolder->m_tFolderModify = sb.st_mtime;
												}
											}
										}

										if (update)
										{
											iTooltipLastObjectId = t.entid;
											iTooltipAlreadyLoaded = t.talreadyloaded;
											iTooltipObjectReady = true;

											BackBufferIsGroup = bIsGroup;
											BackBufferEntityID = t.entid;
											BackBufferObjectID = g.entitybankoffset + t.entid;
											BackBufferImageID = g.importermenuimageoffset + 50;

											BackBufferRotateZ = ObjectAngleZ(BackBufferObjectID);
											BackBufferRotateY = ObjectAngleY(BackBufferObjectID) + 15;
											BackBufferRotateX = ObjectAngleX(BackBufferObjectID);
											BackBufferZoom = 1.0f;
											BackBufferCamLeft = 0.0f;
											BackBufferCamUp = 0.0f;

											if (bLargePreview)
											{
												iLargePreviewImageID = BackBufferImageID;
												BackBufferSizeX = thumb_x * 2.0f;
												BackBufferSizeY = thumb_y * 2.0f;
											}
											else
											{
												BackBufferSizeX = thumb_x;
												BackBufferSizeY = thumb_y;
											}
											if (ObjectExist(BackBufferObjectID) && GetNumberOfFrames(BackBufferObjectID) > 0 && t.entityprofile[BackBufferEntityID].animmax > 0)
											{
												//PE: Stop any running animations. set default pose.
												int iFrameStart = t.entityanim[BackBufferEntityID][0].start;
												SetObjectFrame(BackBufferObjectID, iFrameStart);
												//StopObject(BackBufferObjectID); //Stop will cancel wicked updateonce.
											}
											BackBufferZoom = 1.0f;
											BackBufferCamLeft = 0.0f;
											BackBufferCamUp = 0.0f;
											bRotateBackBuffer = false;
											bBackBufferAnimated = false;
											bLoopBackBuffer = false;
											RevertBackbufferCubemap();

											//PE: We must enable editor light here, so its ready for the next frame where we grab the backbuffer.
											if (!bDoBackbufferUpdate)
											{
												WickedCall_EnableThumbLight(true);
											}

											if (bDoBackbufferUpdate)
												if (textureId >= 4000 && textureId < UIV3IMAGES)
													if (bLargePreview)
														bRotateBackBuffer = false;
													else
														bRotateBackBuffer = true;

											//PE: Prefer myfiles->m_Backdrop it has the latest changes.
											if (!(t.entityprofile[t.entid].BackBufferZoom == -1.0f && t.entityprofile[t.entid].BackBufferCamLeft == -1.0f && t.entityprofile[t.entid].BackBufferRotateX == -1.0f))
											{
												//Found settings, set restore.
												RestoreBackBufferZoom = t.entityprofile[t.entid].BackBufferZoom;
												RestoreBackBufferCamLeft = t.entityprofile[t.entid].BackBufferCamLeft;
												RestoreBackBufferCamUp = t.entityprofile[t.entid].BackBufferCamUp;
												RestoreBackBufferRotateX = t.entityprofile[t.entid].BackBufferRotateX;
												RestoreBackBufferRotateY = t.entityprofile[t.entid].BackBufferRotateY;
												bBackBufferRestoreCamera = true; //Restore from fpe settings in next call.

												if (ObjectExist(BackBufferObjectID) && GetNumberOfFrames(BackBufferObjectID) > 0 && t.entityprofile[BackBufferEntityID].animmax > 0)
												{
													if (t.entityprofile[BackBufferEntityID].iThumbnailAnimset >= 0 && t.entityprofile[BackBufferEntityID].iThumbnailAnimset < t.entityprofile[BackBufferEntityID].startofaianim)
													{
														// new method uses name instead of fixed values
														if (t.entityprofile[BackBufferEntityID].playanimineditor == -1)
														{
															// uses name instead of index, the negative is the ordinal into the animset
															extern void entity_loop_using_negative_playanimineditor(int e, int obj, cstr animname);
															entity_loop_using_negative_playanimineditor(0, BackBufferObjectID, t.entityprofile[BackBufferEntityID].playanimineditor_name);
														}
														else
														{
															int iAnimationSet = t.entityprofile[BackBufferEntityID].iThumbnailAnimset;
															int iFrameStart = t.entityanim[BackBufferEntityID][iAnimationSet].start;
															int iFrameEnd = t.entityanim[BackBufferEntityID][iAnimationSet].finish;
															SetObjectFrame(BackBufferObjectID, iFrameStart);
															LoopObject(BackBufferObjectID, iFrameStart, iFrameEnd);
														}
														bBackBufferAnimated = true;
													}
													if (bBackBufferAnimated == true)
													{
														if (t.entityprofile[BackBufferEntityID].animspeed > 0)
														{
															t.tanimspeed_f = t.entityprofile[BackBufferEntityID].animspeed;
															SetObjectSpeed(BackBufferObjectID, t.tanimspeed_f);
														}
													}
												}
											}

											if (bIsGroup == true)
											{
												CreateBackdropObject(false, cstr("texturebank\\backdrops\\") + t.entityprofile[iEntIDWas].thumbnailbackdrop, EntWas_s);
											}
											else
											{
												if (myfiles->m_Backdrop.Len() > 0)
												{
													CreateBackdropObject(false, cstr("texturebank\\backdrops\\") + myfiles->m_Backdrop, t.addentityfile_s); //PE: We need a extra frame, as we set the material dirty in this call.
												}
												else
												{
													if (t.entityprofile[t.entid].thumbnailbackdrop.Len() > 0)
														CreateBackdropObject(false, cstr("texturebank\\backdrops\\") + t.entityprofile[t.entid].thumbnailbackdrop, t.addentityfile_s);
													else
														CreateBackdropObject(false, "None", t.addentityfile_s);
												}
											}

											if (bDoBackbufferUpdate)
											{
												//BackBufferSizeX = 512;
												//BackBufferSizeY = 512;
												BackBufferSaveCacheName = ""; //No saving on tooltip images

												if (textureId >= 4000 && textureId < UIV3IMAGES)
												{
													BackBufferRotateZ = ObjectAngleZ(BackBufferObjectID);
													BackBufferRotateY = ObjectAngleY(BackBufferObjectID) + 15;
													BackBufferRotateX = ObjectAngleX(BackBufferObjectID);
													BackBufferZoom = 1.0f;
													BackBufferCamLeft = 0.0f;
													BackBufferCamUp = 0.0f;
													if (bLargePreview)
														bRotateBackBuffer = false;
													else
														bRotateBackBuffer = true;
													BackBufferImageID = textureId;
													iLargePreviewImageID = BackBufferImageID;
													bLoopBackBuffer = true;
												}

											}

											if (bForceUpdate)
											{
												BackBufferRotateZ = ObjectAngleZ(BackBufferObjectID);
												BackBufferRotateY = ObjectAngleY(BackBufferObjectID) + 15;
												BackBufferRotateX = ObjectAngleX(BackBufferObjectID);
												BackBufferZoom = 1.0f;
												BackBufferCamLeft = 0.0f;
												BackBufferCamUp = 0.0f;
												bRotateBackBuffer = false;
												bLoopBackBuffer = true;
											}

											bDoneOneThumbPerSync = true;
										}
										else
										{
											bRotateBackBuffer = false;
											bLoopBackBuffer = false;
										}
									}
								}
							}

							ImGui::PopStyleVar();

							ImGui::PopID();
							ImGui::PushID(uniqueId + 30000);
							ImVec2 opos = ImGui::GetCursorPos();

							if (myfiles->bFavorite)
							{
								int iImageSize = 20;
								ImGui::SetCursorPos(ImVec2(opos.x + 12.0f, opos.y - 16.0f - iImageSize));
								ImGui::SetItemAllowOverlap();
								if (ImGui::ImgBtn(MEDIA_FAVORITE, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
								{
									//Remove from favorite.
									cstr file = myfiles->m_sPath;
									file = file + "\\" + myfiles->m_sName.Get();
									file = file.Lower();
									extern std::vector<std::string> files_favorite;
									myfiles->bFavorite = false;
									for (int i = 0; i < files_favorite.size(); i++)
									{
										cstr check = cstr((char *)files_favorite[i].c_str()).Lower();
										if (file == check)
										{
											//Delete.
											files_favorite.erase(files_favorite.begin() + i);
										}
									}
									saveVectorFileContent("favoritelist.ini", files_favorite);
								}
								ImGui::SetCursorPos(opos);
								if (!bThumbHovered)
									bThumbHovered = ImGui::IsItemHovered();
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("Remove From Favourite");
							}
							else
							{
								int iImageSize = 20;
								ImVec2 opos = ImGui::GetCursorPos();
								ImGui::SetCursorPos(ImVec2(opos.x + 12.0f, opos.y - 16.0f - iImageSize));
								ImGui::SetItemAllowOverlap();
								if (ImGui::ImgBtn(MEDIA_FAVORITE_DIS, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
								{
									//Add to favorite.
									cstr file = myfiles->m_sPath;
									file = file + "\\" + myfiles->m_sName.Get();
									extern std::vector<std::string> files_favorite;
									myfiles->bFavorite = true;
									files_favorite.push_back(file.Get());
									saveVectorFileContent("favoritelist.ini", files_favorite);
								}
								ImGui::SetCursorPos(opos);
								if (!bThumbHovered)
									bThumbHovered = ImGui::IsItemHovered();
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add to Favourite");
							}

							if (bDisplayText)
							{
								//if (strlen(cHeader) > 0)
								//{
								//	ImGui::Text("%s (%s)", sFinal.c_str(), cHeader);
								//	if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s (%s)", sFinal.c_str(), cHeader);
								//}
								//else
								//{
								//}
								if (iDisplayLibraryType == 4)
								{
									char cDisplayName[MAX_PATH];
									strcpy (cDisplayName, sFinal.c_str());
									FormatLUAFilenameToTitle(cDisplayName);
									sFinal = cDisplayName;
									ImGui::Text("%s", sFinal.c_str());
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", sFinal.c_str());

									if (myfiles->m_sDLuaDescription != "")
									{
										//Always use same size box on all DLUA boxes. looks better.
										ImGui::BeginChild("##DLUADescriptionbox", ImVec2(media_icon_size, (ImGui::GetTextLineHeight() * 5)-7.0f ), true, ImGuiWindowFlags_NoMove); //| ImGuiWindowFlags_AlwaysUseWindowPadding
										ImGui::TextWrapped(myfiles->m_sDLuaDescription.Get());
										ImGui::EndChild();
										ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x, ImGui::GetCursorPos().y + 3.0f));
									}
								}
								else
								{
									if (iDisplayLibraryType == 0)
									{
										ImGui::Text("  %s", sFinal.c_str());
									}
									else
									{
										ImGui::Text("%s", sFinal.c_str());
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", sFinal.c_str());
								}
							}

							if (bSecondScrollActive && secondscrolltofile && secondscrolltofile == myfiles)
							{
								secondscrolltofile = NULL;
								//PE: Test second scrool if list is correct.
								if (imgui_GetMinMaxButtonState(0))
								{
									//Full screen.
									if (ImGui::GetCursorPosY() > (media_icon_size*0.75))
										ImGui::SetScrollY(ImGui::GetCursorPosY()); //+(media_icon_size*0.5));
									else
										ImGui::SetScrollY(0.0f);
								}
								else
								{
									float cpy = ImGui::GetCursorPosY();
									float scy = ImGui::GetScrollY();
									if (cpy > (media_icon_size*0.75))
									{
										//PE: Try DirectPosition.y;
										if (0)
										{
											ImGui::SetScrollY(DirectPosition.y);
										}
										else
										{
											if (cpy < ((media_icon_size*3.0)*0.75))
											{
												ImGui::SetScrollY(0.0);
											}
											else if (scy > 0 && cpy > (media_icon_size*2.0))
											{
												ImGui::SetScrollY(cpy - (media_icon_size*2.0));
											}
											else if (scy > 0 && cpy > (media_icon_size))
											{
												ImGui::SetScrollY(cpy - (media_icon_size));
											}
											else
											{
												ImGui::SetScrollY(DirectPosition.y + (media_icon_size*0.75));
											}
										}
									}
									else
										ImGui::SetScrollY(0.0f);
								}

							}
							//PE: Check if we need to adjust scroll after a window resize.
							if (!firstvisiblefile && scrolltofile && scrolltofile == myfiles)
							{
								if (bScrollInNextFrame)
								{
									firstvisiblefile = scrolltofile;
									bScrollInNextFrame = false;
								}
								else
								{
									firstvisiblefile = scrolltofile;
									secondscrolltofile = scrolltofile;
									bSecondScrollActive = false;
									scrolltofile = NULL;
									if (imgui_GetMinMaxButtonState(0))
									{
										//Full screen.
										if (ImGui::GetCursorPosY() > (media_icon_size*0.75))
											ImGui::SetScrollY(ImGui::GetCursorPosY()); //+(media_icon_size*0.5));
										else
											ImGui::SetScrollY(0.0f);
									}
									else
									{
										float cpy = ImGui::GetCursorPosY();
										float scy = ImGui::GetScrollY();
										if (cpy > (media_icon_size*0.75))
										{
											//PE: Try DirectPosition.y;
											if (0)
											{
												ImGui::SetScrollY(DirectPosition.y);
											}
											else
											{
												if (cpy < ((media_icon_size*3.0)*0.75))
												{
													ImGui::SetScrollY(0.0);
												}
												else if (scy > 0 && cpy > (media_icon_size*2.0))
												{
													ImGui::SetScrollY(cpy - (media_icon_size*2.0));
												}
												else if (scy > 0 && cpy > (media_icon_size))
												{
													ImGui::SetScrollY(cpy - (media_icon_size));
												}
												else
												{
													ImGui::SetScrollY(DirectPosition.y + (media_icon_size*0.75) );
												}
											}
										}
										else
											ImGui::SetScrollY(0.0f);
									}

									//ImGui::SetScrollHereY(1.0f);
								}
							}

							//PE: Draw selection last so we can overlap spacing.
							if( (myfiles->iFlags == 1 || selectedmediafile == myfiles) && bVisibleOnScreen)
							{
								ImGuiWindow* window = ImGui::GetCurrentWindow();
								ImVec4 bg_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram]; // { 0.0, 0.0, 0.0, 1.0 };
								window->DrawList->AddRect(selection_bb.Min, selection_bb.Max, ImGui::GetColorU32(bg_col), 0.0f, 0, 3.0f);
							}

							//PE: Right click context menu removed from design.
							if (0)
							{
								static cFolderItem::sFolderFiles * ContextSelection = NULL;
								if (bThumbHovered || ContextSelection == myfiles)
								{
									if (!bInContextThumb || ContextSelection == myfiles)
									{
										if (ImGui::BeginPopupContextWindow())
										{
											bInContextThumb = true;
											ContextSelection = myfiles;
											if (ImGui::MenuItem("Update Thumbnail"))
											{
												std::string sFpeName = path_for_filename.c_str();
												sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
												t.addentityfile_s = sFpeName.c_str();


												CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
												if (FileExist(BackBufferCacheName.Get()))
												{
													DeleteAFile(BackBufferCacheName.Get());
													if (myfiles->iPreview > 0)
													{
														if (GetImageExistEx(myfiles->iPreview) && myfiles->iPreview >= 4000 && myfiles->iPreview < UIV3IMAGES) { //PE: Need to protect system images after tool img range has changed. (myfiles->iPreview can be a system icon)
															iDeleteInNextUpdate = myfiles->iPreview;
														}
													}
													myfiles->iPreview = 0;
													myfiles->iBigPreview = 0;
												}
												ContextSelection = NULL;
											}

											if (myfiles->bFavorite)
											{
												if (ImGui::MenuItem("Remove Favourite"))
												{
													cstr file = myfiles->m_sPath;
													file = file + "\\" + myfiles->m_sName.Get();
													extern std::vector<std::string> files_favorite;
													myfiles->bFavorite = false;
													//Remove.
													auto itr = std::find(files_favorite.begin(), files_favorite.end(), file.Get());
													if (itr != files_favorite.end())
														files_favorite.erase(itr);
													saveVectorFileContent("favoritelist.ini", files_favorite);
													ContextSelection = NULL;
												}
											}
											else
											{
												if (ImGui::MenuItem("Add to Favourite"))
												{
													cstr file = myfiles->m_sPath;
													file = file + "\\" + myfiles->m_sName.Get();
													extern std::vector<std::string> files_favorite;
													myfiles->bFavorite = true;
													files_favorite.push_back(file.Get());
													saveVectorFileContent("favoritelist.ini", files_favorite);
													ContextSelection = NULL;
												}
											}
											ImGui::EndPopup();
										}
										else
											bInContextThumb = false;
									}
								}
							}
							ImGui::NextColumn();

						}
						ImGui::PopID();
						preview_count++;

					}

					ImGui::SetWindowFontScale(1.0);

				} //bValid

			} //#### MAIN LOOP iLoop < sorted_files.size() ####


			ImGui::EndColumns();

			if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
				//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				ImGui::Text("");
				ImGui::Text("");
			}

			//ImGui::Columns(1);
		}

		if (!bAnySelectedItemsAvailable) {
			//PE: We got no selections , we can reset first shift seen.
			if (!io.KeyShift) {
				firstShiftFile = NULL;
			}
		}
		ImGui::SetWindowFontScale(1.0);

		ImRect bbwinclient(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
		if (ImGui::IsMouseHoveringRect(bbwinclient.Min, bbwinclient.Max))
		{
			bImGuiGotFocus = true;
			bEntityGotFocus = true;
		}
		if (ImGui::IsAnyItemFocused()) {
			bImGuiGotFocus = true;
			bEntityGotFocus = true;
		}
		
		ImGui::EndChild();

		ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
		if (ImGui::IsMouseHoveringRect(bbwin.Min - ImVec2(1, 1), bbwin.Max , false))
		{
			bImGuiGotFocus = true;
			bEntityGotFocus = true;
		}
		if (ImGui::IsAnyItemFocused()) {
			bImGuiGotFocus = true;
			bEntityGotFocus = true;
		}

		ImGui::Indent(10);
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x, ImGui::GetCursorPos().y+1.0f));

		ImGui::PushItemWidth(150.f);
		float fSliderPos = ImGui::GetContentRegionAvailWidth() - 150.0f - 16.0f;
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x + fSliderPos, ImGui::GetCursorPos().y + 7.0f));
		ImGui::SetWindowFontScale(0.6);
		int iMaxSlider = 8;
		if (fSliderPos > 820) iMaxSlider++;
		if (fSliderPos > 1000) iMaxSlider++;
		if (pref.iSetColumnsEntityLib > iMaxSlider) pref.iSetColumnsEntityLib = iMaxSlider;
		if (pref.iSetColumnsEntityLib < 1) pref.iSetColumnsEntityLib = 1;

		ImGui::SliderInt("##fScaleIcons", &pref.iSetColumnsEntityLib, 1, iMaxSlider, " ");
		ImGui::SetWindowFontScale(1.0);
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set Columns %d" , pref.iSetColumnsEntityLib);
		ImGui::PopItemWidth();
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x, ImGui::GetCursorPos().y +7.0f));

		//PE: Display new buttons.
		int iButtons = 3;
		if (lf_multi_selections_count > 0)
			iButtons++;

		ImVec2 vContentSize = ImGui::GetContentRegionAvail();
		float fButWidth = vContentSize.x / iButtons;
		fButWidth -= 10.0f; //But spacing.
		if (fButWidth < 30.0f)
			fButWidth = 30.0f;

		float fFontSize = ImGui::GetFontSize();
		ImGui::SetWindowFontScale(1.4);

		if (bTriggerCloseEntityWindow)
		{
			bCheckForClosing = true;
			bTriggerCloseEntityWindow = false;
		}

		if (iDisplayLibraryType > 0)
		{
			//###############
			//#### Audio ####
			//###############

			if (iDisplayLibraryType == 1) //Music
			{
				int buts = 2;
				if (selectedmediafile != NULL) buts = 3;
				fButWidth = vContentSize.x / buts;
				fButWidth -= 10.0f;
				// Marketplace
				if (ImGui::StyleButton("Get More Music and Sound", ImVec2(fButWidth, fFontSize*2.0)))
				{
					DeleteWaypointsAddedToCurrentCursor();
					CloseDownEditorProperties();
					bMarketplace_Window = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Click to get more Music and Sound");
				// Direct import here
				if (1)
				{
					static int import_process = 0;
					static cstr import_filename = "";
					static char import_name[MAX_PATH];
					if (import_process == 1)
					{
						static char import_to[MAX_PATH];
						strcpy(import_to, "audiobank\\users"); //currently fixed.

						bool bValid = true;
						if (strlen(import_name) < 1 || import_filename.Len() < 1)
						{
							bValid = false;
							import_process = 0; //Cancel.
						}
						if (bValid)
						{
							extern char g_pAbsPathToConverter[MAX_PATH];
							std::string process_name = g_pAbsPathToConverter;
							replaceAll(process_name, "\\Guru-Converter.exe", "\\ffmpeg.exe");
							HANDLE g_hConvertImportTOOggProcess = NULL;
							DARKSDK BOOL DB_ExecuteFile(HANDLE* phExecuteFileProcess, char* Operation, char* Filename, char* String, char* Path, bool bWaitForTermination);
							char parameters[MAX_PATH];
							char destination[MAX_PATH];
							strcpy(destination, "audiobank\\user\\");
							strcat(destination, import_name);

							//PE: Simple import , no options, so always to .wav
							//PE: use -y -i to always overwrite.
							if (0) //ogg
							{
								strcat(destination, ".ogg");
								GG_GetRealPath(destination, 1);
								strcpy(parameters, "-y -i \"");
								strcat(parameters, import_filename.Get());
								strcat(parameters, "\" -c:a libvorbis -q:a 4 \"");
								strcat(parameters, destination);
								strcat(parameters, "\"");
							}
							else
							{
								strcat(destination, ".wav");
								GG_GetRealPath(destination, 1);
								strcpy(parameters, "-y -i \"");
								strcat(parameters, import_filename.Get());
								strcat(parameters, "\" \"");
								strcat(parameters, destination);
								strcat(parameters, "\"");
							}

							::SetCursor(::LoadCursor(NULL, IDC_WAIT));
							DB_ExecuteFile(&g_hConvertImportTOOggProcess, "hide", (char *)process_name.c_str(), parameters, "", true);
							int iTimeout = 4000;
							int iRunning = 1;
							while (iRunning == 1)
							{
								iRunning = 0;
								DWORD dwStatus;
								if (GetExitCodeProcess(g_hConvertImportTOOggProcess, &dwStatus) == TRUE)
									if (dwStatus == STILL_ACTIVE)
										iRunning = 1;
								Sleep(1);
								if (iTimeout-- <= 0) iRunning = 0; //Timeout 4 sec.
							}
							CloseHandle(g_hConvertImportTOOggProcess);
							::SetCursor(::LoadCursor(NULL, IDC_ARROW));

							//Done close down.
							import_process = 0;
							iLastDisplayLibraryType = -1; //Update search and refresh if any new files found.
							sStartLibrarySearchString = "user";
						}
					}
					if (import_process == 2)
					{
						import_process = 1; //Need a frame for triggermessage
					}
					if (import_process == 0)
					{
						ImGui::SameLine();
						if (ImGui::StyleButton("Import Music And Sound", ImVec2(fButWidth, fFontSize*2.0)))
						{
							//Select File.
							//Select name.
							//Convert and copy to 'audiobank/users'.
							//ffmpeg can be used.
							cStr tOldDir = GetDir();
							char * cFileSelected;
							cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "All\0*.mp3;*.wav;*.ogg\0mp3\0*.mp3\0wav\0*.wav\0ogg\0*.ogg\0", g.mysystem.mapbankAbs_s.Get(), NULL);
							SetDir(tOldDir.Get());
							if (cFileSelected && strlen(cFileSelected) > 0)
							{
								import_filename = cFileSelected;

								//import_name
								cstr importer_getfilenameonly(LPSTR pFileAndPossiblePath);
								cstr tmp = importer_getfilenameonly(import_filename.Get());
								strcpy(import_name, tmp.Get());
								if (tmp.Len() > 4)
								{
									import_name[strlen(import_name) - 4] = 0;
								}
								import_process = 1;
								sprintf(cTriggerMessage, "Importing");
								bTriggerMessage = true;
							}
						}
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to import Music or Sound");
					}
				}
				if (selectedmediafile != NULL)
				{
					ImGui::SameLine();
					if (ImGui::StyleButton("Add Selected", ImVec2(fButWidth, fFontSize*2.0)))
					{
						//Sent selection to imgui ID that have last requested a media file.
						playingiles = NULL;

						//Stop anything playing.
						if (SoundExist(MEDIA_PLAY) == 1)
						{
							StopSound(MEDIA_PLAY);
							DeleteSound(MEDIA_PLAY);
						}
						if (SoundExist(g.temppreviewsoundoffset) == 1)
						{
							StopSound(g.temppreviewsoundoffset);
							DeleteSound(g.temppreviewsoundoffset);
						}

						cFolderItem *pNewFolder = selectedmediafile->pNewFolder;
						cStr path = pNewFolder->m_sFolderFullPath.Get();
						int ipath_remove_len = path.Len();
						if (pNewFolder->m_iEntityOffset > 0)
							ipath_remove_len = pNewFolder->m_iEntityOffset;

						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;


						std::string path_for_filename = final_name;
						std::string sSoundName = "";
						if(iDisplayLibraryType == 1) sSoundName = "audiobank\\";
						sSoundName = sSoundName + path_for_filename.c_str();
						if (path_for_filename.length() == 0)
							sSoundName = sSoundName + selectedmediafile->m_sName.Get();
						else
							sSoundName = sSoundName + "\\" + selectedmediafile->m_sName.Get();
						if (sSoundName != "")
						{
							sSelectedLibrarySting = sSoundName.c_str();
							iSelectedLibraryStingReturnID = iLibraryStingReturnToID;
						}
						bCheckForClosing = true;
						bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.

						selectedmediafile = NULL;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add Selected");
				}
			}

			//################
			//#### Images ####
			//################

			if (iDisplayLibraryType == 2) //Images
			{
				int buts = 1;
				if (selectedmediafile != NULL) buts = 2;
				fButWidth = vContentSize.x / buts;
				fButWidth -= 10.0f;

				if (ImGui::StyleButton("Import Image", ImVec2(fButWidth, fFontSize*2.0)))
				{
					static char picture_default_folder[MAX_PATH] = "\0";
					if (strlen(picture_default_folder) <= 0)
					{
						//Init. 
						if ((SHGetFolderPathA(NULL, CSIDL_COMMON_PICTURES, NULL, 0, &picture_default_folder[0])) != S_OK)
						{
							//Failed try another.
							if ((SHGetFolderPathA(NULL, CSIDL_MYPICTURES, NULL, 0, &picture_default_folder[0])) != S_OK)
							{
								//Failed try another.
								if ((SHGetFolderPathA(NULL, CSIDL_COMMON_DOCUMENTS, NULL, 0, &picture_default_folder[0])) != S_OK)
								{
									strcpy(picture_default_folder, "c:\\");
								}
							}
						}
					}
					//
					cStr tOldDir = GetDir();
					char * cFileSelected;
					cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "all\0*.*\0png\0*.png\0jpg\0*.jpg\0jpeg\0*.jpeg\0dds\0*.dds\0bmp\0*.bmp\0jpeg\0*.jpeg\0", picture_default_folder, NULL ,true);
					SetDir(tOldDir.Get());
					if (cFileSelected && strlen(cFileSelected) > 0)
					{
						cstr import_filename = cFileSelected;
						strcpy(picture_default_folder, cFileSelected);
						//import_name
						cstr importer_getfilenameonly(LPSTR pFileAndPossiblePath);
						cstr tmp = importer_getfilenameonly(import_filename.Get());

						char destination[MAX_PATH];
						strcpy(destination, "imagebank\\user\\");
						strcat(destination, tmp.Get());
						GG_GetRealPath(destination, 1);
						CopyFileA(import_filename.Get(), destination, false);
						sStartLibrarySearchString = "user";
					}
				}
				/* for now images marketlplace is disabled
				//REMOVED_EARLYACCESS
				if (ImGui::StyleButton("Get More Images", ImVec2(fButWidth, fFontSize*2.0)))
				{
					DeleteWaypointsAddedToCurrentCursor();
					CloseDownEditorProperties();
					bMarketplace_Window = true;
					//We can reuse iDisplayLibraryType in marketplace.
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Get More Images (This feature is not yet complete)");
				*/

				if (selectedmediafile != NULL)
				{
					ImGui::SameLine();
					if (ImGui::StyleButton("Add Selected Image", ImVec2(fButWidth, fFontSize*2.0)))
					{
						//Sent selection to imgui ID that have last requested a media file.
						playingiles = NULL;

						cFolderItem *pNewFolder = selectedmediafile->pNewFolder;
						cStr path = pNewFolder->m_sFolderFullPath.Get();
						int ipath_remove_len = path.Len();
						if (pNewFolder->m_iEntityOffset > 0)
							ipath_remove_len = pNewFolder->m_iEntityOffset;

						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;


						std::string path_for_filename = final_name;
						std::string sImageName = "";
						sImageName = "imagebank\\";
						sImageName = sImageName + path_for_filename.c_str();
						if (path_for_filename.length() == 0)
							sImageName = sImageName + selectedmediafile->m_sName.Get();
						else
							sImageName = sImageName + "\\" + selectedmediafile->m_sName.Get();
						if (sImageName != "")
						{
							sSelectedLibrarySting = sImageName.c_str();
							iSelectedLibraryStingReturnID = iLibraryStingReturnToID;
						}
						bCheckForClosing = true;
						bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.

						selectedmediafile = NULL;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add Selected Image");
				}
			}


			//###############
			//#### Video ####
			//###############

			if (iDisplayLibraryType == 3) //Video
			{
				int buts = 0;
				if (selectedmediafile != NULL) buts = 1;
				fButWidth = vContentSize.x / buts;
				fButWidth -= 10.0f;
				/* not in EA
				if (ImGui::StyleButton("Get More Videos", ImVec2(fButWidth, fFontSize*2.0)))
				{
					DeleteWaypointsAddedToCurrentCursor();
					CloseDownEditorProperties();
					bMarketplace_Window = true;
					//We can reuse iDisplayLibraryType in marketplace.
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Get More Videos (This feature is not yet complete)");
				ImGui::SameLine();
				*/

				if (selectedmediafile != NULL)
				{
					if (ImGui::StyleButton("Add Selected Video", ImVec2(fButWidth, fFontSize*2.0)))
					{
						//Sent selection to imgui ID that have last requested a media file.
						playingiles = NULL;

						cFolderItem *pNewFolder = selectedmediafile->pNewFolder;
						cStr path = pNewFolder->m_sFolderFullPath.Get();
						int ipath_remove_len = path.Len();
						if (pNewFolder->m_iEntityOffset > 0)
							ipath_remove_len = pNewFolder->m_iEntityOffset;

						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;

						std::string path_for_filename = final_name;
						std::string sVideoName = "";
						if (iDisplayLibraryType == 3) sVideoName = "videobank\\";
						sVideoName = sVideoName + path_for_filename.c_str();
						if (path_for_filename.length() == 0)
							sVideoName = sVideoName + selectedmediafile->m_sName.Get();
						else
							sVideoName = sVideoName + "\\" + selectedmediafile->m_sName.Get();
						if (sVideoName != "")
						{
							sSelectedLibrarySting = sVideoName.c_str();
							iSelectedLibraryStingReturnID = iLibraryStingReturnToID;
						}
						bCheckForClosing = true;
						bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.

						selectedmediafile = NULL;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add Selected Video");
				}
			}

			//################
			//#### Script ####
			//################
			char pChosenSelectedBehaviorFile[MAX_PATH];
			strcpy (pChosenSelectedBehaviorFile, "");
			if (iDisplayLibraryType == 4) //Script
			{
				// get more
				//int buts = 2;
				//if (selectedmediafile != NULL) buts = 3;
				//fButWidth = vContentSize.x / buts;
				//fButWidth -= 10.0f;
				//
				//if (ImGui::StyleButton("Get More Behaviors", ImVec2(fButWidth, fFontSize*2.0)))
				//{
				//	ExecuteFile ("https://forum.game-guru.com/", "", "", 1);
				//	/* not fort EA
				//	DeleteWaypointsAddedToCurrentCursor();
				//	CloseDownEditorProperties();
				//	bMarketplace_Window = true;
				//	//We can reuse iDisplayLibraryType in marketplace.
				//	*/
				//}
				//if (ImGui::IsItemHovered()) ImGui::SetTooltip("Get More Behaviors by visiting the GameGuru MAX forums");

				// get more
				int buts = 1;
				if (pref.iEnableDeveloperProperties)
				{
					if (selectedmediafile != NULL) buts = 2;
				}
				fButWidth = vContentSize.x / buts;
				fButWidth -= 10.0f;

				// create new
				if (pref.iEnableDeveloperProperties)
				{
					//ImGui::SameLine();
					if (ImGui::StyleButton("Create New Behavior", ImVec2(fButWidth, fFontSize*2.0)))
					{
						// trigger entry of unique behavior name
						library_createbehavior = true;
						strcpy (library_newbehaviorname, "");
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Create a new blank behavior script, ready for editing with the behavior editor");
					ImGui::SameLine();
				}

				// create a new state with unique name
				if (library_createbehavior == true)
				{
					// Can create new behvaior
					ImGui::SetNextWindowSize(ImVec2(26 * ImGui::GetFontSize(), 8 * ImGui::GetFontSize()), ImGuiCond_Once);
					ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
					cstr sUniqueWinName = cstr("Enter A Name for your New Behavior##BehaviorEditorNew");
					ImGui::Begin(sUniqueWinName.Get(), &library_createbehavior, 0);
					ImGui::Indent(10);
					cstr sUniqueInputName = cstr("##Behavior Name") + cstr(1);
					ImGui::PushItemWidth(-10);
					ImGui::Text("");
					ImGui::Text("Type a name for your new Behavior and press ENTER:");
					if (ImGui::IsRootWindowOrAnyChildFocused() && !ImGui::IsAnyItemActive() && !ImGui::IsMouseClicked(0)) ImGui::SetKeyboardFocusHere(0);
					if (ImGui::InputText(sUniqueInputName.Get(), library_newbehaviorname, 250, ImGuiInputTextFlags_EnterReturnsTrue))
					{
						// cannot contain spaces
						bool bContainsASpace = false;
						for (int n = 0; n < strlen(library_newbehaviorname); n++)
						{
							if (library_newbehaviorname[n] == ' ')
								bContainsASpace = true;
						}
						if (bContainsASpace == true)
						{
							sprintf(cTriggerMessage, "The behavior name cannot contain spaces");
							bTriggerMessage = true;
						}
						else
						{
							// create a behavior script in the user folder
							char pNewScriptPath[MAX_PATH];
							sprintf(pNewScriptPath, "%s\\Files\\scriptbank\\user\\%s.lua", g.fpscrootdir_s.Get(),library_newbehaviorname);
							GG_GetRealPath(pNewScriptPath, 1);
							if (FileExist(pNewScriptPath) == 1)
							{
								sprintf(cTriggerMessage, "This behavior name already exists");
								bTriggerMessage = true;
							}
							else
							{
								// temp
								char pLine[2048];

								// generate a blank LUA script
								OpenToWrite(1, pNewScriptPath);
								WriteString(1, "-- DESCRIPTION: This is a custom behavior, and can be configured with [customvalue1=0(0,100)], [customvalue2=0(0,100)] and [customvalue3=0(0,100)].");
								sprintf(pLine, "master_interpreter_core = require \"scriptbank\\\\masterinterpreter\""); WriteString(1, pLine);
								
								WriteString(1, "");
								sprintf(pLine, "g_%s = {}", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, "g_%s_behavior = {}", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, "g_%s_behavior_count = 0", library_newbehaviorname); WriteString(1, pLine);

								WriteString(1, "");
								sprintf(pLine, "function %s_init(e)", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " g_%s[e] = {}", library_newbehaviorname); WriteString(1, pLine);

								sprintf(pLine, " g_%s[e][\"bycfilename\"] = \"scriptbank\\\\user\\\\%s.byc\"", library_newbehaviorname, library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " g_%s_behavior_count = master_interpreter_core.masterinterpreter_load (g_%s[e], g_%s_behavior )", library_newbehaviorname, library_newbehaviorname, library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " %s_properties(e,0,0,0)", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, "end"); WriteString(1, pLine);

								WriteString(1, "");
								sprintf(pLine, "function %s_properties(e, customvalue1, customvalue2, customvalue3)", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " g_%s[e]['customvalue1'] = customvalue1", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " g_%s[e]['customvalue2'] = customvalue2", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " g_%s[e]['customvalue3'] = customvalue3", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " master_interpreter_core.masterinterpreter_restart (g_%s[e], g_Entity[e])", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, "end"); WriteString(1, pLine);

								WriteString(1, "");
								sprintf(pLine, "function %s_main(e)", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " if g_%s[e] ~= nil and g_%s_behavior_count > 0 then", library_newbehaviorname, library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, "  g_%s_behavior_count = master_interpreter_core.masterinterpreter (g_%s_behavior, g_%s_behavior_count, e, g_%s[e], g_Entity[e])", library_newbehaviorname, library_newbehaviorname, library_newbehaviorname, library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " end"); WriteString(1, pLine);
								sprintf(pLine, "end"); WriteString(1, pLine);
								WriteString(1, "");
								CloseFile(1);

								// create a blank thumbnail for script
								char pBlankFile[MAX_PATH];
								sprintf(pBlankFile, "scriptbank\\user\\blank_icon.jpg");
								char pThumbFile[MAX_PATH];
								sprintf(pThumbFile, "%s\\Files\\scriptbank\\user\\%s.jpg", g.fpscrootdir_s.Get(), library_newbehaviorname);
								GG_GetRealPath(pThumbFile, 1);
								CopyFileA(pBlankFile, pThumbFile, TRUE);

								// when created, auto select this for the object
								char pRelativePathToScript[MAX_PATH];
								sprintf(pRelativePathToScript, "user\\%s.lua", library_newbehaviorname);
								strcpy (pChosenSelectedBehaviorFile, pRelativePathToScript);
							}
						}

						// finished here
						library_createbehavior = false;
						strcpy(library_newbehaviorname, "");
					}
					ImGui::PopItemWidth();
					ImGui::Indent(-10);
					bImGuiGotFocus = true;
					ImGui::End();
				}

				// add selected
				if (selectedmediafile != NULL)
				{
					if (ImGui::StyleButton("Add Selected Behavior", ImVec2(fButWidth, fFontSize*2.0)))
					{
						cFolderItem *pNewFolder = selectedmediafile->pNewFolder;
						cStr path = pNewFolder->m_sFolderFullPath.Get();
						int ipath_remove_len = path.Len();
						if (pNewFolder->m_iEntityOffset > 0)
							ipath_remove_len = pNewFolder->m_iEntityOffset;

						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;

						std::string path_for_filename = final_name;

						std::string sScriptName = "";
						sScriptName = sScriptName + path_for_filename.c_str();
						if (path_for_filename.length() == 0)
							sScriptName = sScriptName + selectedmediafile->m_sName.Get();
						else
							sScriptName = sScriptName + "\\" + selectedmediafile->m_sName.Get();

						// trigger selected
						strcpy (pChosenSelectedBehaviorFile, sScriptName.c_str());
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add Selected Behavior");
				}
			}

			// if cxeated/selected behavior
			if (strlen(pChosenSelectedBehaviorFile)>0)
			{
				// created or added
				//Sent selection to imgui ID that have last requested a media file.
				playingiles = NULL;
				sSelectedLibrarySting = pChosenSelectedBehaviorFile;
				iSelectedLibraryStingReturnID = iLibraryStingReturnToID;
				bCheckForClosing = true;
				bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.
				selectedmediafile = NULL;
			}

			//###################
			//#### Particles ####
			//###################

			if (iDisplayLibraryType == 5)
			{
				int buts = 1;
				if (selectedmediafile != NULL) buts = 2;
				fButWidth = vContentSize.x / buts;
				fButWidth -= 10.0f;
				LPSTR pParticleEditorTitle = "Particle Editor";
				LPSTR pParticleEditorTooltip = "Update GameGuru MAX to the latest version to get the Particle Editor Tool";
				extern bool g_bParticleEditorPresent;
				if (g_bParticleEditorPresent == true)
				{
					pParticleEditorTitle = "Create New Particles";
					pParticleEditorTooltip = "Create More Particles using the Particle Editor";
				}
				if (ImGui::StyleButton(pParticleEditorTitle, ImVec2(fButWidth, fFontSize*2.0)))
				{
					if (g_bParticleEditorPresent == true)
					{
						extern void launchOrShowParticleEditor(void);
						launchOrShowParticleEditor();
					}
					/* no longer sell functionality
					else
					{
						if (g_bUpdateAppAvailable == true)
							ExecuteFile("https://www.game-guru.com/order?_ga=2.121561419.292858542.1654524806-1982497974.1625668666#dlc", "", "", 0);
						else
							ExecuteFile("https://store.steampowered.com/dlc/1247290/GameGuru_MAX/", "", "", 0);
					}
					*/
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip(pParticleEditorTooltip);

				if (selectedmediafile != NULL)
				{
					ImGui::SameLine();
					if (ImGui::StyleButton("Add Selected Particle", ImVec2(fButWidth, fFontSize*2.0)))
					{
						//Sent selection to imgui ID that have last requested a media file.
						playingiles = NULL;

						cFolderItem *pNewFolder = selectedmediafile->pNewFolder;
						cStr path = pNewFolder->m_sFolderFullPath.Get();
						int ipath_remove_len = path.Len();
						if (pNewFolder->m_iEntityOffset > 0)
							ipath_remove_len = pNewFolder->m_iEntityOffset;

						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;

						std::string path_for_filename = final_name;
						std::string sScriptName = "";
						sScriptName = "particlesbank\\";
						sScriptName = sScriptName + path_for_filename.c_str();
						if (path_for_filename.length() == 0)
							sScriptName = sScriptName + selectedmediafile->m_sName.Get();
						else
							sScriptName = sScriptName + "\\" + selectedmediafile->m_sName.Get();
						if (sScriptName != "")
						{
							sSelectedLibrarySting = sScriptName.c_str();
							iSelectedLibraryStingReturnID = iLibraryStingReturnToID;
						}
						bCheckForClosing = true;
						bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.

						selectedmediafile = NULL;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add Selected Particles");
				}
				
			}
		}
		else
		{
			if (iDisplayLibrarySubType == 0)
			{
				if (ImGui::StyleButton("Get More Objects", ImVec2(fButWidth, fFontSize*2.0)))
				{
					DeleteWaypointsAddedToCurrentCursor();
					CloseDownEditorProperties();
					bMarketplace_Window = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Get More Objects from the Marketplace");

				ImGui::SameLine();
				if (ImGui::StyleButton("Import 3D Model", ImVec2(fButWidth, fFontSize*2.0)))
				{
					// copied from marketplace import
					DeleteWaypointsAddedToCurrentCursor();
					CloseDownEditorProperties();
					CloseAllOpenTools();
					iLaunchAfterSync = 8; //Import model
					iSkibFramesBeforeLaunch = 5;
					bMarketplace_Window = false;
					bTriggerCloseEntityWindow = true;
					bCheckForClosingForce = true; //Force window to close.
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Import 3D Model in the OBJ, FBX, GLTF or DBO format");

				ImGui::SameLine();
				if (ImGui::StyleButton("Character Creator", ImVec2(fButWidth, fFontSize*2.0)))
				{
					DeleteWaypointsAddedToCurrentCursor();
					//CheckTooltipObjectDelete();
					CloseDownEditorProperties();
					CloseAllOpenTools();

					//g_bCharacterCreatorPlusActivated = true;
					iLaunchAfterSync = 82; //Start Character Creator
					iSkibFramesBeforeLaunch = 2;
					strcpy(cTriggerMessage, "Loading Character Creator");
					bTriggerMessage = true;

					bCheckForClosing = true;
					bEnableWeather = false;
				}

				if (lf_multi_selections_count > 0)
				{
					ImGui::SameLine();
					std::string insert_text;
					//Display insert button.
					insert_text = " Add ";
					insert_text += std::to_string(lf_multi_selections_count);
					insert_text += " Objects to Level ";
					if (ImGui::StyleButton(insert_text.c_str(), ImVec2(fButWidth, fFontSize*2.0)))
					{
						//Insert all selected items.
						bAddNewSelectionToGame = true;
						iAddSelectionStep = 0;
					}
				}
			}
		}
		ImGui::SetWindowFontScale(1.0);

		ImGui::Indent(-10);
#ifdef DYNAMICLOADUNLOAD
		max_load_persync = 10; // 15 to slow try 10
#endif
		lf_multi_selections_count = multi_selections_count; //Use last frames count.

		if (!bImagesStillInImGuiQueue && !bLargePreview && bAddNewSelectionToGame)
		{
			extern cstr g_sTempGroupForThumbnail;
			if (g_sTempGroupForThumbnail.Len() > 0 )
			{
				//hmm
				//extern int GetGroupIndexFromName (cstr sLookFor);
				//current_selected_group = GetGroupIndexFromName(g_sTempGroupForThumbnail);
				g_sTempGroupForThumbnail = "";
			}

			DeleteWaypointsAddedToCurrentCursor();
			CloseDownEditorProperties();

			//Remove any selections.
			t.inputsys.constructselection = 0;
			if (t.gridentityobj > 0)
			{
				DeleteObject(t.gridentityobj);
				t.gridentityobj = 0;
			}

			//PE: Make sure we free all not used textures-objects before adding new objects.
			FreeTempImageList();

			t.refreshgrideditcursor = 1;
			t.gridentity = 0;
			t.gridentityposoffground = 0;
			t.gridentityusingsoftauto = 0;
			editor_refresheditmarkers();

			cFolderItem *pSearchFolder = &MainEntityList;
			pSearchFolder = pSearchFolder->m_pNext;
			cStr path_remove;
			int ipath_remove_len;
			if (pSearchFolder) {
				path_remove = pSearchFolder->m_sFolderFullPath.Get();
				ipath_remove_len = path_remove.Len();
			}

			bool bOneFound = false;

			iAddSelectionStep++;
			while(pSearchFolder)
			{
				cStr path = pSearchFolder->m_sFolderFullPath.Get();
				bool bDoubleEntityBank = false;
				char *finde = (char *)pestrcasestr(path.Get(), "\\entitybank"); //Support entitybank inside entitybank.
				if (finde)
				{
					finde += 11;
					finde = (char *)pestrcasestr(finde, "\\entitybank");
					if (finde) bDoubleEntityBank = true;
				}
				if (!bDoubleEntityBank && path.Right(11) == "\\entitybank") {
					ipath_remove_len = path.Len();
				}
				else
				{
					if (pSearchFolder->m_pFirstFile) {

						cFolderItem::sFolderFiles * searchfiles = pSearchFolder->m_pFirstFile->m_pNext;
						while (searchfiles)
						{
							if (searchfiles->iFlags == 1)
							{
								bOneFound = true;
								if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
								if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
								if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;

								//Insert.
								cStr path = pSearchFolder->m_sFolderFullPath.Get();
								char *final_name = path.Get();
								final_name += ipath_remove_len;
								if (*final_name == '\\')
									final_name++;
								std::string path_for_filename = final_name;

								std::string sFpeName = path_for_filename.c_str();
								sFpeName = sFpeName + "\\" + searchfiles->m_sName.Get();
								#ifdef WICKEDENGINE
								iLastEntityOnCursor = 0;
								#endif

								char adding[256];
								strcpy(adding, searchfiles->m_sName.Get());
								if (strlen(adding) > 4)
									adding[strlen(adding) - 4] = 0;
								
								iMessageTimer = 0; //Restart fading.
								sprintf(cTriggerMessage, "Adding \"%s\" to Level", adding);
								bTriggerMessage = true;

								t.addentityfile_s = sFpeName.c_str();
								if (t.addentityfile_s != "")
								{
									entity_adduniqueentity(false);
									t.tasset = t.entid;
									if (t.talreadyloaded == 0)
									{
										editor_filllibrary();
									}
								}

								searchfiles->iFlags = 0;
							}
							if (bOneFound) break;
							searchfiles = searchfiles->m_pNext;
						}
					}
				}
				if (bOneFound) break;
				pSearchFolder = pSearchFolder->m_pNext;
			}
			if (iAddSelectionStep > 0 && !bOneFound)
			{
				bCheckForClosing = true;
				bAddNewSelectionToGame = false;
				iAddSelectionStep = 0;
			}
		}

		bool bAreWeOverLapping = false;
		if (!bIsWeDocked) 
		{
			//If we are over the rendertarget hide window.
			float itmptopmousex = ImGui::GetWindowPos().x;
			float itmptopmousey = ImGui::GetWindowPos().y;
			int iSecureZone = 4;

			if (bImGuiRenderTargetFocus && itmptopmousex >= (renderTargetAreaPos.x + iSecureZone) && itmptopmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmptopmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmptopmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
			float itmpmousex = ImGui::GetWindowPos().x + ImGui::GetWindowSize().x;
			float itmpmousey = ImGui::GetWindowPos().y + ImGui::GetWindowSize().y;
			if (bExternal_Entities_Window && bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x + iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmptopmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmptopmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
			itmpmousex = ImGui::GetWindowPos().x + ImGui::GetWindowSize().x;
			itmpmousey = ImGui::GetWindowPos().y;
			if (bExternal_Entities_Window && bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x + iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmpmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmpmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
			itmpmousex = ImGui::GetWindowPos().x;
			itmpmousey = ImGui::GetWindowPos().y + ImGui::GetWindowSize().y;
			if (bExternal_Entities_Window && bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x + iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmpmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmpmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
		}
		if (!bIsWeDocked && bCheckForClosing) {
			if (bAreWeOverLapping || bCheckForClosingForce)
			{
				bExternal_Entities_Window = false;
			}
		}

		//Remove window on right click if we are overlapping.
		if (bAreWeOverLapping && t.inputsys.mclick == 2)
			bExternal_Entities_Window = false;

		bCheckForClosingForce = false;
		bCheckForClosing = false;

		CheckMinimumDockSpaceSize(250.0f);

		//Render titlebar centered.
		cstr title = "Object Library - What do you want to add to your level?";
		cstr titlesmall = "Object Library";
		if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1)
		{
			title = "Animation Library - What do you want to add to your object?";
			titlesmall = "Animation Library";
		}
		if (iDisplayLibraryType > 0)
		{
			if (iDisplayLibraryType == 1)
			{
				title = "Music and Sound Library - What do you want to add to your level?";
				titlesmall = "Music and Sound Library";
			}
			if (iDisplayLibraryType == 2)
			{
				title = "Image Library - What do you want to add to your level?";
				titlesmall = "Image Library";
			}
			if (iDisplayLibraryType == 3)
			{
				title = "Video Library - What do you want to add to your level?";
				titlesmall = "Video Library";
			}
			if (iDisplayLibraryType == 4)
			{
				title = "Behavior Library - What do you want to add to your level?";
				titlesmall = "Behavior Library";
			}
			if (iDisplayLibraryType == 5)
			{
				title = "Particle Library - What do you want to add to your level?";
				titlesmall = "Particle Library";
			}
		}
		float fTextSize = ImGui::CalcTextSize(title.Get()).x;
		if (ImGui::GetWindowSize().x < fTextSize)
		{
			title = titlesmall;
			fTextSize = ImGui::CalcTextSize(title.Get()).x;
			if (ImGui::GetWindowSize().x < fTextSize)
			{
				title = "";
				fTextSize = 0.0f;
			}
		}
		float xcenter = (ImGui::GetWindowSize().x*0.5) - (fTextSize*0.5);
		ImVec2 titlebar_pos = ImGui::GetWindowPos() + ImVec2(xcenter, 4);
		ImGuiWindow* window = ImGui::GetCurrentWindow();

		if (imgui_AddMinMaxButton(0, false))
		{
			//Record where to scroll to after a window resize.
			if (firstvisiblefile)
			{
				scrolltofile = firstvisiblefile;
				bScrollInNextFrame = true;
			}
		}

		//ImGui::Columns(1);
		ImGui::EndColumns();

		ImGui::End();

		//Render title bar after End. end fill titlebar.
		ImGuiContext& g = *GImGui;
		window->DrawList->AddText(g.Font, g.FontSize, titlebar_pos, ImGui::GetColorU32(ImGuiCol_Text), title.Get());

	}
	else 
	{
		/*if (g_bPreviewLighting)
		{
			restore_visuals(t.visuals, t.visualsStorage);
			restore_visuals(t.editorvisuals, t.visualsStorage);
			g_bPreviewLighting = false;
			Wicked_Update_Visuals(&t.editorvisuals);
		}*/

		//Window closed.
		FreeTempImageList();
		if (iVideoThumbID > 0 && AnimationExist(iVideoThumbID))
		{
			iStopVideoInNextFrame = iVideoThumbID;
			iVideoThumbID = 0;
		}
		// free any temp groups created for Smart Object previews
		extern cstr g_sTempGroupForThumbnail;
		if(g_sTempGroupForThumbnail.Len()>0 )
		{
			int store_current_selected_group = current_selected_group;
			extern int GetGroupIndexFromName (cstr sLookFor);
			current_selected_group = GetGroupIndexFromName(g_sTempGroupForThumbnail);
			UnGroupSelected(true);
			gridedit_deleteentityrubberbandfrommap();
			gridedit_clearentityrubberbandlist();
			g_sTempGroupForThumbnail = "";
			if (store_current_selected_group != -1 )
				g.entityrubberbandlist = vEntityGroupList[store_current_selected_group];
		}
	}

	static bool bExternal_Entities_Window_Last = false;
	if (bExternal_Entities_Window != bExternal_Entities_Window_Last)
	{
		//PE: Rick was so fast he could click one object and start a rotate on another thumb in the same loop, this fix it :)
		bExternal_Entities_Window_Last = bExternal_Entities_Window;
		if (!bExternal_Entities_Window)
		{
			//PE: If just closed, disable any thumb grab.
			bLoopBackBuffer = false;
			BackBufferImageID = 0;
		}
	}

	if (sGotoPreviewWithFile != "")
	{
		if (!bLargePreview && bCheckGotoPreview)
		{
			//We failed to find the char, cancel request.
			sGotoPreviewWithFile = "";
		}
	}
}


#define MINMAX_WINDOWS 10
ImRect rRetoreWindowSize[MINMAX_WINDOWS];
bool rMinMaxState[MINMAX_WINDOWS];
bool rMinMaxTrigger[MINMAX_WINDOWS];
bool rMinMaxInit[MINMAX_WINDOWS] = { false,false,false,false,false,false,false,false,false,false };
bool bMinMaxGlobalInit = false;
bool imgui_GetMinMaxButtonState(int win) { return rMinMaxState[win]; }
bool imgui_CheckMinMaxStartupState(int win)
{
	ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
	ImVec2 viewPortSize = ImGui::GetMainViewport()->Size * 0.95;
	ImVec2 vCurSize = ImGui::GetWindowSize();
	if (vCurSize.x >= viewPortSize.x && vCurSize.y >= viewPortSize.y)
	{
		//bResetObjectLibrarySize = true;
		//PE: Instead of resetting window to default , set it as maximized.
		rMinMaxState[win] = true;
		//ImGui::SetNextWindowSize(ImVec2(66 * ImGui::GetFontSize(), (43 * ImGui::GetFontSize()) + 19.0), ImGuiCond_Always); //ImGuiCond_FirstUseEver
		ImVec2 vSize = ImVec2(66 * ImGui::GetFontSize(), (43 * ImGui::GetFontSize()) + 19.0);
		ImVec2 vCenter = viewPortPos + (ImGui::GetMainViewport()->Size*0.5);
		vCenter -= vSize * 0.5;
		rRetoreWindowSize[win].Min = vCenter;
		rRetoreWindowSize[win].Max = vSize;
		return true;
	}
	return false;
}

bool imgui_AddMinMaxButton(int win, bool bRestore)
{
	bool bRet = false;
	if (win >= MINMAX_WINDOWS || win < 0) return bRet;

	if (!bMinMaxGlobalInit)
	{
		for (int i = 0;i < MINMAX_WINDOWS; i++)
		{
			rMinMaxInit[i] = false;
		}
		bMinMaxGlobalInit = true;
	}
	if (!rMinMaxInit[win])
	{
		rRetoreWindowSize[win].Min = ImGui::GetWindowPos();
		rRetoreWindowSize[win].Max = ImGui::GetWindowSize();
		rMinMaxState[win] = false;
		rMinMaxTrigger[win] = false;
		rMinMaxInit[win] = true;
	}

	if (!bRestore)
	{
		//Display buttons.
		ImRect avail_window_rect;
		avail_window_rect.Min = ImGui::GetWindowPos();
		avail_window_rect.Max = ImGui::GetWindowPos() + ImGui::GetWindowSize();
		//avail_window_rect.Min.y -= 15.0f;
		#define USEARROWBUTTON
		ImGui::PushClipRect(avail_window_rect.Min, avail_window_rect.Max, false);
		#ifdef USEARROWBUTTON
			ImVec2 vMinMaxButton = ImVec2(ImGui::GetWindowSize().x - 38.0f, 4.0);
		#else
			ImVec2 vMinMaxButton = ImVec2(ImGui::GetWindowSize().x - 44.0f, -2.0);
		#endif
		ImGui::SetCursorPos(vMinMaxButton);
		ImGui::SetItemAllowOverlap();
		int iIcon = MEDIA_MINIMIZE;
		int iDirection = ImGuiDir_Down;
		if (rMinMaxState[win] == false) {
			iIcon = MEDIA_MAXIMIZE;
			iDirection = ImGuiDir_Up;
		}

		ImVec4 col = ImGui::GetStyleColorVec4(ImGuiCol_Text);
		ImU32 text_col = ImGui::GetColorU32(ImGuiCol_Text);

		#ifdef USEARROWBUTTON
		auto *style = &ImGui::GetStyle();
		float ioldframe = style->FrameBorderSize;
		ImVec2 oldpadding = style->FramePadding;
		style->FrameBorderSize = 0.0f;
		style->FramePadding.x = 0;
		style->FramePadding.y = 0;
		if (ImGui::MinMaxButtonEx("##minmaxSelection", iDirection))
		#else
		if (ImGui::ImgBtn(iIcon, ImVec2(20, 20), ImColor(255, 255, 255, 0), ImColor(255, 255, 255, 255), drawCol_hover, drawCol_Down, -1, 0, 0, 0, true, false, false, false, false, bBoostIconColors))
		#endif
		{
			if (rMinMaxState[win] == false)
				rMinMaxState[win] = true;
			else
				rMinMaxState[win] = false;
			rMinMaxTrigger[win] = true;
			if (rMinMaxState[win])
			{
				//Update size pos with current windows settings.
				rRetoreWindowSize[win].Min = ImGui::GetWindowPos();
				rRetoreWindowSize[win].Max = ImGui::GetWindowSize();
			}
			bRet = true;
		}
		#ifdef USEARROWBUTTON
		style->FramePadding = oldpadding;
		style->FrameBorderSize = ioldframe;
		#endif
		ImGui::PopClipRect();
	}
	else
	{
		if (rMinMaxTrigger[win])
		{
			if (rMinMaxState[win])
			{
				//Set max size, but keep old size.
				ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
				ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;
				ImGui::SetNextWindowPos(viewPortPos, ImGuiCond_Always);
				ImGui::SetNextWindowSize(viewPortSize, ImGuiCond_Always); //full screen.
			}
			else
			{
				//Restore old settings.
				ImGui::SetNextWindowPos(rRetoreWindowSize[win].Min, ImGuiCond_Always);
				ImGui::SetNextWindowSize(rRetoreWindowSize[win].Max, ImGuiCond_Always);
			}
			rMinMaxTrigger[win] = false;
		}
	}
	return bRet;
}

void FreeTempImageList(void)
{
	if (g_TempimageList.size() > 0)
	{
		//t.entid = 0 ; is used for automated generating of thumbs, so delete this.
		if (ObjectExist(g.entitybankoffset)) 
		{
			DeleteObject(g.entitybankoffset);
		}
		if (iRestoreEntidMaster >= 0 && g.entidmaster > iRestoreEntidMaster)
		{
			//PE: Free loaded objects
			for (int i = iRestoreEntidMaster;i < g.entidmaster; i++)
			{
				int iEntId = i + 1;
				cstr sFree = t.entitybank_s[iEntId];
				if (ObjectExist(g.entitybankoffset + iEntId)) 
				{
					//PE: We use a before/after list to free all used textures later.
					DeleteObject(g.entitybankoffset + iEntId);
				}
			}
		}

		// restore g.entidmaster
		if (iRestoreEntidMaster >= 0)
		{
			g.entidmaster = iRestoreEntidMaster;
		}
		iRestoreEntidMaster = -1;

		//PE: TODO check legacy loaded images is part of g_imageList, should not be a problem as they are not actually inside wicked, check anyway.

		//PE: Compare the lists and check if we need to delete any textures.
		for (int i = 0; i < g_imageList.size(); i++)
		{
			sImageList* pImage = NULL;
			if (i >= g_TempimageList.size())
			{
				pImage = &g_imageList[i];
			}
			else
			{
				if (g_imageList[i].image != g_TempimageList[i].image)
				{
					pImage = &g_imageList[i];
				}
			}
			if (pImage)
			{
				// free texture
				WickedCall_FreeImage(pImage);
			}
		}

		// clear temp image list
		g_TempimageList.clear();
	}
}

bool DeleteEntityFromLists(int e)
{
	bool bFound = false;
	for (int l = 0; l < MAXGROUPSLISTS; l++)
	{
		if (vEntityGroupList[l].size() > 0)
		{

			for (int i = 0; i < vEntityGroupList[l].size(); i++)
			{
				if (e == vEntityGroupList[l][i].e)
				{
					vEntityGroupList[l].erase(vEntityGroupList[l].begin() + i);
					bFound = true;
					break;
				}
			}
		}
		if(bFound)
			break;
	}
	if (!bFound)
	{
		for (int i = 0; i < vEntityLockedList.size(); i++)
		{
			if (e == vEntityLockedList[i].e)
			{
				vEntityLockedList.erase(vEntityLockedList.begin() + i);
				bFound = true;
				break;
			}
		}
	}
	//Recursive as list's is changing.
	if (bFound)
		DeleteEntityFromLists(e);
	return(bFound);
}


void AddGroupListToRubberBand(int l)
{
	bool bFound = false;
	if (g.entityrubberbandlist.size() <= 0) {
		g.entityrubberbandlist = vEntityGroupList[l];
		return;
	}

	if (vEntityGroupList[l].size() > 0)
	{
		for (int i = 0; i < vEntityGroupList[l].size(); i++)
		{
			int e = vEntityGroupList[l][i].e;
			bool found = false;
			for (int l = 0; l < g.entityrubberbandlist.size(); l++)
			{
				if (g.entityrubberbandlist[l].e == e) {
					found = true;
				}
			}
			if (!found)
			{
				sRubberBandType rubberbandItem;
				rubberbandItem.e = e;
				rubberbandItem.x = t.entityelement[e].x;
				rubberbandItem.y = t.entityelement[e].y;
				rubberbandItem.z = t.entityelement[e].z;
				#ifdef WICKEDENGINE
				rubberbandItem.px = t.entityelement[e].x;
				rubberbandItem.py = t.entityelement[e].y;
				rubberbandItem.pz = t.entityelement[e].z;
				rubberbandItem.rx = t.entityelement[e].rx;
				rubberbandItem.ry = t.entityelement[e].ry;
				rubberbandItem.rz = t.entityelement[e].rz;			
				rubberbandItem.quatmode = t.entityelement[e].quatmode;
				rubberbandItem.quatx = t.entityelement[e].quatx;
				rubberbandItem.quaty = t.entityelement[e].quaty;
				rubberbandItem.quatz = t.entityelement[e].quatz;
				rubberbandItem.quatw = t.entityelement[e].quatw;
				rubberbandItem.scalex = t.entityelement[e].scalex;
				rubberbandItem.scaley = t.entityelement[e].scaley;
				rubberbandItem.scalez = t.entityelement[e].scalez;
				#endif
				g.entityrubberbandlist.push_back(rubberbandItem);
			}
		}
	}
	return;
}

void CheckGroupListForRubberbandSelections(int entityindex)
{

	int grouplist = isEntityInGroupList(entityindex);
	if (grouplist >= 0)
	{
		//Check all objects in the current rubberband if they belong to a group.
		for (int i = 0; i < g.entityrubberbandlist.size(); i++)
		{
			int e = g.entityrubberbandlist[i].e;
			if (e > 0)
			{
				int group = isEntityInGroupList(e, grouplist);
				if (group >= 0)
					AddGroupListToRubberBand(group);
			}
		}

		//PE: We must add to current rubberband.
		AddGroupListToRubberBand(grouplist);
	}
	
	//Scan entityindex in all groups.
	for (int l = 0; l < MAXGROUPSLISTS; l++)
	{
		if (l != grouplist)
		{
			int group = isEntityInGroupListDirect(entityindex, l);
			if (group >= 0) {
				AddGroupListToRubberBand(group);
			}
		}
	}

	//Recheck new rubberband if any new entity is in other lists.
	for (int i = 0; i < g.entityrubberbandlist.size(); i++)
	{
		int e = g.entityrubberbandlist[i].e;
		if (e > 0)
		{
			//Check all groups.
			for (int l = 0; l < MAXGROUPSLISTS; l++)
			{
				int group = isEntityInGroupListDirect(e, l);
				if (group >= 0) {
					AddGroupListToRubberBand(group);
				}
			}
		}
	}
}

void ClearAllGroupLists(void)
{
	for (int l = 0; l < MAXGROUPSLISTS; l++)
	{
		sEntityGroupListName[l] = "";
		vEntityGroupList[l].clear();
		iEntityGroupListImage[l] = 0;
	}
	for (int i = 0; i < vEntityLockedList.size(); i++)
	{
		int e = vEntityLockedList[i].e;
		t.entityelement[e].editorlock = 0;
		sObject* pObject;
		if (t.entityelement[e].obj > 0) {
			pObject = g_ObjectList[t.entityelement[e].obj];
			if (pObject) {
				WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
			}
		}
	}
	vEntityLockedList.clear();
	g.entityrubberbandlist.clear();
}


void ReplaceEntityInGroupList(int e, int eto)
{
	for (int l = 0; l < MAXGROUPSLISTS; l++)
	{
		if (vEntityGroupList[l].size() > 0)
		{

			for (int i = 0; i < vEntityGroupList[l].size(); i++)
			{
				if (e == vEntityGroupList[l][i].e)
				{
					vEntityGroupList[l][i].e = eto;
				}
			}
		}
	}
}

int isEntityInGroupList(int e,int ignoregroup)
{
	bool bFound = false;
	for (int l = 0; l < MAXGROUPSLISTS; l++)
	{
		if (!(ignoregroup >= 0 && ignoregroup == l))
		{
			if (vEntityGroupList[l].size() > 0)
			{
				for (int i = 0; i < vEntityGroupList[l].size(); i++)
				{
					if (e == vEntityGroupList[l][i].e)
					{
						//found return list.
						return(l);
					}
				}
			}
		}
	}
	return(-1);
}

int isEntityInGroupListDirect(int e, int group)
{
	if (vEntityGroupList[group].size() > 0)
	{
		for (int i = 0; i < vEntityGroupList[group].size(); i++)
		{
			if (e == vEntityGroupList[group][i].e)
			{
				//found return list.
				return(group);
			}
		}
	}

	return(-1);
}

#ifdef WICKEDENGINE
void DuplicateLogicConnections (std::vector<sRubberBandType> vEntityDuplicateList )
{
	// have 'vEntityDuplicateList' which is the original and g.entityrubberbandlist which is the duplicated copy
	// just copied logic connections into t.grideleprof
	// so duplicate them for the newly duplicated
	bool bDuplicateLogic = true;
	if (bDuplicateLogic == true)
	{
		// generate new LinkIDs in duplicate
		for (int listindex = 0; listindex < (int)vEntityDuplicateList.size(); listindex++)
		{
			// original and duplicate
			int iOriginalE = vEntityDuplicateList[listindex].e;
			if (t.entityelement[iOriginalE].eleprof.iObjectLinkID != 0)
			{
				int iDuplicateE = g.entityrubberbandlist[listindex].e;
				t.entityelement[iDuplicateE].eleprof.iObjectLinkID = GenerateRelationshipUniqueLinkID();
			}
		}

		// scan old data, find old LinkIDs and replace with new ones
		int iListsSize = (int)vEntityDuplicateList.size();
		for (int listindex = 0; listindex < iListsSize; listindex++)
		{
			// original and duplicate
			int iOriginalE = vEntityDuplicateList[listindex].e;
			int iDuplicateE = g.entityrubberbandlist[listindex].e;

			// for each entity relationships, assign new LinkIDs
			for (int i = 0; i < 10; i++)
			{
				int iRelationshipLinkID = t.entityelement[iOriginalE].eleprof.iObjectRelationships[i];
				if (iRelationshipLinkID != 0)
				{
					// look for the link in the list of original entities
					int newLinkID = 0;
					for (int searchlist = 0; searchlist < iListsSize; searchlist++)
					{
						int iSearchOriginalE = vEntityDuplicateList[searchlist].e;
						int iSearchOriginalLinkID = t.entityelement[iSearchOriginalE].eleprof.iObjectLinkID;
						if (iSearchOriginalLinkID == iRelationshipLinkID)
						{
							int iFoundInDuplicateE = g.entityrubberbandlist[searchlist].e;
							newLinkID = t.entityelement[iFoundInDuplicateE].eleprof.iObjectLinkID;
							break;
						}
					}

					// link to new LinkID for this relationship connection
					t.entityelement[iDuplicateE].eleprof.iObjectRelationships[i] = newLinkID;
				}
			}
		}
	}
	else
	{
		// clear all logic connections
		t.grideleprof.iObjectLinkID = 0;
		for (int i = 0; i < 10; i++)
		{
			t.grideleprof.iObjectRelationships[i] = 0;
			t.grideleprof.iObjectRelationshipsData[i] = 0;
			t.grideleprof.iObjectRelationshipsType[i] = 0;
		}
	}
}
#endif

void DuplicateFromList(std::vector<sRubberBandType> vEntityDuplicateList)
{
	//Dublicate all from a list.
	if (vEntityDuplicateList.size() > 0)
	{
		// a small offset so user can see new pasted entity
		float fShiftOffsetForPasteX = 50.0f + rand() % 50;
		float fShiftOffsetForPasteZ = 50.0f + rand() % 50;
		if (rand() % 2 == 0) fShiftOffsetForPasteX = -fShiftOffsetForPasteX;
		if (rand() % 2 == 0) fShiftOffsetForPasteZ = -fShiftOffsetForPasteZ;

		int iAnchorEntityIndex = -1;

		// we are also going to move rubber band selection to new pasted group
		g.entityrubberbandlist.clear();

		// for each entity, create a duplicate and offset slightly so we can see it
		for (int i = 0; i < (int)vEntityDuplicateList.size(); i++)
		{
			// duplicate new entity as clone of relevant original clipboard entity
			int e = vEntityDuplicateList[i].e;
			t.gridentity = t.entityelement[e].bankindex;
			#ifdef WICKEDENGINE
			//PE: all t.gridentity... need to be set for this to work correctly.
			t.entid = t.gridentity;
			entity_fillgrideleproffromprofile();  // t.entid
			t.gridentityposx_f = t.entityelement[e].x;
			t.gridentityposy_f = t.entityelement[e].y;
			t.gridentityposz_f = t.entityelement[e].z;
			t.gridentityrotatex_f = t.entityelement[e].rx;
			t.gridentityrotatey_f = t.entityelement[e].ry;
			t.gridentityrotatez_f = t.entityelement[e].rz;
			t.gridentityrotatequatmode = t.entityelement[e].quatmode;
			t.gridentityrotatequatx_f = t.entityelement[e].quatx;
			t.gridentityrotatequaty_f = t.entityelement[e].quaty;
			t.gridentityrotatequatz_f = t.entityelement[e].quatz;
			t.gridentityrotatequatw_f = t.entityelement[e].quatw;
			if (t.entityprofile[t.gridentity].ismarker == 10)
			{
				t.gridentityscalex_f = 100.0f + t.entityelement[e].scalex;
				t.gridentityscaley_f = 100.0f + t.entityelement[e].scaley;
				t.gridentityscalez_f = 100.0f + t.entityelement[e].scalez;
			}
			else
			{
				t.gridentityscalex_f = ObjectScaleX(t.entityelement[e].obj);
				t.gridentityscaley_f = ObjectScaleY(t.entityelement[e].obj);
				t.gridentityscalez_f = ObjectScaleZ(t.entityelement[e].obj);
			}
			// this seems to wipe out what "entity_fillgrideleproffromprofile" did!
			t.grideleprof = t.entityelement[e].eleprof;
			entity_cleargrideleprofrelationshipdata();
			#endif

			#ifdef WICKEDENGINE
			//PE: InstanceObject - Cursor,Object Tools - objects must always be real clones.
			extern bool bNextObjectMustBeClone;
			bNextObjectMustBeClone = true;
			#endif

			gridedit_addentitytomap();

			#ifdef WICKEDENGINE
			bNextObjectMustBeClone = false;
			#endif

			if (iAnchorEntityIndex == -1) iAnchorEntityIndex = t.e;
			t.entityelement[t.e].x = t.entityelement[e].x + fShiftOffsetForPasteX;
			t.entityelement[t.e].y = t.entityelement[e].y;
			t.entityelement[t.e].z = t.entityelement[e].z + fShiftOffsetForPasteZ;
			t.entityelement[t.e].rx = t.entityelement[e].rx;
			t.entityelement[t.e].ry = t.entityelement[e].ry;
			t.entityelement[t.e].rz = t.entityelement[e].rz;
			t.entityelement[t.e].quatmode = t.entityelement[e].quatmode;
			t.entityelement[t.e].quatx = t.entityelement[e].quatx;
			t.entityelement[t.e].quaty = t.entityelement[e].quaty;
			t.entityelement[t.e].quatz = t.entityelement[e].quatz;
			t.entityelement[t.e].quatw = t.entityelement[e].quatw;
			t.entityelement[t.e].editorfixed = t.entityelement[e].editorfixed;
			t.entityelement[t.e].staticflag = t.entityelement[e].staticflag;
			t.entityelement[t.e].scalex = t.entityelement[e].scalex;
			t.entityelement[t.e].scaley = t.entityelement[e].scaley;
			t.entityelement[t.e].scalez = t.entityelement[e].scalez;
			t.entityelement[t.e].soundset = t.entityelement[e].soundset;
			t.entityelement[t.e].soundset1 = t.entityelement[e].soundset1;
			t.entityelement[t.e].soundset2 = t.entityelement[e].soundset2;
			t.entityelement[t.e].soundset3 = t.entityelement[e].soundset3;
			t.entityelement[t.e].soundset4 = t.entityelement[e].soundset4;
			#ifdef WICKEDENGINE
			t.entityelement[t.e].soundset5 = t.entityelement[e].soundset5;
			t.entityelement[t.e].soundset6 = t.entityelement[e].soundset6;
			#endif
			t.entityelement[t.e].eleprof = t.entityelement[e].eleprof;
			PositionObject(t.entityelement[t.e].obj, t.entityelement[t.e].x, t.entityelement[t.e].y, t.entityelement[t.e].z);
			RotateObject(t.entityelement[t.e].obj, t.entityelement[t.e].rx, t.entityelement[t.e].ry, t.entityelement[t.e].rz);

			// and add to new rubber band group
			sRubberBandType rubberbandItem;
			rubberbandItem.e = t.e;
			rubberbandItem.x = t.entityelement[t.e].x;
			rubberbandItem.y = t.entityelement[t.e].y;
			rubberbandItem.z = t.entityelement[t.e].z;
			#ifdef WICKEDENGINE
			rubberbandItem.px = t.entityelement[t.e].x;
			rubberbandItem.py = t.entityelement[t.e].y;
			rubberbandItem.pz = t.entityelement[t.e].z;
			rubberbandItem.rx = t.entityelement[t.e].rx;
			rubberbandItem.ry = t.entityelement[t.e].ry;
			rubberbandItem.rz = t.entityelement[t.e].rz;
			rubberbandItem.quatmode = t.entityelement[t.e].quatmode;
			rubberbandItem.quatx = t.entityelement[t.e].quatx;
			rubberbandItem.quaty = t.entityelement[t.e].quaty;
			rubberbandItem.quatz = t.entityelement[t.e].quatz;
			rubberbandItem.quatw = t.entityelement[t.e].quatw;
			rubberbandItem.scalex = t.entityelement[t.e].scalex;
			rubberbandItem.scaley = t.entityelement[t.e].scaley;
			rubberbandItem.scalez = t.entityelement[t.e].scalez;
			#endif
			g.entityrubberbandlist.push_back(rubberbandItem);
		}

		// clone all the logic connections
		DuplicateLogicConnections(vEntityDuplicateList);

		// switch widget to newly pasted entity so can instantly widget it about
		if (iAnchorEntityIndex != -1)
		{
			if (t.entityelement[iAnchorEntityIndex].editorlock == 0)
			{
				t.widget.pickedEntityIndex = iAnchorEntityIndex;
				t.widget.pickedObject = t.entityelement[iAnchorEntityIndex].obj;
			}
		}

		// ensure gridentity cleared after duplication
		t.gridentity = 0;
	}
}

int DuplicateFromListToCursor(std::vector<sRubberBandType> vEntityDuplicateList, bool bRandomShiftXZ)
{
	// anchor to a single object for dragging
	int iAnchorEntityIndex = -1;

	// Dublicate all from a list.
	if (vEntityDuplicateList.size() > 0)
	{
		// a small offset so user can see new pasted entity
		float fShiftOffsetForPasteX = 0.0f;
		float fShiftOffsetForPasteZ = 0.0f;
		if (bRandomShiftXZ == true)
		{
			fShiftOffsetForPasteX = 50.0f + rand() % 50;
			fShiftOffsetForPasteZ = 50.0f + rand() % 50;
			if (rand() % 2 == 0) fShiftOffsetForPasteX = -fShiftOffsetForPasteX;
			if (rand() % 2 == 0) fShiftOffsetForPasteZ = -fShiftOffsetForPasteZ;
		}

		// we are also going to move rubber band selection to new pasted group
		g.entityrubberbandlist.clear();

		float higesty = -999999.0f, lowesty = 999999.0;
		// for each entity, create a duplicate and offset slightly so we can see it
		for (int i = 0; i < (int)vEntityDuplicateList.size(); i++)
		{
			// duplicate new entity as clone of relevant original clipboard entity
			int e = vEntityDuplicateList[i].e;
			bool bLowestFound = false;
			t.gridentity = t.entityelement[e].bankindex;
			#ifdef WICKEDENGINE
			//PE: all t.gridentity... need to be set for this to work correctly.
			t.entid = t.gridentity;
			entity_fillgrideleproffromprofile();  // t.entid
			t.gridentityposx_f = t.entityelement[e].x;
			t.gridentityposy_f = t.entityelement[e].y;
			if (higesty < t.gridentityposy_f) higesty = t.gridentityposy_f;
			if (lowesty > t.gridentityposy_f)
			{
				lowesty = t.gridentityposy_f;
				bLowestFound = true;
			}
			t.gridentityposz_f = t.entityelement[e].z;
			t.gridentityrotatex_f = t.entityelement[e].rx;
			t.gridentityrotatey_f = t.entityelement[e].ry;
			t.gridentityrotatez_f = t.entityelement[e].rz;
			t.gridentityrotatequatmode = t.entityelement[e].quatmode;
			t.gridentityrotatequatx_f = t.entityelement[e].quatx;
			t.gridentityrotatequaty_f = t.entityelement[e].quaty;
			t.gridentityrotatequatz_f = t.entityelement[e].quatz;
			t.gridentityrotatequatw_f = t.entityelement[e].quatw;
			if (t.entityprofile[t.gridentity].ismarker == 10)
			{
				t.gridentityscalex_f = 100.0f + t.entityelement[e].scalex;
				t.gridentityscaley_f = 100.0f + t.entityelement[e].scaley;
				t.gridentityscalez_f = 100.0f + t.entityelement[e].scalez;
			}
			else
			{
				t.gridentityscalex_f = ObjectScaleX(t.entityelement[e].obj);
				t.gridentityscaley_f = ObjectScaleY(t.entityelement[e].obj);
				t.gridentityscalez_f = ObjectScaleZ(t.entityelement[e].obj);
			}
			// this seems to wipe out what "entity_fillgrideleproffromprofile" did!
			t.grideleprof = t.entityelement[e].eleprof;
			entity_cleargrideleprofrelationshipdata();
			#endif

			// add object to the level
			#ifdef WICKEDENGINE
			//PE: InstanceObject - Cursor,Object Tools - objects must always be real clones.
			extern bool bNextObjectMustBeClone;
			bNextObjectMustBeClone = true;
			#endif

			gridedit_addentitytomap();

			#ifdef WICKEDENGINE
			bNextObjectMustBeClone = false;
			#endif

			//PE: Always use the lowest Y object in list.
			if (iAnchorEntityIndex == -1 || bLowestFound ) iAnchorEntityIndex = t.e;
			t.entityelement[t.e].x = t.entityelement[e].x + fShiftOffsetForPasteX;
			t.entityelement[t.e].y = t.entityelement[e].y;
			t.entityelement[t.e].z = t.entityelement[e].z + fShiftOffsetForPasteZ;
			t.entityelement[t.e].rx = t.entityelement[e].rx;
			t.entityelement[t.e].ry = t.entityelement[e].ry;
			t.entityelement[t.e].rz = t.entityelement[e].rz;
			t.entityelement[t.e].quatmode = t.entityelement[e].quatmode;
			t.entityelement[t.e].quatx = t.entityelement[e].quatx;
			t.entityelement[t.e].quaty = t.entityelement[e].quaty;
			t.entityelement[t.e].quatz = t.entityelement[e].quatz;
			t.entityelement[t.e].quatw = t.entityelement[e].quatw;
			t.entityelement[t.e].editorfixed = t.entityelement[e].editorfixed;
			t.entityelement[t.e].staticflag = t.entityelement[e].staticflag;
			t.entityelement[t.e].scalex = t.entityelement[e].scalex;
			t.entityelement[t.e].scaley = t.entityelement[e].scaley;
			t.entityelement[t.e].scalez = t.entityelement[e].scalez;
			t.entityelement[t.e].soundset = t.entityelement[e].soundset;
			t.entityelement[t.e].soundset1 = t.entityelement[e].soundset1;
			t.entityelement[t.e].soundset2 = t.entityelement[e].soundset2;
			t.entityelement[t.e].soundset3 = t.entityelement[e].soundset3;
			t.entityelement[t.e].soundset4 = t.entityelement[e].soundset4;
			#ifdef WICKEDENGINE
			t.entityelement[t.e].soundset5 = t.entityelement[e].soundset5;
			t.entityelement[t.e].soundset6 = t.entityelement[e].soundset6;
			#endif
			t.entityelement[t.e].eleprof = t.entityelement[e].eleprof;
			PositionObject(t.entityelement[t.e].obj, t.entityelement[t.e].x, t.entityelement[t.e].y, t.entityelement[t.e].z);
			RotateObject(t.entityelement[t.e].obj, t.entityelement[t.e].rx, t.entityelement[t.e].ry, t.entityelement[t.e].rz);

			// need to generate new particles
			if (t.entityprofile[t.gridentity].ismarker == 0)
			{
				entity_updateautoflatten(t.e);
			}
			if (t.entityprofile[t.gridentity].ismarker == 10)
			{
				t.entityelement[t.e].eleprof.newparticle.emitterid = -1;
				entity_updateparticleemitter(t.e);
			}

			// and add to new rubber band group
			sRubberBandType rubberbandItem;
			rubberbandItem.e = t.e;
			rubberbandItem.x = t.entityelement[t.e].x;
			rubberbandItem.y = t.entityelement[t.e].y;
			rubberbandItem.z = t.entityelement[t.e].z;
			#ifdef WICKEDENGINE
			rubberbandItem.px = t.entityelement[t.e].x;
			rubberbandItem.py = t.entityelement[t.e].y;
			rubberbandItem.pz = t.entityelement[t.e].z;
			rubberbandItem.rx = t.entityelement[t.e].rx;
			rubberbandItem.ry = t.entityelement[t.e].ry;
			rubberbandItem.rz = t.entityelement[t.e].rz;
			rubberbandItem.quatmode = t.entityelement[t.e].quatmode;
			rubberbandItem.quatx = t.entityelement[t.e].quatx;
			rubberbandItem.quaty = t.entityelement[t.e].quaty;
			rubberbandItem.quatz = t.entityelement[t.e].quatz;
			rubberbandItem.quatw = t.entityelement[t.e].quatw;
			rubberbandItem.scalex = t.entityelement[t.e].scalex;
			rubberbandItem.scaley = t.entityelement[t.e].scaley;
			rubberbandItem.scalez = t.entityelement[t.e].scalez;
			#endif
			g.entityrubberbandlist.push_back(rubberbandItem);
		}

		// clone all the logic connections
		DuplicateLogicConnections(vEntityDuplicateList);

		// Select and add first entity to cursor, along with the rubberband.
		if (iAnchorEntityIndex != -1)
		{
			//PE: Need to set scale from group settings. t.entityelement[iAnchorEntityIndex].scalex
			AddEntityToCursor(iAnchorEntityIndex, false);
			//Change to just place under cursor.
			t.inputsys.dragoffsetx_f = 0;
			t.inputsys.dragoffsety_f = 0;
			fHitPointX = 0;
			fHitPointY = HITPOINTYSTARTPOS;
			fHitPointZ = 0;
			fHitOffsetX = 0;
			fHitOffsetY = 0;
			fHitOffsetZ = 0;

			g_bHoldGridEntityPosWhenManaged = true;
			g_fHoldGridEntityPosX = t.gridentityposx_f;
			g_fHoldGridEntityPosY = t.gridentityposy_f;
			g_fHoldGridEntityPosZ = t.gridentityposz_f;

			/*LB: This caused complex groups dragged in when widget mode on to stick to left of screen (fHitOffsetY of zero allows inital dragging)
			//PE: Make sure cursor offset is set at bottom of selection list.
			float seletion_height = higesty - lowesty;
			if (seletion_height > 1.0f && seletion_height < 5000.0f)
			{
				fHitOffsetY = seletion_height;
			}
			*/

			//LB: should not change modes without users permission
			//PE: Always start in horizontal mode.
			//iObjectMoveMode = 0;
			//LB: When dragging in groups, need to be in smart mode to handle object placement on terrain/surface
			iObjectMoveMode = 2; // not happy to change users preference, need better solution for release
		}

		//LB: when duplicate, we create a child group spawned from the parent, use unique "iParentGroupID" to keep track of parent and children
		CreateNewGroup(vEntityDuplicateList[0].iGroupID);

		//LB: when duplicate, clear last selected so do not double highlight and mess up correct group selection list!
		iLastSelectedEntityGroup = -1;
		iLastSelectedEntity = -1;
	}
	return(iAnchorEntityIndex);
}

void ListGroupContextMenu(bool bPickedOnly, int iEntityId)
{
	int iEntid = t.widget.pickedEntityIndex;
	if (iEntityId > 0)
		iEntid = iEntityId;
	for (int l = 0; l < MAXGROUPSLISTS; l++)
	{
		if (vEntityGroupList[l].size() > 0 )
		{
			cstr sContextMenuString = cstr("Add to Group") + cstr(l + 1);
			if (ImGui::MenuItem(sContextMenuString.Get()))
			{
				if ( (g.entityrubberbandlist.size() > 0 && !bPickedOnly) || iEntid > 0)
				{
					int iLoop = 1;
					if (g.entityrubberbandlist.size() > 0 && !bPickedOnly)
						iLoop = g.entityrubberbandlist.size();
					for (int i = 0; i < (int)iLoop; i++)
					{
						int e = iEntid;
						if (g.entityrubberbandlist.size() > 0 && !bPickedOnly)
							e = g.entityrubberbandlist[i].e;
						bool bAlreadyThere = false;
						for (int il = 0; il < (int)vEntityGroupList[l].size(); il++)
						{
							if (e == vEntityGroupList[l][il].e)
							{
								bAlreadyThere = true;
								break;
							}
						}
						if (!bAlreadyThere)
						{
							sRubberBandType newItem;
							newItem.e = e;
							newItem.x = t.entityelement[e].x;
							newItem.y = t.entityelement[e].y;
							newItem.z = t.entityelement[e].z;
							vEntityGroupList[l].push_back(newItem);
						}
					}
					if (!bPickedOnly)
					{
						g.entityrubberbandlist.clear();
						widget_switchoff();
					}
				}
			}
		}
	}
}

int GetGroupIndexFromName (cstr sLookFor)
{
	int iParentGroupID = -1;
	for (int l = 0; l < MAXGROUPSLISTS; l++)
	{
		if (sEntityGroupListName[l].Len() > 0)
		{
			if (stricmp (sEntityGroupListName[l].Get(), sLookFor.Get()) == NULL)
			{
				iParentGroupID = l;
				break;
			}
		}
	}
	return iParentGroupID;
}

void UnGroupSelected(bool bRetainRubberBandList)
{
	//Ungroup to cursor and delete current group.
	if (current_selected_group >= 0)
	{
		entity_createundoaction(eUndoSys_Object_UnGroup, current_selected_group);
		g.entityrubberbandlist = vEntityGroupList[current_selected_group];
		//Set widget on first item in list.
		int e = g.entityrubberbandlist[0].e;
		if (e > 0)
		{
			if (t.entityelement[e].editorlock == 0)
			{
				t.widget.pickedEntityIndex = e;
				t.widget.pickedObject = t.entityelement[e].obj;
			}
		}
		vEntityGroupList[current_selected_group].clear();
		if (ImageExist(iEntityGroupListImage[current_selected_group]))
		{
			//Image is already on screen. so dont delete before its reused.
			//It will get the same id next time so we can do this.
			iEntityGroupListImage[current_selected_group] = 0;
		}
		sEntityGroupListName[current_selected_group] = "";
		current_selected_group = -1;

		// Also ensure objects not still rubberband highlighted as the user may think they are still grouped when the 
		// primary object in the old group is dragged about
		if (bRetainRubberBandList == false )
			g.entityrubberbandlist.clear();
	}
}

void UnGroupUndoSys(int index)
{
	//Ungroup to cursor and delete current group.
	if (index >= 0)
	{
		g.entityrubberbandlist = vEntityGroupList[index];
		//Set widget on first item in list.
		int e = g.entityrubberbandlist[0].e;
		if (e > 0)
		{
			if (t.entityelement[e].editorlock == 0)
			{
				t.widget.pickedEntityIndex = e;
				t.widget.pickedObject = t.entityelement[e].obj;
			}
		}
		vEntityGroupList[index].clear();
		if (ImageExist(iEntityGroupListImage[index]))
		{
			//Image is already on screen. so dont delete before its reused.
			//It will get the same id next time so we can do this.
			iEntityGroupListImage[index] = 0;
		}
		sEntityGroupListName[index] = "";
		current_selected_group = -1;

		// Also ensure objects not still rubberband highlighted 
		g.entityrubberbandlist.clear();
	}
}
void GroupUndoSys(int index, std::vector<sRubberBandType> groupData)
{
	// Add the entities from the undo event to the rubberband list and then create a group from the rubberband
	g.entityrubberbandlist.clear();
	for (int i = 0; i < groupData.size(); i++)
	{
		g.entityrubberbandlist.push_back(groupData[i]);
	}

	CreateNewGroup(-1, true, "", false);
}

void CreateNewGroup(int iParentGroupID, bool bSnapshotGroupThumb, cstr GroupName_s, bool bGenerateUndo)
{
	if (g.entityrubberbandlist.size() > 0)
	{
		//Check for duplicate.
		for (int i = 0; i < MAXGROUPSLISTS; i++)
		{
			if (vEntityGroupList[i].size() > 0)
			{
				if (vEntityGroupList[i].size() == g.entityrubberbandlist.size())
				{ 
					bool bAllFound = true;
					for (int ir = 0; ir < g.entityrubberbandlist.size(); ir++)
					{
						int e = g.entityrubberbandlist[ir].e;
						bool bfound = false;

						for (int il = 0; il < vEntityGroupList[i].size(); il++)
						{
							if (vEntityGroupList[i][il].e == e)
							{
								bfound = true;
								break;
							}
						}
						if (!bfound)
							bAllFound = false;
					}
					if (bAllFound) //All found in group.
						return;
				}

			}
		}

		GetRubberbandLowHighValues();

		//Remove empty.
		int dest = 0;
		for (int i = 0; i < MAXGROUPSLISTS; i++)
		{
			if (vEntityGroupList[i].size() > 0)
			{
				if (i != dest)
				{
					//move
					vEntityGroupList[dest] = vEntityGroupList[i];
					if (current_selected_group == dest)
						current_selected_group = dest;
					iEntityGroupListImage[dest] = iEntityGroupListImage[i];
					iEntityGroupListImage[i] = 0;
					sEntityGroupListName[dest] = sEntityGroupListName[i];
					sEntityGroupListName[i] = "";
					vEntityGroupList[i].clear();
				}
				dest++;
			}
		}
		
		//Move list down.
		for (int l = MAXGROUPSLISTS-1; l > 0; l--)
		{
			if (vEntityGroupList[l - 1].size() > 0)
			{
				vEntityGroupList[l] = vEntityGroupList[l - 1];
				if (current_selected_group == l - 1)
					current_selected_group = l;
				iEntityGroupListImage[l] = iEntityGroupListImage[l - 1];
				sEntityGroupListName[l] = sEntityGroupListName[l - 1];
			}
		}
		vEntityGroupList[0].clear();
		sEntityGroupListName[0] = "";

		// only create a thumbnail for parent groups, child groups are never shown
		int iImageID = 0;
		if (iParentGroupID == -1)
		{
			//Find free image id.
			for (int i = 0; i < MAXGROUPSLISTS; i++)
			{
				bool bAlreadyUsed = false;
				int iNewImageID = BACKBUFFERIMAGE + i;
				for (int l = MAXGROUPSLISTS; l > 0; l--)
				{
					if (iEntityGroupListImage[l] == iNewImageID)
					{
						bAlreadyUsed = true;
						break;
					}
				}
				if (!bAlreadyUsed) 
				{
					iImageID = iNewImageID;
					break;
				}
			}
			if (iImageID == 0) return; //No free imageID.
		}

		//Find free list.
		for (int l = 0; l < MAXGROUPSLISTS; l++)
		{
			if (vEntityGroupList[l].size() <= 0)
			{
				//Free, copy rubberband.
				vEntityGroupList[l] = g.entityrubberbandlist;
				widget_switchoff();

				//PE: Generate tumbnail of group.
				iEntityGroupListImage[l] = iImageID;
				if (bSnapshotGroupThumb == true)
				{
					// creating a group with NEW GROUP
					BackBufferIsGroup = false;
					BackBufferEntityID = 0;
					BackBufferObjectID = 0;
					BackBufferImageID = iEntityGroupListImage[l];
					BackBufferSizeX = 512 * 2.0f;
					BackBufferSizeY = 288 * 2.0f;
					BackBufferZoom = 1.0f;
					BackBufferCamLeft = 0.0f;
					BackBufferCamUp = 0.0f;
					bRotateBackBuffer = false;
					bBackBufferAnimated = false;
					bLoopBackBuffer = false;
					BackBufferSnapShotMode = true;
					if (BitmapExist(99))
					{
						DeleteBitmapEx(99);
					}
					bFullScreenBackbuffer = true;
					extern int bStopBackbufferGrab;
					bStopBackbufferGrab = 1;
				}
				else
				{
					// creating a group when we ADDED from Object Library
					int entid = 0;
					for (int i = 0; i < g.entityrubberbandlist.size(); i++)
					{
						// first update object from final entity element data
						int e = g.entityrubberbandlist[i].e;
						entid = t.entityelement[e].bankindex;
						if (t.entityprofile[entid].ismarker == 0)
						{
							// use this one!
							break;
						}
					}
					if (entid > 0)
					{
						BackBufferIsGroup = true;
						BackBufferEntityID = entid;
						BackBufferObjectID = g.entitybankoffset + entid;
						BackBufferImageID = iEntityGroupListImage[l];
						BackBufferSizeX = 512 * 2.0f;
						BackBufferSizeY = 288 * 2.0f;
						BackBufferZoom = 1.0f;
						BackBufferCamLeft = 0.0f;
						BackBufferCamUp = 0.0f;
						bRotateBackBuffer = false;
						bBackBufferAnimated = false;
						bLoopBackBuffer = false;
						if (BitmapExist(99))
						{
							DeleteBitmapEx(99);
						}
						bFullScreenBackbuffer = true;
						extern int bStopBackbufferGrab;
						bStopBackbufferGrab = 1;
					}
				}

				// assign name to group
				sEntityGroupListName[l] = GroupName_s;

				//Set selection on last created group.
				current_selected_group = l;
				break;
			}
		}

		//LB: if creating a child group, assign the parentID to it
		if (iParentGroupID == -1)
		{
			// creating a parent group
			if (current_selected_group >= 0)
			{
				g_iUniqueGroupID++;
				for (int n = 0; n < vEntityGroupList[current_selected_group].size(); n++)
				{
					vEntityGroupList[current_selected_group][n].iGroupID = g_iUniqueGroupID;
					vEntityGroupList[current_selected_group][n].iParentGroupID = -1;
				}

				// only "switch" to group tab if a parent group created, user will never see child groups being created here!
				if (sEntityGroupListName[current_selected_group].Len() == 0)
				{
					// Display group tab only for non smart objects
					i_switch_group_tab = 2;
				}
			}
		}
		else
		{
			// creating a child group of passed in iParentGroupID
			if (current_selected_group >= 0)
			{
				for (int n = 0; n < vEntityGroupList[current_selected_group].size(); n++)
				{
					vEntityGroupList[current_selected_group][n].iGroupID = -1;
					vEntityGroupList[current_selected_group][n].iParentGroupID = iParentGroupID;
				}
			}
		}

		if(bGenerateUndo)
			entity_createundoaction(eUndoSys_Object_Group, current_selected_group);
	}
}

void MakeFPELine (LPSTR pLine, LPSTR pFieldName, int iOptionalIndex, cstr str)
{
	// we want to have aligned spaced fields
	memset(pLine, 0, MAX_PATH);
	strcpy(pLine, "                 = ");

	// final field name
	char pFinalFieldName[MAX_PATH];
	strcpy (pFinalFieldName, pFieldName);
	if (iOptionalIndex > 0)
	{
		cstr pOptionalNum = cstr(iOptionalIndex);
		strcat(pFinalFieldName, pOptionalNum.Get());
	}

	// fill with field name
	if (strlen(pFieldName) <= 17)
	{
		memcpy(pLine, pFinalFieldName, strlen(pFinalFieldName));
	}
	else
	{
		strcpy (pLine, pFinalFieldName);
		strcat (pLine, " = ");
	}

	// add value for field
	strcat (pLine, str.Get());
}

bool SaveGroup(int iGroupID, LPSTR pObjectSavedFilename)
{
	if (current_selected_group < 0) return false;
	// collect all objects in this group
	g.entityrubberbandlist = vEntityGroupList[current_selected_group];
	if (g.entityrubberbandlist.size() == 0)
	{
		strcpy(cTriggerMessage, "Group failed to save - no objects in group");
		bTriggerMessage = true;
		return false;
	}

	// save default location
	char pEntityBankFolder[MAX_PATH];
	strcpy (pEntityBankFolder, g.fpscrootdir_s.Get());
	strcat (pEntityBankFolder, "\\Files\\entitybank\\");
	GG_GetRealPath(pEntityBankFolder, true);
	char pSaveDefaultLocation[MAX_PATH];
	strcpy (pSaveDefaultLocation, pEntityBankFolder);
	strcat (pSaveDefaultLocation, "user\\");

	// select filename to save as or have one passed in
	char pFileSelectedEntered[MAX_PATH];
	char* cFileSelectedEntered = NULL;
	if (strlen(pObjectSavedFilename) > 0)
	{
		strcpy ( pFileSelectedEntered, pSaveDefaultLocation);
		strcat ( pFileSelectedEntered, pObjectSavedFilename);
		cFileSelectedEntered = pFileSelectedEntered;
	}
	else
	{
		cStr tOldDir = GetDir();
		cFileSelectedEntered = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_SAVE, "fpe\0*.fpe\0", pSaveDefaultLocation, NULL);
		SetDir(tOldDir.Get());
	}

	if (cFileSelectedEntered == NULL)
	{
		strcpy(cTriggerMessage, "Group failed to save - you must specify a location inside entitybank");
		bTriggerMessage = true;
		return false;
	}

	// ensure entered filename has the .fpoe extension
	char cFileSelected[MAX_PATH];
	strcpy (cFileSelected, cFileSelectedEntered);
	if (strnicmp (cFileSelected + strlen(cFileSelected) - 4, ".fpe", 4) != NULL)
		strcat (cFileSelected, ".fpe");

	// can only save into entitybank
	if (strnicmp (cFileSelected, pEntityBankFolder, strlen(pEntityBankFolder)) != NULL)
	{
		strcpy(cTriggerMessage, "Group failed to save - you must specify a location inside entitybank");
		bTriggerMessage = true;
		return false;
	}

	// extract name from file chosen
	char pGroupObjectName[MAX_PATH];
	strcpy (pGroupObjectName, cFileSelected + strlen(pSaveDefaultLocation));
	pGroupObjectName[strlen(pGroupObjectName) - 4] = 0;

	// group object filename
	char pGroupObjectFilename[MAX_PATH];
	strcpy (pGroupObjectFilename, cFileSelected);
	GG_GetRealPath(pGroupObjectFilename, false);

	// gather grouip info
	int iGroupCount = g.entityrubberbandlist.size();

	// create FPE file (Group Object)
	char pLine[MAX_PATH];

	// check if one already exists of this name
	if (FileExist(pGroupObjectFilename) == 1)
	{
		strcpy(cTriggerMessage, "Group failed to save - an object of this name already exists!");
		bTriggerMessage = true;
		return false;
	}

	// write smart object
	if (FileOpen(1) == 1) CloseFile (1);
	OpenToWrite (1, pGroupObjectFilename);
	if (FileOpen(1) == 1)
	{
		WriteString (1, "; Group Object (Smart Object)");
		WriteString (1, "; header");
		MakeFPELine(pLine, "desc", 0, cstr(pGroupObjectName)); WriteString (1, pLine);
		WriteString (1, "");
		WriteString (1, "; group details");
		MakeFPELine(pLine, "isgroupobject", 0, cstr(1)); WriteString (1, pLine);
		MakeFPELine(pLine, "groupobjcount", 0, cstr(iGroupCount)); WriteString (1, pLine);
		WriteString (1, "");
		WriteString (1, "; group list");
		int e = g.entityrubberbandlist[0].e;
		float fBaseX = t.entityelement[e].x;
		float fBaseY = t.entityelement[e].y;
		float fBaseZ = t.entityelement[e].z;
		for (int i = 1; i <= iGroupCount; i++)
		{
			e = g.entityrubberbandlist[i - 1].e;
			int entid = t.entityelement[e].bankindex;
			LPSTR pEntityName = t.entitybank_s[entid].Get();

			MakeFPELine(pLine, "objname", i, cstr(pEntityName)); WriteString (1, pLine);
			MakeFPELine(pLine, "objoffx", i, cstr(t.entityelement[e].x - fBaseX)); WriteString (1, pLine);
			MakeFPELine(pLine, "objoffy", i, cstr(t.entityelement[e].y - fBaseY)); WriteString (1, pLine);
			MakeFPELine(pLine, "objoffz", i, cstr(t.entityelement[e].z - fBaseZ)); WriteString (1, pLine);
			MakeFPELine(pLine, "objrotx", i, cstr(t.entityelement[e].rx)); WriteString (1, pLine);
			MakeFPELine(pLine, "objroty", i, cstr(t.entityelement[e].ry)); WriteString (1, pLine);
			MakeFPELine(pLine, "objrotz", i, cstr(t.entityelement[e].rz)); WriteString (1, pLine);
			MakeFPELine(pLine, "objscalex", i, cstr(t.entityelement[e].scalex)); WriteString (1, pLine);
			MakeFPELine(pLine, "objscaley", i, cstr(t.entityelement[e].scaley)); WriteString (1, pLine);
			MakeFPELine(pLine, "objscalez", i, cstr(t.entityelement[e].scalez)); WriteString (1, pLine);
			MakeFPELine(pLine, "objphysicsmode", i, cstr(t.entityelement[e].eleprof.physics)); WriteString (1, pLine);
			MakeFPELine(pLine, "objstaticmode", i, cstr(t.entityelement[e].staticflag)); WriteString (1, pLine);
			MakeFPELine(pLine, "objisimmobile", i, cstr(t.entityelement[e].eleprof.isimmobile)); WriteString (1, pLine);

			if (t.entityprofile[entid].ismarker == 10)
			{
				MakeFPELine(pLine, "objshowstart", i, cstr(t.entityelement[e].eleprof.newparticle.bParticle_Show_At_Start)); WriteString (1, pLine);
			}
			else
			{
				MakeFPELine(pLine, "objshowstart", i, cstr(t.entityelement[e].eleprof.spawnatstart)); WriteString (1, pLine);
			}

			if (t.entityprofile[entid].ismarker == 10)
			{
				LPSTR pParticleName = t.entityelement[e].eleprof.newparticle.emittername.Get();
				MakeFPELine(pLine, "objpartname", i, cstr(pParticleName)); WriteString (1, pLine);
				MakeFPELine(pLine, "objpartloop", i, cstr(t.entityelement[e].eleprof.newparticle.bParticle_Looping_Animation)); WriteString (1, pLine);
				MakeFPELine(pLine, "objpartspeed", i, cstr(t.entityelement[e].eleprof.newparticle.fParticle_Speed)); WriteString (1, pLine);
				MakeFPELine(pLine, "objpartopacity", i, cstr(t.entityelement[e].eleprof.newparticle.fParticle_Opacity)); WriteString (1, pLine);
			}
			if (t.entityprofile[entid].ismarker == 2)
			{
				int lightindex = t.entityelement[e].eleprof.light.index;
				MakeFPELine(pLine, "objlighttype", i, cstr(t.entityelement[e].eleprof.light.index)); WriteString (1, pLine);
				MakeFPELine(pLine, "objlightcolor", i, cstr((int)t.entityelement[e].eleprof.light.color)); WriteString (1, pLine);
				MakeFPELine(pLine, "objlightdist", i, cstr(t.entityelement[e].eleprof.light.range)); WriteString (1, pLine);
				MakeFPELine(pLine, "objlightradius", i, cstr(t.entityelement[e].eleprof.light.offsetup)); WriteString (1, pLine);
				MakeFPELine(pLine, "objlightcast", i, cstr(t.entityelement[e].eleprof.castshadow)); WriteString (1, pLine);
				LPSTR pBehaviorName = t.entityelement[e].eleprof.aimain_s.Get();
				MakeFPELine(pLine, "objlightlogic", i, cstr(pBehaviorName)); WriteString (1, pLine);
			}
		}
		WriteString (1, "");
		WriteString (1, "; thumbnail");
		WriteString (1, "thumbnailbackdrop = Blue showroom.dds");
		CloseFile (1);

		//PE: If we got a generated thumb use this.
		if (ImageExist(iEntityGroupListImage[current_selected_group]))
		{
			char *find = (char *) pestrcasestr(cFileSelected, "entitybank\\");
			if (find)
			{
				cstr fname = (find + 11);
				CreateBackBufferCacheName(fname.Get(), 512, 288);
				SaveImage(BackBufferCacheName.Get(), iEntityGroupListImage[current_selected_group]);
			}
		}
	}
	else
	{
		strcpy(cTriggerMessage, "Group failed to save - could not write the new object file");
		bTriggerMessage = true;
		return false;
	}

	// success
	strcpy (pObjectSavedFilename, pGroupObjectFilename + strlen(pEntityBankFolder));
	return true;
}

bool ReadFPELine (LPSTR pTryField, LPSTR pThisField, int* piOptionalIndex)
{
	if (strnicmp (pThisField, pTryField, strlen(pTryField)) == NULL)
	{
		char pNumberPart[32];
		strcpy (pNumberPart, pThisField + strlen(pTryField));
		if (pNumberPart[0] != ' ')
		{
			*piOptionalIndex = atoi(pNumberPart);
		}
		return true;
	}
	else
	{
		return false;
	}
}

struct sObjTable
{
	int entid;
	int e;
};

bool LoadGroup(LPSTR pAbsFilename)
{
	// init vars and clear rubberband list
	cstr sGroupObjectName;
	int iGroupCount = 0;
	bool bGroupFileValid = false;
	g.entityrubberbandlist.clear();
	sObjTable* pObjTable = NULL;

	// parse group file to get all objects
	if (FileExist(pAbsFilename) == 1)
	{
		// parse group file
		std::vector <cstr> groupdata_s;
		Dim (groupdata_s, 9999);
		LoadArray (pAbsFilename, groupdata_s);
		for ( int groupline = 0; groupline < 9999; groupline++)
		{
			cstr line_s = groupdata_s[groupline];
			if (Len(line_s.Get()) > 0)
			{
				LPSTR pLine = line_s.Get();
				if (pLine[0] != ';')
				{
					// take fieldname and values
					for (t.c = 0; t.c < Len(pLine); t.c++)
					{
						if (pLine[t.c] == '=') { t.mid = t.c + 1; break; }
					}
					t.field_s = Lower(removeedgespaces(Left(pLine, t.mid - 1)));
					t.value_s = removeedgespaces(Right(pLine, Len(pLine) - t.mid));
					for (t.c = 0; t.c < Len(t.value_s.Get()); t.c++)
					{
						if (t.value_s.Get()[t.c] == ',') { t.mid = t.c + 1; break; }
					}
					t.value1 = ValF(removeedgespaces(Left(t.value_s.Get(), t.mid - 1)));
					t.value2_s = removeedgespaces(Right(t.value_s.Get(), Len(t.value_s.Get()) - t.mid));
					if (Len(t.value2_s.Get()) > 0)  t.value2 = ValF(t.value2_s.Get()); else t.value2 = -1;

					// populate with values found
					t.tryfield_s = "desc"; if (t.field_s == t.tryfield_s)  sGroupObjectName = t.value_s;
					t.tryfield_s = "isgroupobject"; if (t.field_s == t.tryfield_s)  bGroupFileValid = t.value1;
					t.tryfield_s = "groupobjcount";
					if (t.field_s == t.tryfield_s)
					{
						iGroupCount = t.value1;
						pObjTable = new sObjTable[iGroupCount + 1];
						memset(pObjTable, 0, sizeof(pObjTable));
					}
					if (iGroupCount > 0 && bGroupFileValid == true)
					{
						int iOptionalIndex = 0;
						if (ReadFPELine("objname", t.field_s.Get(), &iOptionalIndex))
						{
							// load this entity or find existing entid
							t.entid = 0;
							t.addentityfile_s = t.value_s.Get();
							if (t.addentityfile_s != "")
							{
								// allow filename only to be specified indicating file is local to main smart object FPE
								bool bNameOnlyNoPath = true;
								char pEntityFilePath[MAX_PATH];
								strcpy(pEntityFilePath, t.addentityfile_s.Get());
								for (int n = 0; n < strlen(pEntityFilePath); n++)
								{
									if (pEntityFilePath[n] == '\\' || pEntityFilePath[n] == '/')
									{
										bNameOnlyNoPath = false;
										break;
									}
								}
								if (bNameOnlyNoPath == true)
								{
									// get path of main smart object file
									char pMainSmartFilePath[MAX_PATH];
									strcpy(pMainSmartFilePath, pAbsFilename);
									for (int n = strlen(pMainSmartFilePath)-1; n>0; n--)
									{
										if (pMainSmartFilePath[n] == '\\' || pMainSmartFilePath[n] == '/')
										{
											pMainSmartFilePath[n] = 0;
											break;
										}
									}					

									// add a path to this local smaert object to load child of smart object
									strcpy(pEntityFilePath, pMainSmartFilePath);
									strcat(pEntityFilePath, "\\");
									strcat(pEntityFilePath, t.addentityfile_s.Get());
									t.addentityfile_s = pEntityFilePath;
								}
								entity_adduniqueentity(false);
							}
							else
							{
								// could not load this object in the group!
								t.entid = 0;
							}
							pObjTable[iOptionalIndex].entid = t.entid;

							// add new entity element
							t.gridentity = t.entid;
							t.gridentityeditorfixed = 0;
							t.entitymaintype = 1;
							t.entitybankindex = t.entid;
							t.gridentitystaticmode = 0;
							t.gridentityhasparent = 0;
							t.gridentityposx_f = 0;
							t.gridentityposz_f = 0;
							t.gridentityposy_f = 0;
							t.gridentityrotatex_f = 0;
							t.gridentityrotatey_f = 0;
							t.gridentityrotatez_f = 0;
							t.gridentityrotatequatmode = 1;
							t.gridentityrotatequatx_f = 0;
							t.gridentityrotatequaty_f = 0;
							t.gridentityrotatequatz_f = 0;
							t.gridentityrotatequatw_f = 1;
							t.gridentityscalex_f = 100;
							t.gridentityscaley_f = 100;
							t.gridentityscalez_f = 100;
							entity_fillgrideleproffromprofile();
							entity_addentitytomap();

							// add to rubberband list (e for now, rest populated later)
							int e = t.e;
							sRubberBandType rubberbandItem;
							rubberbandItem.e = e;
							g.entityrubberbandlist.push_back(rubberbandItem);

							// add reference to object table (for rest of objxxx parsing)
							pObjTable[iOptionalIndex].e = e;
							pObjTable[iOptionalIndex].entid = t.entid;

							// no leftover fields from entity loaddata (called above)
							t.field_s = "";
						}
						if (ReadFPELine("objoffx", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].x = t.value1;
						if (ReadFPELine("objoffy", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].y = t.value1;
						if (ReadFPELine("objoffz", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].z = t.value1;
						if (ReadFPELine("objrotx", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].rx = t.value1;
						if (ReadFPELine("objroty", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].ry = t.value1;
						if (ReadFPELine("objrotz", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].rz = t.value1;
						if (ReadFPELine("objscalex", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].scalex = t.value1;
						if (ReadFPELine("objscaley", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].scaley = t.value1;
						if (ReadFPELine("objscalez", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].scalez = t.value1;
						if (ReadFPELine("objphysicsmode", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.physics = t.value1;
						if (ReadFPELine("objstaticmode", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].staticflag = t.value1;
						if (ReadFPELine("objisimmobile", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.isimmobile = t.value1;
						if (ReadFPELine("objshowstart", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.newparticle.bParticle_Show_At_Start = t.value1;
						if (ReadFPELine("objshowstart", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.spawnatstart = t.value1;
						if (ReadFPELine("objpartname", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.newparticle.emittername = t.value_s;
						if (ReadFPELine("objpartloop", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.newparticle.bParticle_Looping_Animation = t.value1;
						if (ReadFPELine("objpartspeed", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.newparticle.fParticle_Speed = t.value1;
						if (ReadFPELine("objpartopacity", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.newparticle.fParticle_Opacity = t.value1;
						if (ReadFPELine("objlighttype", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.light.index = t.value1;
						if (ReadFPELine("objlightcolor", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.light.color = t.value1;
						if (ReadFPELine("objlightdist", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.light.range = t.value1;
						if (ReadFPELine("objlightradius", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.light.offsetup = t.value1;
						if (ReadFPELine("objlightcast", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.castshadow = t.value1;
						if (ReadFPELine("objlightlogic", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.aimain_s = t.value_s;
					}
				}
			}
		}
		UnDim(groupdata_s);

		// location to place the entityelements for this group load
		float fBaseX = 0;
		//float fBaseY = 600;
		float fBaseY = -500000; //PE: Hide master group.
		float fBaseZ = 0;

		// raise baseY so lowest object in the group is one floor
		float fLowest = 0.0f;
		for (int i = 0; i < g.entityrubberbandlist.size(); i++)
		{
			int e = g.entityrubberbandlist[i].e;
			if (t.entityelement[e].y < fLowest)
				fLowest = t.entityelement[e].y;
		}
		if (fLowest<0.0f ) fBaseY -= fLowest;

		// populate rubberband list items
		for (int i = 0; i < g.entityrubberbandlist.size(); i++)
		{
			// first update object from final entity element data
			int e = g.entityrubberbandlist[i].e;

			// place entity so can be seen
			t.entityelement[e].x += fBaseX;
			t.entityelement[e].y += fBaseY;
			t.entityelement[e].z += fBaseZ;

			// update entity object from its new settings
			t.tupdatee = e; entity_updateentityobj();
			
			t.entityelement[e].iIsSmarkobjectDummyObj = 1; //PE: We need a way so we dont display these, in the detailed object list.

			// update lights and particles too
			int entid = t.entityelement[e].bankindex;
			if (t.entityprofile[entid].ismarker == 0)
			{
				entity_updateautoflatten(t.tupdatee);
			}
			if (t.entityprofile[entid].ismarker == 2 || t.entityprofile[entid].ismarker == 5 || t.entityelement[t.e].eleprof.usespotlighting)
			{
				t.entityelement[e].eleprof.light.index = 0;
				lighting_refresh();
			}
			if (t.entityprofile[entid].ismarker == 10)
			{
				t.entityelement[e].eleprof.newparticle.emitterid = -1;
				entity_updateparticleemitter(t.tupdatee);
			}

			// and then add correct values to rubberband list
			g.entityrubberbandlist[i].x = t.entityelement[e].x;
			g.entityrubberbandlist[i].y = t.entityelement[e].y;
			g.entityrubberbandlist[i].z = t.entityelement[e].z;
			g.entityrubberbandlist[i].px = t.entityelement[e].x;
			g.entityrubberbandlist[i].py = t.entityelement[e].y;
			g.entityrubberbandlist[i].pz = t.entityelement[e].z;
			g.entityrubberbandlist[i].rx = t.entityelement[e].rx;
			g.entityrubberbandlist[i].ry = t.entityelement[e].ry;
			g.entityrubberbandlist[i].rz = t.entityelement[e].rz;
			
			// calculate quat from ROTXYZ in smart object child
			entity_updatequatfromeuler(e);
			
			g.entityrubberbandlist[i].quatmode = t.entityelement[e].quatmode;
			g.entityrubberbandlist[i].quatx = t.entityelement[e].quatx;
			g.entityrubberbandlist[i].quaty = t.entityelement[e].quaty;
			g.entityrubberbandlist[i].quatz = t.entityelement[e].quatz;
			g.entityrubberbandlist[i].quatw = t.entityelement[e].quatw;
			g.entityrubberbandlist[i].scalex = t.entityelement[e].scalex;
			g.entityrubberbandlist[i].scaley = t.entityelement[e].scaley;
			g.entityrubberbandlist[i].scalez = t.entityelement[e].scalez;
		}

		// create group from list
		CreateNewGroup(-1, false, cstr(pAbsFilename));
	}
	else
	{
		strcpy(cTriggerMessage, "Group failed to load - no file found");
		return false;
	}

	// success
	return true;
}

void AddEntityToCursor(int e, bool bDuplicate)
{
	if (e <= 0) return;

	if (t.gridentityinzoomview > 0) return; //Return if we are in "properties".

	if (!bDuplicate && t.entityelement[e].editorlock) return; //Dont allow selection of locked entity.


	//PE: we loose status somewhere, so force it off after adding a entity to map.
	extern bool bCubesVisible;
	if (bCubesVisible == false) bCubesVisible = true; //Force.

	if (!bDuplicate)
		iLastEntityOnCursor = e;
	else
		iLastEntityOnCursor = 0;

	//PE: Check if we can do a valid offset.
	float clickx = 0.0f, clickz = 0.0f, fPickedYAxis = 0.0f;
	// PE: Mixed system

	bDetectTerrainOnly = false;

	if (!bDuplicate)
	{
		int iObj = t.entityelement[e].obj;
		bool bVisible = false;
		if (iObj > 0)
		{
			if (ObjectExist(iObj) == 1)
			{
				sObject* pObject = g_ObjectList[iObj];
				bVisible = pObject->bVisible;
				HideObject(iObj);
			}
		}
		//Sent ray with the object visible.
		WickedCall_GetPick(&clickx, &fPickedYAxis, &clickz, NULL, NULL, NULL, NULL, GGRENDERLAYERS_NORMAL);

		if (bVisible)
		{
			ShowObject(iObj);
		}
	}

	if (!bDuplicate)
	{
		if (g.entityrubberbandlist.size() > 0)
		{
			bool bEntityOk = false;
			//Only allow selection/move if within rubberband.
			for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
			{
				int ent = g.entityrubberbandlist[i].e;
				if (ent == e)
				{
					bEntityOk = true;
					break;
				}
			}
			if (!bEntityOk) return;
		}
	}
	if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
	if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
	if (bImporter_Window) { importer_quit(); bImporter_Window = false; }

	DeleteWaypointsAddedToCurrentCursor();
	//CheckTooltipObjectDelete();
	CloseDownEditorProperties();

	//LB: Only when not in shooter mode
	//LB: shooter now a filter mode if (!Shooter_Tools_Window)
	{
		//Make sure we are in entity mode.
		bForceKey = true;
		csForceKey = "o";
	}

	t.tentitytoselect = e;
	t.widget.duplicatebuttonselected = 0;
	t.gridentityautofind = 7;

	t.onetimeentitypickup = 1;

	//  extract entity from the map
	if (t.tentitytoselect > 0)
	{
		if (t.entityelement[t.tentitytoselect].editorfixed == 0)
		{
			fExtractYValue = t.entityelement[t.tentitytoselect].y;

			t.gridentityeditorfixed = t.entityelement[t.tentitytoselect].editorfixed;
			t.gridentity = t.entityelement[t.tentitytoselect].bankindex;
			t.ttrygridentitystaticmode = t.entityelement[t.tentitytoselect].staticflag;
			t.ttrygridentity = t.gridentity; editor_validatestaticmode();
			t.gridedit.autoflatten = t.entityprofile[t.gridentity].autoflatten;
			//t.gridedit.entityspraymode = 0; //PE: spray checkbox.
			if (t.gridentityautofind == 7)
			{
				//  widget extracts without forcing entity to Floor
				t.gridentityautofind = 0;
				t.gridentityposoffground = 1;
				t.gridentityusingsoftauto = 0;
			}
			else
			{
				t.gridentityposoffground = 0;
				t.gridentityusingsoftauto = 1;
				#ifdef WICKEDENGINE
				// MAX handles its own positioning system
				#else
				if (t.entityprofile[t.gridentity].defaultstatic == 0 && t.entityprofile[t.gridentity].isimmobile == 1)
				{
					t.gridentityautofind = 1;
				}
				else
				#endif
				{
					t.gridentityautofind = 0;
				}
			}
			t.gridentitysurfacesnap = 0; // surfacesnap off as messes up extract offset for entity
			t.gridentityextractedindex = t.tentitytoselect;
			t.gridentityhasparent = 0;//t.entityelement[t.tentitytoselect].iHasParentIndex; 210317 - break association when extract so can place free of parent
			t.gridentityposx_f = t.entityelement[t.tentitytoselect].x;
			t.gridentityposy_f = t.entityelement[t.tentitytoselect].y;
			t.gridentityposz_f = t.entityelement[t.tentitytoselect].z;
			t.gridentityrotatex_f = t.entityelement[t.tentitytoselect].rx;
			t.gridentityrotatey_f = t.entityelement[t.tentitytoselect].ry;
			t.gridentityrotatez_f = t.entityelement[t.tentitytoselect].rz;
			t.gridentityrotatequatmode = t.entityelement[t.tentitytoselect].quatmode;
			t.gridentityrotatequatx_f = t.entityelement[t.tentitytoselect].quatx;
			t.gridentityrotatequaty_f = t.entityelement[t.tentitytoselect].quaty;
			t.gridentityrotatequatz_f = t.entityelement[t.tentitytoselect].quatz;
			t.gridentityrotatequatw_f = t.entityelement[t.tentitytoselect].quatw;
			if (t.entityprofile[t.gridentity].ismarker == 10)
			{
				t.gridentityscalex_f = 100.0f + t.entityelement[t.tentitytoselect].scalex;
				t.gridentityscaley_f = 100.0f + t.entityelement[t.tentitytoselect].scaley;
				t.gridentityscalez_f = 100.0f + t.entityelement[t.tentitytoselect].scalez;
			}
			else
			{
				t.gridentityscalex_f = ObjectScaleX(t.entityelement[t.tentitytoselect].obj);
				t.gridentityscaley_f = ObjectScaleY(t.entityelement[t.tentitytoselect].obj);
				t.gridentityscalez_f = ObjectScaleZ(t.entityelement[t.tentitytoselect].obj);
			}
			t.grideleprof = t.entityelement[t.tentitytoselect].eleprof;
			t.grideleproflastname_s = t.grideleprof.name_s;

			//  Transfer any waypoint association
			t.waypointindex = t.entityelement[t.tentitytoselect].eleprof.trigger.waypointzoneindex;
			t.grideleprof.trigger.waypointzoneindex = t.waypointindex;
			t.waypoint[t.waypointindex].linkedtoentityindex = 0;

			//Just place under cursor.
			t.inputsys.dragoffsetx_f = 0;
			t.inputsys.dragoffsety_f = 0;

			float lowy = 0.0f;

			if (bDuplicate)
			{
				//PE: New object need a unique particle id.
				t.grideleprof.newparticle.emitterid = -1;
			}

			// get object size before we delete it
			float fObjectRealSize = 0.0f;
			if (t.tentitytoselect > 0) 
				fObjectRealSize = ObjectSize(t.entityelement[t.tentitytoselect].obj, 1);

			if (!bDuplicate) 
			{
				lowy = GetLowestY(t.entityelement[t.tentitytoselect].obj);
				g_UndoSysObjectIsBeingMoved = true; // this is not a real delete, just a step in highlighting the entity
				t.gridentitypreferelementindex = t.tentitytoselect; // set a preference where we want object put back into element index
				gridedit_deleteentityfrommap();
				g_UndoSysObjectIsBeingMoved = false;
				t.onetimeentitypickup = 0;
				//PE: If this is a light ,
				if (t.entityprofile[t.gridentity].ismarker == 2 || t.entityprofile[t.gridentity].ismarker == 5)
				{
					//Add the light.
					if (t.gridentitywickedlightindex == 0)
					{
						int iLightType = 1;
						if (t.grideleprof.usespotlighting) iLightType = 2;
						t.gridentitywickedlightindex = WickedCall_AddLight(iLightType);
					}
					if (t.gridentitywickedlightindex > 0)
					{
						float lightx = t.gridentityposx_f;
						float lighty = t.gridentityposy_f;
						float lightz = t.gridentityposz_f;
						float lightax = t.gridentityrotatex_f;
						float lightay = t.gridentityrotatey_f;
						float lightaz = t.gridentityrotatez_f;
						float lightrange = t.grideleprof.light.range;
						float lightspotradius = t.grideleprof.light.offsetup;
						int colr = ((t.grideleprof.light.color & 0x00ff0000) >> 16);
						int colg = ((t.grideleprof.light.color & 0x0000ff00) >> 8);
						int colb = (t.grideleprof.light.color & 0x000000ff);
						bool bCastShadow = true;
						if (t.grideleprof.castshadow == 1) bCastShadow = false;
						WickedCall_UpdateLight(t.gridentitywickedlightindex, lightx, lighty, lightz, lightax, lightay, lightaz, lightrange, lightspotradius, colr, colg, colb, bCastShadow);
					}
				}
			}

			fHitPointX = 0;
			fHitPointY = HITPOINTYSTARTPOS;
			fHitPointZ = 0;
			fHitOffsetX = 0;
			fHitOffsetY = 0;
			fHitOffsetZ = 0;
			iStartMouseX = (int)ImGui::GetMousePos().x;
			iStartMouseY = (int)ImGui::GetMousePos().y;
			iLastHitObjectID = 0;

			g_bHoldGridEntityPosWhenManaged = true;
			g_fHoldGridEntityPosX = t.gridentityposx_f;
			g_fHoldGridEntityPosY = t.gridentityposy_f;
			g_fHoldGridEntityPosZ = t.gridentityposz_f;

			if (!bDuplicate)
			{
				// LB: get the first hit XYZ when click an object to move about
				fHitPointX = t.inputsys.localx_f;
				fHitPointY = t.inputsys.localcurrentterrainheight_f;
				fHitPointZ = t.inputsys.localy_f;
				fHitOffsetX = fHitPointX - t.gridentityposx_f;
				fHitOffsetY = fHitPointY - t.gridentityposy_f;
				fHitOffsetZ = fHitPointZ - t.gridentityposz_f;

				/* LB: all this gets wrong point as widget_getplanepos is one frame behind now!
				//####TEST
				//PE: Test using widget system.
				fHitPointX = t.gridentityposx_f;
				fHitPointY = t.gridentityposy_f;
				fHitPointZ = t.gridentityposz_f;
				int picksystem = t.widget.pickedSection;
				float fActivePosX = t.gridentityposx_f;
				float fActivePosY = t.gridentityposy_f;		
				int iRealObjectMoveMode = iObjectMoveMode;
				if (iObjectMoveModeDropSystem > 0) iRealObjectMoveMode = 0;
				if (iRealObjectMoveMode != 1)
				{
					//PE: We need a plane hit on the first click.
					//if (t.inputsys.localcurrentterrainheight_f != 0.0f)
					{
						fHitPointY = t.inputsys.localcurrentterrainheight_f;
						fActivePosY = t.inputsys.localcurrentterrainheight_f;
					}
				}
				float fActivePosZ = t.gridentityposz_f;
				float fPlanePosX, fPlanePosY, fPlanePosZ;
				t.widget.pickedSection = -99; //t.widget.widgetXZObj;
				bool widget_getplanepos(float fActivePosX, float fActivePosY, float fActivePosZ, float* pPlanePosX, float* pPlanePosY, float* pPlanePosZ);
				bool bPlanePosRegistered = widget_getplanepos(fActivePosX, fActivePosY, fActivePosZ, &fPlanePosX, &fPlanePosY, &fPlanePosZ);
				if (bPlanePosRegistered == true)
				{
					//record position where clicked
					fHitOffsetX = fPlanePosX - fActivePosX;
					fHitOffsetY = fPlanePosY - t.gridentityposy_f;// fActivePosY; to give correct Y offset
					fHitOffsetZ = fPlanePosZ - fActivePosZ;
				}
				//In vertical move we need another using the Y system.
				if (iObjectMoveMode == 1)
				{
					t.widget.pickedSection = -98;
					bool bPlanePosRegistered = widget_getplanepos(fActivePosX, fActivePosY, fActivePosZ, &fPlanePosX, &fPlanePosY, &fPlanePosZ);
					if (bPlanePosRegistered == true)
					{
						fHitOffsetY = fPlanePosY - fActivePosY;
					}
				}
				*/

				//PE: Need to start rubberbandmove with same values.
				t.fOldGridEntityX = t.gridentityposx_f;
				t.fOldGridEntityY = t.gridentityposy_f;
				t.fOldGridEntityZ = t.gridentityposz_f;
				t.fOldGridEntityRX = t.gridentityrotatex_f;
				t.fOldGridEntityRY = t.gridentityrotatey_f;
				t.fOldGridEntityRZ = t.gridentityrotatez_f;
				t.fOldGridEntityQuatMode = t.gridentityrotatequatmode;
				t.fOldGridEntityQuatX = t.gridentityrotatequatx_f;
				t.fOldGridEntityQuatY = t.gridentityrotatequaty_f;
				t.fOldGridEntityQuatZ = t.gridentityrotatequatz_f;
				t.fOldGridEntityQuatW = t.gridentityrotatequatw_f;

				// LB: as above, not needed as not changed pickedSection
				///t.widget.pickedSection = picksystem;
			}
			else
			{
				g.entityrubberbandlist.clear();
			}
			//####TESTEND

			// get size of object selected, to determine if to use drop system (only used for larger objects)
			iObjectMoveModeDropSystemUsing = 0;
			int iForwardFacing = t.entityprofile[t.gridentity].forwardfacing;
			float fUpDownAngle = WrapValue(CameraAngleX(0));
			if (fUpDownAngle > 10.0f && fUpDownAngle < 91.0f)
			{
				// down is fine for ghost drop
				if (t.tentitytoselect > 0 && fObjectRealSize > 20.0f && iForwardFacing == 0 && g_iStackToSurfaceMode == 1)
				{
					bool bJustForInitialDragIn = false;
					if (bDraggingActive == false && fHitOffsetX == 0 && fHitOffsetY == 0 && fHitOffsetZ == 0) bJustForInitialDragIn = true;
					if (bDraggingActive == true && t.gridentityposx_f == 0 && t.gridentityposz_f == 0) bJustForInitialDragIn = true;
					if (bDraggingActiveInitial == true)	bJustForInitialDragIn = true;
					if (bJustForInitialDragIn == true || g.entityrubberbandlist.size() <= 1)
					{
						iObjectMoveModeDropSystemUsing = 1;
					}
				}
			}
			else
			{
				// looking up and to side, drop system not a good idea
			}

			if (!bDuplicate) 
			{
				// find surface height (terrain is surface for now)
				//float fHitX, fHitY, fHitZ;
				//float fSurfaceFloorHeight = GGORIGIN_Y;
				//if (WickedCall_SentRay(t.entityelement[t.tentitytoselect].x, t.entityelement[t.tentitytoselect].y, t.entityelement[t.tentitytoselect].z, 0, -1.0f, 0, &fHitX, &fHitY, &fHitZ, NULL, NULL, NULL, NULL, GGRENDERLAYERS_TERRAIN))
				//{
				//	fSurfaceFloorHeight = fHitY;
				//}

				// in smart positning mode, always find surface when drop into level
				if (iObjectMoveMode == 2 && iObjectMoveModeDropSystem == 0)
				{
					if (iObjectMoveModeDropSystemUsing == 1 && g_bHoldGridEntityPosWhenManaged == false)
					{
						iObjectMoveModeDropSystem = 1;
						t.inputsys.dragoffsetx_f = 0.0f;
						t.inputsys.dragoffsety_f = 0.0f;
					}
				}
				else
				{
					// positioning mode horiz and vert do not seek surface adjustment, so keep as is
					t.inputsys.dragoffsetx_f = t.entityelement[t.tentitytoselect].x - clickx;
					t.inputsys.dragoffsety_f = t.entityelement[t.tentitytoselect].z - clickz;
				}
			}
			else
			{
				// in smart positning mode, always find surface when drop into level
				if (iObjectMoveMode == 2 && iObjectMoveModeDropSystem == 0)
				{
					if (iObjectMoveModeDropSystemUsing == 1 && g_bHoldGridEntityPosWhenManaged == false)
					{
						iObjectMoveModeDropSystem = 1;
						t.inputsys.dragoffsetx_f = 0.0f;
						t.inputsys.dragoffsety_f = 0.0f;
					}
				}
			}

			t.widget.pickedObject = 0;
			widget_updatewidgetobject();
			t.refreshgrideditcursor = 1;
		}
	}
}


void BeginDragDropFPE(char *fpe, int textureid, bool bToolTipActive, ImVec2 vISize)
{
	if (bWaitOnMouseRelease)
	{
		if (!ImGui::IsMouseDown(0))
			bWaitOnMouseRelease = false;
	}

	if (bToolTipActive && pref.iEnableDragDropEntityMode && !bWaitOnMouseRelease && t.gridentity == 0 && t.gridentityobj == 0 && ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
	{

		cstr find = fpe;

		cFolderItem *pSearchFolder = &MainEntityList;
		cFolderItem::sFolderFiles * foundfiles = NULL;
		pSearchFolder = pSearchFolder->m_pNext;
		cStr path = "";
		cStr path_remove = pSearchFolder->m_sFolderFullPath.Get();
		std::string sFpeName;
		int ipath_remove_len = path_remove.Len();
		bool bFound = false;
		while (pSearchFolder)
		{
			if (pSearchFolder->iType == 0)
			{
				cStr path = pSearchFolder->m_sFolderFullPath.Get();

				bool bDoubleEntityBank = false;
				char *finde = (char *)pestrcasestr(path.Get(), "\\entitybank"); //Support entitybank inside entitybank.
				if (finde)
				{
					finde += 11;
					finde = (char *)pestrcasestr(finde, "\\entitybank");
					if (finde) bDoubleEntityBank = true;
				}

				if (!bDoubleEntityBank && path.Right(11) == "\\entitybank")
				{
					ipath_remove_len = path.Len();
				}
				else
				{
					if (pSearchFolder->m_pFirstFile) {
						cFolderItem::sFolderFiles * searchfiles = pSearchFolder->m_pFirstFile->m_pNext;
						while (searchfiles) {
							foundfiles = searchfiles;
							path = pSearchFolder->m_sFolderFullPath.Get();
							char *final_name = path.Get();
							final_name += ipath_remove_len;
							if (*final_name == '\\')
								final_name++;

							std::string path_for_filename = final_name;
							sFpeName = path_for_filename.c_str();
							sFpeName = sFpeName + "\\" + foundfiles->m_sName.Get();
							if (stricmp(find.Get(), sFpeName.c_str()) == 0)
								bFound = true;
							if (bFound)
								break;
							searchfiles = searchfiles->m_pNext;
						}
					}
				}
				if (bFound)
					break;
			}
			pSearchFolder = pSearchFolder->m_pNext;
		}

		if (bFound && foundfiles)
		{
			CloseDownEditorProperties();
			t.inputsys.constructselection = 0;

			foundfiles->m_dropptr = foundfiles;
			foundfiles->iAnimationFrom = 0;

			foundfiles->m_sFolder = sFpeName.c_str();
			ImGui::SetDragDropPayload("DND_MODEL_DROP_TARGET", foundfiles, sizeof(void *));
			ImGui::ImgBtn(textureid, vISize, drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false);
			//ImGui::Text("%s", myfiles->m_sName.Get());
			//ImGui::SetCursorPos(oldCursor);
			pDragDropFile = foundfiles;
			/*ImGui::EndDragDropSource();*/
			bReadyToDropEntity = false;
			iDragDropActive = 50;
			bDraggingActive = true;
			bDraggingActiveInitial = true;
			// LB: these can be uninitialised, but we need these filled so the plane can be under the cursor initially
			t.gridentityposx_f = t.inputsys.localx_f;
			t.gridentityposy_f = t.inputsys.localcurrentterrainheight_f;
			t.gridentityposz_f = t.inputsys.localy_f;
		}
		// ZJ: Moved this here, to prevent the icons being dragged in release, and assertion error in debug, when bFound is false 
		ImGui::EndDragDropSource();
	}
}


void DisplayFPEMedia(bool readonly, int entid, entityeleproftype *edit_grideleprof)
{
	int tflagtext = 0, tflagimage = 0; //PE: These is not used in VRTECH ?
	bool mediaactive[6] = { true,true,true,true,true,true };
	int iActiveMedia = 0;

	if (!edit_grideleprof)
	{
		edit_grideleprof = &t.grideleprof;
	}

	if (readonly)
	{
		ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
		ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
	}

	if (readonly)
	{
		if (edit_grideleprof->soundset_s.Len() <= 0)
		{
			mediaactive[0] = false;
			iActiveMedia++;
		}
		if (edit_grideleprof->soundset1_s.Len() <= 0)
		{
			mediaactive[1] = false;
			iActiveMedia++;
		}
		if (edit_grideleprof->soundset2_s.Len() <= 0)
		{
			mediaactive[2] = false;
			iActiveMedia++;
		}
		if (edit_grideleprof->soundset3_s.Len() <= 0)
		{
			mediaactive[3] = false;
			iActiveMedia++;
		}
		if (edit_grideleprof->soundset5_s.Len() <= 0)
		{
			mediaactive[4] = false;
			iActiveMedia++;
		}
		if (edit_grideleprof->soundset6_s.Len() <= 0)
		{
			mediaactive[5] = false;
			iActiveMedia++;
		}
	}
	
	// Sound
	if (t.tflagsound == 1 || t.tflagsoundset == 1 || tflagtext == 1 || tflagimage == 1)
	{
		cstr group_text;
		if (tflagtext == 1 || tflagimage == 1)
		{
			if (tflagtext == 1) group_text = "Text";
			if (tflagimage == 1) group_text = "Image";
		}
		else
		{
			group_text = "Media";
		}


		//ImGui::TextCenter(group_text.Get());

		if (g.fpgcgenre == 1)
		{
			if (t.entityprofile[entid].ischaracter > 0)
			{
				if(mediaactive[0])
					edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Sound0", t.strarr_s[254].Get(), "audiobank\\",readonly);
			}
			else
			{
				if (g.vrqcontrolmode != 0)
				{
					if (t.tflagsound == 1 && t.tflagsoundset != 1)
					{
						//PE: changed from 469 to 467 , should be sound0
						if(mediaactive[0])
							edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\",readonly);
					}
				}
				else
				{
					if (t.tflagsound == 1 && t.tflagsoundset != 1)
					{
						if (mediaactive[0])
							edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\",readonly);
					}
				}
				if (t.tflagsoundset == 1)
				{
					if (mediaactive[0])
						edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[469].Get(), t.strarr_s[255].Get(), "audiobank\\voices\\",readonly);
				}
				if (tflagtext == 1)
				{
					if (mediaactive[0])
						edit_grideleprof->soundset_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Text to Appear", "Enter text to appear in-game",readonly);
				}
				if (tflagimage == 1)
				{
					if (mediaactive[0])
					{
#ifdef WICKEDENGINE
						#define IMGFILEID (PROPERTIES_CACHE_ICONS+998)
						static cstr imgfile = "";
						static int imgfile_preview_id = 0;
						if (edit_grideleprof->soundset_s != imgfile)
						{
							//Load new image preview.
							imgfile_preview_id = 0;
							if (edit_grideleprof->soundset_s != "")
							{
								image_setlegacyimageloading(true);
								LoadImage((char *)edit_grideleprof->soundset_s.Get(), IMGFILEID);
								image_setlegacyimageloading(false);
								imgfile_preview_id = IMGFILEID;
								if (!GetImageExistEx(IMGFILEID))
								{
									imgfile_preview_id = 0;
								}
							}
							imgfile = edit_grideleprof->soundset_s;
						}

						edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Image File", "Select image to appear in-game", "imagebank\\", readonly);

						if (imgfile_preview_id > 0 && GetImageExistEx(imgfile_preview_id))
						{
							float w = ImGui::GetContentRegionAvailWidth();
							float iwidth = w;
							float ImgW = ImageWidth(imgfile_preview_id);
							float ImgH = ImageHeight(imgfile_preview_id);
							float fHighRatio = ImgH / ImgW;
							ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (iwidth*0.5), 0.0f));
							ImGui::ImgBtn(imgfile_preview_id, ImVec2(iwidth - 18.0f, (iwidth - 18.0f) * fHighRatio), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
						}
						#else
						edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Image File", "Select image to appear in-game", "scriptbank\\images\\imagesinzone\\", readonly);
						#endif
					}
				}
			}

			if (t.tflagnosecond == 0)
			{
				if (t.tflagsound == 1 || t.tflagsoundset == 1)
				{
					//We got some missing translations.
					if (t.strarr_s[468] == "") t.strarr_s[468] = "Sound1";
					if (t.strarr_s[480] == "") t.strarr_s[480] = "Sound2";
					if (t.strarr_s[481] == "") t.strarr_s[481] = "Sound3";
					if (t.strarr_s[482] == "") t.strarr_s[482] = "Sound4";
					if (mediaactive[1])
						edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), t.strarr_s[468].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly);
					if (mediaactive[2])
						edit_grideleprof->soundset2_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset2_s.Get(), t.strarr_s[480].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly);
					if (mediaactive[3])
						edit_grideleprof->soundset3_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset3_s.Get(), t.strarr_s[481].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly);
					if (mediaactive[4])
						edit_grideleprof->soundset5_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset5_s.Get(), t.strarr_s[482].Get(), t.strarr_s[254].Get(), "audiobank\\", readonly);
					if (mediaactive[5])
						edit_grideleprof->soundset6_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset6_s.Get(), "Sound5", t.strarr_s[254].Get(), "audiobank\\", readonly);
				}
			}
		}
		else
		{
			if (t.tflagsoundset == 1)
			{
				if (mediaactive[0])
					edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[469].Get(), t.strarr_s[255].Get(), "audiobank\\voices\\",readonly);
			}
			else
			{
				if (mediaactive[0])
					edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\",readonly); ++t.controlindex;
			}
			if (mediaactive[1])
				edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), t.strarr_s[468].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly); ++t.controlindex;
		}

	}

	// Video
	if (t.tflagvideo == 1)
	{
		//t.strarr_s[597].Get()
		if (mediaactive[1])
			edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), "Video Slot", t.strarr_s[601].Get(), "videobank\\",readonly);
	}

	if (readonly)
	{
		ImGui::PopItemFlag();
		ImGui::PopStyleVar();
	}
}

void DisplayFPEPhysics(bool readonly, int entid, entityeleproftype *edit_grideleprof)
{
	if (readonly)
	{
		ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
		ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
	}

	if (!edit_grideleprof)
	{
		edit_grideleprof = &t.grideleprof;
	}

	//Physics
	cstr desc ="";
	if (t.entityprofile[entid].ismarker == 0 && t.entityprofile[entid].islightmarker == 0)
	{
		ImGui::PushItemWidth(-10);

		//t.strarr_s[596].Get()
		//ImGui::TextCenter(t.strarr_s[596].Get());
		if (edit_grideleprof->physics != 1)  edit_grideleprof->physics = 0;

		//t.grideleprof.physics = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.physics), t.strarr_s[580].Get(), t.strarr_s[581].Get(), 0);
		bool btmp = edit_grideleprof->physics;
		ImGui::Checkbox("Object Uses Physics?", &btmp);
		edit_grideleprof->physics = btmp;
		desc = t.strarr_s[581];
		if (ImGui::IsItemHovered() && desc.Len() > 0)
		{
			//When using checkbox, change text.
			std::string newtext = desc.Get();
			replaceAll(newtext, "Set to YES", "If set");
			replaceAll(newtext, " to YES", "");
			ImGui::SetTooltip("%s", newtext.c_str());
		}

		btmp = edit_grideleprof->phyalways;
		ImGui::Checkbox("Always Active?", &btmp);
		edit_grideleprof->phyalways = btmp;
		desc = t.strarr_s[583];
		if (ImGui::IsItemHovered() && desc.Len() > 0)
		{
			//When using checkbox, change text.
			std::string newtext = desc.Get();
			replaceAll(newtext, "Set to YES", "If set");
			replaceAll(newtext, " to YES", "");
			ImGui::SetTooltip("%s", newtext.c_str());
		}

		//t.grideleprof.phyweight = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.phyweight), t.strarr_s[584].Get(), t.strarr_s[585].Get()));
		ImGui::TextCenter("Weight of Object");
		desc = t.strarr_s[585];
		ImGui::MaxSliderInputInt("##weightphysics", &edit_grideleprof->phyweight, 0, 1000, desc.Get());
		
		// ZJ: Replaced with updated gadget style (above).
		//ImGui::SliderInt("##weightphysics", &edit_grideleprof->phyweight, 0, 1000);
		//if (ImGui::IsItemHovered() && desc.Len() > 0) ImGui::SetTooltip("%s", desc.Get());

		//t.grideleprof.phyfriction = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.phyfriction), t.strarr_s[586].Get(), t.strarr_s[587].Get()));
		ImGui::TextCenter("Object's Friction");
		desc = t.strarr_s[587];
		ImGui::MaxSliderInputInt("##frictionphysics", &edit_grideleprof->phyfriction, 0, 1000, desc.Get());
		
		// ZJ: Replaced with updated gadget style (above).
		//ImGui::SliderInt("##frictionphysics", &edit_grideleprof->phyfriction, 0, 1000);
		//if (ImGui::IsItemHovered() && desc.Len() > 0) ImGui::SetTooltip("%s", desc.Get());

		//`setpropertystring2(group,Str(grideleprof.phyforcedamage),strarr$(588),strarr$(589)) ; inc controlindex
		//`setpropertystring2(group,Str(grideleprof.rotatethrow),strarr$(590),strarr$(591)) ; inc controlindex

		if (t.tflagsimpler == 0)
		{
			//t.grideleprof.explodable = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.explodable), t.strarr_s[592].Get(), t.strarr_s[593].Get(), 0);
			btmp = edit_grideleprof->explodable;
			ImGui::Checkbox("Explodable Object?", &btmp);
			edit_grideleprof->explodable = btmp;
			desc = t.strarr_s[593];
			if (ImGui::IsItemHovered() && desc.Len() > 0)
			{
				//When using checkbox, change text.
				std::string newtext = desc.Get();
				replaceAll(newtext, "Set to YES", "If set");
				replaceAll(newtext, " to YES", "");
				ImGui::SetTooltip("%s", newtext.c_str());
			}

			//t.grideleprof.explodedamage = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.explodedamage), t.strarr_s[594].Get(), t.strarr_s[595].Get()));
			ImGui::TextCenter("Explosion Damage");
			desc = t.strarr_s[595];
			ImGui::MaxSliderInputInt("##damagephysics", &edit_grideleprof->explodedamage, 0, 1000, desc.Get());
			
			// ZJ: Replaced with updated gadget style (above).
			//ImGui::SliderInt("##damagephysics", &edit_grideleprof->explodedamage, 0, 500);
			//if (ImGui::IsItemHovered() && desc.Len() > 0) ImGui::SetTooltip("%s", desc.Get());
		}

		ImGui::PopItemWidth();
	}

	if (readonly)
	{
		ImGui::PopItemFlag();
		ImGui::PopStyleVar();
	}
}

void gridedit_makelighthybrid ( void )
{
	// create a single object that has multiple meshes inside it to represent different light types
	LPSTR pHybridLightModel = "entitybank\\_markers\\hybridlight.dbo";
	if (FileExist(pHybridLightModel) == 0)
	{
		// load in point light
		LoadObject ("entitybank\\_markers\\light.dbo", g.tempobjectoffset+0);
		RotateLimb(g.tempobjectoffset + 0, 0, 90, 0, 0);

		// load in spot light
		LoadObject ("entitybank\\_markers\\spotlight.dbo", g.tempobjectoffset+1);
		RotateObject(g.tempobjectoffset + 1, -90, 0, 0);
		MakeMeshFromObject(g.tempobjectoffset + 1, g.tempobjectoffset + 1);

		// add spot to point
		sObject* pObject = GetObjectData(g.tempobjectoffset+0);
		int iFrameCount = pObject->iFrameCount;
		AddLimb(g.tempobjectoffset+0, iFrameCount, g.tempobjectoffset + 1);

		// remove unneeded resources
		DeleteMesh(g.tempobjectoffset + 1);
		DeleteObject(g.tempobjectoffset + 1);

		//PE: saved object only have 3 frames ?
		// save new hybrid light for use by all new light markers
		SaveObject (pHybridLightModel, g.tempobjectoffset);
	}
}

entityeleproftype *lua_grideleprof;
entityeleproftype lua_readonly_grideleprof; //Temp for readonly dynamic lua parsing.

void DisplayFPEBehavior( bool readonly, int entid, entityeleproftype *edit_grideleprof, int elementID)
{
	//FPE Properties.
	bool bDisplaySmallIcon = false;
	bool bDisplayName = false;
	static int fpe_current_selected_script = 0;
	static bool fpe_current_loaded_script_has_dlua = false;
	int media_icon_size = 64;
	LPSTR pAIRoot = "scriptbank\\";

	if (readonly)
	{
		ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
		ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
	}

	if (readonly)
		lua_grideleprof = &lua_readonly_grideleprof;
	else {
		if (!edit_grideleprof)
			lua_grideleprof = &t.grideleprof;
		else
			lua_grideleprof = edit_grideleprof;
	}

	if (!edit_grideleprof)
	{
		edit_grideleprof = &t.grideleprof;
	}

	if (t.tflagai == 1)
	{
		if (g.quickparentalcontrolmode == 2)
		{
			if (t.entityprofile[entid].ismarker == 0)
			{
				if (t.tflagchar == 1)
					pAIRoot = "scriptbank\\people\\";
				else
					pAIRoot = "scriptbank\\objects\\";
			}
			else
			{
				pAIRoot = "scriptbank\\markers\\";
			}
		}
	}

	fPropertiesColoumWidth = ImGui::GetCursorPosX() + 90.0f;

	#ifdef USENEWMEDIASELECTWINDOWS
	char cDisplayName[MAX_PATH];
	strcpy(cDisplayName, edit_grideleprof->aimain_s.Get());
	char * find = (char *)pestrcasestr(cDisplayName, "\\");
	while (find)
	{
		find++;
		strcpy(cDisplayName, find);
		find = (char *)pestrcasestr(cDisplayName, "\\");
	}
	// special format for LUA titles
	FormatLUAFilenameToTitle(cDisplayName);
	#endif

	if (t.entityprofile[entid].ischaracter > 0)
	{
		//"Character Properties"
		if (bDisplaySmallIcon)
		{
			//Display icon.
			if (t.entityprofile[entid].iThumbnailSmall > 0) {
				float w = ImGui::GetContentRegionAvailWidth();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (media_icon_size*0.5), 0.0f));
				ImGui::ImgBtn(t.entityprofile[entid].iThumbnailSmall, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
			}
		}
		//Display name.
		if(bDisplayName)
			edit_grideleprof->name_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->name_s.Get(), "Name", t.strarr_s[204].Get(), readonly);


		int speech_entries = 0;
		bool bUpdateMainString = false;

		for (int speech_loop = 0; speech_loop < 5; speech_loop++)
			speech_ids[speech_loop] = -1;
		
		//"Character Behavior"
		//ImGui::TextCenter("Behaviors");

		ImGui::PushItemWidth(-10);

		// scan PEOPLE folder for complete list of script
		std::vector<cstr> scriptList_s; scriptList_s.clear();
		std::vector<cstr> scriptListTitle_s; scriptListTitle_s.clear();
		cstr oldDir_s = GetDir();
		SetDir(g.fpscrootdir_s.Get());
		SetDir("Files\\scriptbank\\people");
		ChecklistForFiles();
		for (int f = 1; f <= ChecklistQuantity(); f++)
		{
			cstr tfile_s = ChecklistString(f);
			LPSTR pFilename = tfile_s.Get();
			if (tfile_s != "." && tfile_s != "..")
			{
				if (strnicmp(pFilename + strlen(pFilename) - 4, ".lua", 4) == NULL)
				{
					// create a readable title from file
					char pTitleName[256];
					strcpy(pTitleName, pFilename);
					pTitleName[strlen(pTitleName) - 4] = 0;
					for (int n = 0; n < strlen(pTitleName); n++)
					{
						if (n == 0)
						{
							if (pTitleName[n] >= 'a' && pTitleName[n] <= 'z')
								pTitleName[n] -= ('a' - 'A');
						}
						else
						{
							if (pTitleName[n] >= 'A' && pTitleName[n] <= 'Z')
								pTitleName[n] += ('a' - 'A');
						}
						if (pTitleName[n] == '_') pTitleName[n] = ' ';
					}

					// add script and title to list
					scriptList_s.push_back(cstr("people\\") + tfile_s);
					scriptListTitle_s.push_back(cstr(pTitleName));
				}
			}
		}
		scriptList_s.push_back(cstr(""));
		scriptListTitle_s.push_back(cstr("Custom"));
		SetDir(oldDir_s.Get());

		// and create items list
		static int g_scriptpeople_item_count = 0;
		static char** g_scriptpeople_items = NULL;
		if (g_scriptpeople_item_count != scriptList_s.size())
		{
			if (g_scriptpeople_items)
			{
				for (int i = 0; i < g_scriptpeople_item_count; i++) SAFE_DELETE(g_scriptpeople_items[i]);
				SAFE_DELETE(g_scriptpeople_items);
			}
			g_scriptpeople_item_count = scriptList_s.size();
			g_scriptpeople_items = new char*[g_scriptpeople_item_count];
			for (int i = 0; i < g_scriptpeople_item_count; i++)
			{
				g_scriptpeople_items[i] = new char[256];
				strcpy(g_scriptpeople_items[i], scriptListTitle_s[i].Get());
			}
		}

		int item_current_type_selection = g_scriptpeople_item_count - 1; //Default Custom.
		for (int i = 0; i < g_scriptpeople_item_count - 1; i++)
		{
			if (pestrcasestr(edit_grideleprof->aimain_s.Get(), scriptList_s[i].Get()))
			{
				item_current_type_selection = i;
				break;
			}
		}

		if (fpe_current_loaded_script != item_current_type_selection)
		{
			//Load in lua and check for custom properties.
			cstr script_name = "scriptbank\\";
			if (item_current_type_selection < g_scriptpeople_item_count - 1)
				script_name += (char *)scriptList_s[item_current_type_selection].Get();
			else
				script_name += edit_grideleprof->aimain_s;

			#ifdef USENEWMEDIASELECTWINDOWS
			fpe_current_loaded_script_image = PROPERTIES_CACHE_ICONS + fpe_current_loaded_script_image_count;
			if (fpe_current_loaded_script_image_count++ > 10) fpe_current_loaded_script_image_count = 0; //Make sure we dont have a old image already displayed inside imgui.
			std::string sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
			if (pref.current_style == 25 || pref.current_style == 3)
				sImgName += ".png";
			else
				sImgName += "2.png";
			image_setlegacyimageloading(true);
			LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
			image_setlegacyimageloading(false);
			if (!GetImageExistEx(fpe_current_loaded_script_image))
			{
				if (!(pref.current_style == 25 || pref.current_style == 3))
				{
					sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
					sImgName += ".png";
					image_setlegacyimageloading(true);
					LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
					image_setlegacyimageloading(false);
					if (!GetImageExistEx(fpe_current_loaded_script_image))
					{
						fpe_current_loaded_script_image = FILETYPE_SCRIPT;
					}
				}
				else
					fpe_current_loaded_script_image = FILETYPE_SCRIPT;
			}
			#endif

			//Try to parse script.
			int iObjID = t.entityelement[elementID].obj;
			if (iObjID == 0 && t.gridentityobj>0) iObjID = t.gridentityobj;
			ParseLuaScriptWithElementID(lua_grideleprof, script_name.Get(), iObjID);
			fpe_current_loaded_script = item_current_type_selection;

			if (lua_grideleprof->PropertiesVariableActive == 1)
			{
				bUpdateMainString = true;
				fpe_current_loaded_script_has_dlua = true;
			}
			else
			{
				if (fpe_current_loaded_script_has_dlua)
				{
					//Reset t.grideleprof.soundset4_s that contain the dlua calls.
					lua_grideleprof->soundset4_s = "";
					fpe_current_loaded_script_has_dlua = false;
				}
			}
		}

		#ifdef USENEWMEDIASELECTWINDOWS
		float w = ImGui::GetContentRegionAvailWidth() - 16.0f;
		float ImgW = ImageWidth(fpe_current_loaded_script_image);
		float ImgH = ImageHeight(fpe_current_loaded_script_image);
		float fRatio = w/ImgW;

		ImGuiWindow* window = ImGui::GetCurrentWindow();
		if (iSelectedLibraryStingReturnID == window->GetID("ScriptSelector##+"))
		{
			//Update Script.
			if (sSelectedLibrarySting != "")
			{
				if ( stricmp (edit_grideleprof->aimain_s.Get(), sSelectedLibrarySting.Get()) != NULL )
				{
					// changed behavior of object, ensure any behavior specific properties are cleared (as they cannot be set if new behavior does not expose them)
					edit_grideleprof->overrideanimset_s = "";
					edit_grideleprof->hasweapon_s = t.entityprofile[entid].hasweapon_s;
					edit_grideleprof->hasweapon = 0;
					extern bool g_bNowPopulateWithCorrectAnimSet;			
					g_bNowPopulateWithCorrectAnimSet = true;
				}
				edit_grideleprof->aimain_s = sSelectedLibrarySting;
				sSelectedLibrarySting = "";
				iSelectedLibraryStingReturnID = -1; //disable.
				fpe_current_loaded_script = -1; //Reload image and DLUA.
			}
		}
		if (ImGui::ImgBtn(fpe_current_loaded_script_image, ImVec2(ImgW*fRatio, ImgH*fRatio), drawCol_black, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, false))
		{
			//Select script.
			sStartLibrarySearchString = "People";
			iLastDisplayLibraryType = -1;
			bExternal_Entities_Window = true;
			iDisplayLibraryType = 4;
			iLibraryStingReturnToID = window->GetID("ScriptSelector##+");
			if (edit_grideleprof->aimain_s.Len() > 0)
				sMakeDefaultSelecting = edit_grideleprof->aimain_s;

		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Character Behavior");

		ImGui::TextCenter(cDisplayName);

		#else
		if (ImGui::Combo("##BehavioursSimpleInput", &item_current_type_selection, g_scriptpeople_items, g_scriptpeople_item_count, 20))
		{
			if (item_current_type_selection < g_scriptpeople_item_count - 1)
			{
				edit_grideleprof->aimain_s = scriptList_s[item_current_type_selection].Get();
			}
			else
			{
				edit_grideleprof->aimain_s = "";
			}
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Character Behavior");
		#endif

		ImGui::PopItemWidth();

		#ifndef USENEWMEDIASELECTWINDOWS
		if (item_current_type_selection == g_scriptpeople_item_count - 1)
		{
			//Custom script , display directly.
			std::string ms = t.strarr_s[417].Get();
			ms = "Script";
			cstr aim = edit_grideleprof->aimain_s;
			edit_grideleprof->aimain_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->aimain_s.Get(), (char *)ms.c_str(), t.strarr_s[207].Get(), pAIRoot,readonly);
			if (aim != edit_grideleprof->aimain_s)
				fpe_current_loaded_script = -1;
		}
		#endif

		if (lua_grideleprof->PropertiesVariableActive == 1) 
		{
			speech_entries = DisplayLuaDescription(lua_grideleprof);
		}
		else 
		{
			if (lua_grideleprof->PropertiesVariable.VariableDescription.Len() > 0) 
			{
				if(edit_grideleprof->aimain_s != "default.lua") //No need to display.
					DisplayLuaDescriptionOnly(lua_grideleprof);
			}
		}

		#ifdef WICKEDENGINE
		bool bUseSoundVariants = lua_grideleprof->iUseSoundVariants;
		if (ImGui::Checkbox("Use Sound Variants", &bUseSoundVariants))
		{
			lua_grideleprof->iUseSoundVariants = bUseSoundVariants;
		}
		
		#endif

		if (speech_entries > 0)
		{
			//@Lee all SPEECH control is moved to this function.
			//PE: need this to point to lua_grideleprof.
			SpeechControls(speech_entries, bUpdateMainString, edit_grideleprof);
		}

		// removed from MAX, we want all pertinant values through the DLUA system!
		#ifndef WICKEDENGINE
		ImGui::TextCenter("Move Speed");
		ImGui::PushItemWidth(-10);
		//ImGui::SliderInt("##Movement SpeedSimpleInput", &edit_grideleprof->speed, 1, 500);
		ImGui::MaxSliderInputInt("##Movement SpeedSimpleInput", &edit_grideleprof->speed, 1, 500, "Set Movement Speed");
		//if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set Movement Speed");
		if (t.playercontrol.thirdperson.enabled == 1) t.tanimspeed_f = t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed;
		else t.tanimspeed_f = edit_grideleprof->animspeed;
		ImGui::PopItemWidth();
		ImGui::TextCenter("Anim Speed");
		ImGui::PushItemWidth(-10);
		int tmpint = t.tanimspeed_f;
		//ImGui::SliderInt("##Animation SpeedSimpleInput", &tmpint, 1, 500);
		ImGui::MaxSliderInputInt("##Animatin SpeedSimpleInput", &tmpint, 1, 500, "Set Animation Speed");
		//if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set Animation Speed");
		t.tanimspeed_f = tmpint;
		ImGui::PopItemWidth();
		if (t.playercontrol.thirdperson.enabled == 1) t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed = t.tanimspeed_f;
		else edit_grideleprof->animspeed = t.tanimspeed_f;
		#endif
	}
	else if (t.tflaglight == 1)
	{
		bool bLightChanged = false;
		bool bLightTypeChanged = false;
		bool bNoLightRotate = false;
		bool bUpdateMainString = false;
		int speech_entries = 0;

		#ifdef WICKEDENGINE

		//PE: Add dynamic lua to the light.
		static cstr current_loaded_script = "";
		if (fpe_current_loaded_script == -1 || current_loaded_script != edit_grideleprof->aimain_s)
		{
			//Load in lua and check for custom properties.
			cstr script_name = "scriptbank\\";
			script_name += edit_grideleprof->aimain_s;

			fpe_current_loaded_script = 9999;
			current_loaded_script = edit_grideleprof->aimain_s;

			#ifdef USENEWMEDIASELECTWINDOWS
			fpe_current_loaded_script_image = PROPERTIES_CACHE_ICONS + fpe_current_loaded_script_image_count;
			if (fpe_current_loaded_script_image_count++ > 10) fpe_current_loaded_script_image_count = 0; //Make sure we dont have a old image already displayed inside imgui.
			std::string sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
			if (pref.current_style == 25 || pref.current_style == 3)
				sImgName += ".png";
			else
				sImgName += "2.png";
			image_setlegacyimageloading(true);
			LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
			image_setlegacyimageloading(false);
			if (!GetImageExistEx(fpe_current_loaded_script_image))
			{
				if (!(pref.current_style == 25 || pref.current_style == 3))
				{
					sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
					sImgName += ".png";
					image_setlegacyimageloading(true);
					LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
					image_setlegacyimageloading(false);
					if (!GetImageExistEx(fpe_current_loaded_script_image))
					{
						fpe_current_loaded_script_image = FILETYPE_SCRIPT;
					}
				}
				else
					fpe_current_loaded_script_image = FILETYPE_SCRIPT;
			}
			#endif

			//Try to parse script.

			ParseLuaScript(lua_grideleprof, script_name.Get());

			if (lua_grideleprof->PropertiesVariableActive == 1)
			{
				bUpdateMainString = true;
				fpe_current_loaded_script_has_dlua = true;
			}
			else
			{
				if (fpe_current_loaded_script_has_dlua)
				{
					//Reset t.grideleprof.soundset4_s that contain the dlua calls.
					lua_grideleprof->soundset4_s = "";
					fpe_current_loaded_script_has_dlua = false;
				}
			}
		}
		//END DLUA.

		#endif

		//Display icon.
		if (bDisplaySmallIcon)
		{
			if (t.entityprofile[entid].iThumbnailSmall > 0) {
				float w = ImGui::GetContentRegionAvailWidth();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (media_icon_size*0.5), 0.0f));
				ImGui::ImgBtn(t.entityprofile[entid].iThumbnailSmall, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
			}
		}

		//#########################################
		//#### Display predefined light setup. ####
		//#########################################

		//Palette.
		#define MAXPREDEFINEDSETUPS 32
		#define LIGHTTYPEPOINT 0
		#define LIGHTTYPESPOT 1
		static bool PredefinedLightInit = false;
		static int iPredefinedLights = 16;
		int iPredefinedSetups = 16;
		static ImVec4 vPredefined_Light_Palette[MAXPREDEFINEDSETUPS];
		static int iPredefined_Light_Type[MAXPREDEFINEDSETUPS];
		static int iPredefined_Light_Range[MAXPREDEFINEDSETUPS];
		static float fPredefined_Light_ProbeScale[MAXPREDEFINEDSETUPS];

		static int iPredefined_Light_Radius[MAXPREDEFINEDSETUPS];
		static float fPredefined_Light_AngX[MAXPREDEFINEDSETUPS];
		static float fPredefined_Light_AngY[MAXPREDEFINEDSETUPS];
		static float fPredefined_Light_AngZ[MAXPREDEFINEDSETUPS];

		static int current_light_selected = -1;
		static bool bSetUpDefaultPAletteWithDefaultColors = true;
		static bool bFirstTimeInFindBestChoice = false;
		static int iLastEntityElementIDHere = -1;
		if (elementID != iLastEntityElementIDHere)
		{
			iLastEntityElementIDHere = elementID;
			bFirstTimeInFindBestChoice = true;
		}

		float fOne = 1.0f / 255.0f;
		if (!PredefinedLightInit)
		{
			// Mix POINT , SPOT with same palette
			if (bSetUpDefaultPAletteWithDefaultColors == true)
			{
				for (int i = 0; i < 16;i++)
				{
					fPredefined_Light_ProbeScale[i] = 2.0f; //PE: Was 1
					iPredefined_Light_Radius[i] = 45;
					fPredefined_Light_AngX[i] = 90;
					fPredefined_Light_AngY[i] = 0;
					fPredefined_Light_AngZ[i] = 0;
				}
				bSetUpDefaultPAletteWithDefaultColors = false;
				vPredefined_Light_Palette[0] = ImVec4(255 * fOne, 255 * fOne, 255 * fOne, 1.0f);
				iPredefined_Light_Type[0] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[0] = 300.0f / 3.0;

				vPredefined_Light_Palette[1] = ImVec4(255 * fOne, 255 * fOne, 255 * fOne, 1.0f);
				iPredefined_Light_Type[1] = LIGHTTYPESPOT;
				iPredefined_Light_Range[1] = 600.0f / 3.0;
				fPredefined_Light_AngX[1] = 45;

				vPredefined_Light_Palette[2] = ImVec4(110.0f * fOne, 110.0f * fOne, 110.0f * fOne, 1.0f);
				iPredefined_Light_Type[2] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[2] = 300.0f / 3.0;

				vPredefined_Light_Palette[3] = ImVec4(110.0f * fOne, 110.0f * fOne, 110.0f * fOne, 1.0f);
				iPredefined_Light_Type[3] = LIGHTTYPESPOT;
				iPredefined_Light_Range[3] = 600.0f / 3.0;
				fPredefined_Light_AngX[3] = 45;

				vPredefined_Light_Palette[4] = ImVec4(78 * fOne, 144 * fOne, 236 * fOne, 1.0f);
				iPredefined_Light_Type[4] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[4] = 300.0f / 3.0;

				vPredefined_Light_Palette[5] = ImVec4(78 * fOne, 144 * fOne, 236 * fOne, 1.0f);
				iPredefined_Light_Type[5] = LIGHTTYPESPOT;
				iPredefined_Light_Range[5] = 600.0f / 3.0;
				fPredefined_Light_AngX[5] = 45;

				vPredefined_Light_Palette[6] = ImVec4(192 * fOne, 73 * fOne, 223 * fOne, 1.0f);
				iPredefined_Light_Type[6] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[6] = 300.0f / 3.0;

				vPredefined_Light_Palette[7] = ImVec4(192 * fOne, 73 * fOne, 223 * fOne, 1.0f);
				iPredefined_Light_Type[7] = LIGHTTYPESPOT;
				iPredefined_Light_Range[7] = 600.0f / 3.0;
				fPredefined_Light_AngX[7] = 45;

				vPredefined_Light_Palette[8] = ImVec4(224 * fOne, 50 * fOne, 42 * fOne, 1.0f);
				iPredefined_Light_Type[8] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[8] = 300.0f / 3.0;

				vPredefined_Light_Palette[9] = ImVec4(224 * fOne, 50 * fOne, 42 * fOne, 1.0f);
				iPredefined_Light_Type[9] = LIGHTTYPESPOT;
				iPredefined_Light_Range[9] = 600.0f / 3.0;
				fPredefined_Light_AngX[9] = 45;

				vPredefined_Light_Palette[10] = ImVec4(245 * fOne, 234 * fOne, 65 * fOne, 1.0f);
				iPredefined_Light_Type[10] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[10] = 300.0f / 3.0;

				vPredefined_Light_Palette[11] = ImVec4(245 * fOne, 234 * fOne, 65 * fOne, 1.0f);
				iPredefined_Light_Type[11] = LIGHTTYPESPOT;
				iPredefined_Light_Range[11] = 600.0f / 3.0;
				fPredefined_Light_AngX[11] = 45;

				vPredefined_Light_Palette[12] = ImVec4(0 * fOne, 207 * fOne, 99 * fOne, 1.0f);
				iPredefined_Light_Type[12] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[12] = 300.0f / 3.0;

				vPredefined_Light_Palette[13] = ImVec4(0 * fOne, 207 * fOne, 99 * fOne, 1.0f);
				iPredefined_Light_Type[13] = LIGHTTYPESPOT;
				iPredefined_Light_Range[13] = 600.0f / 3.0;
				fPredefined_Light_AngX[13] = 45;

				vPredefined_Light_Palette[14] = ImVec4(250 * fOne, 168 * fOne, 50 * fOne, 1.0f);
				iPredefined_Light_Type[14] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[14] = 300.0f / 3.0;

				vPredefined_Light_Palette[15] = ImVec4(250 * fOne, 168 * fOne, 50 * fOne, 1.0f);
				iPredefined_Light_Type[15] = LIGHTTYPESPOT;
				iPredefined_Light_Range[15] = 600.0f / 3.0;
				fPredefined_Light_AngX[15] = 45;

			}
			iPredefinedSetups = 16;
			iPredefinedLights = 16;

			//Pack all colors to the top of the list.
			int iDest = 0;
			for (int il = 0;il < 16; il++)
			{
				if (pref.iSaved_Light_Type[il] != -1)
				{
					pref.iSaved_Light_Type[iDest] = pref.iSaved_Light_Type[il];
					pref.vSaved_Light_Palette_R[iDest] = pref.vSaved_Light_Palette_R[il];
					pref.vSaved_Light_Palette_G[iDest] = pref.vSaved_Light_Palette_G[il];
					pref.vSaved_Light_Palette_B[iDest] = pref.vSaved_Light_Palette_B[il];
					pref.iSaved_Light_Range[iDest] = pref.iSaved_Light_Range[il];
					pref.fSaved_Light_ProbeScale[iDest] = pref.fSaved_Light_ProbeScale[il];

					pref.iSaved_Light_Radius[iDest] = pref.iSaved_Light_Radius[il];
					pref.fSaved_Light_AngX[iDest] = pref.fSaved_Light_AngX[il];
					pref.fSaved_Light_AngY[iDest] = pref.fSaved_Light_AngY[il];
					pref.fSaved_Light_AngZ[iDest] = pref.fSaved_Light_AngZ[il];

					if (il > iDest) pref.iSaved_Light_Type[il] = -1;
					iDest++;
				}
			}
			for (int il = 0;il < 16; il++)
			{
				if (pref.iSaved_Light_Type[il] != -1)
				{
					vPredefined_Light_Palette[iPredefinedLights] = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
					vPredefined_Light_Palette[iPredefinedLights].x = pref.vSaved_Light_Palette_R[il];
					vPredefined_Light_Palette[iPredefinedLights].y = pref.vSaved_Light_Palette_G[il];
					vPredefined_Light_Palette[iPredefinedLights].z = pref.vSaved_Light_Palette_B[il];
					iPredefined_Light_Type[iPredefinedLights] = pref.iSaved_Light_Type[il];
					iPredefined_Light_Range[iPredefinedLights] = pref.iSaved_Light_Range[il];
					fPredefined_Light_ProbeScale[iPredefinedLights] = pref.fSaved_Light_ProbeScale[il];

					iPredefined_Light_Radius[iPredefinedLights] = pref.iSaved_Light_Radius[il];
					fPredefined_Light_AngX[iPredefinedLights] = pref.fSaved_Light_AngX[il];
					fPredefined_Light_AngY[iPredefinedLights] = pref.fSaved_Light_AngY[il];
					fPredefined_Light_AngZ[iPredefinedLights] = pref.fSaved_Light_AngZ[il];

					iPredefinedLights++;
				}
			}
			current_light_selected = -1;
			PredefinedLightInit = true;
		}

		// LB: this starts the picking of the best index (if any)
		if (bFirstTimeInFindBestChoice == true)
			current_light_selected = -1;

		int light_icons_columns = 4;
		float light_w = ImGui::GetContentRegionAvailWidth() - 10.0f;
		float light_image_size = light_w / (float)light_icons_columns;
		light_image_size -= ((2.0f) * light_icons_columns) - 2.0f;
		ImVec4 IconColor = { 1.0f,1.0f,1.0f,1.0f };
		int iSelections = 0;

		#ifdef INCLUDEPREDEFINEDLIGHTS

		for (int i = 0; i < iPredefinedLights; i++)
		{
			ImVec4 background = vPredefined_Light_Palette[i];

			int iTextureID = LIGHT_POINT;
			if (iPredefined_Light_Type[i] == LIGHTTYPESPOT) iTextureID = LIGHT_SPOT;

			ImRect image_bb;
			ImVec2 padding = { 1.0, 1.0 };
			ImGuiWindow* window = ImGui::GetCurrentWindow();
			ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];

			// LB: This picks best index
			if (bFirstTimeInFindBestChoice == true)
			{
				if (edit_grideleprof->usespotlighting == iPredefined_Light_Type[i] &&
					edit_grideleprof->light.range == iPredefined_Light_Range[i] &&
					edit_grideleprof->light.fLightHasProbe == fPredefined_Light_ProbeScale[i])
				{
					DWORD color = 0xff000000 + ((unsigned int)(vPredefined_Light_Palette[i].x * 255.0f) << 16) + ((unsigned int)(vPredefined_Light_Palette[i].y * 255.0f) << 8) + +((unsigned int)(vPredefined_Light_Palette[i].z * 255.0f));
					if (color == edit_grideleprof->light.color)
					{
						current_light_selected = i;
						bFirstTimeInFindBestChoice = false;
					}
				}
			}

			if (current_light_selected == i)
			{
				image_bb= ImRect((window->DC.CursorPos - padding), window->DC.CursorPos + padding + ImVec2(light_image_size, light_image_size) );
			}

			ImGui::PushID(LIGHT_POINT + i);
			if (ImGui::ImgBtn(iTextureID, ImVec2(light_image_size, light_image_size), background, IconColor, ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
			{
				//change
				current_light_selected = i;

				float fr = vPredefined_Light_Palette[i].x * 255.0f;
				float fg = vPredefined_Light_Palette[i].y * 255.0f;
				float fb = vPredefined_Light_Palette[i].z * 255.0f;
				edit_grideleprof->light.color = 0xff000000 + ((unsigned int)fr << 16) + ((unsigned int)fg << 8) + +((unsigned int)fb);
				
				//edit_grideleprof->usespotlighting now follow the same types, if we should add area,sphere.
				if (edit_grideleprof->usespotlighting != iPredefined_Light_Type[i])
				{
					bLightTypeChanged = true;
					edit_grideleprof->usespotlighting = iPredefined_Light_Type[i];
				}

				edit_grideleprof->light.range = iPredefined_Light_Range[i]; //PE: Cant do it here, custom will fail. / 3.0f; // more sensible 
				edit_grideleprof->light.fLightHasProbe = fPredefined_Light_ProbeScale[i]; //PE: Cant do it here, custom will fail. *2.0f; // more sensible 

				edit_grideleprof->light.offsetup = iPredefined_Light_Radius[i];
				if (elementID > 0)
				{
					t.entityelement[elementID].rx = fPredefined_Light_AngX[i];
					t.entityelement[elementID].ry = fPredefined_Light_AngY[i];
					t.entityelement[elementID].rz = fPredefined_Light_AngZ[i];

					if (t.entityelement[elementID].obj > 0)
					{
						RotateObject(t.entityelement[elementID].obj, t.entityelement[elementID].rx, t.entityelement[elementID].ry, t.entityelement[elementID].rz);
					}

					if (g.entityrubberbandlist.size() == 0)
					{
						int iActiveObj = t.widget.activeObject;
						if (iActiveObj > 0)
						{
							RotateObject(iActiveObj, t.entityelement[elementID].rx, t.entityelement[elementID].ry, t.entityelement[elementID].rz);
							g_bRefreshRotationValuesFromObjectOnce = true;
						}
					}
					bNoLightRotate = true;
				}

				bLightChanged = true;
				g_bLightProbeScaleChanged = true;
			}
			ImGui::PopID();
			if (current_light_selected == i)
			{
				if (iSelections++ > 0)
				{
					//Mark dublicates.
					tool_selected_col.w = 0.2;
				}

				window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Light Preference");
			
			ImVec2 restore_cursorpos = ImGui::GetCursorPos();
			if ((i + 1) % light_icons_columns != 0 && i != iPredefinedLights - 1)
				ImGui::SameLine();
		}
		bFirstTimeInFindBestChoice = false;

		if (ImGui::StyleButton("Add Light", ImVec2((light_w*0.5f) - 4.0f, 0)))
		{
			ImGui::OpenPopup("##pickV2LightType");
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add a New Custom Light Using The Current Settings.");

		ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
		if (ImGui::BeginPopup("##pickV2LightType", ImGuiWindowFlags_NoMove))
		{
			float popupwidth = 224.0f;
			ImGui::SetCursorPosX(popupwidth);
			ImGui::SetCursorPosX(0.0f);

			int type_selection = edit_grideleprof->usespotlighting;
			ImVec4 background = { 0.0f,0.0f,0.0f,0.0f };
			ImRect image_bb;
			ImVec2 padding = { 1.0, 1.0 };
			ImGuiWindow* window = ImGui::GetCurrentWindow();
			ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];

			ImGui::TextCenter("Choose a Light Type");
			ImGui::Text("");
			float spacer = 64.0f;
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(spacer*0.5, 0.0f));
			if(type_selection == 0) image_bb = ImRect((window->DC.CursorPos - padding), window->DC.CursorPos + padding + ImVec2(spacer, spacer));

			if (ImGui::ImgBtn(LIGHT_POINT, ImVec2(spacer, spacer), background, IconColor, ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
			{
				edit_grideleprof->usespotlighting = 0;
				bLightTypeChanged = true;
				bLightChanged = true;
				bNoLightRotate = true;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Point Light");

			ImGui::SameLine();
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(spacer*0.5, 0.0f));
			if (type_selection != 0) image_bb = ImRect((window->DC.CursorPos - padding), window->DC.CursorPos + padding + ImVec2(spacer, spacer));
			if (ImGui::ImgBtn(LIGHT_SPOT, ImVec2(spacer, spacer), background, IconColor, ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
			{
				edit_grideleprof->usespotlighting = 1;
				bLightTypeChanged = true;
				bLightChanged = true;
				bNoLightRotate = true;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Spot Light");
			window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);

			ImGui::Text("");
			ImGui::Text("");
			if (ImGui::StyleButton("Cancel", ImVec2(96, 0)))
			{
				ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Cancel");

			ImGui::SameLine();
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(popupwidth-96-96, 0.0f));

			if (ImGui::StyleButton("Add Light", ImVec2(96, 0)))
			{
				int iFreeEntry = -1;
				bool bIsDuplicate = false;

				//Scan for dups.
				// LB: allow duplicates!!
				//for (int il = 0;il < iPredefinedLights; il++)
				//{
				//	if (edit_grideleprof->usespotlighting == iPredefined_Light_Type[il] &&
				//		edit_grideleprof->light.range == iPredefined_Light_Range[il] &&
				//		edit_grideleprof->light.fLightHasProbe == fPredefined_Light_ProbeScale[il])
				//	{
				//		DWORD color = 0xff000000 + ((unsigned int)(vPredefined_Light_Palette[il].x * 255.0f) << 16) + ((unsigned int)(vPredefined_Light_Palette[il].y * 255.0f) << 8) + +((unsigned int)(vPredefined_Light_Palette[il].z * 255.0f));
				//		if (color == edit_grideleprof->light.color)
				//		{
				//			bIsDuplicate = true;
				//			current_light_selected = il;
				//			break;
				//		}
				//	}
				//}
				if (!bIsDuplicate)
				{
					for (int il = 0;il < 16; il++)
					{
						if (pref.iSaved_Light_Type[il] == -1)
						{
							iFreeEntry = il;
							break;
						}
					}
					if (iFreeEntry != -1)
					{
						pref.vSaved_Light_Palette_R[iFreeEntry] = ((edit_grideleprof->light.color & 0x00ff0000) >> 16) / 255.0f;
						pref.vSaved_Light_Palette_G[iFreeEntry] = ((edit_grideleprof->light.color & 0x0000ff00) >> 8) / 255.0f;
						pref.vSaved_Light_Palette_B[iFreeEntry] = (edit_grideleprof->light.color & 0x000000ff) / 255.0f;
						pref.iSaved_Light_Type[iFreeEntry] = edit_grideleprof->usespotlighting;
						pref.iSaved_Light_Range[iFreeEntry] = edit_grideleprof->light.range;
						pref.fSaved_Light_ProbeScale[iFreeEntry] = edit_grideleprof->light.fLightHasProbe;
						PredefinedLightInit = false; //Setup everything again.

						pref.iSaved_Light_Radius[iFreeEntry] = edit_grideleprof->light.offsetup;
						if (elementID > 0)
						{
							pref.fSaved_Light_AngX[iFreeEntry] = t.entityelement[elementID].rx;
							pref.fSaved_Light_AngY[iFreeEntry] = t.entityelement[elementID].ry;
							pref.fSaved_Light_AngZ[iFreeEntry] = t.entityelement[elementID].rz;
						}

					}
				}
				ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add Light");

			ImGui::EndPopup();
		}

		ImGui::SameLine(); 
		bool bDisableButton = true;
		if (current_light_selected != -1 && current_light_selected > 15) bDisableButton = false;
		if (ImGui::StyleButtonEx("Delete Light", ImVec2((light_w*0.5f) - 4.0f, 0), bDisableButton))
		{
			if (current_light_selected >= iPredefinedSetups)
			{
				pref.iSaved_Light_Type[current_light_selected - iPredefinedSetups] = -1;
				PredefinedLightInit = false; //Setup everything again.
			}
		}
		if (ImGui::IsItemHovered())
		{
			if (bDisableButton == true)
				ImGui::SetTooltip("Cannot delete first 16 default lights");
			else
				ImGui::SetTooltip("Delete selected custom light");
		}

		if (ImGui::StyleButton("Reset to Default Light", ImVec2(light_w, 0)) )
		{
			current_light_selected = -1;
			//LB: Doies not reset current light, but the palette choices
			//edit_grideleprof->usespotlighting = 0;
			//edit_grideleprof->light.color = 0xffffffff;
			//edit_grideleprof->light.range = 500;
			//edit_grideleprof->light.fLightHasProbe = 1.0f;
			//if (elementID > 0)
			//{
			//	t.entityelement[elementID].rx = 0.0f;
			//	if (t.entityelement[elementID].obj > 0)
			//		RotateObject(t.entityelement[elementID].obj, t.entityelement[elementID].rx, t.entityelement[elementID].ry, t.entityelement[elementID].rz);
			//
			//	if (g.entityrubberbandlist.size() == 0)
			//	{
			//		if (t.widget.activeObject > 0)
			//		{
			//			RotateObject(t.widget.activeObject, t.entityelement[elementID].rx, t.entityelement[elementID].ry, t.entityelement[elementID].rz);
			//			g_bRefreshRotationValuesFromObjectOnce = true;
			//		}
			//	}
			//}
			bLightTypeChanged = true;
			bLightChanged = true;
			g_bLightProbeScaleChanged = true;
			bSetUpDefaultPAletteWithDefaultColors = true;
			PredefinedLightInit = false; //Setup everything again.
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Reset Light to The Default Settings");


		#endif

		//Name and color setup only.
		//ImGui::Text("");
		if(bDisplayName)
			edit_grideleprof->name_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->name_s.Get(), "Name", t.strarr_s[204].Get(),readonly);

		ImGui::TextCenter("Light Distance");

		ImGui::PushItemWidth(-10);
		if (ImGui::MaxSliderInputInt("##LightRangeSimpleInput", &edit_grideleprof->light.range, 0, 1000, t.strarr_s[250].Get()))
		{
			current_light_selected = -1;
			bLightChanged = true;
		}
		float fTmp = edit_grideleprof->light.range*100;
		//if (ImGui::MaxSliderInputFloat2("##LightRangeSimpleInput", &fTmp, 0.0f, 300000.0f, t.strarr_s[250].Get(), 0, 300000.0f, 42.0f))
		//{
		//	current_light_selected = -1;
		//	bLightChanged = true;
		//}
		//edit_grideleprof->light.range = fTmp/100.0f;
		ImGui::PopItemWidth();

		#ifdef WICKEDENGINE

		if (edit_grideleprof->usespotlighting != 0)
		{
			ImGui::TextCenter("Spotlight Radius");
			ImGui::PushItemWidth(-10);


			if (ImGui::MaxSliderInputInt("##SpotlightRangeSimpleInput", &edit_grideleprof->light.offsetup, 3, 160, "Sets the spotlight radius"))
			{
				current_light_selected = -1;
				bLightChanged = true;
			}
			//float fTmp = edit_grideleprof->light.range * 100;
			//float fRad = edit_grideleprof->light.offsetup;
			////fRad = edit_grideleprof->coneangle;
			//if (ImGui::MaxSliderInputFloat2("##SpotlightRangeSimpleInput", &fRad, 0.0f, 160.0f, "Sets the spotlight radius", 0, 160.0f, 45.0f))
			//{
			//	edit_grideleprof->light.offsetup = fRad;
			//	//edit_grideleprof->coneangle = fRad;
			//	//edit_grideleprof->coneheight = fRad;
			//	current_light_selected = -1;
			//	bLightChanged = true;
			//}
			ImGui::PopItemWidth();
		}
		
		// ZJ: Removed for now.
		//if (pref.iObjectEnableAdvanced)
		//{
		//	ImGui::TextCenter("Light Probe Scale");
		//	ImGui::PushItemWidth(-10);
		//	int iTmp = edit_grideleprof->light.fLightHasProbe;
		//	if (ImGui::MaxSliderInputInt("##fLightProbeScaleSimpleInput", &iTmp, 0, 500, "Specify the scaling of the environment probe attached to the light"))
		//	{
		//		current_light_selected = -1;
		//		bLightChanged = true;
		//		g_bLightProbeScaleChanged = true;
		//		edit_grideleprof->light.fLightHasProbe = iTmp;
		//	}
		//	//fTmp = edit_grideleprof->light.fLightHasProbe * 100;
		//	//if (ImGui::MaxSliderInputFloat2("##fLightProbeScaleSimpleInput", &fTmp, 1.0f, 500.0f, "Specify the scaling of the environment probe attached to the light", 0, 100.0f, 42.0f))
		//	//{
		//	//	// triggers probe debug to show
		//	//	current_light_selected = -1;
		//	//	g_bLightProbeScaleChanged = true;
		//	//	bLightChanged = true;
		//	//}
		//	//edit_grideleprof->light.fLightHasProbe = fTmp / 100.0f;
		//	ImGui::PopItemWidth();
		//}
		#endif

		ImGui::TextCenter("Light Color");
		float colors[5];
		colors[3] = ((edit_grideleprof->light.color & 0xff000000) >> 24) / 255.0f;
		colors[0] = ((edit_grideleprof->light.color & 0x00ff0000) >> 16) / 255.0f;
		colors[1] = ((edit_grideleprof->light.color & 0x0000ff00) >> 8) / 255.0f;
		colors[2] = (edit_grideleprof->light.color & 0x000000ff) / 255.0f;

		ImVec4 mycolor = ImVec4(colors[0], colors[1], colors[2], 1.0);
		float w = ImGui::GetContentRegionAvailWidth();
		extern bool bUseOrgHue;
		bUseOrgHue = true;
		bool open_popup = ImGui::ColorButton("##NewV2LightColor", mycolor, 0, ImVec2(w - 10.0, 0));
		if (open_popup) ImGui::OpenPopup("##pickV2LightColor");
		if (ImGui::BeginPopup("##pickV2LightColor", ImGuiWindowFlags_NoMove))
		{
			if (ImGui::ColorPicker4("##pickerV2LightColor", (float*)&mycolor, ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoSmallPreview))
			{
				//LB: team decided the select light is being actively reconfigured
				//current_light_selected = -1; (see bwlow)
				bLightChanged = true;
			}
			ImGui::EndPopup();
		}
		bUseOrgHue = false;
		colors[0] = mycolor.x * 255.0f;
		colors[1] = mycolor.y * 255.0f;
		colors[2] = mycolor.z * 255.0f;
		edit_grideleprof->light.color = 0xff000000 + ((unsigned int)colors[0] << 16) + ((unsigned int)colors[1] << 8) + +((unsigned int)colors[2]);

		ImGuiWindow* window = ImGui::GetCurrentWindow();
		void* lpTexture = GetImagePointer(TOOL_PENCIL);
		ImVec2 vDrawPos = { ImGui::GetCursorScreenPos().x + (ImGui::GetContentRegionAvail().x - 30.0f) ,ImGui::GetCursorScreenPos().y - (ImGui::GetFontSize()*1.5f) - 3.0f };
		window->DrawList->AddImage((ImTextureID)lpTexture, vDrawPos, vDrawPos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1, 1, 1, 1)));
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set Light Color");

		//LB: Grr, seems all castshadows up to now (Feb2022) are zero, and we need them to be
		// casting by default, so we will assume 'castshadow==0 or -1' is CAST and 'castshadow==1' is NO CAST
		bool bCastShadow = true;
		if (edit_grideleprof->castshadow == 1 ) bCastShadow = false;
		if (ImGui::Checkbox("Cast Shadow", &bCastShadow))
		{
			if (bCastShadow == true)
				edit_grideleprof->castshadow = -1;
			else
				edit_grideleprof->castshadow = 1;
			bLightChanged = true;
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set whether a shadow is cast");

		//LB: whatever the current palette selection, it will be changed!
		if (current_light_selected != -1)
		{
			vPredefined_Light_Palette[current_light_selected].x = mycolor.x;
			vPredefined_Light_Palette[current_light_selected].y = mycolor.y;
			vPredefined_Light_Palette[current_light_selected].z = mycolor.z;
		}

		//#### Light Behaviour ####
		ImGui::TextCenter("Light Behaviour");

		#ifdef USENEWLIGHTBEHAVIOUR
		w = ImGui::GetContentRegionAvailWidth() - 16.0f;
		float ImgW = ImageWidth(fpe_current_loaded_script_image);
		float ImgH = ImageHeight(fpe_current_loaded_script_image);
		float fRatio = w / ImgW;

		if (iSelectedLibraryStingReturnID == window->GetID("ScriptSelector##+"))
		{
			//Update Script.
			if (sSelectedLibrarySting != "")
			{
				edit_grideleprof->aimain_s = sSelectedLibrarySting;
				sSelectedLibrarySting = "";
				iSelectedLibraryStingReturnID = -1; //disable.
				fpe_current_loaded_script = -1; //Reload image and DLUA.
			}
		}
		if (ImGui::ImgBtn(fpe_current_loaded_script_image, ImVec2(ImgW*fRatio, ImgH*fRatio), drawCol_black, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, false))
		{
			//Select script.
			sStartLibrarySearchString = "Light";
			iLastDisplayLibraryType = -1;
			bExternal_Entities_Window = true;
			iDisplayLibraryType = 4;
			iLibraryStingReturnToID = window->GetID("ScriptSelector##+");
			if (edit_grideleprof->aimain_s.Len() > 0)
				sMakeDefaultSelecting = edit_grideleprof->aimain_s;

		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Light Behavior");

		ImGui::TextCenter(cDisplayName);
		#else

		//Combo light script selection.

		const char* light_behaviour[] = { "None" , "Flicker", "Strobe", "Rotate" };
		const char* light_scripts[] = { "markers\\light1.lua" , "markers\\lightflicker.lua", "markers\\lightstrobe.lua", "markers\\lightrotate.lua" };
		int iBehaviourItems = IM_ARRAYSIZE(light_behaviour);
		int current_light_behaviour = -1;
		for (int i = 0; i < iBehaviourItems; i++)
		{
			if (stricmp(light_scripts[i], edit_grideleprof->aimain_s.Get()) == 0)
			{
				current_light_behaviour = i;
				break;
			}
		}
		if (current_light_behaviour < 0) current_light_behaviour = 0; //default None.

		ImGui::PushItemWidth(-10);
		if (ImGui::Combo("##comboLightBehaviour", &current_light_behaviour, light_behaviour, iBehaviourItems))
		{
			edit_grideleprof->aimain_s = light_scripts[current_light_behaviour];
			fpe_current_loaded_script = -1; //Reload image and DLUA.
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Light Behavior");
		ImGui::PopItemWidth();
		#endif	

		if (lua_grideleprof->PropertiesVariableActive == 1) {
			speech_entries = DisplayLuaDescription(lua_grideleprof);
		}
		else
		{
			if (lua_grideleprof->PropertiesVariable.VariableDescription.Len() > 0) 
			{
				if (edit_grideleprof->aimain_s != "default.lua" )//&& edit_grideleprof->aimain_s != "markers\\light1.lua") //No need to display.
					DisplayLuaDescriptionOnly(lua_grideleprof);
			}
		}

		if (speech_entries > 0)
		{
			// all SPEECH control is moved to this function.
			SpeechControls(speech_entries, bUpdateMainString, edit_grideleprof);
		}

		// update the light live
		#ifdef WICKEDENGINE

		bool bAllowProbeUpdate = false;

		if (!readonly)
		{
			//PE: Make sure to always remove debug probe.
			if (ImGui::IsMouseDown(0) == 0 && wiRenderer::GetToDrawDebugEnvProbes())
				wiRenderer::SetToDrawDebugEnvProbes(false);

			// update light if change angles
			static float fLastLightXAngle = -1.0f;
			static float fLastLightYAngle = -1.0f;
			static float fLastLightZAngle = -1.0f;
			if (elementID > 0)
			{
				if (t.entityelement[elementID].rx != fLastLightXAngle || t.entityelement[elementID].ry != fLastLightYAngle || t.entityelement[elementID].rz != fLastLightZAngle)
				{
					fLastLightXAngle = t.entityelement[elementID].rx;
					fLastLightYAngle = t.entityelement[elementID].ry;
					fLastLightZAngle = t.entityelement[elementID].rz;
					bLightChanged = true;
				}
			}
			
			//Update light is a bit slow so...
			if (bLightChanged || g_bLightProbeScaleChanged)
			{
				int ilightIndex = 0;
				float lightx, lighty, lightz, lightax, lightay, lightaz;
				if (elementID > 0)
					ilightIndex = t.entityelement[elementID].eleprof.light.index;

				if (!bNoLightRotate && bLightTypeChanged && elementID > 0)
				{
					if (edit_grideleprof->usespotlighting == LIGHTTYPESPOT)
						t.entityelement[elementID].rx = 45.0f; //Default to 45 angle x so we can see the spot on terrain.
					else
					{
						#ifdef WICKEDENGINE
						t.entityelement[elementID].rx = 90.0f; //PE: Wicked object default to angle x 90.
						#else
						t.entityelement[elementID].rx = 0.0f;
						#endif
					}

					if (t.entityelement[elementID].obj > 0)
					{
						RotateObject(t.entityelement[elementID].obj, t.entityelement[elementID].rx, t.entityelement[elementID].ry, t.entityelement[elementID].rz);
					}

					if (g.entityrubberbandlist.size() == 0)
					{
						int iActiveObj = t.widget.activeObject;
						if (iActiveObj > 0)
						{
							RotateObject(iActiveObj, t.entityelement[elementID].rx, t.entityelement[elementID].ry, t.entityelement[elementID].rz);
							g_bRefreshRotationValuesFromObjectOnce = true;
						}
					}
				}

				if (elementID > 0 && ilightIndex > 0)
				{
					int iWickedLightIndex = t.infinilight[ilightIndex].wickedlightindex;

					if (bLightTypeChanged)
					{
						//Recreate light.
						WickedCall_DeleteLight(iWickedLightIndex);
						int iLightType = 1;
						if (edit_grideleprof->usespotlighting) iLightType = 2;
						iWickedLightIndex = WickedCall_AddLight(iLightType);
						t.infinilight[ilightIndex].wickedlightindex = iWickedLightIndex;
						bLightTypeChanged = false;
					}

					lightx = t.entityelement[elementID].x;
					lighty = t.entityelement[elementID].y;
					lightz = t.entityelement[elementID].z;
					lightax = t.entityelement[elementID].rx;
					lightay = t.entityelement[elementID].ry;
					lightaz = t.entityelement[elementID].rz;
					float lightrange = edit_grideleprof->light.range;
					float spotlightradius = edit_grideleprof->light.offsetup;
					float fLightHasProbe = edit_grideleprof->light.fLightHasProbe;
					int colr = colors[0];
					int colg = colors[1];
					int colb = colors[2];
					bool bCastShadow = true;
					if (edit_grideleprof->castshadow == 1) bCastShadow = false;

					//PE: Also update infinilight.
					t.infinilight[ilightIndex].f_angle_x = lightax;
					t.infinilight[ilightIndex].f_angle_y = lightay;
					t.infinilight[ilightIndex].f_angle_z = lightaz;
					t.infinilight[ilightIndex].x = lightx;
					t.infinilight[ilightIndex].y = lighty;
					t.infinilight[ilightIndex].z = lightz;
					t.infinilight[ilightIndex].range = lightrange;
					t.infinilight[ilightIndex].spotlightradius = spotlightradius;
					t.infinilight[ilightIndex].colrgb.r = colr;
					t.infinilight[ilightIndex].colrgb.g = colg;
					t.infinilight[ilightIndex].colrgb.b = colb;
					t.infinilight[ilightIndex].fLightHasProbe = fLightHasProbe;
					t.infinilight[ilightIndex].bCanShadow = bCastShadow;
					WickedCall_UpdateLight(iWickedLightIndex, lightx, lighty, lightz, lightax, lightay, lightaz, lightrange, spotlightradius, colr, colg, colb, bCastShadow);

					// and detect if light probe scale changes
					if (g_bLightProbeScaleChanged)
					{
						if (t.entityprofile[t.entityelement[elementID].bankindex].ismarker == 2)
						{
							float fLightProbeScale = t.entityelement[elementID].eleprof.light.fLightHasProbe;
							if (fLightProbeScale > 0)
								entity_placeprobe(t.entityelement[elementID].obj, fLightProbeScale);
							else
								entity_deleteprobe(t.entityelement[elementID].obj);
						}
						g_bLightProbeScaleChanged = false;
					}
				}
				else
				{
					if (bLightTypeChanged)
					{
						//Recreate light.
						if(t.gridentitywickedlightindex > 0)
							WickedCall_DeleteLight(t.gridentitywickedlightindex);
						t.gridentitywickedlightindex = 0;
						bLightTypeChanged = false;
					}
					if (t.gridentitywickedlightindex == 0)
					{
						int iLightType = 1;
						if (edit_grideleprof->usespotlighting) iLightType = 2;
						t.gridentitywickedlightindex = WickedCall_AddLight(iLightType);
					}
					if (t.gridentitywickedlightindex > 0)
					{
						lightx = t.gridentityposx_f;
						lighty = t.gridentityposy_f;
						lightz = t.gridentityposz_f;
						lightax = t.gridentityrotatex_f;
						lightay = t.gridentityrotatey_f;
						lightaz = t.gridentityrotatez_f;
						float lightrange = edit_grideleprof->light.range;
						float spotlightradius = edit_grideleprof->light.offsetup;
						int colr = colors[0];
						int colg = colors[1];
						int colb = colors[2];
						bool bCastShadow = true;
						if (edit_grideleprof->castshadow == 1) bCastShadow = false;
						WickedCall_UpdateLight(t.gridentitywickedlightindex, lightx, lighty, lightz, lightax, lightay, lightaz, lightrange, spotlightradius, colr, colg, colb, bCastShadow);
					}
				}

				// ensure the light object itself is updated
				int obj = t.entityelement[elementID].obj;
				entity_updatelightobj(elementID,obj);
			}
		}
		#endif

	}
	#ifdef USENEWPARTICLESETUP
	else if (t.entityprofile[entid].ismarker == 10)
	{
		//Particles.
		#define MAXPREDEFINEDPARTICLESETUPS 32

		static bool bPredefinedParticleInit = false;

		static int iPredefinedParticles = 9;
		int iPredefinedParticleSetups = 9;
		static cstr Predefined_Particle_Name[MAXPREDEFINEDPARTICLESETUPS];
		static int Predefined_Particle_Image[MAXPREDEFINEDPARTICLESETUPS];
		static bool Predefined_bParticle_Preview[MAXPREDEFINEDPARTICLESETUPS];
		static bool Predefined_bParticle_Show_At_Start[MAXPREDEFINEDPARTICLESETUPS];
		static bool Predefined_bParticle_Looping_Animation[MAXPREDEFINEDPARTICLESETUPS];
		static bool Predefined_bParticle_Full_Screen[MAXPREDEFINEDPARTICLESETUPS];
		static float Predefined_fParticle_Fullscreen_Duration[MAXPREDEFINEDPARTICLESETUPS];
		static float Predefined_fParticle_Fullscreen_Fadein[MAXPREDEFINEDPARTICLESETUPS];
		static float Predefined_fParticle_Fullscreen_Fadeout[MAXPREDEFINEDPARTICLESETUPS];
		static cstr Predefined_Particle_Fullscreen_Transition[MAXPREDEFINEDPARTICLESETUPS];
		static float Predefined_fParticle_Speed[MAXPREDEFINEDPARTICLESETUPS];
		static float Predefined_fParticle_Opacity[MAXPREDEFINEDPARTICLESETUPS];


		newparticletype newparticle_init[MAXPREDEFINEDPARTICLESETUPS];

		if (!bPredefinedParticleInit)
		{
			//Init.
			for (int i = 0; i < iPredefinedParticleSetups; i++)
			{
				if (ImageExist(Predefined_Particle_Image[i]))
				{
					if(Predefined_Particle_Image[i] != FILETYPE_PARTICLE)
						DeleteImage(Predefined_Particle_Image[i]);
				}
				Predefined_Particle_Image[i] = 0;
			}

			for (int i = 0; i < iPredefinedParticleSetups; i++)
			{
				//Defaults
				Predefined_bParticle_Preview[i] = true;
				Predefined_bParticle_Show_At_Start[i] = true;
				Predefined_bParticle_Looping_Animation[i] = true;
				Predefined_bParticle_Full_Screen[i] = false;
				Predefined_fParticle_Fullscreen_Duration[i] = 10.0f;
				Predefined_fParticle_Fullscreen_Fadein[i] = 1.0f;
				Predefined_fParticle_Fullscreen_Fadeout[i] = 1.0f;
				Predefined_Particle_Fullscreen_Transition[i] = "";
				Predefined_fParticle_Speed[i] = 1.0f;
				Predefined_fParticle_Opacity[i] = 1.0f;

				if (i == 0) Predefined_Particle_Name[i] = "particlesbank\\default";
				if (i == 1) Predefined_Particle_Name[i] = "particlesbank\\portal5";
				if (i == 2) Predefined_Particle_Name[i] = "particlesbank\\stylized_poisonring";
				if (i == 3) Predefined_Particle_Name[i] = "particlesbank\\smoke_billowy";
				if (i == 4) Predefined_Particle_Name[i] = "particlesbank\\fountain_directional";
				if (i == 5) Predefined_Particle_Name[i] = "particlesbank\\fire_tornado_3";
				if (i == 6) Predefined_Particle_Name[i] = "particlesbank\\fire_and_smoke";
				if (i == 7) Predefined_Particle_Name[i] = "particlesbank\\explosion";
				if (i == 8) Predefined_Particle_Name[i] = "particlesbank\\smoke_thick";

				if (i == 7) Predefined_bParticle_Looping_Animation[i] = false;

				Predefined_Particle_Image[i] = MARKETPLACE_ICONS + 50 + i;

				cstr img = Predefined_Particle_Name[i] + cstr(".arx");
				CreateBackBufferCacheName(img.Get(), 512, 288);
				SetMipmapNum(1); //PE: mipmaps not needed.
				image_setlegacyimageloading(true);
				if (FileExist(BackBufferCacheName.Get()))
				{
					LoadImage((char *)BackBufferCacheName.Get(), Predefined_Particle_Image[i]);
					if (!ImageExist(Predefined_Particle_Image[i]))
					{
						Predefined_Particle_Image[i] = FILETYPE_PARTICLE;
					}
				}
				else
				{
					Predefined_Particle_Image[i] = FILETYPE_PARTICLE;
				}
				image_setlegacyimageloading(false);
				SetMipmapNum(-1);
			}

			iPredefinedParticles = iPredefinedParticleSetups;

			//Pack to top of list.
			int iDest = 0;
			for (int i = 0;i < 16; i++)
			{
				if (strlen(pref.Saved_Particle_Name[i]) > 0)
				{
					strcpy(pref.Saved_Particle_Name[iDest],pref.Saved_Particle_Name[i]);
					pref.Saved_bParticle_Preview[iDest] = pref.Saved_bParticle_Preview[i];
					pref.Saved_bParticle_Show_At_Start[iDest] = pref.Saved_bParticle_Show_At_Start[i];
					pref.Saved_bParticle_Looping_Animation[iDest] = pref.Saved_bParticle_Looping_Animation[i];
					pref.Saved_bParticle_Full_Screen[iDest] = pref.Saved_bParticle_Full_Screen[i];
					pref.Saved_fParticle_Fullscreen_Duration[iDest] = pref.Saved_fParticle_Fullscreen_Duration[i];
					pref.Saved_fParticle_Fullscreen_Fadein[iDest] = pref.Saved_fParticle_Fullscreen_Fadein[i];
					pref.Saved_fParticle_Fullscreen_Fadeout[iDest] = pref.Saved_fParticle_Fullscreen_Fadeout[i];
					strcpy(pref.Saved_Particle_Fullscreen_Transition[iDest],pref.Saved_Particle_Fullscreen_Transition[i]);
					pref.Saved_fParticle_Speed[iDest] = pref.Saved_fParticle_Speed[i];
					pref.Saved_fParticle_Opacity[iDest] = pref.Saved_fParticle_Opacity[i];

					if (i > iDest) strcpy(pref.Saved_Particle_Name[i],"");
					iDest++;
				}
			}

			//Add saved from prefs.
			for (int i = 0; i < 16; i++)
			{
				if (strlen(pref.Saved_Particle_Name[i]) > 0)
				{
					Predefined_Particle_Image[iPredefinedParticles] = MARKETPLACE_ICONS + 50 + iPredefinedParticles + i;
					Predefined_Particle_Name[iPredefinedParticles] = pref.Saved_Particle_Name[i];
					Predefined_bParticle_Preview[iPredefinedParticles] = pref.Saved_bParticle_Preview[i];
					Predefined_bParticle_Show_At_Start[iPredefinedParticles] = pref.Saved_bParticle_Show_At_Start[i];
					Predefined_bParticle_Looping_Animation[iPredefinedParticles] = pref.Saved_bParticle_Looping_Animation[i];
					Predefined_bParticle_Full_Screen[iPredefinedParticles] = pref.Saved_bParticle_Full_Screen[i];
					Predefined_fParticle_Fullscreen_Duration[iPredefinedParticles] = pref.Saved_fParticle_Fullscreen_Duration[i];
					Predefined_fParticle_Fullscreen_Fadein[iPredefinedParticles] = pref.Saved_fParticle_Fullscreen_Fadein[i];
					Predefined_fParticle_Fullscreen_Fadeout[iPredefinedParticles] = pref.Saved_fParticle_Fullscreen_Fadeout[i];
					Predefined_Particle_Fullscreen_Transition[iPredefinedParticles] = pref.Saved_Particle_Fullscreen_Transition[i];
					Predefined_fParticle_Speed[iPredefinedParticles] = pref.Saved_fParticle_Speed[i];
					Predefined_fParticle_Opacity[iPredefinedParticles] = pref.Saved_fParticle_Opacity[i];

					cstr img = Predefined_Particle_Name[iPredefinedParticles];
					if (strlen(pref.Saved_Particle_Name[i]) > 4)
					{
						if (strnicmp(img.Get() + strlen(img.Get()) - 4, ".arx", 4) == NULL)
						{
							img = Left(img.Get(), Len(img.Get()) - 4);
						}
					}
					img = img + cstr(".arx");

					CreateBackBufferCacheName(img.Get(), 512, 288);
					SetMipmapNum(1); //PE: mipmaps not needed.
					image_setlegacyimageloading(true);
					if (FileExist(BackBufferCacheName.Get()))
					{
						LoadImage((char *)BackBufferCacheName.Get(), Predefined_Particle_Image[iPredefinedParticles]);
						if (!ImageExist(Predefined_Particle_Image[iPredefinedParticles]))
						{
							Predefined_Particle_Image[iPredefinedParticles] = FILETYPE_PARTICLE;
						}
					}
					else
					{
						Predefined_Particle_Image[iPredefinedParticles] = FILETYPE_PARTICLE;
					}
					image_setlegacyimageloading(false);
					SetMipmapNum(-1);

					iPredefinedParticles++;
				}
			}

			bPredefinedParticleInit = true;
		}


		static int current_particle_selected = -1;
		bool bUpdateParticle = false;

		//static bool bSetUpDefaultPAletteWithDefaultColors = true;
		static bool bFindBestParticleChoice = false;
		static int iLastParticleEntityElementIDHere = -1;
		if (elementID != iLastParticleEntityElementIDHere)
		{
			iLastParticleEntityElementIDHere = elementID;
			current_particle_selected = -1;
			bFindBestParticleChoice = true;
		}

		if (bFindBestParticleChoice)
		{
			bFindBestParticleChoice = false;

			//Try to locate a matching particle setup.
			for (int i = 0; i < iPredefinedParticles; i++)
			{
				bool bValid = true;
				std::string sString = t.entityelement[elementID].eleprof.newparticle.emittername.Get();
				replaceAll(sString, "/", "\\");
				if ( stricmp(sString.c_str() , Predefined_Particle_Name[i].Get()) != 0 ) bValid = false;
				//if (t.entityelement[elementID].eleprof.newparticle.emittername != Predefined_Particle_Name[i]) bValid = false;
				if (t.entityelement[elementID].eleprof.newparticle.bParticle_Preview != Predefined_bParticle_Preview[i]) bValid = false;
				if (t.entityelement[elementID].eleprof.newparticle.bParticle_Show_At_Start != Predefined_bParticle_Show_At_Start[i]) bValid = false;
				if (t.entityelement[elementID].eleprof.newparticle.bParticle_Looping_Animation != Predefined_bParticle_Looping_Animation[i]) bValid = false;
				if (t.entityelement[elementID].eleprof.newparticle.Particle_Fullscreen_Transition != Predefined_Particle_Fullscreen_Transition[i]) bValid = false;

				//Float roundings so cant just compare. just use int's.
				if ( (int) t.entityelement[elementID].eleprof.newparticle.bParticle_Full_Screen != (int) Predefined_bParticle_Full_Screen[i]) bValid = false;
				if ( (int) t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Duration != (int) Predefined_fParticle_Fullscreen_Duration[i]) bValid = false;
				if ( (int) t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Fadein != (int) Predefined_fParticle_Fullscreen_Fadein[i]) bValid = false;
				if ( (int) t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Fadeout != (int) Predefined_fParticle_Fullscreen_Fadeout[i]) bValid = false;
				//Remove precision so we get the best match.
				if ( (int) (t.entityelement[elementID].eleprof.newparticle.fParticle_Speed*5) != (int) (Predefined_fParticle_Speed[i]*5) ) bValid = false;
				if ( (int) (t.entityelement[elementID].eleprof.newparticle.fParticle_Opacity*5) != (int) (Predefined_fParticle_Opacity[i]*5) ) bValid = false;

				if (bValid)
				{
					current_particle_selected = i;
					break;
				}

			}
		}

		#define USEPARTICLECOLUMNS
		int particle_icons_columns = 3;
		float particle_w = ImGui::GetContentRegionAvailWidth() - 10.0f;
		float particle_image_size = particle_w / (float)particle_icons_columns;
		#ifdef USEPARTICLECOLUMNS
		particle_image_size -= 3; //Border of 1
		#endif
		float fRatio = 288.0f / 512.0f;
		particle_image_size -= ((2.0f) * particle_icons_columns) - 2.0f;
		ImVec4 IconColor = { 1.0f,1.0f,1.0f,1.0f };
		ImVec4 background = { 0.0f,0.0f,0.0f,1.0f };
		ImGuiWindow* window = ImGui::GetCurrentWindow();

		#ifdef USEPARTICLECOLUMNS
		ImVec2 iOldWindowPadding = ImGui::GetStyle().WindowPadding;
		ImGui::GetStyle().WindowPadding = { 1.0f,1.0f };
		ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 4));
		ImGui::Columns(3, "mycolumns3particles", false);  //false no border
		if (particle_image_size < 200)
		{
		}
		#endif

		ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
		bool bDrawsSelection = false;
		ImRect image_draw_bb;
		for (int i = 0; i < iPredefinedParticles; i++)
		{
			ImRect image_bb;
			ImVec2 padding = { 0.0, 1.0 };

			//Auto pick ?

			if (current_particle_selected == i)
			{
				image_bb = ImRect((window->DC.CursorPos - padding), window->DC.CursorPos + padding + ImVec2(particle_image_size, particle_image_size * fRatio));
			}

			//ImGui::BeginChildFrame(ImGui::GetID("particleframe"), ImVec2(particle_image_size, particle_image_size * fRatio + ImGui::GetTextLineHeightWithSpacing()), ImGuiWindowFlags_NoMove| ImGuiWindowFlags_NoResize| ImGuiWindowFlags_NoScrollbar);

			ImGui::PushID(FILETYPE_PARTICLE + i);
			if (ImGui::ImgBtn(Predefined_Particle_Image[i], ImVec2(particle_image_size, particle_image_size * fRatio), background, IconColor, ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, true, false)) //bBoostIconColors
			{
				//Change selection.
				current_particle_selected = i;
				//Setup default parameters.
				bUpdateParticle = true;

				if (elementID > 0)
				{
					int iParticleEmitter = t.entityelement[elementID].eleprof.newparticle.emitterid;
					if (iParticleEmitter != -1)
					{
						gpup_deleteEffect(iParticleEmitter);
					}
					t.entityelement[elementID].eleprof.newparticle.emitterid = -1;
					t.entityelement[elementID].eleprof.newparticle.emittername = Predefined_Particle_Name[current_particle_selected];

					t.entityelement[elementID].eleprof.newparticle.bParticle_Preview = Predefined_bParticle_Preview[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.bParticle_Show_At_Start = Predefined_bParticle_Show_At_Start[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.bParticle_Looping_Animation = Predefined_bParticle_Looping_Animation[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.bParticle_Full_Screen = Predefined_bParticle_Full_Screen[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Duration = Predefined_fParticle_Fullscreen_Duration[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Fadein = Predefined_fParticle_Fullscreen_Fadein[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Fadeout = Predefined_fParticle_Fullscreen_Fadeout[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.Particle_Fullscreen_Transition = Predefined_Particle_Fullscreen_Transition[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Speed = Predefined_fParticle_Speed[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Opacity = Predefined_fParticle_Opacity[current_particle_selected];

					edit_grideleprof->newparticle = t.entityelement[elementID].eleprof.newparticle;
				}
			}
			ImGui::PopID();

			if (current_particle_selected == i)
			{
				//if (iSelections++ > 0)
				//{
				//	//Mark dublicates.
				//	tool_selected_col.w = 0.2;
				//}
				#ifndef USEPARTICLECOLUMNS
				window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
				#else
				image_draw_bb = image_bb;
				bDrawsSelection = true;
				#endif
			}
			#ifndef USEPARTICLECOLUMNS
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Particle Preference");
			#endif

			#ifdef USEPARTICLECOLUMNS
			char *find = (char *)pestrcasestr(Predefined_Particle_Name[i].Get(), "particlesbank\\");
			if (find) find += 14;
			if (particle_image_size > 130)
			{
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Particle Preference");
				if (find)
				{
					ImGui::TextCenter(find);
				}
			}
			else if(find)
			{
				cstr tooltip = cstr("Select Particle (") + cstr(find) + cstr(")");
				if (ImGui::IsItemHovered()) ImGui::SetTooltip(tooltip.Get());
			}
			else
			{
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Particle Preference");
			}
			#endif

			#ifdef USEPARTICLECOLUMNS
			ImGui::NextColumn();
			#else	
			if ((i + 1) % particle_icons_columns != 0 && i != iPredefinedParticles - 1)
				ImGui::SameLine();
			#endif

		}
		#ifdef USEPARTICLECOLUMNS
		ImGui::Columns(1);
		if (bDrawsSelection)
		{
			window->DrawList->AddRect(image_draw_bb.Min, image_draw_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		}

		ImGui::GetStyle().WindowPadding = iOldWindowPadding;
		ImGui::PopStyleVar();

		#endif
		ImGui::Text("");

		if (ImGui::StyleButton("Add New Particle##+", ImVec2((particle_w*0.5f) - 4.0f, 0)) || iSelectedLibraryStingReturnID == window->GetID("Add New Particle##+"))
		{
			if (iSelectedLibraryStingReturnID == window->GetID("Add New Particle##+"))
			{
				//This goes to the saved in pref. find free.
				int iSaveTo = -1;
				for (int i = 0; i < 16; i++)
				{
					if (strlen(pref.Saved_Particle_Name[i]) <= 0)
					{
						iSaveTo = i;
						break;
					}
				}
				if (iSaveTo > -1)
				{
					if (strnicmp(sSelectedLibrarySting.Get() + strlen(sSelectedLibrarySting.Get()) - 4, ".arx", 4) == NULL) sSelectedLibrarySting = Left(sSelectedLibrarySting.Get(), Len(sSelectedLibrarySting.Get()) - 4);
					strcpy(pref.Saved_Particle_Name[iSaveTo], sSelectedLibrarySting.Get());

					current_particle_selected = iSaveTo + iPredefinedParticleSetups;

					if (current_particle_selected >= 0 && current_particle_selected < 32)
						Predefined_Particle_Name[current_particle_selected] = sSelectedLibrarySting;

				}

				sSelectedLibrarySting = "";
				iSelectedLibraryStingReturnID = -1; //disable.

				//PE: Add new settings to current particle.
				if (iSaveTo > -1 && elementID > 0)
				{
					int iParticleEmitter = t.entityelement[elementID].eleprof.newparticle.emitterid;
					if (iParticleEmitter != -1)
					{
						gpup_deleteEffect(iParticleEmitter);
					}
					t.entityelement[elementID].eleprof.newparticle.emitterid = -1;
					t.entityelement[elementID].eleprof.newparticle.emittername = Predefined_Particle_Name[current_particle_selected];
					//Setup defaults.
					Predefined_bParticle_Preview[current_particle_selected] = true;
					Predefined_bParticle_Show_At_Start[current_particle_selected] = true;
					Predefined_bParticle_Looping_Animation[current_particle_selected] = true;
					Predefined_bParticle_Full_Screen[current_particle_selected] = false;
					Predefined_fParticle_Fullscreen_Duration[current_particle_selected] = 10.0f;
					Predefined_fParticle_Fullscreen_Fadein[current_particle_selected] = 1.0f;
					Predefined_fParticle_Fullscreen_Fadeout[current_particle_selected] = 1.0f;
					Predefined_Particle_Fullscreen_Transition[current_particle_selected] = "";
					Predefined_fParticle_Speed[current_particle_selected] = 1.0f;
					Predefined_fParticle_Opacity[current_particle_selected] = 1.0f;
					//Add new settings to eleprof.
					t.entityelement[elementID].eleprof.newparticle.bParticle_Preview = Predefined_bParticle_Preview[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.bParticle_Show_At_Start = Predefined_bParticle_Show_At_Start[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.bParticle_Looping_Animation = Predefined_bParticle_Looping_Animation[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.bParticle_Full_Screen = Predefined_bParticle_Full_Screen[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Duration = Predefined_fParticle_Fullscreen_Duration[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Fadein = Predefined_fParticle_Fullscreen_Fadein[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Fadeout = Predefined_fParticle_Fullscreen_Fadeout[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.Particle_Fullscreen_Transition = Predefined_Particle_Fullscreen_Transition[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Speed = Predefined_fParticle_Speed[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Opacity = Predefined_fParticle_Opacity[current_particle_selected];

					edit_grideleprof->newparticle = t.entityelement[elementID].eleprof.newparticle;

					bUpdateParticle = true; //Start new effect.
				}

				bPredefinedParticleInit = false; //Setup everything again.

			}
			else
			{
				//Open select particle window.
				bExternal_Entities_Window = true;
				iDisplayLibraryType = 5;
				iLibraryStingReturnToID = window->GetID("Add New Particle##+");
			}
		}

		ImGui::SameLine();
		bool bDisableButton = true;
		if (current_particle_selected != -1 && current_particle_selected > iPredefinedParticleSetups-1) bDisableButton = false;
		if (ImGui::StyleButtonEx("Delete Particle", ImVec2((particle_w*0.5f) - 4.0f, 0), bDisableButton))
		{
			if (current_particle_selected >= iPredefinedParticleSetups)
			{
				strcpy(pref.Saved_Particle_Name[current_particle_selected - iPredefinedParticleSetups], "");
				bPredefinedParticleInit = false; //Setup everything again.
			}
		}
		if (ImGui::IsItemHovered())
		{
			if (bDisableButton == true)
				ImGui::SetTooltip("Cannot delete first 9 default particles");
			else
				ImGui::SetTooltip("Delete selected custom particle");
		}

		if (ImGui::StyleButton("Reset to Default Particles", ImVec2(particle_w, 0)))
		{
			//Dont reset saved.
			current_particle_selected = -1;
			bPredefinedParticleInit = false; //Setup everything again.
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Reset Particles to The Default Settings");

		ImGui::TextCenter("Particle Values");

		bool btmp = edit_grideleprof->newparticle.bParticle_Preview;
		if( ImGui::Checkbox("Preview Particle Effect", &btmp) )
		{
			bUpdateParticle = true;
		}
		edit_grideleprof->newparticle.bParticle_Preview = btmp;
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Toggle whether the particle effect shows in the editor");

		btmp = edit_grideleprof->newparticle.bParticle_Show_At_Start;
		if (ImGui::Checkbox("Show at start of level", &btmp))
		{
			bUpdateParticle = true;
		}
		edit_grideleprof->newparticle.bParticle_Show_At_Start = btmp;
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Toggle whether the particle effect shows at the start of the level");

		btmp = edit_grideleprof->newparticle.bParticle_Looping_Animation;
		if (ImGui::Checkbox("Looping Animation", &btmp))
		{
			bUpdateParticle = true;
		}
		edit_grideleprof->newparticle.bParticle_Looping_Animation = btmp;
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Choose whether the particle repeats, or plays once only");

		ImGui::TextCenter("Animation Speed");
		ImGui::PushItemWidth(-10);
		int tmpint = edit_grideleprof->newparticle.fParticle_Speed * 100.0f; // 1.0 = normal.
		if (ImGui::MaxSliderInputInt("##Animation Speed", &tmpint, 0, 200, "Animation Speed"))
		{
			bUpdateParticle = true;
		}
		edit_grideleprof->newparticle.fParticle_Speed = (float) tmpint/100.0f;
		ImGui::PopItemWidth();
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set the global speed of the particle effect");

		ImGui::TextCenter("Opacity");
		ImGui::PushItemWidth(-10);
		tmpint = edit_grideleprof->newparticle.fParticle_Opacity * 100.0f; // 1.0 = normal.
		if (ImGui::MaxSliderInputInt("##OpacityParticle", &tmpint, 0, 200, "Opacity"))
		{
			bUpdateParticle = true;
		}
		edit_grideleprof->newparticle.fParticle_Opacity = (float)tmpint / 100.0f;
		ImGui::PopItemWidth();
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set the global opacity of the particle effect");

		//LB: removed for now until we have logic that supports transitions
		#ifdef USEFULLSCREENPARTICLETRANSITIONS
		ImGui::TextCenter("Full Screen Effect");

		btmp = edit_grideleprof->newparticle.bParticle_Full_Screen;
		if (ImGui::Checkbox("Fill Screen With Effect", &btmp))
		{
			bUpdateParticle = true;
		}
		edit_grideleprof->newparticle.bParticle_Full_Screen = btmp;

		if (edit_grideleprof->newparticle.bParticle_Full_Screen)
		{

			ImGui::PushItemWidth(-10);
			ImGui::TextCenter("Duration of Display");
			float fTmp = edit_grideleprof->newparticle.fParticle_Fullscreen_Duration;
			if (ImGui::MaxSliderInputFloat2("##DurationofDisplaySimpleInput", &fTmp, 0.0f, 120.0f, "Duration of Display (in seconds)", 0, 120.0f, 42.0f))
			{
				bUpdateParticle = true;
			}
			edit_grideleprof->newparticle.fParticle_Fullscreen_Duration = fTmp;

			ImGui::TextCenter("Fade in Speed");
			fTmp = edit_grideleprof->newparticle.fParticle_Fullscreen_Fadein;
			if (ImGui::MaxSliderInputFloat2("##FadeinSpeedSimpleInput", &fTmp, 0.0f, 120.0f, "Fade in Speed (in seconds)", 0, 120.0f, 42.0f))
			{
				bUpdateParticle = true;
			}
			edit_grideleprof->newparticle.fParticle_Fullscreen_Fadein = fTmp;

			ImGui::TextCenter("Fade Out Speed");
			fTmp = edit_grideleprof->newparticle.fParticle_Fullscreen_Fadeout;
			if (ImGui::MaxSliderInputFloat2("##FadeOutSpeedSimpleInput", &fTmp, 0.0f, 120.0f, "Fade Out Speed (in seconds)", 0, 120.0f, 42.0f))
			{
				bUpdateParticle = true;
			}
			edit_grideleprof->newparticle.fParticle_Fullscreen_Fadeout = fTmp;

			ImGui::TextCenter("Transition Effect");

			static cstr TransitionString = "STARTVAL";
			static int iTransitionImage = FILETYPE_PARTICLE;
			float transition_image_size = particle_w * 0.75;

			if (TransitionString != edit_grideleprof->newparticle.Particle_Fullscreen_Transition)
			{
				TransitionString = edit_grideleprof->newparticle.Particle_Fullscreen_Transition;
				iTransitionImage = MARKETPLACE_ICONS + 50 + 32;

				cstr img = TransitionString + cstr(".arx");

				CreateBackBufferCacheName(img.Get(), 512, 288);
				image_setlegacyimageloading(true);
				if (FileExist(BackBufferCacheName.Get()))
				{
					LoadImage((char *)BackBufferCacheName.Get(), iTransitionImage);
					if (!ImageExist(iTransitionImage))
					{
						iTransitionImage = FILETYPE_PARTICLE;
					}
				}
				else
				{
					iTransitionImage = FILETYPE_PARTICLE;
				}
				image_setlegacyimageloading(false);

			}
			if (iTransitionImage > 0)
			{
				ImGui::PushID(FILETYPE_PARTICLE + 32);
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(transition_image_size*0.125, 0.0));
				if (ImGui::ImgBtn(iTransitionImage, ImVec2(transition_image_size, transition_image_size * fRatio), background, IconColor, ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, true, false) ||
					iSelectedLibraryStingReturnID == window->GetID("Add New Transition##+"))
				{
					if (iSelectedLibraryStingReturnID == window->GetID("Add New Transition##+"))
					{

						if (strnicmp(sSelectedLibrarySting.Get() + strlen(sSelectedLibrarySting.Get()) - 4, ".arx", 4) == NULL) sSelectedLibrarySting = Left(sSelectedLibrarySting.Get(), Len(sSelectedLibrarySting.Get()) - 4);
						edit_grideleprof->newparticle.Particle_Fullscreen_Transition = sSelectedLibrarySting;
						sSelectedLibrarySting = "";
						iSelectedLibraryStingReturnID = -1; //disable.
						bUpdateParticle = true;
					}
					else
					{
						//Open select particle window.
						bExternal_Entities_Window = true;
						iDisplayLibraryType = 5;
						iLibraryStingReturnToID = window->GetID("Add New Transition##+");
					}

				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select New Transition Effect");

				ImGui::PopID();

			}

			//cstr newfile_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->newparticle.emittername.Get(), "Transition Effect", "Select a Transition Effect", "particlesbank\\", readonly);
			//if (strnicmp(newfile_s.Get() + strlen(newfile_s.Get()) - 4, ".arx", 4) == NULL) newfile_s = Left(newfile_s.Get(), Len(newfile_s.Get()) - 4);
			//if (newfile_s != edit_grideleprof->newparticle.Particle_Fullscreen_Transition)
			//{
			//	//Get a thumb.
			//	edit_grideleprof->newparticle.Particle_Fullscreen_Transition = newfile_s;
			//}
			//Particle_Fullscreen_Transition = "";
			//PE: ?

			ImGui::PopItemWidth();

//					fParticle_Fullscreen_Duration = 10.0f; //Sec.
//					fParticle_Fullscreen_Fadein = 4.0f; //Sec.
//					fParticle_Fullscreen_Fadeout = 4.0f; //Sec.
//					Particle_Fullscreen_Transition = "";

		}
		#endif

		if (bUpdateParticle && elementID > 0)
		{
			t.entityelement[elementID].eleprof.newparticle = edit_grideleprof->newparticle;
			if (current_particle_selected >= 0)
			{
				//Update predefined values.
				Predefined_bParticle_Preview[current_particle_selected] = edit_grideleprof->newparticle.bParticle_Preview;
				Predefined_bParticle_Show_At_Start[current_particle_selected] = edit_grideleprof->newparticle.bParticle_Show_At_Start;
				Predefined_bParticle_Looping_Animation[current_particle_selected] = edit_grideleprof->newparticle.bParticle_Looping_Animation;
				Predefined_bParticle_Full_Screen[current_particle_selected] = edit_grideleprof->newparticle.bParticle_Full_Screen;
				Predefined_fParticle_Fullscreen_Duration[current_particle_selected] = edit_grideleprof->newparticle.fParticle_Fullscreen_Duration;
				Predefined_fParticle_Fullscreen_Fadein[current_particle_selected] = edit_grideleprof->newparticle.fParticle_Fullscreen_Fadein;
				Predefined_fParticle_Fullscreen_Fadeout[current_particle_selected] = edit_grideleprof->newparticle.fParticle_Fullscreen_Fadeout;
				Predefined_Particle_Fullscreen_Transition[current_particle_selected] = edit_grideleprof->newparticle.Particle_Fullscreen_Transition;
				Predefined_fParticle_Speed[current_particle_selected] = edit_grideleprof->newparticle.fParticle_Speed;
				Predefined_fParticle_Opacity[current_particle_selected] = edit_grideleprof->newparticle.fParticle_Opacity;
			}

			if (current_particle_selected >= iPredefinedParticleSetups)
			{
				//This is a pref setup so update new settings.
				int icust = current_particle_selected - iPredefinedParticleSetups;
				if (icust >= 0 && icust < 16)
				{
					//pref.Saved_Particle_Name[icust] never change.
					pref.Saved_bParticle_Preview[icust] = edit_grideleprof->newparticle.bParticle_Preview;
					pref.Saved_bParticle_Show_At_Start[icust] = edit_grideleprof->newparticle.bParticle_Show_At_Start;
					pref.Saved_bParticle_Looping_Animation[icust] = edit_grideleprof->newparticle.bParticle_Looping_Animation;
					pref.Saved_bParticle_Full_Screen[icust] = edit_grideleprof->newparticle.bParticle_Full_Screen;
					pref.Saved_fParticle_Fullscreen_Duration[icust] = edit_grideleprof->newparticle.fParticle_Fullscreen_Duration;
					pref.Saved_fParticle_Fullscreen_Fadein[icust] = edit_grideleprof->newparticle.fParticle_Fullscreen_Fadein;
					pref.Saved_fParticle_Fullscreen_Fadeout[icust] = edit_grideleprof->newparticle.fParticle_Fullscreen_Fadeout;
					strcpy(pref.Saved_Particle_Fullscreen_Transition[icust], edit_grideleprof->newparticle.Particle_Fullscreen_Transition.Get());
					pref.Saved_fParticle_Speed[icust] = edit_grideleprof->newparticle.fParticle_Speed;
					pref.Saved_fParticle_Opacity[icust] = edit_grideleprof->newparticle.fParticle_Opacity;
				}
			}

			int iParticleEmitter = t.entityelement[elementID].eleprof.newparticle.emitterid;
			if (iParticleEmitter == -1)
			{
				iParticleEmitter = gpup_loadEffect(t.entityelement[elementID].eleprof.newparticle.emittername.Get(), 0, 0, 0, 1.0);
				gpup_emitterActive(iParticleEmitter, 0);
				t.entityelement[elementID].eleprof.newparticle.emitterid = iParticleEmitter;
			}
			if (iParticleEmitter != -1)
			{
				gpup_setGlobalPosition(iParticleEmitter, t.entityelement[elementID].x, t.entityelement[elementID].y, t.entityelement[elementID].z);
				gpup_resetLocalPosition(iParticleEmitter);
				float fSpeedX, fSpeedY, fSpeedZ;
				sObject* pObject = GetObjectData(t.entityelement[elementID].obj);
				gpup_getEmitterSpeedAngleAdjustment(iParticleEmitter, &fSpeedX, &fSpeedY, &fSpeedZ);
				GGVECTOR3 vecSpeedDirection = GGVECTOR3(fSpeedX - 0.5f, fSpeedY - 0.5f, fSpeedZ - 0.5f);
				GGVec3TransformCoord(&vecSpeedDirection, &vecSpeedDirection, &pObject->position.matRotation);
				gpup_setEmitterSpeedAngleAdjustment(iParticleEmitter, 0.5f + vecSpeedDirection.x, 0.5f + vecSpeedDirection.y, 0.5f + vecSpeedDirection.z);
				gpup_setGlobalScale(iParticleEmitter, 100.0f + t.entityelement[elementID].scalex);
				gpup_emitterActive(iParticleEmitter, t.entityelement[elementID].eleprof.newparticle.bParticle_Preview);
				gpup_setEffectAnimationSpeed(iParticleEmitter, t.entityelement[elementID].eleprof.newparticle.fParticle_Speed);
				gpup_setEffectOpacity(iParticleEmitter, t.entityelement[elementID].eleprof.newparticle.fParticle_Opacity);
			}
			edit_grideleprof->newparticle = t.entityelement[elementID].eleprof.newparticle;
		}
	}
	#endif
	else if (t.entityprofile[entid].ismarker == 1)
	{
		//Start Marker.
		//Display icon.
		if (bDisplaySmallIcon)
		{
			if (t.entityprofile[entid].iThumbnailSmall > 0) {
				float w = ImGui::GetContentRegionAvailWidth();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (media_icon_size*0.5), 0.0f));
				ImGui::ImgBtn(t.entityprofile[entid].iThumbnailSmall, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
			}
		}

		//Name only.
		//ImGui::Text("");
		if(bDisplayName)
			edit_grideleprof->name_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->name_s.Get(), "Name", t.strarr_s[204].Get(),readonly);


		// DLUA support added here.
		int speech_entries = 0;
		bool bUpdateMainString = false;
		for (int speech_loop = 0; speech_loop < 5; speech_loop++)
			speech_ids[speech_loop] = -1;
		if (fpe_current_loaded_script != fpe_current_selected_script)
		{
			//Load in lua and check for custom properties.
			cstr script_name = "scriptbank\\";
			script_name += edit_grideleprof->aimain_s;

			//Try to parse script.
			ParseLuaScript(lua_grideleprof, script_name.Get());
			fpe_current_loaded_script = fpe_current_selected_script;

			if (lua_grideleprof->PropertiesVariableActive == 1) {
				bUpdateMainString = true;
				fpe_current_loaded_script_has_dlua = true;
			}
			else {
				if (fpe_current_loaded_script_has_dlua) {
					//Reset edit_grideleprof->soundset4_s that contain the dlua calls.
					edit_grideleprof->soundset4_s = "";
					fpe_current_loaded_script_has_dlua = false;
				}
			}
		}

		#ifdef USENEWMEDIASELECTWINDOWS
		if (pref.current_style == 25 || pref.current_style == 3)
		{
			fpe_current_loaded_script_image = PLAYER_START;
		}
		else
		{
			fpe_current_loaded_script_image = PLAYER_START2;
		}
		//Display only no selections.
		ImGui::PushItemWidth(-10);
		float w = ImGui::GetContentRegionAvailWidth() - 16.0f;
		float ImgW = ImageWidth(fpe_current_loaded_script_image);
		float ImgH = ImageHeight(fpe_current_loaded_script_image);
		float fRatio = w / ImgW;
		ImGui::ImgBtn(fpe_current_loaded_script_image, ImVec2(ImgW*fRatio, ImgH*fRatio), drawCol_black, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, false);
		//ImGui::TextCenter(cDisplayName);
		ImGui::PopItemWidth();
		#endif

		// Markers behaviours
		if (lua_grideleprof->PropertiesVariableActive == 1 || lua_grideleprof->PropertiesVariable.VariableDescription.Len() > 0)
		{
			//"Behaviors"
			if (lua_grideleprof->PropertiesVariableActive == 1) {
				speech_entries = DisplayLuaDescription(lua_grideleprof);
			}
			else {
				if (lua_grideleprof->PropertiesVariable.VariableDescription.Len() > 0) {
					if (edit_grideleprof->aimain_s != "default.lua") //No need to display.
						DisplayLuaDescriptionOnly(lua_grideleprof);
				}
			}
		}

		if (speech_entries > 0)
		{
			// all SPEECH control is moved to this function.
			SpeechControls(speech_entries, bUpdateMainString, edit_grideleprof);
		}

		ImGui::TextCenter("Player Settings");
		ImGui::Spacing();
		ImGui::TextCenter("Speed");
		ImGui::PushItemWidth(-10);
		ImGui::MaxSliderInputInt("##Movement SpeedSimpleInput", &edit_grideleprof->speed, 1, 500, 0);
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set Player Speed");
		if (t.playercontrol.thirdperson.enabled == 1) t.tanimspeed_f = t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed;
		else t.tanimspeed_f = edit_grideleprof->animspeed;
		ImGui::PopItemWidth();

		#ifdef WICKEDENGINE
		ImGui::TextCenter("Swimming Speed");
		ImGui::PushItemWidth(-10);
		int iSwimSpeed = t.playercontrol.fSwimSpeed;
		ImGui::MaxSliderInputInt("##SwimSpeedSimpleInput", &iSwimSpeed, 1, 100, "Modifies how much distance is travelled with each swimming stroke");
		t.playercontrol.fSwimSpeed = iSwimSpeed;
		ImGui::PopItemWidth();

		
		ImGui::TextCenter("Health");
		static int iPlayerNormalStrength = 500;
		int iPlayerInvincible = 0;
		if (edit_grideleprof->strength == 99999) iPlayerInvincible = 1;
		if (iPlayerInvincible == 0)
		{
			ImGui::PushItemWidth(-10);
			ImGui::MaxSliderInputInt("##PlayerHealthSimpleInput", &edit_grideleprof->strength, 1, 1000, 0);
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set Player Health");
			ImGui::PopItemWidth();
		}
		int iLastPlayerInvincible = iPlayerInvincible;
		iPlayerInvincible = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(iPlayerInvincible), "Invulnerable", "Controls whether the player has infinite health", 0, readonly);
		if (iLastPlayerInvincible != iPlayerInvincible)
		{
			if (iPlayerInvincible == 1)
			{
				iPlayerNormalStrength = edit_grideleprof->strength;
				edit_grideleprof->strength = 99999;
			}
			else
			{
				edit_grideleprof->strength = iPlayerNormalStrength;
			}
		}

		// health regeneration
		ImGui::TextCenter("Health Regeneration");
		ImGui::TextCenter("Amount");
		ImGui::MaxSliderInputInt("##RegenRate", &t.playercontrol.regenrate, 0, 1000, "Sets the amount of health to be regenerated at a time");
		ImGui::TextCenter("Rate");
		ImGui::MaxSliderInputInt("##RegenSpeed", &t.playercontrol.regenspeed, 0, 1000, "Sets how often health will be regenerated (in milliseconds)");
		ImGui::TextCenter("Delay");
		ImGui::MaxSliderInputInt("##RegenDelay", &t.playercontrol.regendelay, 0, 5000, "Sets the amount of time to wait  (in milliseonds) after taking damage, until health starts regenerating");
		ImGui::Spacing();
		
		#endif

		// Player Has Weapon
		if (t.tflaghasweapon == 1 && t.playercontrol.thirdperson.enabled == 0 && g.quickparentalcontrolmode != 2)
		{
			// weapon selection
			#ifdef WICKEDENGINE
			LPSTR pAttachmentTitle = "Weapon";
			#else
			LPSTR pAttachmentTitle = "Attachment";
			#endif
			#ifdef WICKEDENGINE
			edit_grideleprof->hasweapon_s = imgui_setpropertylist2c_v2(t.group, t.controlindex, edit_grideleprof->hasweapon_s.Get(), pAttachmentTitle, t.strarr_s[209].Get(), 1, readonly, false, true, true, 0);
			
			ImGui::TextCenter("Ammo Quantity");
			ImGui::MaxSliderInputInt("##AmmoQuantity", &edit_grideleprof->quantity, 0, 1000, "Amount of ammo the player starts with");

			ImGui::TextCenter("Weapon Damage Multiplier");
			int iModifier = edit_grideleprof->weapondamagemultiplier * 100;
			if (ImGui::MaxSliderInputInt("##WeaponDamageM", &iModifier, 1, 1000, "Percent of weapon damage that the player does compared to enemies"))
			{
				edit_grideleprof->weapondamagemultiplier = iModifier * 0.01f;
			}
			ImGui::TextCenter("Melee Damage Multiplier");
			iModifier = edit_grideleprof->meleedamagemultiplier * 100;
			if (ImGui::MaxSliderInputInt("##MeleeDamageM", &iModifier, 1, 1000, "Percent of melee damage that the player does compared to enemies"))
			{
				edit_grideleprof->meleedamagemultiplier = iModifier * 0.01f;
			}

			// configure weapon slots for player (functionality exists from Classic)
			ImGui::TextCenter("Preferred Weapon Slots");
			for (int key = 1; key <= 9; key++)
			{
				char pLabel[32];
				sprintf(pLabel, "Key %d", key);
				char pLabelTokenName[32];
				sprintf(pLabelTokenName, "weapprefkey1%d", key);
				ImGui::Text(pLabel);
				ImGui::SameLine();
				cstr slot_s = "";

				for (int gunid = 1; gunid <= g.gunmax; gunid++)
				{
					if (t.weaponSlotPreferrenceSettings[key] > 0 && t.weaponSlotPreferrenceSettings[key] == gunid)
					{
						slot_s = t.gun[gunid].name_s;
						break;
					}
				}

				cstr lastslot = slot_s;
				slot_s = imgui_setpropertylist2c_v2(t.group, t.controlindex, slot_s.Get(), pLabelTokenName, t.strarr_s[209].Get(), 61, readonly, false, true, true, 0);
				if (stricmp(slot_s.Get(), lastslot.Get()) != NULL)
				{
					// assign a new preference
					if (stricmp(slot_s.Get(), "") == NULL) //When "No Preference" option is selected slot_s is set to ""
					{
						t.weaponSlotPreferrenceSettings[key] = 0;
						t.weaponslot[key].pref = 0;
					}
					else
					{
						for (int gunid = 1; gunid <= g.gunmax; gunid++)
						{
							if (stricmp(slot_s.Get(), t.gun[gunid].name_s.Get()) == NULL)
							{
								t.weaponSlotPreferrenceSettings[key] = gunid;
								t.weaponslot[key].pref = gunid;
								break;
							}
						}
					}

					// and save out the new layout
					extern void gun_gatherslotorder_save (void);
					gun_gatherslotorder_save();
				}
			}

			#else
			edit_grideleprof->hasweapon_s = imgui_setpropertylist2c_v2(t.group, t.controlindex, edit_grideleprof->hasweapon_s.Get(), pAttachmentTitle, t.strarr_s[209].Get(), 1,readonly, false);
			#endif
		}
		ImGui::Spacing();
		ImGui::TextCenter("Effects");
	
		bool bHeartbeatSound = edit_grideleprof->perentityflags & 1;
		bHeartbeatSound = !bHeartbeatSound;
		bool bScreenBlood = edit_grideleprof->perentityflags & (1 << 1);
		bScreenBlood = !bScreenBlood;
		
		if (ImGui::Checkbox("Heartbeat Sound", &bHeartbeatSound))
		{
		}
		if(ImGui::IsItemHovered()) ImGui::SetTooltip("Controls whether a heartbeat sound is looped when the player is hurt");

		if (ImGui::Checkbox("Screen Blood", &bScreenBlood))
		{
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Controls whether blood is rendered on screen when the player is hurt");

		DWORD flags = !bHeartbeatSound;
		int iScreenBloodOff = !bScreenBlood;
		flags |= (iScreenBloodOff << 1);
		edit_grideleprof->perentityflags = flags;

		bool bDamageIndicator = t.huddamage.damageindicatoron;
		if (ImGui::Checkbox("Damage Indicator", &bDamageIndicator))
		{
			t.huddamage.damageindicatoron = bDamageIndicator;
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Sets whether a damage indicator appears when the player gets hurt");

		bool bFlashlightDisabled = edit_grideleprof->usespotlighting;
		if (ImGui::Checkbox("Flashlight Disabled", &bFlashlightDisabled))
		{
			edit_grideleprof->usespotlighting = bFlashlightDisabled;
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Sets whether the flashlight is disabled for the player");

	}
	else
	{
		//#################
		//#### Objects ####
		//################# 

		t.tokay = 1;
		if (ObjectExist(g.entitybankoffset + entid) == 1)
		{
			if (GetNumberOfFrames(g.entitybankoffset + entid) > 0)
			{
				t.tokay = 0;
			}
		}

		int speech_entries = 0;
		bool bUpdateMainString = false;

		for (int speech_loop = 0; speech_loop < 5; speech_loop++)
			speech_ids[speech_loop] = -1;

		//health.lua
		cstr aimain = edit_grideleprof->aimain_s.Lower();
		//new: trigger anyting not a marker.
		if (t.entityprofile[entid].ismarker == 0)// || aimain == "key.lua" || aimain == "objects\\key.lua" || aimain == "door.lua" || aimain == "default.lua" || aimain == "health.lua" || aimain == "pickuppable.lua" ) ) 
		{
			//"Name"
			//Display icon.
			if (bDisplaySmallIcon)
			{
				if (t.entityprofile[entid].iThumbnailSmall > 0) {
					float w = ImGui::GetContentRegionAvailWidth();
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (media_icon_size*0.5), 0.0f));
					ImGui::ImgBtn(t.entityprofile[entid].iThumbnailSmall, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
				}
			}
			if(bDisplayName)
				edit_grideleprof->name_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->name_s.Get(), "Name", t.strarr_s[204].Get(),readonly);

			// Object behaviours "Behaviors"
			// scan OBJECTS folder for complete list of script
			std::vector<cstr> scriptList_s; scriptList_s.clear();
			std::vector<cstr> scriptListTitle_s; scriptListTitle_s.clear();
			cstr oldDir_s = GetDir();
			SetDir(g.fpscrootdir_s.Get());
			SetDir("Files\\scriptbank\\objects");
			ChecklistForFiles();
			for (int f = 1; f <= ChecklistQuantity(); f++)
			{
				cstr tfile_s = ChecklistString(f);
				LPSTR pFilename = tfile_s.Get();
				if (tfile_s != "." && tfile_s != "..")
				{
					if (strnicmp(pFilename + strlen(pFilename) - 4, ".lua", 4) == NULL)
					{
						// create a readable title from file
						char pTitleName[256];
						strcpy(pTitleName, pFilename);
						pTitleName[strlen(pTitleName) - 4] = 0;
						for (int n = 0; n < strlen(pTitleName); n++)
						{
							if (n == 0)
							{
								if (pTitleName[n] >= 'a' && pTitleName[n] <= 'z')
									pTitleName[n] -= ('a' - 'A');
							}
							else
							{
								if (pTitleName[n] >= 'A' && pTitleName[n] <= 'Z')
									pTitleName[n] += ('a' - 'A');
							}
							if (pTitleName[n] == '_') pTitleName[n] = ' ';
						}

						// add script and title to list
						scriptList_s.push_back(cstr("objects\\") + tfile_s);
						scriptListTitle_s.push_back(cstr(pTitleName));
					}
				}
			}
			scriptList_s.push_back(cstr(""));
			scriptListTitle_s.push_back(cstr("Custom"));
			SetDir(oldDir_s.Get());

			// and create items list
			static int g_scriptobjects_item_count = 0;
			static char** g_scriptobjects_items = NULL;
			if (g_scriptobjects_item_count != scriptList_s.size())
			{
				if (g_scriptobjects_items)
				{
					for (int i = 0; i < g_scriptobjects_item_count; i++) SAFE_DELETE(g_scriptobjects_items[i]);
					SAFE_DELETE(g_scriptobjects_items);
				}
				g_scriptobjects_item_count = scriptList_s.size();
				g_scriptobjects_items = new char*[g_scriptobjects_item_count];
				for (int i = 0; i < g_scriptobjects_item_count; i++)
				{
					g_scriptobjects_items[i] = new char[256];
					strcpy(g_scriptobjects_items[i], scriptListTitle_s[i].Get());
				}
			}

			// find selection
			int item_current_type_selection = g_scriptobjects_item_count - 1; //Default Custom.
			for (int i = 0; i < g_scriptobjects_item_count - 1; i++)
			{
				if (pestrcasestr(edit_grideleprof->aimain_s.Get(), scriptList_s[i].Get()))
				{
					item_current_type_selection = i;
					break;
				}
			}

			if (fpe_current_loaded_script != item_current_type_selection)
			{
				//Load in lua and check for custom properties.
				cstr script_name = "scriptbank\\";
				if (item_current_type_selection < g_scriptobjects_item_count - 1) //PE: Need to check for custom
					script_name += scriptList_s[item_current_type_selection];
				else
					script_name += edit_grideleprof->aimain_s;

				#ifdef USENEWMEDIASELECTWINDOWS
				fpe_current_loaded_script_image = PROPERTIES_CACHE_ICONS + fpe_current_loaded_script_image_count;
				if (fpe_current_loaded_script_image_count++ > 10) fpe_current_loaded_script_image_count = 0;
				std::string sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
				if (pref.current_style == 25 || pref.current_style == 3)
					sImgName += ".png";
				else
					sImgName += "2.png";
				image_setlegacyimageloading(true);
				LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
				image_setlegacyimageloading(false);
				if (!GetImageExistEx(fpe_current_loaded_script_image))
				{
					if (!(pref.current_style == 25 || pref.current_style == 3))
					{
						sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
						sImgName += ".png";
						image_setlegacyimageloading(true);
						LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
						image_setlegacyimageloading(false);
						if (!GetImageExistEx(fpe_current_loaded_script_image))
						{
							fpe_current_loaded_script_image = FILETYPE_SCRIPT;
						}
					}
					else
						fpe_current_loaded_script_image = FILETYPE_SCRIPT;
				}
				#endif

				//Try to parse script.
				ParseLuaScriptWithElementID(lua_grideleprof, script_name.Get(),t.entityelement[elementID].obj);
				fpe_current_loaded_script = item_current_type_selection;

				if (lua_grideleprof->PropertiesVariableActive == 1)
				{
					bUpdateMainString = true;
					fpe_current_loaded_script_has_dlua = true;
				}
				else
				{
					if (fpe_current_loaded_script_has_dlua)
					{
						//Reset edit_grideleprof->soundset4_s that contain the dlua calls.
						edit_grideleprof->soundset4_s = "";
						fpe_current_loaded_script_has_dlua = false;
					}
				}
			}

			if (t.entityprofile[entid].bIsDecal)
			{
				if (elementID > 0)
				{
					ImGui::TextCenter("Decal Speed");
					ImGui::PushItemWidth(-10);
					int tmpint = t.entityelement[elementID].fDecalSpeed * 100.0; // 1.0 = normal.
					if (ImGui::MaxSliderInputInt("##Decal Speed", &tmpint, 1, 200, "Decal Speed"))
					{
						t.entityelement[elementID].fDecalSpeed = (float)tmpint / 100.0;
						SetupDecalObject(t.tobj, elementID);
					}
					t.entityelement[elementID].fDecalSpeed = (float)tmpint / 100.0;
					ImGui::PopItemWidth();
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set the speed of the decal effect");

					ImGui::TextCenter("Decal Opacity");
					ImGui::PushItemWidth(-10);
					tmpint = t.entityelement[elementID].fDecalOpacity * 100.0; // 1.0 = normal.
					if (ImGui::MaxSliderInputInt("##DecalOpacity", &tmpint, 0, 100, "Decal Opacity"))
					{
						if (tmpint > 100) tmpint = 100;
						if (tmpint < 0) tmpint = 0;
						t.entityelement[elementID].fDecalOpacity = (float)tmpint / 100.0;
						SetupDecalObject(t.tobj, elementID);
					}
					t.entityelement[elementID].fDecalOpacity = (float)tmpint / 100.0;
					ImGui::PopItemWidth();
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set the opacity of the decal effect");
				}
			}

			#ifdef USENEWMEDIASELECTWINDOWS
			ImGui::PushItemWidth(-10);
			float w = ImGui::GetContentRegionAvailWidth() - 16.0f;
			float ImgW = ImageWidth(fpe_current_loaded_script_image);
			float ImgH = ImageHeight(fpe_current_loaded_script_image);
			float fRatio = w / ImgW;

			ImGuiWindow* window = ImGui::GetCurrentWindow();
			if (iSelectedLibraryStingReturnID == window->GetID("ScriptSelector##+"))
			{
				//Update Script.
				if (sSelectedLibrarySting != "")
				{
					edit_grideleprof->aimain_s = sSelectedLibrarySting;
					sSelectedLibrarySting = "";
					iSelectedLibraryStingReturnID = -1; //disable.
					fpe_current_loaded_script = -1; //Reload image and DLUA.
					if(!pestrcasestr(edit_grideleprof->aimain_s.Get(), "default.lua"))
					{
						//PE: When selecting a script, disable static so script will run.
						if (elementID > 0) t.entityelement[elementID].staticflag = 0;
					}
				}
			}
			//if (ImGui::ImgBtn(fpe_current_loaded_script_image, ImVec2(ImgW*fRatio, ImgH*fRatio), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true))
			if (ImGui::ImgBtn(fpe_current_loaded_script_image, ImVec2(ImgW*fRatio, ImgH*fRatio), drawCol_black, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0,false))
			{
				//Select script.
				if (t.entityprofile[entid].bIsDecal)
					sStartLibrarySearchString = "Decal";
				else
					sStartLibrarySearchString = "Objects";
				iLastDisplayLibraryType = -1;
				bExternal_Entities_Window = true;
				iDisplayLibraryType = 4;
				iLibraryStingReturnToID = window->GetID("ScriptSelector##+");
				if ( edit_grideleprof->aimain_s.Len() > 0)
					sMakeDefaultSelecting = edit_grideleprof->aimain_s;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Object Behavior");
			ImGui::TextCenter(cDisplayName);
			ImGui::PopItemWidth();
			#else
			ImGui::PushItemWidth(-10);
			if (ImGui::Combo("##Behaviours2SimpleInput", &item_current_type_selection, g_scriptobjects_items, g_scriptobjects_item_count, 20))
			{
				if (item_current_type_selection >= 0) {
					edit_grideleprof->aimain_s = scriptList_s[item_current_type_selection];
					//PE: When selecting a script, disable static so script will run.
					if (elementID > 0) t.entityelement[elementID].staticflag = 0;
				}
				else
					edit_grideleprof->aimain_s = "default.lua";
				aimain = edit_grideleprof->aimain_s.Lower();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Object Behavior");
			ImGui::PopItemWidth();
			#endif

			#ifndef USENEWMEDIASELECTWINDOWS
			if (item_current_type_selection == g_scriptobjects_item_count - 1)
			{
				//Custom Behaviours , display directly.
				std::string ms = t.strarr_s[417].Get();
				ms = "Script";
				cstr aim = edit_grideleprof->aimain_s;
				edit_grideleprof->aimain_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->aimain_s.Get(), (char *)ms.c_str(), t.strarr_s[207].Get(), pAIRoot,readonly);
				aimain = edit_grideleprof->aimain_s.Lower();
				if (aim != edit_grideleprof->aimain_s)
				{
					fpe_current_loaded_script = -1;
					//PE: When selecting a script, disable static so script will run.
					if (elementID > 0) t.entityelement[elementID].staticflag = 0;
				}
			}
			#endif

			if (lua_grideleprof->PropertiesVariableActive == 1)
			{
				speech_entries = DisplayLuaDescription(lua_grideleprof);
			}
			else
			{
				if (lua_grideleprof->PropertiesVariable.VariableDescription.Len() > 0)
				{
					if (edit_grideleprof->aimain_s != "default.lua") //No need to display.
						DisplayLuaDescriptionOnly(lua_grideleprof);
				}
			}


			if (speech_entries > 0)
			{
				// all SPEECH control is moved to this function.
				SpeechControls(speech_entries, bUpdateMainString, edit_grideleprof);
			}
		}
		else
		{
			//PE: Support markers > 1 here.
			if (t.entityprofile[entid].ismarker > 1) 
			{
				//ismarker = 1 has its own function.
				//DLUA support added here.
				bool bUpdateMainString = false;
				for (int speech_loop = 0; speech_loop < 5; speech_loop++)
					speech_ids[speech_loop] = -1;
				if (fpe_current_loaded_script != fpe_current_selected_script) 
				{
					//Load in lua and check for custom properties.
					cstr script_name = "scriptbank\\";
					script_name += edit_grideleprof->aimain_s;

					#ifdef USENEWMEDIASELECTWINDOWS
					fpe_current_loaded_script_image = PROPERTIES_CACHE_ICONS + fpe_current_loaded_script_image_count;
					if (fpe_current_loaded_script_image_count++ > 10) fpe_current_loaded_script_image_count = 0;
					std::string sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
					if (pref.current_style == 25 || pref.current_style == 3)
						sImgName += ".png";
					else
						sImgName += "2.png";
					image_setlegacyimageloading(true);
					LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
					image_setlegacyimageloading(false);
					if (!GetImageExistEx(fpe_current_loaded_script_image))
					{
						if (!(pref.current_style == 25 || pref.current_style == 3))
						{
							sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
							sImgName += ".png";
							image_setlegacyimageloading(true);
							LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
							image_setlegacyimageloading(false);
							if (!GetImageExistEx(fpe_current_loaded_script_image))
							{
								fpe_current_loaded_script_image = FILETYPE_SCRIPT;
							}
						}
						else
							fpe_current_loaded_script_image = FILETYPE_SCRIPT;
					}
					#endif

					//Try to parse script.
					ParseLuaScript(edit_grideleprof, script_name.Get());
					fpe_current_loaded_script = fpe_current_selected_script;

					if (edit_grideleprof->PropertiesVariableActive == 1) {
						bUpdateMainString = true;
						fpe_current_loaded_script_has_dlua = true;
					}
					else 
					{
						if (fpe_current_loaded_script_has_dlua) 
						{
							//Reset edit_grideleprof->soundset4_s that contain the dlua calls.
							edit_grideleprof->soundset4_s = "";
							fpe_current_loaded_script_has_dlua = false;
						}
					}
				}

				#ifdef USENEWMEDIASELECTWINDOWS
				//Display only no selections.
				ImGui::PushItemWidth(-10);
				float w = ImGui::GetContentRegionAvailWidth() - 16.0f;
				float ImgW = ImageWidth(fpe_current_loaded_script_image);
				float ImgH = ImageHeight(fpe_current_loaded_script_image);
				float fRatio = w / ImgW;

				//LB: Do allow TRIGGER ZONE script to change
				ImGuiWindow* window = ImGui::GetCurrentWindow();
				if (t.entityprofile[entid].ismarker == 3 && t.entityprofile[entid].trigger.stylecolor == 2)
				{
					if (iSelectedLibraryStingReturnID == window->GetID("ScriptSelector##+"))
					{
						//Update Script.
						if (sSelectedLibrarySting != "")
						{
							edit_grideleprof->aimain_s = sSelectedLibrarySting;
							sSelectedLibrarySting = "";
							iSelectedLibraryStingReturnID = -1;
							fpe_current_loaded_script = -1;
						}
					}
				}
				if (ImGui::ImgBtn(fpe_current_loaded_script_image, ImVec2(ImgW*fRatio, ImgH*fRatio), drawCol_black, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, false))
				{
					//LB: But do allow TRIGGER ZONE script to change
					if (t.entityprofile[entid].ismarker == 3 && t.entityprofile[entid].trigger.stylecolor == 2)
					{
						//Select script.
						sStartLibrarySearchString = "Markers";
						iLastDisplayLibraryType = -1;
						bExternal_Entities_Window = true;
						iDisplayLibraryType = 4;
						iLibraryStingReturnToID = window->GetID("ScriptSelector##+");
						if (edit_grideleprof->aimain_s.Len() > 0)
						{
							sMakeDefaultSelecting = edit_grideleprof->aimain_s;
						}
					}
				}
				ImGui::TextCenter(cDisplayName);
				ImGui::PopItemWidth();
				#endif


				if (edit_grideleprof->PropertiesVariableActive == 1 || edit_grideleprof->PropertiesVariable.VariableDescription.Len() > 0)
				{
					//ImGui::Indent(10);

					if (edit_grideleprof->PropertiesVariableActive == 1) {
						speech_entries = DisplayLuaDescription(edit_grideleprof);
					}
					else {
						if (edit_grideleprof->PropertiesVariable.VariableDescription.Len() > 0) {
							DisplayLuaDescriptionOnly(edit_grideleprof);
						}
					}

					//ImGui::Indent(-10);
				}

				if (speech_entries > 0)
				{
					// all SPEECH control is moved to this function.
					SpeechControls(speech_entries, bUpdateMainString, edit_grideleprof);
				}

			}

		}
	}

	// All objects need 'certain fields' as pretty commmon  to have it for the script
	//PE: Markers also have these fields. So anything with dlua active.
	if (edit_grideleprof->PropertiesVariable.VariableDescription.Len() > 0) //t.entityprofile[entid].ismarker == 0) // so as not to interfere with markers
	{
		bool bSound0Mentioned = false;
		bool bSound1Mentioned = false;
		bool bSound2Mentioned = false;
		bool bSound3Mentioned = false;
		bool bVideoSlotMentioned = false;
		bool bIfUsedMentioned = false;
		bool bUseKeyMentioned = false;
		bool bShootingWeaponMentioned = false;
		bool bMeleeWeaponMentioned = false;
		int iAnimationSetMentioned = 0;
		char pCaptureAnyScriptDesc[10240 + (80 * 300) + (80 * 300)];

		strcpy(pCaptureAnyScriptDesc, edit_grideleprof->PropertiesVariable.VariableDescription.Get());
		for (int i = 0; i < edit_grideleprof->PropertiesVariable.iVariables; i++)
		{
			strcat(pCaptureAnyScriptDesc, edit_grideleprof->PropertiesVariable.VariableSectionDescription[i]);
		}
		for (int i = 0; i < edit_grideleprof->PropertiesVariable.iVariables; i++)
		{
			strcat(pCaptureAnyScriptDesc, edit_grideleprof->PropertiesVariable.VariableSectionEndDescription[i]);
		}
		if (strstr(pCaptureAnyScriptDesc, "<Sound0>") != 0) bSound0Mentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Sound1>") != 0) bSound1Mentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Sound2>") != 0) bSound2Mentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Sound3>") != 0) bSound3Mentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Video Slot>") != 0) bVideoSlotMentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<If Used>") != 0) bIfUsedMentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Use Key>") != 0) bUseKeyMentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Shooting Weapon>") != 0) bShootingWeaponMentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Melee Weapon>") != 0) bMeleeWeaponMentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Soldier Animations>") != 0) iAnimationSetMentioned = 1;
		if (strstr(pCaptureAnyScriptDesc, "<Melee Animations>") != 0) iAnimationSetMentioned = 2;
		if (strstr(pCaptureAnyScriptDesc, "<Zombie Animations>") != 0) iAnimationSetMentioned = 3;
		if (strstr(pCaptureAnyScriptDesc, "<Default Animations>") != 0) iAnimationSetMentioned = 4;		

		if (bSound0Mentioned || bSound1Mentioned || bSound2Mentioned || bSound3Mentioned || bVideoSlotMentioned || bIfUsedMentioned || bUseKeyMentioned || bShootingWeaponMentioned || bMeleeWeaponMentioned || iAnimationSetMentioned>0)
		{
			if (bVideoSlotMentioned == true)
			{
				#ifdef WICKEDENGINE
				#define VIDEOFILEID (PROPERTIES_CACHE_ICONS+997)
				static cstr videofile = "";
				static int videofile_preview_id = 0;
				if (edit_grideleprof->soundset1_s != videofile)
				{
					//Load new image preview.
					videofile_preview_id = 0;
					if (edit_grideleprof->soundset1_s != "")
					{
						videofile_preview_id = VIDEOFILEID;

						std::string stmp = edit_grideleprof->soundset1_s.Get();
						replaceAll(stmp, "videobank", ""); //Video thumbs stored without videobank.
						replaceAll(stmp, "\\\\", "\\"); //Remove double backslash.

						bool CreateBackBufferCacheName(char *file, int width, int height);
						extern cstr BackBufferCacheName;
						CreateBackBufferCacheName((char *)stmp.c_str(), 512, 288);
						SetMipmapNum(1); //PE: mipmaps not needed.
						image_setlegacyimageloading(true);
						if (FileExist(BackBufferCacheName.Get()))
						{
							LoadImage((char *)BackBufferCacheName.Get(), videofile_preview_id);
						}
						image_setlegacyimageloading(false);
						SetMipmapNum(-1);
						if (!GetImageExistEx(VIDEOFILEID))
						{
							videofile_preview_id = 0;
						}
					}
					videofile = edit_grideleprof->soundset1_s;
				}
				#endif
				#ifdef WICKEDENGINE
				edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), "Video Slot", "Choose a movie file (mp4 format) to play when the player enters this zone", "videobank\\", readonly);
				#else
				edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), "Video Slot", t.strarr_s[601].Get(), "videobank\\", readonly);
				#endif
				#ifdef WICKEDENGINE
				if (videofile_preview_id > 0 && GetImageExistEx(videofile_preview_id))
				{
					extern ImVec4 drawCol_back;
					extern ImVec4 drawCol_normal;
					extern ImVec4 drawCol_hover;
					extern ImVec4 drawCol_Down;

					float w = ImGui::GetContentRegionAvailWidth();
					float iwidth = w;
					float ImgW = ImageWidth(videofile_preview_id);
					float ImgH = ImageHeight(videofile_preview_id);
					float fHighRatio = ImgH / ImgW;
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (iwidth*0.5), 0.0f));
					ImGui::ImgBtn(videofile_preview_id, ImVec2(iwidth - 18.0f, (iwidth - 18.0f) * fHighRatio), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
				}
				#endif
			}
			#ifdef WICKEDENGINE
			if (bSound0Mentioned == true && bVideoSlotMentioned == false) edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Sound0", t.strarr_s[253].Get(), "audiobank\\",readonly);
			#else
			if (bSound0Mentioned == true) edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Sound0", t.strarr_s[253].Get(), "audiobank\\", readonly);
			#endif
			if (bSound1Mentioned == true) edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), "Sound1", t.strarr_s[254].Get(), "audiobank\\", readonly);
			if (bSound2Mentioned == true) edit_grideleprof->soundset2_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset2_s.Get(), "Sound2", t.strarr_s[254].Get(), "audiobank\\", readonly);
			if (bSound3Mentioned == true) edit_grideleprof->soundset3_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset3_s.Get(), "Sound3", t.strarr_s[254].Get(), "audiobank\\", readonly);
			if (bIfUsedMentioned == true) edit_grideleprof->ifused_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->ifused_s.Get(), t.strarr_s[437].Get(), t.strarr_s[226].Get(), readonly);
			if (bUseKeyMentioned == true) edit_grideleprof->usekey_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->usekey_s.Get(), t.strarr_s[436].Get(), t.strarr_s[225].Get(), readonly);
			bool readonly = false;
			if (bShootingWeaponMentioned == true || bMeleeWeaponMentioned == true)
			{
				if (t.entityprofile[entid].ischaracter == 1)
				{
					extern void animsystem_weaponproperty (int, bool, entityeleproftype*, bool, bool);
					animsystem_weaponproperty(t.entityprofile[entid].characterbasetype, readonly, edit_grideleprof, bShootingWeaponMentioned, bMeleeWeaponMentioned);
				}
			}
			if (iAnimationSetMentioned > 0)
			{
				extern void animsystem_animationsetproperty (int, bool, entityeleproftype*, int, int);
				animsystem_animationsetproperty(t.entityprofile[entid].characterbasetype, readonly, edit_grideleprof, iAnimationSetMentioned, elementID);
			}
		}
	}

	// particle file moved here for WICKED
	#ifdef WICKEDENGINE
	#ifndef USENEWPARTICLESETUP
	if (t.entityprofile[entid].ismarker == 10)
	{
		cstr newfile_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->newparticle.emittername.Get(), "Particle File", "Select a particle file (this is temporary and not the final design)", "particlesbank\\",readonly);
		if (strnicmp(newfile_s.Get() + strlen(newfile_s.Get()) - 4, ".arx", 4) == NULL) newfile_s = Left(newfile_s.Get(), Len(newfile_s.Get()) - 4);
		if (newfile_s != edit_grideleprof->newparticle.emittername)
		{
			edit_grideleprof->newparticle.emittername = newfile_s;
			if (edit_grideleprof->newparticle.emitterid != -1)
			{
				gpup_deleteEffect(edit_grideleprof->newparticle.emitterid);
				edit_grideleprof->newparticle.emitterid = -1;
			}
			//PE: Activate instantly.
			if (elementID > 0)
			{
				t.entityelement[elementID].eleprof.newparticle.emittername = edit_grideleprof->newparticle.emittername;
				t.entityelement[elementID].eleprof.newparticle.emitterid = -1;
				entity_updateparticleemitter(elementID);
				edit_grideleprof->newparticle.emitterid = t.entityelement[elementID].eleprof.newparticle.emitterid;
			}
		}
	}
	#endif
	#endif

	if (readonly)
	{
		ImGui::PopItemFlag();
		ImGui::PopStyleVar();
	}
}

void DisplayFPEGeneral(bool readonly, int entid, entityeleproftype *edit_grideleprof, int elementID)
{
	ImGui::Indent(10);

	if (!edit_grideleprof)
	{
		edit_grideleprof = &t.grideleprof;
	}
	t.group = 0;

	bool bRubberbandActive = false;
	if (g.entityrubberbandlist.size() > 0) bRubberbandActive = true;
	bool bAllGotPhysics = false;

	// Character allegiance.
	if (t.entityprofile[entid].ischaracter)
	{
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, 6.0f));
		ImGui::Text("Allegiance");
		ImGui::SameLine();
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
		ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
		ImGui::PushItemWidth(-10);

		if (g.entityrubberbandlist.size() == 0)
		{
			const char* items_combo[] = { "Enemy", "Ally", "Neutral" };
			ImGui::Combo("##ShooteriCharAlliance", &edit_grideleprof->iCharAlliance, items_combo, IM_ARRAYSIZE(items_combo));
			if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Set Character Allegiance");
			ImGui::PopItemWidth();
		}
		else
		{
			const char* items_combo[] = { "(change all)", "Enemies", "Allies", "Neutral" };

			int new_selection = t.entityelement[g.entityrubberbandlist[0].e].eleprof.iCharAlliance;
			bool bGotSameSelection = true;
			//Check if all selection are the same.
			for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
			{
				int e = g.entityrubberbandlist[i].e;
				if (e > 0 && t.entityprofile[t.entityelement[e].bankindex].ischaracter > 0)
				{
					if (t.entityelement[e].eleprof.iCharAlliance != new_selection)
					{
						bGotSameSelection = false;
						break;
					}
				}
			}
			if (bGotSameSelection)
				new_selection++;
			else
				new_selection = 0;

			if (ImGui::Combo("##ShooteriCharAlliancem", &new_selection, items_combo, IM_ARRAYSIZE(items_combo)))
			{
				if (new_selection > 0)
				{
					new_selection--;
					for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
					{
						int e = g.entityrubberbandlist[i].e;
						if (e > 0 && t.entityprofile[t.entityelement[e].bankindex].ischaracter > 0)
						{
							t.entityelement[e].eleprof.iCharAlliance = new_selection;
						}
					}
				}
			}
			if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Set Character Allegiance");
		}
	}

	if (t.entityprofile[entid].ismarker == 0 || t.entityprofile[entid].islightmarker == 1)
	{
		if (g.gentitytogglingoff == 0)
		{
			int iShape = t.entityprofile[entid].collisionmode;
			if (edit_grideleprof->iOverrideCollisionMode != -1) iShape = edit_grideleprof->iOverrideCollisionMode;
			if (iShape == 9 || iShape == 10 )
			{
				// static only - hulls cannot be made dynamic at this time!
				const char* items[] = { "Static Hull" };
				int item_current = 0;
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::Text("Static mode");
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
				ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##combostaticPhysics3", &item_current, items, IM_ARRAYSIZE(items)))
				{
					// nothing to choose
				}
				ImGui::PopItemWidth();
			}
			else
			{
				t.tokay = 1;
				if (ObjectExist(g.entitybankoffset + entid) == 1)
				{
					if (GetNumberOfFrames(g.entitybankoffset + entid) > 0)
					{
						t.tokay = 0;
					}
				}
				if (t.tokay == 1 || bRubberbandActive)
				{
					//Static , physics on , physics off.
					const char* items[] = { "Static", "Physics on", "Physics off" };
					const char* itemsAll[] = { "Change All To" , "Static", "Physics on", "Physics off" };
					const char** Selected = items;
					int iArraySize = 3;
					int item_current = 0;
					if (t.entityelement[elementID].staticflag == 1)
						item_current = 0;
					else if (edit_grideleprof->physics)
						item_current = 1;
					else
						item_current = 2;

					int iIndexCount = 0;
					bool bAllTheSame = true;
					if (bRubberbandActive)
					{
						//Check if all selected have the same settings.
						for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
						{
							int e = g.entityrubberbandlist[i].e;
							int item_test = 0;
							if (t.entityelement[e].staticflag == 1)
								item_test = 0;
							else if (t.entityelement[e].eleprof.physics)
								item_test = 1;
							else
								item_test = 2;
							if (item_test != item_current)
							{
								bAllTheSame = false;
								iIndexCount = 1;
								Selected = itemsAll;
								iArraySize = 4;
								item_current = 0;
								break;
							}
						}
					}
					if (bAllTheSame && item_current == 1) bAllGotPhysics = true;

					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

					ImGui::Text("Static mode");
					ImGui::SameLine();
					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
					ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
					ImGui::PushItemWidth(-10);
					if (ImGui::Combo("##combostaticPhysics", &item_current, Selected, iArraySize))
					{
						//Change.
						if (iIndexCount == 1 && item_current == 0)
						{
							//Ignore change all.
						}
						else if (item_current == 0 + iIndexCount && t.tokay == 1) //Only non animated can get static.
						{
							t.entityelement[elementID].staticflag = 1;
							edit_grideleprof->physics = 1;
						}
						else if (item_current == 0 + iIndexCount && t.tokay == 0)
						{
							//Ignore Animated and Static.
						}
						else if (item_current == 1 + iIndexCount)
						{
							t.entityelement[elementID].staticflag = 0;
							edit_grideleprof->physics = 1;
						}
						else
						{
							//No physics
							t.entityelement[elementID].staticflag = 0;
							edit_grideleprof->physics = 0;
						}

						if (bRubberbandActive)
						{
							//Check if all selected have the same settings.
							for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
							{
								int e = g.entityrubberbandlist[i].e;
								int masterid = t.entityelement[e].bankindex;
								int ok = 1;
								if (ObjectExist(g.entitybankoffset + masterid) == 1)
								{
									if (GetNumberOfFrames(g.entitybankoffset + masterid) > 0)
									{
										ok = 0;
									}
								}
								if (iIndexCount == 1 && item_current == 0)
								{
									//Ignore change all.
								}
								else if (item_current == 0 + iIndexCount && ok == 1) //Only non animated can get static.
								{
									t.entityelement[e].staticflag = 1;
									t.entityelement[e].eleprof.physics = 1;
								}
								else if (item_current == 0 + iIndexCount && ok == 0)
								{
									//Ignore Animated and Static.
								}
								else if (item_current == 1 + iIndexCount)
								{
									t.entityelement[e].staticflag = 0;
									t.entityelement[e].eleprof.physics = 1;
								}
								else
								{
									//No physics
									t.entityelement[e].staticflag = 0;
									t.entityelement[e].eleprof.physics = 0;
								}

							}
						}
					}
					ImGui::PopItemWidth();
				}
				else
				{
					
					// Only display physics for characters in advanced mode.
					bool bDisplayPhysics = true;
					if (t.entityprofile[entid].ischaracter == 1)
						bDisplayPhysics = false;

					if (bDisplayPhysics)
					{
						//Animated Only physics on/off cant be static.
						const char* items[] = { "Physics on", "Physics off" };
						int item_current = 0;
						if (edit_grideleprof->physics)
							item_current = 0;
						else
							item_current = 1;

						ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
						ImGui::Text("Physics");
						ImGui::SameLine();
						ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
						ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
						ImGui::PushItemWidth(-10);
						if (ImGui::Combo("##combostaticPhysics2", &item_current, items, IM_ARRAYSIZE(items)))
						{
							//Change.
							if (item_current == 0)
							{
								t.entityelement[elementID].staticflag = 0;
								edit_grideleprof->physics = 1;
							}
							else
							{
								//No physics
								t.entityelement[elementID].staticflag = 0;
								edit_grideleprof->physics = 0;
							}
						}
						ImGui::PopItemWidth();
					}
				}
			}
		}
	}

	if (t.tflagspawn == 1)
	{
		if (bRubberbandActive)
		{
			bool bAllTheSame = true;
			//Check if all selected have the same settings.
			for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
			{
				int e = g.entityrubberbandlist[i].e;
				if (t.entityelement[e].eleprof.spawnatstart != edit_grideleprof->spawnatstart)
				{
					bAllTheSame = false;
					break;
				}
			}
			if (bAllTheSame)
			{
				int spawnatstart = edit_grideleprof->spawnatstart;
				edit_grideleprof->spawnatstart = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->spawnatstart), "Show at start of level (Change All)", t.strarr_s[563].Get(), 0, readonly); //t.strarr_s[562].Get()
				if (spawnatstart != edit_grideleprof->spawnatstart)
				{
					for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
					{
						int e = g.entityrubberbandlist[i].e;
						t.entityelement[e].eleprof.spawnatstart = edit_grideleprof->spawnatstart;
					}
				}
			}
		}
		else
		{
			edit_grideleprof->spawnatstart = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->spawnatstart), "Show at start of level", t.strarr_s[563].Get(), 0, readonly); //t.strarr_s[562].Get()
		}
	}

#ifdef WICKEDENGINE
	if (g_bEnableAutoFlattenSystem && t.entityprofile[entid].autoflatten != 0 && !bRubberbandActive)
	{
		bool bOld = edit_grideleprof->bAutoFlatten;
		edit_grideleprof->bAutoFlatten = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->bAutoFlatten), "Auto Flatten", "Flattens the terrain under the object and clears any trees and grass", 0, readonly);
		if (bOld != edit_grideleprof->bAutoFlatten)
		{
			if (elementID > 0)
			{
				if (!edit_grideleprof->bAutoFlatten && edit_grideleprof->iFlattenID != -1)
				{
					//PE: Disabled remove any flatten.
					GGTerrain_RemoveFlatArea(edit_grideleprof->iFlattenID);
					t.entityelement[elementID].eleprof.iFlattenID = edit_grideleprof->iFlattenID = -1;
				}
				if (edit_grideleprof->bAutoFlatten)
				{
					if (edit_grideleprof->iFlattenID == -1)
						entity_autoFlattenWhenAdded(elementID);
					else
						entity_updateautoflatten(elementID);
					edit_grideleprof->iFlattenID = t.entityelement[elementID].eleprof.iFlattenID;
					g.projectmodified = 1;
				}
			}
		}
	}
#endif

	if (edit_grideleprof->physics == 1 && t.entityelement[elementID].staticflag == 0)
	{
		bool bDisplayPhysics = true;
		if (t.entityprofile[entid].ischaracter == 1)
			bDisplayPhysics = false;

		if (bDisplayPhysics)
		{
			//Affected by gravity
			if (bRubberbandActive)
			{
				if (bAllGotPhysics)
				{
					int iAffectedByGravity = edit_grideleprof->iAffectedByGravity;
					edit_grideleprof->iAffectedByGravity = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->iAffectedByGravity), "Affected by gravity (Change All)", "If set this object will be affected by gravity", 0, readonly); //t.strarr_s[562].Get()
					if (edit_grideleprof->iAffectedByGravity != iAffectedByGravity)
					{
						for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
						{
							int e = g.entityrubberbandlist[i].e;
							t.entityelement[e].eleprof.iAffectedByGravity = edit_grideleprof->iAffectedByGravity;
						}
					}
				}
			}
			else
				edit_grideleprof->iAffectedByGravity = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->iAffectedByGravity), "Affected by gravity", "If set this object will be affected by gravity", 0, readonly); //t.strarr_s[562].Get()
		}
	}

	// added Specular Control per entity
	#ifdef WICKEDENGINE
	#else
	if (t.tflagvis == 1)
	{
		if (t.tflagsimpler == 0)
		{
			edit_grideleprof->specularperc = atol(imgui_setpropertystring2(t.group, Str(edit_grideleprof->specularperc), "Specular", "Set specular percentage to modulate entity specular effect"));
		}
	}
	#endif

	// strength of an entity is standard
	#ifdef WICKEDENGINE
	if (t.entityprofile[entid].ischaracter == 0)
	{
		ImGui::TextCenter("Strength");
		ImGui::PushItemWidth(-10);
		ImGui::MaxSliderInputInt("##StrengthSimpleInput", &edit_grideleprof->strength, 1, 500, "Sets the strength of the object");
		ImGui::PopItemWidth();
	}
	else
	{
		// Only for characters do we need these.
		ImGui::TextCenter("Health");
		ImGui::PushItemWidth(-10);
		ImGui::MaxSliderInputInt("##HealthSimpleInput", &edit_grideleprof->strength, 1, 500, "Sets the health of the character");
		ImGui::PopItemWidth();

		if (pref.iObjectEnableAdvanced)
		{
			ImGui::TextCenter("Speed");
			ImGui::PushItemWidth(-10);
			ImGui::MaxSliderInputInt("##AnimationSpeedSimpleInput", &edit_grideleprof->iMoveSpeed, 1, 500, "Sets the animation and/or move speed of the character");
			ImGui::PopItemWidth();

			ImGui::TextCenter("Turn Speed");
			ImGui::PushItemWidth(-10);
			ImGui::MaxSliderInputInt("##TurnSpeedSimpleInput", &edit_grideleprof->iTurnSpeed, 1, 500, "Sets the turn speed of the character");
			ImGui::PopItemWidth();
		}
		
		ImGui::TextCenter("View Angle");
		ImGui::PushItemWidth(-10);
		int iValue = edit_grideleprof->coneangle;
		ImGui::MaxSliderInputInt("##ViewAngleSimpleInput", &iValue, 1, 180, "Sets the viewing angle of the character");
		edit_grideleprof->coneangle = iValue;
		ImGui::PopItemWidth();
		ImGui::TextCenter("View Range");
		ImGui::PushItemWidth(-10);
		iValue = edit_grideleprof->conerange;
		ImGui::MaxSliderInputInt("##ViewRangeSimpleInput", &iValue, 100, 2000, "Sets the range at which the character can see");
		edit_grideleprof->conerange = iValue;
		ImGui::PopItemWidth();
	}

	if (!t.entityprofile[entid].ischaracter)
	{
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 15));
		ImGui::Text("Collision Shape");
		ImGui::SameLine();
		ImGui::Indent(100);
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
		ImGui::PushItemWidth(-10);
		char* pCollisionShapes[10] = { "Box","Polygon","Sphere","Cylinder","Convex Hull","Character Collision","Tree Collision","No Collision","Hull Decomp","Collision Mesh" };
		char pSelectedCollision[64];

		ImGui::PushItemFlag(ImGuiItemFlags_Disabled, false);
		ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 1.0f);

		int iShape = t.entityprofile[entid].collisionmode;
		if (edit_grideleprof->iOverrideCollisionMode != -1)	iShape = edit_grideleprof->iOverrideCollisionMode;
		switch (iShape)
		{
		case 0:
			strcpy(pSelectedCollision, pCollisionShapes[0]);
			break;
		case 1:
			strcpy(pSelectedCollision, pCollisionShapes[1]);
			break;
		case 2:
			strcpy(pSelectedCollision, pCollisionShapes[2]);
			break;
		case 3:
			strcpy(pSelectedCollision, pCollisionShapes[3]);
			break;
		case 9:
			strcpy(pSelectedCollision, pCollisionShapes[4]);
			break;
		case 21:
			strcpy(pSelectedCollision, pCollisionShapes[5]);
			break;
		case 50:
			strcpy(pSelectedCollision, pCollisionShapes[6]);
			break;
		case 11:
			strcpy(pSelectedCollision, pCollisionShapes[7]);
			break;
		case 10:
			strcpy(pSelectedCollision, pCollisionShapes[8]);
			break;
		case 8:
			strcpy(pSelectedCollision, pCollisionShapes[9]);
			break;
		default:
			break;
		}
		if (ImGui::BeginCombo("##ImporterCollisionShape", &pSelectedCollision[0], ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge))
		{
			for (int i = 0; i < 10; i++)
			{
				// Don't display "Polygon" collision for dynamic objects.
				if (i == 1 && t.entityelement[elementID].staticflag == 0) continue;

				// get collision shape name
				char* pCollisionShapeName = pCollisionShapes[i];

				// assign correct item based on pSelectedCollision
				bool is_selected = false;
				if (strcmp(pSelectedCollision, pCollisionShapeName) == NULL)
				{
					is_selected = true;
				}
				if (ImGui::Selectable(pCollisionShapeName, is_selected))
				{
					strcpy(pSelectedCollision, pCollisionShapeName);
					int iCollisionSelection = -1;
					switch (i)
					{
						case 0: iCollisionSelection = 0; break;
						case 1: iCollisionSelection = 1; break;
						case 2: iCollisionSelection = 2; break;
						case 3: iCollisionSelection = 3; break;
						case 4: iCollisionSelection = 9; break;
						case 5: iCollisionSelection = 21; break;
						case 6: iCollisionSelection = 50; break;
						case 7: iCollisionSelection = 11; break;
						case 8: iCollisionSelection = 10; break;
						case 9: iCollisionSelection = 8; break;
					}
					edit_grideleprof->iOverrideCollisionMode = iCollisionSelection;
					if (iCollisionSelection == 8 || iCollisionSelection == 9 || iCollisionSelection == 10)
					{
						t.entityelement[elementID].staticflag = 1;
						edit_grideleprof->physics = 1;
					}
				}
				if (is_selected) ImGui::SetItemDefaultFocus();
			}
			ImGui::EndCombo();
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set the collision type the object will use for physics");
		ImGui::Indent(-100);
		ImGui::PopItemWidth();
		ImGui::PopItemFlag();
		ImGui::PopStyleVar();
	}
	ImGui::Indent(-10);
	#endif

	// Character Has Weapon
	// moved to detection within LUA script via 'bShootingWeaponMentioned'
	if (ImGui::IsAnyItemFocused()) bImGuiGotFocus = true;

	// if not static, we may explode it
	if (t.entityelement[elementID].staticflag == 0)
	{
		if (t.entityprofile[entid].isimmobile == 1 && t.entityprofile[entid].ischaracter == 0)
		{
			// special case cannot blow up things like collectables, ammo, weapons, etc
		}
		else
		{
			ImGui::Indent(10);
			edit_grideleprof->explodable = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->explodable), "Explodable", "If set this object will explode when destroyed", 0, readonly);
			if (edit_grideleprof->explodable != 0)
			{
				ImGui::TextCenter("Explosion Damage");
				ImGui::MaxSliderInputInt("##ExplodeDamageSimpleInput", &edit_grideleprof->explodedamage, 0, 500, "Sets the damage dealt when this object explodes");
			}
			ImGui::Indent(-10);
		}
	}

	// Moved Always Active to general properties
	ImGui::Indent(10);
	bool btmp = edit_grideleprof->phyalways;
	ImGui::Checkbox("Always Active?", &btmp);
	edit_grideleprof->phyalways = btmp;
	if (ImGui::IsItemHovered()) ImGui::SetTooltip("If set the object will always be active, no matter how far away the player might be");
	ImGui::Indent(-10);

	// Is Immobile a useful tick to have in general and especially for freezing character positions in place for specific animations to work
	ImGui::Indent(10);
	edit_grideleprof->isimmobile = imgui_setpropertylist2(t.group, t.controlindex, Str(edit_grideleprof->isimmobile), t.strarr_s[457].Get(), t.strarr_s[247].Get(), 0);
	ImGui::Indent(-10);
}

void DisplayFPEAdvanced(bool readonly, int entid, entityeleproftype *edit_grideleprof, int elementID)
{
	int tflagtext = 0, tflagimage = 0; //PE: These is not used in VRTECH ?
	if (t.entityprofile[entid].ismarker == 3)
	{
		if (!t.entityprofile[entid].markerindex <= 1)
		{
			#ifdef VRTECH
			#else
			if (t.entityprofile[entid].markerindex == 2) tflagtext = 1;
			if (t.entityprofile[entid].markerindex == 3) tflagimage = 1;
			#endif
		}
	}

	if (!edit_grideleprof)
	{
		edit_grideleprof = &t.grideleprof;
	}

	int adv_flasgs = ImGuiTreeNodeFlags_DefaultOpen;
	if (g.vrqcontrolmode > 0)
	{
		//Simple version.
		adv_flasgs = ImGuiTreeNodeFlags_None;
	}

	bool bAdvencedOpen = true;
	if (bAdvencedOpen)
	{
		ImGui::Indent(10);

		t.group = 0;

		static int current_loaded_script = -1;
		static int current_selected_script = 0;
		static bool current_loaded_script_has_dlua = false;
		int speech_entries = 0;

		t.group = 0;
		if (t.tflagchar == 0 && t.tflagvis == 1 && t.tflagsimpler == 0)
		{
			//if (ImGui::StyleCollapsingHeader(t.strarr_s[412].Get(), ImGuiTreeNodeFlags_DefaultOpen))
			ImGui::TextCenter(t.strarr_s[412].Get());
			{
				// 101016 - Additional General Parameters
				edit_grideleprof->isocluder = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->isocluder), "Occluder", "Set to YES makes this object an occluder", 0, readonly);
				edit_grideleprof->isocludee = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->isocludee), "Occludee", "Set to YES makes this object an occludee", 0, readonly);
			}

			// these will be back when EBE needs doors and windows
			//setpropertystring2(t.group,Str(t.grideleprof.parententityindex),"Parent Index","Selects another entity element to be a parent") ; ++t.controlindex;
			//setpropertystring2(t.group,Str(t.grideleprof.parentlimbindex),"Parent Limb","Specifies the limb index of the parent to connect with") ; ++t.controlindex;
		}

		t.group = 1;
		//if (ImGui::StyleCollapsingHeader(t.strarr_s[415].Get(), ImGuiTreeNodeFlags_DefaultOpen))
		if (t.entityprofile[entid].lives == 0)
			ImGui::TextCenter(t.strarr_s[415].Get());
		{
			//  Basic AI
			if (t.tflagai == 1)
			{
				// can redirect to better folders if in g.quickparentalcontrolmode
				LPSTR pAIRoot = "scriptbank\\";
				if (g.quickparentalcontrolmode == 2)
				{
					if (t.entityprofile[entid].ismarker == 0)
					{
						if (t.tflagchar == 1)
							pAIRoot = "scriptbank\\people\\";
						else
							pAIRoot = "scriptbank\\objects\\";
					}
					else
					{
						pAIRoot = "scriptbank\\markers\\";
					}
				}
				cstr tmpvalue;
				tmpvalue = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->aimain_s.Get(), t.strarr_s[417].Get(), t.strarr_s[207].Get(), pAIRoot,readonly);
				if (edit_grideleprof->aimain_s != tmpvalue)
				{
					edit_grideleprof->aimain_s = tmpvalue;
					current_loaded_script = -1;
				}
			}
			
			// Has Weapon
			if (t.tflaghasweapon == 1 && t.playercontrol.thirdperson.enabled == 0 && g.quickparentalcontrolmode != 2 && edit_grideleprof->lives == 0)
			{
				edit_grideleprof->hasweapon_s = imgui_setpropertylist2c_v2(t.group, t.controlindex, edit_grideleprof->hasweapon_s.Get(), t.strarr_s[419].Get(), t.strarr_s[209].Get(), 1,readonly, true, true, true, 0);
			}

			//  Is Weapon (FPGC - 280809 - filtered fpgcgenre=1 is shooter genre)
			if (t.tflagweap == 1 && g.fpgcgenre == 1)
			{
				edit_grideleprof->damage = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->damage), t.strarr_s[420].Get(), t.strarr_s[210].Get(), readonly));
				edit_grideleprof->accuracy = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->accuracy), t.strarr_s[421].Get(), "Increases the inaccuracy of conical distribution by 1/100th of t.a degree", readonly));
				if (edit_grideleprof->weaponisammo == 0)
				{
					edit_grideleprof->reloadqty = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->reloadqty), t.strarr_s[422].Get(), t.strarr_s[212].Get(),readonly));
					edit_grideleprof->fireiterations = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->fireiterations), t.strarr_s[423].Get(), t.strarr_s[213].Get(),readonly));
					edit_grideleprof->range = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->range), "Range", "Maximum range of bullet travel",readonly));
					edit_grideleprof->dropoff = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->dropoff), "Dropoff", "Amount in inches of vertical dropoff per 100 feet of bullet travel",readonly));
				}
				else
				{
					edit_grideleprof->lifespan = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->lifespan), t.strarr_s[424].Get(), t.strarr_s[214].Get(),readonly));
					edit_grideleprof->throwspeed = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->throwspeed), t.strarr_s[425].Get(), t.strarr_s[215].Get(),readonly));
					edit_grideleprof->throwangle = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->throwangle), t.strarr_s[426].Get(), t.strarr_s[216].Get(),readonly));
					edit_grideleprof->bounceqty = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->bounceqty), t.strarr_s[427].Get(), t.strarr_s[217].Get(),readonly));
					edit_grideleprof->explodeonhit = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->explodeonhit), t.strarr_s[428].Get(), t.strarr_s[218].Get(), 0,readonly);
				}
				if (t.tflagsimpler == 0)
				{
					edit_grideleprof->usespotlighting = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->usespotlighting), "Spot Lighting", "Set whether emits dynamic spot lighting", 0,readonly);
				}
			}

			//  Is Character
			if (t.tflagchar == 1)
			{
				if (t.tflagsimpler == 0)
				{
					// special check to avoid offering can take weapon if no HUD.X
					t.tfile_s = cstr("gamecore\\guns\\") + edit_grideleprof->hasweapon_s + cstr("\\HUD.X");
					if (FileExist(t.tfile_s.Get()) == 1)
					{
						edit_grideleprof->cantakeweapon = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->cantakeweapon), t.strarr_s[429].Get(), t.strarr_s[219].Get(), 0,readonly);
						//Take Weapon's Ammo
						cstr fieldname = t.strarr_s[430];
						if (fieldname == "Take Weapon's Ammo") fieldname = "Take Weapon Ammo"; //Need to be shorter.
						edit_grideleprof->quantity = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->quantity), fieldname.Get(), t.strarr_s[220].Get(),readonly));
					}
					edit_grideleprof->rateoffire = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->rateoffire), t.strarr_s[431].Get(), t.strarr_s[221].Get(),readonly));
				}
			}
			if (t.tflagquantity == 1 && g.quickparentalcontrolmode != 2 && edit_grideleprof->lives == 0)
			{
				edit_grideleprof->quantity = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->quantity), t.strarr_s[432].Get(), t.strarr_s[222].Get(),readonly));
			}

			//  AI Extra
			if (t.tflagvis == 1 && t.tflagai == 1)
			{
				if (t.tflagchar == 1)
				{
					edit_grideleprof->coneangle = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->coneangle), t.strarr_s[434].Get(), t.strarr_s[224].Get(),readonly));
					edit_grideleprof->conerange = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->conerange), "View Range", "The range within which the AI may see the player. Zero triggers the characters default range.",readonly));
					edit_grideleprof->ifused_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->ifused_s.Get(), t.strarr_s[437].Get(), t.strarr_s[226].Get(),readonly);
					if (g.quickparentalcontrolmode != 2)
						edit_grideleprof->isviolent = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->isviolent), "Blood Effects", "Sets whether blood and screams should be used", 0,readonly);
					if (t.tflagsimpler == 0)
					{
						edit_grideleprof->colondeath = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->colondeath), "End Collision", "Set to NO switches off collision when die", 0,readonly);
					}
				}
				else
				{
					if (t.tflagweap == 0 && t.tflagammo == 0)
					{
						//t.propfield[t.group] = t.controlindex;
						//++t.group; startgroup(t.strarr_s[435].Get()); t.controlindex = 0;
						edit_grideleprof->usekey_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->usekey_s.Get(), t.strarr_s[436].Get(), t.strarr_s[225].Get(),readonly);
						if (t.tflagsimpler != 0 & t.entityprofile[entid].ismarker == 3 && t.entityprofile[entid].trigger.stylecolor == 1)
						{
							// only one level - no winzone chain option
						}
						else
						{
							edit_grideleprof->ifused_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->ifused_s.Get(), t.strarr_s[437].Get(), t.strarr_s[226].Get(),readonly);
						}
					}
				}
			}
			if (t.tflagifused == 1)
			{
				if (t.tflagusekey == 1)
				{
					edit_grideleprof->usekey_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->usekey_s.Get(), t.strarr_s[436].Get(), t.strarr_s[225].Get(),readonly);
				}
				if (t.tflagsimpler != 0 & t.entityprofile[entid].ismarker == 3 && t.entityprofile[entid].trigger.stylecolor == 1)
				{
					// only one level - no winzone chain option
				}
				else
				{
					edit_grideleprof->ifused_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->ifused_s.Get(), t.strarr_s[438].Get(), t.strarr_s[227].Get(),readonly);
				}
			}

		}

		if (t.tflagspawn == 1)
		{
			t.group = 1;
			//if (ImGui::StyleCollapsingHeader(t.strarr_s[439].Get(), ImGuiTreeNodeFlags_DefaultOpen)) 
			ImGui::TextCenter(t.strarr_s[439].Get());
			{
				edit_grideleprof->spawnatstart = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->spawnatstart), t.strarr_s[562].Get(), t.strarr_s[563].Get(), 0,readonly);
			}
		}


		//  Statistics
		if ((t.tflagvis == 1 || t.tflagobjective == 1 || t.tflaglives == 1 || t.tflagstats == 1) && t.tflagweap == 0 && t.tflagammo == 0)
		{
			t.group = 1;
			ImGui::TextCenter(t.strarr_s[451].Get());
			{
				#ifdef PRODUCTV3
				#else
				//if (t.tflaglives == 1)
				//{
				//	edit_grideleprof->lives = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->lives), t.strarr_s[452].Get(), t.strarr_s[242].Get(),readonly));
				//}
				if (t.tflagvis == 1 || t.tflagstats == 1)
				{
					if (t.tflaglives == 1)
					{
						if(edit_grideleprof->lives == 0) // Dont display for player start marker, already there.
							edit_grideleprof->strength = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->strength), t.strarr_s[453].Get(), t.strarr_s[243].Get(),readonly));
					}
					else
					{
						if (t.tflagnotionofhealth == 1)
						{
							edit_grideleprof->strength = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->strength), t.strarr_s[454].Get(), t.strarr_s[244].Get(),readonly));
						}
					}
					if (t.tflagplayersettings == 1)
					{
						if (g.quickparentalcontrolmode != 2)
						{
							edit_grideleprof->isviolent = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->isviolent), "Blood Effects", "Sets whether blood and screams should be used", 0,readonly);
						}
						if (t.tflagnotionofhealth == 1 && edit_grideleprof->lives == 0)
						{
							t.playercontrol.regenrate = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.regenrate), "Regeneration Rate", "Sets the increase value at which the players health will restore",readonly));
							t.playercontrol.regenspeed = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.regenspeed), "Regeneration Speed", "Sets the speed in milliseconds at which the players health will regenerate",readonly));
							t.playercontrol.regendelay = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.regendelay), "Regeneration Delay", "Sets the delay in milliseconds after last damage hit before health starts regenerating",readonly));
						}
						edit_grideleprof->usespotlighting = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->usespotlighting), "Flashlight Disabled", "Sets whether the flashlight is disabled for the player", 0, readonly);
					}

					if(edit_grideleprof->lives == 0)
						edit_grideleprof->speed = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->speed), t.strarr_s[455].Get(), t.strarr_s[245].Get(),readonly));
					if (t.playercontrol.thirdperson.enabled == 1)
					{
						t.tanimspeed_f = t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed;
					}
					else
					{
						t.tanimspeed_f = edit_grideleprof->animspeed;
					}
					t.tanimspeed_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.tanimspeed_f), "Anim Speed", "Sets the default speed of any animation associated with this entity",readonly));

					if (t.playercontrol.thirdperson.enabled == 1)
					{
						t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed = t.tanimspeed_f;
					}
					else
					{
						edit_grideleprof->animspeed = t.tanimspeed_f;
					}
				}
				if (t.tflaghurtfall == 1) 
				{
					edit_grideleprof->hurtfall = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->hurtfall), t.strarr_s[456].Get(), t.strarr_s[246].Get(),readonly));
				}
				#endif
				if (t.tflagplayersettings == 1)
				{
					t.playercontrol.jumpmax_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.jumpmax_f), "Jump Speed", "Sets the jump speed of the player which controls overall jump height",readonly));
					t.playercontrol.gravity_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.gravity_f), "Gravity", "Sets the modified force percentage of the players own gravity",readonly));
					t.playercontrol.fallspeed_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.fallspeed_f), "Fall Speed", "Sets the maximum speed percentage at which the player will fall",readonly));
					t.playercontrol.fFallDamageMultiplier = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.fFallDamageMultiplier), "Fall Damage Multiplier", "Modifies the damage dealt to the player when landing from a fall", readonly));
					t.playercontrol.climbangle_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.climbangle_f), "Climb Angle", "Sets the maximum angle permitted for the player to ascend a slope",readonly));
					if (t.playercontrol.thirdperson.enabled == 0)
					{
						t.playercontrol.wobblespeed_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.wobblespeed_f), "Wobble Speed", "Sets the rate of motion applied to the camera when moving",readonly));
						t.playercontrol.wobbleheight_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.wobbleheight_f * 100), "Wobble Height", "Sets the degree of motion applied to the camera when moving",readonly)) / 100.0f;
						t.playercontrol.footfallpace_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.footfallpace_f * 100), "Footfall Pace", "Sets the rate at which the footfall sound is played when moving",readonly)) / 100.0f;
					}
					t.playercontrol.accel_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.accel_f * 100), "Acceleration", "Sets the acceleration curve used when t.moving from t.a stood position",readonly)) / 100.0f;
				}
				if (t.tflagmobile == 1)
				{
					edit_grideleprof->isimmobile = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->isimmobile), t.strarr_s[457].Get(), t.strarr_s[247].Get(), 0,readonly);
				}
				if (t.tflagmobile == 1)
				{
					if (t.tflagsimpler == 0)
					{
						edit_grideleprof->lodmodifier = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->lodmodifier), "LOD Modifier", "Modify when the LOD transition takes effect. The default value is 0, increase this to a percentage reduce the LOD effect.",readonly));
					}
				}
			}
		}

		//  Team field
		#ifdef PHOTONMP
		#else
		if (t.tflagteamfield == 1)
		{
			// setpropertylist3(t.group, t.controlindex, Str(edit_grideleprof->teamfield), "Team", "Specifies any team affiliation for multiplayer start marker", 0); ++t.controlindex;
		}
		#endif

		DisplayFPEPhysics(false, entid, edit_grideleprof);

		//  Ammo data (FPGC - 280809 - filtered fpgcgenre=1 is shooter genre
		if (g.fpgcgenre == 1)
		{
			if (t.tflagammo == 1 || t.tflagammoclip == 1)
			{
				//if (ImGui::StyleCollapsingHeader(t.strarr_s[459].Get(), ImGuiTreeNodeFlags_DefaultOpen)) 
				ImGui::TextCenter(t.strarr_s[459].Get());
				{
					edit_grideleprof->quantity = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->quantity), t.strarr_s[460].Get(), t.strarr_s[249].Get(),readonly));
				}

			}
		}

		//  Light data
		if (t.tflaglight == 1)
		{
			int iPrevValue = -1;
			bool bUpdateLight = false;
			float colors[5];

			//if (ImGui::StyleCollapsingHeader(t.strarr_s[461].Get(), ImGuiTreeNodeFlags_DefaultOpen))
			ImGui::TextCenter(t.strarr_s[461].Get());
			{
				iPrevValue = edit_grideleprof->light.range;
				edit_grideleprof->light.range = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->light.range), t.strarr_s[462].Get(), t.strarr_s[250].Get(),readonly)); //PE: 462=Light Range
				if (iPrevValue != edit_grideleprof->light.range)
					bUpdateLight = true;

				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::Text(t.strarr_s[463].Get());
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
				ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
				ImGui::PushItemWidth(-10);

				colors[3] = ((edit_grideleprof->light.color & 0xff000000) >> 24) / 255.0f;
				colors[0] = ((edit_grideleprof->light.color & 0x00ff0000) >> 16) / 255.0f;
				colors[1] = ((edit_grideleprof->light.color & 0x0000ff00) >> 8) / 255.0f;
				colors[2] = (edit_grideleprof->light.color & 0x000000ff) / 255.0f;
				if (ImGui::ColorEdit3("##LightColorSetupField", colors, 0))
				{
					colors[0] *= 255.0f;
					colors[1] *= 255.0f;
					colors[2] *= 255.0f;
					colors[3] *= 255.0f;
					edit_grideleprof->light.color = 0xff000000 + ((unsigned int)colors[0] << 16) + ((unsigned int)colors[1] << 8) + +((unsigned int)colors[2]);
					bUpdateLight = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", t.strarr_s[251].Get());
				ImGui::PopItemWidth();

				//setpropertycolor2(t.group, edit_grideleprof->light.color, t.strarr_s[463].Get(), t.strarr_s[251].Get()); ++t.controlindex; //PE: 463=Light Color
				if (t.tflagsimpler == 0)
				{
					iPrevValue = edit_grideleprof->usespotlighting;
					edit_grideleprof->usespotlighting = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->usespotlighting), "Spot Lighting", "Change dynamic light to spot lighting", 0,readonly);
					if (edit_grideleprof->usespotlighting != iPrevValue)
						bUpdateLight = true;
				}
			}

			if (bUpdateLight)
			{
				float lightx = t.entityelement[elementID].x;
				float lighty = t.entityelement[elementID].y;
				float lightz = t.entityelement[elementID].z;
				float lightax = t.entityelement[elementID].rx;
				float lightay = t.entityelement[elementID].ry;
				float lightaz = t.entityelement[elementID].rz;
				float lightrange = edit_grideleprof->light.range;
				float spotlightradius = edit_grideleprof->light.offsetup;
				float fLightHasProbe = edit_grideleprof->light.fLightHasProbe;
				int colr = colors[0];
				int colg = colors[1];
				int colb = colors[2];
				bool bCanShadow = edit_grideleprof->castshadow;

				int iLightIndex = edit_grideleprof->light.index;
				t.infinilight[iLightIndex].x = lightx;
				t.infinilight[iLightIndex].y = lighty;
				t.infinilight[iLightIndex].z = lightz;
				t.infinilight[iLightIndex].f_angle_x = lightax;
				t.infinilight[iLightIndex].f_angle_y = lightay;
				t.infinilight[iLightIndex].f_angle_z = lightaz;
				t.infinilight[iLightIndex].range = lightrange;
				t.infinilight[iLightIndex].spotlightradius = spotlightradius;
				t.infinilight[iLightIndex].fLightHasProbe = fLightHasProbe;
				t.infinilight[iLightIndex].colrgb.r = colr;
				t.infinilight[iLightIndex].colrgb.g = colg;
				t.infinilight[iLightIndex].colrgb.b = colb;
				t.infinilight[iLightIndex].bCanShadow = bCanShadow;		
				uint64_t iWickedLightIndex = t.infinilight[iLightIndex].wickedlightindex;
				WickedCall_UpdateLight(iWickedLightIndex, lightx, lighty, lightz, lightax, lightay, lightaz, lightrange, spotlightradius, colr, colg, colb, bCanShadow);
			}
		}

		//  Decal data
		if (t.tflagtdecal == 1)
		{
			t.propfield[t.group] = t.controlindex;

			//  FPGC - 300710 - could never change base decal, so comment out this property (entity denotes decal choice)
			//     `inc group ; startgroup(strarr$(464)) ; controlindex=0
			//     `setpropertyfile2(group,grideleprof.basedecal$,strarr$(465),strarr$(252),"gamecore\\decals\\") ; inc controlindex

			//  Decal Particle data
			if (t.tflagdecalparticle == 1)
			{
				//++t.group; startgroup("Decal Particle"); t.controlindex = 0;
				//if (ImGui::StyleCollapsingHeader("Decal Particle", ImGuiTreeNodeFlags_DefaultOpen)) 
				ImGui::TextCenter("Decal Particle");
				{
					edit_grideleprof->particleoverride = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->particleoverride), "Custom Settings", "Whether you wish to override default settings", 0,readonly);
					edit_grideleprof->particle.offsety = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.offsety), "OffsetY", "Vertical adjustment of start position",readonly));
					edit_grideleprof->particle.scale = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.scale), "Scale", "A value from 0 to 100, denoting size of particle",readonly));
					edit_grideleprof->particle.randomstartx = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.randomstartx), "Random Start X", "Random start area",readonly));
					edit_grideleprof->particle.randomstarty = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.randomstarty), "Random Start Y", "Random start area",readonly));
					edit_grideleprof->particle.randomstartz = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.randomstartz), "Random Start Z", "Random start area",readonly));
					edit_grideleprof->particle.linearmotionx = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.linearmotionx), "Linear Motion X", "Constant motion direction",readonly));
					edit_grideleprof->particle.linearmotiony = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.linearmotiony), "Linear Motion Y", "Constant motion direction",readonly));
					edit_grideleprof->particle.linearmotionz = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.linearmotionz), "Linear Motion Z", "Constant motion direction",readonly));
					edit_grideleprof->particle.randommotionx = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.randommotionx), "Random Motion X", "Random motion direction",readonly));
					edit_grideleprof->particle.randommotiony = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.randommotiony), "Random Motion Y", "Random motion direction",readonly));
					edit_grideleprof->particle.randommotionz = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.randommotionz), "Random Motion Z", "Random motion direction",readonly));
					edit_grideleprof->particle.mirrormode = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.mirrormode), "Mirror Mode", "Set to one to reverse the particle",readonly));
					edit_grideleprof->particle.camerazshift = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.camerazshift), "Camera Z Shift", "Shift t.particle towards camera",readonly));
					edit_grideleprof->particle.scaleonlyx = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.scaleonlyx), "Scale Only X", "Percentage X over Y scale",readonly));
					edit_grideleprof->particle.lifeincrement = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.lifeincrement), "Life Increment", "Control lifespan of particle",readonly));
					edit_grideleprof->particle.alphaintensity = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.alphaintensity), "Alpha Intensity", "Control alpha percentage of particle",readonly));
					//  V118 - 060810 - knxrb - Decal animation setting (Added animation choice setting).
					edit_grideleprof->particle.animated = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->particle.animated), "Animated Particle", "Sets whether the t.particle t.decal Texture is animated or static.", 0,readonly);
				}
			}
		}

		// New Particle Component
		if (t.tflagnewparticle == 1)
		{
			cstr newfile_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->newparticle.emittername.Get(), "Particle File", "Select a particle file (this is temporary and not the final design)", "particlesbank\\",readonly);
			if (strnicmp(newfile_s.Get() + strlen(newfile_s.Get()) - 4, ".arx", 4) == NULL) newfile_s = Left(newfile_s.Get(), Len(newfile_s.Get()) - 4);
			if (newfile_s != edit_grideleprof->newparticle.emittername)
			{
				edit_grideleprof->newparticle.emittername = newfile_s;
				if (edit_grideleprof->newparticle.emitterid != -1)
				{
					#ifdef WICKEDENGINE
					gpup_deleteEffect(edit_grideleprof->newparticle.emitterid);
					#endif
					edit_grideleprof->newparticle.emitterid = -1;
				}
				#ifdef WICKEDENGINE
				//PE: Activate instantly.
				if (elementID > 0)
				{
					t.entityelement[elementID].eleprof.newparticle.emittername = edit_grideleprof->newparticle.emittername;
					t.entityelement[elementID].eleprof.newparticle.emitterid = -1;
					entity_updateparticleemitter(elementID);
					edit_grideleprof->newparticle.emitterid = t.entityelement[elementID].eleprof.newparticle.emitterid;
				}
				#endif
			}
		}

		// Sound
		if (t.tflagsound == 1 || t.tflagsoundset == 1 || tflagtext == 1 || tflagimage == 1)
		{
			cstr group_text;
			if (tflagtext == 1 || tflagimage == 1)
			{
				if (tflagtext == 1) group_text = "Text";
				if (tflagimage == 1) group_text = "Image";
			}
			else
			{
				group_text = "Media";
			}

			if (speech_entries > 0)
			{
			}

			//if (ImGui::StyleCollapsingHeader(group_text.Get(), ImGuiTreeNodeFlags_DefaultOpen))
			ImGui::TextCenter(group_text.Get());
			{
				if (g.fpgcgenre == 1)
				{
					if (t.entityprofile[entid].ischaracter > 0)
					{
						edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Sound0", t.strarr_s[254].Get(), "audiobank\\",readonly);
					}
					else
					{
						if (g.vrqcontrolmode != 0)
						{
							if (t.tflagsound == 1 && t.tflagsoundset != 1)
							{
								//PE: changed from 469 to 467 , should be sound0
								edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\",readonly);
							}
						}
						else
						{
							if (t.tflagsound == 1 && t.tflagsoundset != 1)
							{
								edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\",readonly);
							}
						}
						if (t.tflagsoundset == 1)
						{
							edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[469].Get(), t.strarr_s[255].Get(), "audiobank\\voices\\",readonly);
						}
						if (tflagtext == 1)
						{
							edit_grideleprof->soundset_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Text to Appear", "Enter text to appear in-game",readonly);
						}
						if (tflagimage == 1)
						{
							#ifdef WICKEDENGINE
							edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Image File", "Select image to appear in-game", "imagebank\\", readonly);
							#else
							edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Image File", "Select image to appear in-game", "scriptbank\\images\\imagesinzone\\",readonly);
							#endif
						}
					}

					if (t.tflagnosecond == 0)
					{
						if (t.tflagsound == 1 || t.tflagsoundset == 1)
						{
							//We got some missing translations.
							if (t.strarr_s[468] == "") t.strarr_s[468] = "Sound1";
							if (t.strarr_s[480] == "") t.strarr_s[480] = "Sound2";
							if (t.strarr_s[481] == "") t.strarr_s[481] = "Sound3";
							if (t.strarr_s[482] == "") t.strarr_s[482] = "Sound4";
							edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), t.strarr_s[468].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly);
							edit_grideleprof->soundset2_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset2_s.Get(), t.strarr_s[480].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly);
							edit_grideleprof->soundset3_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset3_s.Get(), t.strarr_s[481].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly);
							edit_grideleprof->soundset5_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset5_s.Get(), t.strarr_s[482].Get(), t.strarr_s[254].Get(), "audiobank\\", readonly);
							edit_grideleprof->soundset5_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset5_s.Get(), t.strarr_s[482].Get(), t.strarr_s[254].Get(), "audiobank\\", readonly);
				}
					}
				}
				else
				{
					if (t.tflagsoundset == 1)
					{
						edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[469].Get(), t.strarr_s[255].Get(), "audiobank\\voices\\",readonly);
					}
					else
					{
						edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\",readonly); ++t.controlindex;
					}
					edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), t.strarr_s[468].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly); ++t.controlindex;
				}
			}
		}

		// Video
		if (t.tflagvideo == 1)
		{
			if (ImGui::StyleCollapsingHeader(t.strarr_s[597].Get(), ImGuiTreeNodeFlags_DefaultOpen)) {

				//edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[599].Get(), "audiobank\\",readonly);
				edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), "Video Slot", t.strarr_s[601].Get(), "videobank\\",readonly);
			}
		}

		//  Third person settings
		if (t.tflagplayersettings == 1 && t.playercontrol.thirdperson.enabled == 1)
		{
			if (ImGui::StyleCollapsingHeader("Third Person", ImGuiTreeNodeFlags_DefaultOpen)) {

				t.livegroupforthirdperson = t.group;
				t.playercontrol.thirdperson.cameralocked = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(t.playercontrol.thirdperson.cameralocked), "Camera Locked", "Fixes camera height and angle for third person view", 0,readonly);
				t.playercontrol.thirdperson.cameradistance = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.thirdperson.cameradistance), "Camera Distance", "Sets the distance of the third person camera",readonly));
				t.playercontrol.thirdperson.camerashoulder = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.thirdperson.camerashoulder), "Camera X Offset", "Sets the distance to shift the camera over shoulder",readonly));
				t.playercontrol.thirdperson.cameraheight = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.thirdperson.cameraheight), "Camera Y Offset", "Sets the vertical height of the third person camera. If more than twice the camera distance, camera collision disables",readonly));
				t.playercontrol.thirdperson.camerafocus = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.thirdperson.camerafocus), "Camera Focus", "Sets the camera X angle offset to align focus of the third person camera",readonly));
				t.playercontrol.thirdperson.cameraspeed = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.thirdperson.cameraspeed), "Camera Speed", "Sets the retraction speed percentage of the third person camera",readonly));
				t.playercontrol.thirdperson.camerafollow = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(t.playercontrol.thirdperson.camerafollow), "Run Mode", "If set to yes, protagonist uses WASD t.movement mode", 0,readonly);
				t.playercontrol.thirdperson.camerareticle = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(t.playercontrol.thirdperson.camerareticle), "Show Reticle", "Show the third person 'crosshair' reticle Dot ( ", 0,readonly);
			}
		}
		//Advenced open
		ImGui::Indent(-10);
	}
}

int imgui_setpropertylist2_v2(int group, int controlindex, char* data_s, char* field_s, char* desc_s, int listtype,bool readonly)
{
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";

	int current_selection = atoi(ldata_s.Get());


	int listmax = 0;

	listmax = 0;
	if (listtype == 0)
	{
		listmax = 1;
		t.list_s[0] = t.strarr_s[471];
		t.list_s[1] = t.strarr_s[470];
	}
	if (listtype == 1)
	{
		listmax = fillgloballistwithweapons();
	}
	if (listtype == 11)
	{
		listmax = fillgloballistwithbehaviours();
	}

	const char* current_item = t.list_s[current_selection].Get();

	std::string uniquiField = ""; //lfields_s.Get()
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	ImGui::PushItemWidth(-10);
	if (listtype == 0)
	{
		//Checkbox.
		bool bTmp = false;
		if (current_selection == 1)
			bTmp = true;
		ImGui::Checkbox(lfields_s.Get(), &bTmp);
		if (bTmp)
			current_selection = 1;
		else
			current_selection = 0;
	}
	else
	{
		ImGui::TextCenter(lfields_s.Get());
		if (ImGui::BeginCombo(uniquiField.c_str(), current_item)) // The second parameter is the label previewed before opening the combo.
		{
			for (int n = 0; n <= listmax; n++)
			{
				bool is_selected = (current_item == t.list_s[n].Get()); // You can store your selection however you want, outside or inside your objects
				if (ImGui::Selectable(t.list_s[n].Get(), is_selected)) {
					current_selection = n;
					current_item = t.list_s[n].Get();
				}
				if (is_selected)
					ImGui::SetItemDefaultFocus();   // You may set the initial focus when opening the combo (scrolling + for keyboard navigation support)
			}
			ImGui::EndCombo();
		}
	}
	if (ImGui::IsItemHovered())
	{
		if (listtype == 0)
		{
			//When using checkbox, change text.
			std::string newtext = ldesc_s.Get();
			replaceAll(newtext, "Set to YES", "If set");
			replaceAll(newtext, " to YES", "");
			ImGui::SetTooltip("%s", newtext.c_str());
		}
		else
			ImGui::SetTooltip("%s", ldesc_s.Get());
	}

	ImGui::PopItemWidth();
	return current_selection;
}

char* imgui_setpropertylist2c_v2(int group, int controlindex, char* data_s, char* field_s, char* desc_s, int listtype,bool readonly, bool forcharacters, bool bForShooting, bool bForMelee, int iSpecialValue)
{
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s;
	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";
	int current_selection = atoi(ldata_s.Get());
	int listmax = 0;
	bool bIgnoreTitleText = false;
	if (listtype == 61)
	{
		listtype = 1;
		bIgnoreTitleText = true;
	}
	if (listtype == 0)
	{
		listmax = 1;
		t.list_s[0] = t.strarr_s[471];
		t.list_s[1] = t.strarr_s[470];
	}
	if (listtype == 1)
	{
		listmax = fillgloballistwithweaponsQuick(forcharacters, bForShooting, bForMelee);
		#ifdef WICKEDENGINE
		// newer system for MAX weapons - easier to read for users
		for (int n = -1; n <= listmax; n++)
		{
			cstr thisLabel;
			if (n == -1) 
				thisLabel = ldata_s;
			else
				thisLabel = t.list_s[n];
			if (bIgnoreTitleText == true)
			{
				if (strlen (thisLabel.Get()) == 0) thisLabel = "No Preference";
			}
			else
			{
				if (strlen (thisLabel.Get()) == 0) thisLabel = "No Weapon";
			}
			if (stricmp (thisLabel.Get(), "enhanced\\Gloves_Unarmed") == NULL) thisLabel = "Melee Combat";
			//if (stricmp (thisLabel.Get(), "enhanced\\M67") == NULL) thisLabel = "Grenades Only";
			if (stricmp (thisLabel.Get(), "enhanced\\AK") == NULL) thisLabel = "Assault Rifle";
			if (stricmp (thisLabel.Get(), "enhanced\\AR") == NULL) thisLabel = "Patrol Rifle";
			if (stricmp (thisLabel.Get(), "enhanced\\B810") == NULL) thisLabel = "Pocket Knife";
			if (stricmp (thisLabel.Get(), "enhanced\\M29S") == NULL) thisLabel = "Snubnose Revolver";
			if (stricmp (thisLabel.Get(), "enhanced\\Mk18") == NULL) thisLabel = "Compact Assault Rifle";
			if (stricmp (thisLabel.Get(), "enhanced\\Mk19T") == NULL) thisLabel = "Magnum Pistol";
			if (stricmp (thisLabel.Get(), "enhanced\\R870") == NULL) thisLabel = "Tactical Pump Shotgun";
			if (stricmp (thisLabel.Get(), "enhanced\\SledgeHammer") == NULL) thisLabel = "SledgeHammer";
			if (stricmp (thisLabel.Get(), "aztec\\AztecAxe") == NULL) thisLabel = "Aztec Axe";
			if (stricmp (thisLabel.Get(), "aztec\\AztecDagger") == NULL) thisLabel = "Aztec Dagger";
			if (stricmp (thisLabel.Get(), "aztec\\AztecSpear") == NULL) thisLabel = "Aztec Spear";
			if (n == -1)
				ldata_s = thisLabel;
			else
				t.list_s[n] = thisLabel;
		}
		#else
		// older system for attachments
		#endif
		for (int n = 0; n <= listmax; n++)
		{
			if (ldata_s == t.list_s[n]) 
			{
				current_selection = n;
				break;
			}
		}
	}
	if (listtype == 2)
	{
		listmax = fillgloballistwithCharAnimSetsQuick(iSpecialValue);
		for (int n = -1; n <= listmax; n++)
		{
			cstr thisLabel;
			if (n == -1)
				thisLabel = ldata_s;
			else
				thisLabel = t.list_s[n];
			if (strlen (thisLabel.Get()) == 0) thisLabel = "Default Animation";
			if (strlen (thisLabel.Get()) == 1) thisLabel = "Original Animation";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations.dbo") == NULL) thisLabel = "Adult Male Pistol";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations-rifle.dbo") == NULL) thisLabel = "Adult Male Rifle";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations-pistol-lowered.dbo") == NULL) thisLabel = "Adult Male Pistol Lowered";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations-rifle-lowered.dbo") == NULL) thisLabel = "Adult Male Rifle Lowered";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations-shotgun-lowered.dbo") == NULL) thisLabel = "Adult Male Shotgun Lowered";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations-melee.dbo") == NULL) thisLabel = "Adult Male Melee";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations-axe.dbo") == NULL) thisLabel = "Adult Male Axe";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations-spear.dbo") == NULL) thisLabel = "Adult Male Spear";

			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations.dbo") == NULL) thisLabel = "Adult Female Pistol";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations-rifle.dbo") == NULL) thisLabel = "Adult Female Rifle";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations-pistol-lowered.dbo") == NULL) thisLabel = "Adult Female Pistol Lowered";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations-rifle-lowered.dbo") == NULL) thisLabel = "Adult Female Rifle Lowered";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations-shotgun-lowered.dbo") == NULL) thisLabel = "Adult Female Shotgun Lowered";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations-melee.dbo") == NULL) thisLabel = "Adult Female Melee";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations-axe.dbo") == NULL) thisLabel = "Adult Female Axe";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations-spear.dbo") == NULL) thisLabel = "Adult Female Spear";

			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\zombie male\\default animations.dbo") == NULL) thisLabel = "Zombie Male";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\zombie female\\default animations.dbo") == NULL) thisLabel = "Zombie Female";

			if (n == -1)
				ldata_s = thisLabel;
			else
				t.list_s[n] = thisLabel;
		}
		for (int n = 0; n <= listmax; n++)
		{
			if (ldata_s == t.list_s[n])
			{
				current_selection = n;
				break;
			}
		}
	}
	if (listtype == 11)
	{
		listmax = fillgloballistwithbehaviours();
		for (int n = 0; n <= listmax; n++)
		{
			if (ldata_s == t.list_s[n]) {
				current_selection = n;
				break;
			}
		}
	}

	const char* current_item = t.list_s[current_selection].Get();

	std::string uniquiField = "";
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	if (bIgnoreTitleText == false)
	{
		ImGui::TextCenter(lfields_s.Get());
		ImGui::PushItemWidth(-10);
	}
	if (ImGui::BeginCombo(uniquiField.c_str(), current_item))
	{
		for (int n = 0; n <= listmax; n++)
		{
			bool is_selected = (current_item == t.list_s[n].Get());
			if (ImGui::Selectable(t.list_s[n].Get(), is_selected))
			{
				current_selection = n;
				current_item = t.list_s[n].Get();
			}
			if (is_selected) ImGui::SetItemDefaultFocus();
		}
		ImGui::EndCombo();
	}
	if (bIgnoreTitleText == false)
	{
		ImGui::PopItemWidth();
	}

	#ifdef WICKEDENGINE
	// newer system for MAX weapons - easier to read for users
	if (listtype == 2)
	{
		for (int n = -1; n <= listmax; n++)
		{
			cstr thisLabel;
			if (n == -1)
				thisLabel = ldata_s;
			else
				thisLabel = t.list_s[n];
			if (stricmp (thisLabel.Get(), "Default Animation") == NULL) thisLabel = "";
			if (stricmp (thisLabel.Get(), "Original Animation") == NULL) thisLabel = "-";
			if (stricmp (thisLabel.Get(), "Adult Male Pistol") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations.dbo";
			if (stricmp (thisLabel.Get(), "Adult Male Rifle") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations-rifle.dbo";
			if (stricmp (thisLabel.Get(), "Adult Male Pistol Lowered") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations-pistol-lowered.dbo";
			if (stricmp (thisLabel.Get(), "Adult Male Rifle Lowered") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations-rifle-lowered.dbo";
			if (stricmp (thisLabel.Get(), "Adult Male Shotgun Lowered") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations-shotgun-lowered.dbo";
			if (stricmp (thisLabel.Get(), "Adult Male Melee") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations-melee.dbo";
			if (stricmp (thisLabel.Get(), "Adult Male Axe") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations-axe.dbo";
			if (stricmp (thisLabel.Get(), "Adult Male Spear") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations-spear.dbo";

			if (stricmp (thisLabel.Get(), "Adult Female Pistol") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations.dbo";
			if (stricmp (thisLabel.Get(), "Adult Female Rifle") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations-rifle.dbo";
			if (stricmp (thisLabel.Get(), "Adult Female Pistol Lowered") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations-pistol-lowered.dbo";
			if (stricmp (thisLabel.Get(), "Adult Female Rifle Lowered") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations-rifle-lowered.dbo";
			if (stricmp (thisLabel.Get(), "Adult Female Shotgun Lowered") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations-shotgun-lowered.dbo";
			if (stricmp (thisLabel.Get(), "Adult Female Melee") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations-melee.dbo";
			if (stricmp (thisLabel.Get(), "Adult Female Axe") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations-axe.dbo";
			if (stricmp (thisLabel.Get(), "Adult Female Spear") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations-spear.dbo";

			if (stricmp (thisLabel.Get(), "Zombie Male") == NULL) thisLabel = "charactercreatorplus\\parts\\zombie male\\default animations.dbo";
			if (stricmp (thisLabel.Get(), "Zombie Female") == NULL) thisLabel = "charactercreatorplus\\parts\\zombie female\\default animations.dbo";

			if (n == -1)
				ldata_s = thisLabel;
			else
				t.list_s[n] = thisLabel;
		}
	}
	else
	{
		for (int n = -1; n <= listmax; n++)
		{
			cstr thisLabel;
			if (n == -1)
				thisLabel = ldata_s;
			else
				thisLabel = t.list_s[n];
			if (stricmp (thisLabel.Get(), "No Weapon") == NULL) thisLabel = "";
			if (stricmp (thisLabel.Get(), "No Preference") == NULL) thisLabel = "";
			if (stricmp (thisLabel.Get(), "Melee Combat") == NULL) thisLabel = "enhanced\\Gloves_Unarmed";
			if (stricmp (thisLabel.Get(), "Grenades Only") == NULL) thisLabel = "enhanced\\M67";
			if (stricmp (thisLabel.Get(), "Assault Rifle") == NULL) thisLabel = "enhanced\\AK";
			if (stricmp (thisLabel.Get(), "Patrol Rifle") == NULL) thisLabel = "enhanced\\AR";
			if (stricmp (thisLabel.Get(), "Pocket Knife") == NULL) thisLabel = "enhanced\\B810";
			if (stricmp (thisLabel.Get(), "Snubnose Revolver") == NULL) thisLabel = "enhanced\\M29S";
			if (stricmp (thisLabel.Get(), "Compact Assault Rifle") == NULL) thisLabel = "enhanced\\Mk18";
			if (stricmp (thisLabel.Get(), "Magnum Pistol") == NULL) thisLabel = "enhanced\\Mk19T";
			if (stricmp (thisLabel.Get(), "Tactical Pump Shotgun") == NULL) thisLabel = "enhanced\\R870";
			if (stricmp (thisLabel.Get(), "SledgeHammer") == NULL) thisLabel = "enhanced\\SledgeHammer";

			if (stricmp (thisLabel.Get(), "Aztec Axe") == NULL) thisLabel = "aztec\\AztecAxe";
			if (stricmp (thisLabel.Get(), "Aztec Dagger") == NULL) thisLabel = "aztec\\AztecDagger";
			if (stricmp (thisLabel.Get(), "Aztec Spear") == NULL) thisLabel = "aztec\\AztecSpear";

			if (n == -1)
				ldata_s = thisLabel;
			else
				t.list_s[n] = thisLabel;
		}
	}
	#else
		// older system for attachments
	#endif
	return t.list_s[current_selection].Get();
}

char* imgui_setpropertyfile2_v2(int group, char* data_s, char* field_s, char* desc_s, char* within_s,bool readonly, char *startsearch)
{
	char *cRet;
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s, lwithin_s = within_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";
	if (cstr(within_s) == "" || !within_s)  lwithin_s = "";

	std::string uniquiField = "";
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	if (lfields_s != "") 
	{
		ImGui::TextCenter(lfields_s.Get());
	}
	strcpy(cTmpInput, ldata_s.Get());

	bool bSoundSet = false;
	if (pestrcasestr(lfields_s.Get(), "soundset") || lfields_s == "Type") 
	{
		bSoundSet = true;
	}
	if (bSoundSet && t.entityprofile[t.gridentity].ischaracter > 0) 
	{
		//Only displayt Male,FeMale selection.
		ImGui::PushItemWidth(-10);
		const char* items[] = { "Male", "Female" };
		int item_current_type_selection = 0; //Default Custom.
		if (pestrcasestr(cTmpInput, "Female")) 
		{
			item_current_type_selection = 1;
		}
		if (ImGui::Combo(uniquiField.c_str(), &item_current_type_selection, items, IM_ARRAYSIZE(items))) 
		{
			strcpy(cTmpInput, items[item_current_type_selection]);
		}
		if (ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());
		ImGui::PopItemWidth();
		return &cTmpInput[0];
	}

	if(!readonly)
		ImGui::PushItemWidth(-10 - (ImGui::GetFontSize()*2.0)); //-6 padding.
	else
		ImGui::PushItemWidth(-10);

	ImGui::InputText(uniquiField.c_str(), &cTmpInput[0], MAXTEXTINPUT);
	if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());
	if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

	ImGui::PopItemWidth();

	if (!readonly)
	{
		ImGui::SameLine();

		uniquiField = "...";
		uniquiField = uniquiField + "##";
		uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

		ImGui::PushItemWidth(ImGui::GetFontSize()*2.0);

		bool bAudio = false;
		bool bImage = false;
		bool bVideo = false;
		bool bScript = false;
		bool bParticle = false;
		bool bAnimation = false;
		bool bUseNewSelectionWindow = false;

		#ifdef USENEWMEDIASELECTWINDOWS
		if (pestrcasestr(lwithin_s.Get(), "charactercreatorplus\\animations"))
		{
			bUseNewSelectionWindow = true;
			bAnimation = true;
		}
		if (pestrcasestr(lwithin_s.Get(), "audiobank"))
		{
			bUseNewSelectionWindow = true;
			bAudio = true;
		}
		if (pestrcasestr(lwithin_s.Get(), "\\imagesinzone"))
		{
			bUseNewSelectionWindow = true;
			bImage = true;
		}
		if (pestrcasestr(lwithin_s.Get(), "imagebank"))
		{
			bUseNewSelectionWindow = true;
			bImage = true;
		}
		if (pestrcasestr(lwithin_s.Get(), "videobank"))
		{
			bUseNewSelectionWindow = true;
			bVideo = true;
		}
		if (pestrcasestr(lwithin_s.Get(), "scriptbank"))
		{
			bUseNewSelectionWindow = true;
			bScript = true;
		}
		if (pestrcasestr(lwithin_s.Get(), "particlesbank"))
		{
			bUseNewSelectionWindow = true;
			bParticle = true;
		}
		#endif

		if (bUseNewSelectionWindow)
		{
			ImGuiWindow* window = ImGui::GetCurrentWindow();
			if (ImGui::StyleButton(uniquiField.c_str(), ImVec2(ImGui::GetFontSize()*1.48, 0)) || iSelectedLibraryStingReturnID == window->GetID(uniquiField.c_str()))
			{
				cStr tOldDir = GetDir();
				if (iSelectedLibraryStingReturnID == window->GetID(uniquiField.c_str()))
				{
					char * cFileSelected = sSelectedLibrarySting.Get();
					SetDir(tOldDir.Get());
					if (cFileSelected && strlen(cFileSelected) > 0) 
					{
						std::string relative = cFileSelected;
						std::string fullpath = tOldDir.Get();

						std::transform(relative.begin(), relative.end(), relative.begin(), [](unsigned char c) { return ::tolower(c); });
						std::transform(fullpath.begin(), fullpath.end(), fullpath.begin(), [](unsigned char c) { return ::tolower(c); });

						fullpath += "\\";
						if (bSoundSet || pestrcasestr(lwithin_s.Get(), "scriptbank")) 
						{
							if (pestrcasestr(cFileSelected, ".lua"))
								fullpath += "scriptbank\\"; //lwithin_s.Get(); PE: This can change in parent mode 2
						}

						if (pestrcasestr(lwithin_s.Get(), "charactercreatorplus"))
						{
							// animations must pass back as DBOs (not FPEs)
							char pReplaceWithDBO[MAX_PATH];
							strcpy(pReplaceWithDBO, relative.c_str());
							pReplaceWithDBO[strlen(pReplaceWithDBO) - 4] = 0;
							strcat(pReplaceWithDBO, ".dbo");
							relative = pReplaceWithDBO;
						}

						replaceAll(relative, fullpath, "");
						strcpy(cTmpInput, relative.c_str());

						if (bSoundSet) 
						{
							char *found = (char *)pestrcasestr(cTmpInput, "audiobank\\voices\\");
							if (found) 
							{
								found += 17;
								strcpy(cTmpInput, found);
							}
							found = (char *)pestrcasestr(cTmpInput, "\\");
							if (found)
								found[0] = 0;
						}
					}
					iSelectedLibraryStingReturnID = -1; //disable.
					sSelectedLibrarySting = "";
				}
				else
				{
					bExternal_Entities_Window = true;
					iDisplayLibraryType = 0;
					iDisplayLibrarySubType = 0;
					if(bAudio)
						iDisplayLibraryType = 1;
					if (bImage)
						iDisplayLibraryType = 2;
					if(bVideo)
						iDisplayLibraryType = 3;
					if(bScript)
						iDisplayLibraryType = 4;
					if (bParticle)
						iDisplayLibraryType = 5;
					if (bAnimation)
					{
						// uses object library system but subtypes to choose animations only
						iDisplayLibraryType = 0;
						iDisplayLibrarySubType = 1;
					}
					
					if (startsearch)
					{
						sStartLibrarySearchString = startsearch;
					}
					iLibraryStingReturnToID = window->GetID(uniquiField.c_str());
					if (iDisplayLibraryType > 0)
					{
						if (strlen(cTmpInput) > 0)
						{
							sMakeDefaultSelecting = cTmpInput;
							bSelectLibraryViewAll = true;
						}
					}
				}
			}
		}
		else
		{
			if (ImGui::StyleButton(uniquiField.c_str(), ImVec2(ImGui::GetFontSize()*1.48, 0)))
			{
				//PE: filedialogs change dir so.
				cStr tOldDir = GetDir();
				char * cFileSelected;
				cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "All\0*.*\0", lwithin_s.Get(), NULL);

				SetDir(tOldDir.Get());

				if (cFileSelected && strlen(cFileSelected) > 0) 
				{
					std::string relative = cFileSelected;
					std::string fullpath = tOldDir.Get();

					std::transform(relative.begin(), relative.end(), relative.begin(), [](unsigned char c) { return ::tolower(c); });
					std::transform(fullpath.begin(), fullpath.end(), fullpath.begin(), [](unsigned char c) { return ::tolower(c); });

					fullpath += "\\";

					if (bSoundSet || pestrcasestr(lwithin_s.Get(), "scriptbank")) 
					{
						if (pestrcasestr(cFileSelected, ".lua"))
							fullpath += "scriptbank\\"; //lwithin_s.Get(); PE: This can change in parent mode 2
					}

					replaceAll(relative, fullpath, "");
					strcpy(cTmpInput, relative.c_str());

					if (bSoundSet) 
					{
						char *found = (char *)pestrcasestr(cTmpInput, "audiobank\\voices\\");
						if (found) 
						{
							found += 17;
							strcpy(cTmpInput, found);
						}
						found = (char *)pestrcasestr(cTmpInput, "\\");
						if (found)
							found[0] = 0;
					}
				}
			}
		}
		ImGui::PopItemWidth();
	}
	return &cTmpInput[0];
}

char * imgui_setpropertystring2_v2(int group, char* data_s, char* field_s, char* desc_s,bool readonly)
{
	char *cRet;
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";

	std::string uniquiField = ""; //lfields_s.Get();
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	if (lfields_s != "") {
		ImGui::TextCenter(lfields_s.Get());
	}
	ImGui::PushItemWidth(-10);

	int inputFlags = 0;

	strcpy(cTmpInput, ldata_s.Get());
	if (ImGui::InputText(uniquiField.c_str(), &cTmpInput[0], MAXTEXTINPUT, inputFlags)) {
		bImGuiGotFocus = true;
	}
	if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());
	if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

	ImVec2 cpos = ImGui::GetCursorPos();
	ImGui::SetItemAllowOverlap();
	ImGui::SetCursorPos(ImVec2(cpos.x + ImGui::GetContentRegionAvail().x - 33.0f, cpos.y - (ImGui::GetFontSize()*1.5) - 6.0));
	ImGui::ImgBtn(TOOL_PENCIL, ImVec2(16, 16), ImColor(255, 255, 255, 0));
	if (ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());
	if (ImGui::IsItemFocused()) bImGuiGotFocus = true;
	ImGui::SetCursorPos(cpos);

	ImGui::PopItemWidth();

	return &cTmpInput[0];
}

int Get_t_gridentityobj(void)
{
	return t.gridentityobj;
}
int Get_t_gridentity(void)
{
	return t.gridentity;
}

void StartDragDropFromEntityID(int iEntID,int iGroup,int iCustomImage)
{
	if (iEntID < 0) return;
	int masterid = t.entityelement[iEntID].bankindex;
	if (masterid <= 0) return;
	if (masterid > t.entitybank_s.size()) return;
	if (t.entitybank_s[masterid].Len() == 0) return;

	cstr find = t.entitybank_s[masterid];
	cFolderItem *pSearchFolder = &MainEntityList;
	cFolderItem::sFolderFiles * foundfiles = NULL;
	pSearchFolder = pSearchFolder->m_pNext;
	cStr path = "";
	cStr path_remove = pSearchFolder->m_sFolderFullPath.Get();
	std::string sFpeName;
	int ipath_remove_len = path_remove.Len();
	bool bFound = false;
	while (pSearchFolder)
	{
		if (pSearchFolder->iType == 0)
		{
			cStr path = pSearchFolder->m_sFolderFullPath.Get();
			bool bDoubleEntityBank = false;
			char *finde = (char *)pestrcasestr(path.Get(), "\\entitybank"); //Support entitybank inside entitybank.
			if (finde)
			{
				finde += 11;
				finde = (char *)pestrcasestr(finde, "\\entitybank");
				if (finde) bDoubleEntityBank = true;
			}
			if (!bDoubleEntityBank && path.Right(11) == "\\entitybank")
			{
				ipath_remove_len = path.Len();
			}
			else
			{
				if (pSearchFolder->m_pFirstFile) {
					cFolderItem::sFolderFiles * searchfiles = pSearchFolder->m_pFirstFile->m_pNext;
					while (searchfiles) {
						foundfiles = searchfiles;
						path = pSearchFolder->m_sFolderFullPath.Get();
						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;

						std::string path_for_filename = final_name;
						sFpeName = path_for_filename.c_str();
						sFpeName = sFpeName + "\\" + foundfiles->m_sName.Get();
						if (stricmp(find.Get(), sFpeName.c_str()) == 0)
							bFound = true;
						if (bFound)
							break;
						searchfiles = searchfiles->m_pNext;
					}
				}
			}
			if (bFound)
				break;
		}
		pSearchFolder = pSearchFolder->m_pNext;
	}

	if (foundfiles)
	{
		//CheckTooltipObjectDelete();
		CloseDownEditorProperties();
		t.inputsys.constructselection = 0;

		foundfiles->m_dropptr = foundfiles;
		if(iGroup >= 0)
			foundfiles->iAnimationFrom = 100000+ iGroup; //Reuse var for selecting a special entity for drag drop.
		else
			foundfiles->iAnimationFrom = iEntID; //Reuse var for selecting a special entity for drag drop.
		foundfiles->m_sFolder = sFpeName.c_str();
		ImGui::SetDragDropPayload("DND_MODEL_DROP_TARGET", foundfiles, sizeof(void *));
		if (iCustomImage > 0)
		{
			float fRatio = (float) ImageHeight(iCustomImage)  / (float) ImageWidth(iCustomImage);
			float imagew = 200.0f;
			float imageh = imagew * fRatio;
			ImGui::ImgBtn(iCustomImage, ImVec2(imagew, imageh), drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false);
		}
		else
		{
			ImGui::ImgBtn(t.entityprofile[masterid].iThumbnailSmall, ImVec2(media_icon_size_leftpanel, media_icon_size_leftpanel), drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false);
		}
		//ImGui::Text("%s", myfiles->m_sName.Get());
		//ImGui::SetCursorPos(oldCursor);
		pDragDropFile = foundfiles;
		ImGui::EndDragDropSource();
		bReadyToDropEntity = false;
		iDragDropActive = 50;
		bDraggingActive = true;
		bDraggingActiveInitial = true;
		// LB: these can be uninitialised, but we need these filled so the plane can be under the cursor initially
		t.gridentityposx_f = t.inputsys.localx_f;
		t.gridentityposy_f = t.inputsys.localcurrentterrainheight_f;
		t.gridentityposz_f = t.inputsys.localy_f;
	}
}

ImVec4 GetRealSizeToGridEntity(int direction)
{
	//Object size from center, include rotation.
	ImVec4 size = { 0.0f,0.0f,0.0f,0.0f };
	if (t.gridentityobj > 0)
	{
		//PE: Only use pivot on non markers and not on ebe.
		if (t.entityprofile[t.gridentity].isebe == 0 && t.entityprofile[t.gridentity].ismarker == 0)
		{
			//Find lowest point in bounding box, and use this to adjust Y
			sObject* pObject = GetObjectData(t.gridentityobj);
			if (pObject)
			{
				GGMATRIX matARotation;
				GGVECTOR3 box1;
				GGMATRIX matRotateX, matRotateY, matRotateZ;
				if (pObject->position.bFreeFlightRotation)
				{
					matARotation = pObject->position.matFreeFlightRotate;
				}
				else
				{
					//ZXY
					GGMatrixRotationX(&matRotateX, GGToRadian(pObject->position.vecRotate.x));	// x rotation
					GGMatrixRotationY(&matRotateY, GGToRadian(pObject->position.vecRotate.y));	// y rotation
					GGMatrixRotationZ(&matRotateZ, GGToRadian(pObject->position.vecRotate.z));	// z rotation
					matARotation = matRotateX * matRotateY * matRotateZ;
				}
				if (pObject->position.bApplyPivot)
				{
					matARotation *= pObject->position.matPivot;
				}

				AABB aabb;
				if (direction == 0)
				{
//					aabb._min.x = pObject->collision.vecMin.x + pObject->collision.vecMax.x;  //offset from pivot.
					aabb._min.x = (pObject->collision.vecMin.x - pObject->collision.vecMax.x) * 0.5;  //offset from center.
					aabb._min.y = pObject->collision.vecMin.y;
					aabb._min.z = 0.0f;
				}
				else if (direction == 1)
				{
					aabb._min.x = 0.0f;
					aabb._min.y = pObject->collision.vecMin.y;
//					aabb._min.z = pObject->collision.vecMin.z + pObject->collision.vecMax.z; //offset from pivot.
					aabb._min.z = (pObject->collision.vecMin.z - pObject->collision.vecMax.z) * 0.5; //offset from center.
				}
				else if (direction == 2)
				{
					aabb._min.x = fabs((pObject->collision.vecMin.x - pObject->collision.vecMax.x) * 0.5);  //offset from center.
					aabb._min.y = pObject->collision.vecMin.y;
					aabb._min.z = 0.0f;
				}
				else if (direction == 3)
				{
					aabb._min.x = 0.0f;
					aabb._min.y = pObject->collision.vecMin.y;
					aabb._min.z = fabs((pObject->collision.vecMin.z - pObject->collision.vecMax.z) * 0.5); //offset from center.
				}

				box1.x = aabb._min.x; box1.y = aabb._min.y; box1.z = aabb._min.z;
				GGVec3TransformCoord(&box1, &box1, &matARotation);
				aabb._min.x = box1.x; aabb._min.y = box1.y; aabb._min.z = box1.z;
				
				aabb._min.x = (aabb._min.x * pObject->position.vecScale.x);
				aabb._min.y = (aabb._min.y * pObject->position.vecScale.y);
				aabb._min.z = (aabb._min.z * pObject->position.vecScale.z);

				size.x = aabb._min.x;
				size.y = aabb._min.y;
				size.z = aabb._min.z;
				size.w = 1.0;
			}
		}

	}
	return(size);
}

ImVec4 GetRealCenterToObject(int obj)
{
	ImVec4 realcenter = { 0.0f,0.0f,0.0f,0.0f };
	if (obj > 0)
	{
		//Find lowest point in bounding box, and use this to adjust Y
		sObject* pObject = GetObjectData(obj);
		if (pObject)
		{

			GGMATRIX matARotation;
			GGVECTOR3 box1;
			GGMATRIX matRotateX, matRotateY, matRotateZ;
			if (pObject->position.bFreeFlightRotation)
			{
				matARotation = pObject->position.matFreeFlightRotate;
			}
			else
			{
				//ZXY
				GGMatrixRotationX(&matRotateX, GGToRadian(pObject->position.vecRotate.x));	// x rotation
				GGMatrixRotationY(&matRotateY, GGToRadian(pObject->position.vecRotate.y));	// y rotation
				GGMatrixRotationZ(&matRotateZ, GGToRadian(pObject->position.vecRotate.z));	// z rotation
				matARotation = matRotateX * matRotateY * matRotateZ;
			}
			if (pObject->position.bApplyPivot)
			{
				matARotation *= pObject->position.matPivot;
			}

			AABB aabb;
			aabb._min.x = pObject->collision.vecMin.x;
			aabb._min.y = pObject->collision.vecMin.y;
			aabb._min.z = pObject->collision.vecMin.z;
			aabb._max.x = pObject->collision.vecMax.x;
			aabb._max.y = pObject->collision.vecMax.y;
			aabb._max.z = pObject->collision.vecMax.z;

			box1.x = aabb._min.x; box1.y = aabb._min.y; box1.z = aabb._min.z;
			GGVec3TransformCoord(&box1, &box1, &matARotation);
			aabb._min.x = box1.x; aabb._min.y = box1.y; aabb._min.z = box1.z;
			box1.x = aabb._max.x; box1.y = aabb._max.y; box1.z = aabb._max.z;
			GGVec3TransformCoord(&box1, &box1, &matARotation);
			aabb._max.x = box1.x; aabb._max.y = box1.y; aabb._max.z = box1.z;

			aabb._min.x = (aabb._min.x * pObject->position.vecScale.x);
			aabb._min.y = (aabb._min.y * pObject->position.vecScale.y);
			aabb._min.z = (aabb._min.z * pObject->position.vecScale.z);
			aabb._max.x = (aabb._max.x * pObject->position.vecScale.x);
			aabb._max.y = (aabb._max.y * pObject->position.vecScale.y);
			aabb._max.z = (aabb._max.z * pObject->position.vecScale.z);

			realcenter.x = (aabb._min.x + aabb._max.x)*0.5;
			realcenter.y = (aabb._min.y + aabb._max.y)*0.5;
			realcenter.z = (aabb._min.z + aabb._max.z)*0.5;
			realcenter.w = 1.0;
		}
	}
	return(realcenter);
}

ImVec4 GetRealCenterToGridEntity(void)
{
	ImVec4 realcenter = { 0.0f,0.0f,0.0f,0.0f };
	if (t.gridentityobj > 0)
	{

		//PE: Only use pivot on non markers and not on ebe.
		if (t.entityprofile[t.gridentity].isebe == 0 && t.entityprofile[t.gridentity].ismarker == 0)
		{
			//Find lowest point in bounding box, and use this to adjust Y
			sObject* pObject = GetObjectData(t.gridentityobj);
			if (pObject)
			{

				GGMATRIX matARotation;
				GGVECTOR3 box1;
				GGMATRIX matRotateX, matRotateY, matRotateZ;
				if (pObject->position.bFreeFlightRotation)
				{
					matARotation = pObject->position.matFreeFlightRotate;
				}
				else
				{
					//ZXY
					GGMatrixRotationX(&matRotateX, GGToRadian(pObject->position.vecRotate.x));	// x rotation
					GGMatrixRotationY(&matRotateY, GGToRadian(pObject->position.vecRotate.y));	// y rotation
					GGMatrixRotationZ(&matRotateZ, GGToRadian(pObject->position.vecRotate.z));	// z rotation
					matARotation = matRotateX * matRotateY * matRotateZ;
				}
				if (pObject->position.bApplyPivot)
				{
					matARotation *= pObject->position.matPivot;
				}

				AABB aabb;
				aabb._min.x = pObject->collision.vecMin.x;
				aabb._min.y = pObject->collision.vecMin.y;
				aabb._min.z = pObject->collision.vecMin.z;
				aabb._max.x = pObject->collision.vecMax.x;
				aabb._max.y = pObject->collision.vecMax.y;
				aabb._max.z = pObject->collision.vecMax.z;

				box1.x = aabb._min.x; box1.y = aabb._min.y; box1.z = aabb._min.z;
				GGVec3TransformCoord(&box1, &box1, &matARotation);
				aabb._min.x = box1.x; aabb._min.y = box1.y; aabb._min.z = box1.z;
				box1.x = aabb._max.x; box1.y = aabb._max.y; box1.z = aabb._max.z;
				GGVec3TransformCoord(&box1, &box1, &matARotation);
				aabb._max.x = box1.x; aabb._max.y = box1.y; aabb._max.z = box1.z;

				aabb._min.x = (aabb._min.x * pObject->position.vecScale.x);
				aabb._min.y = (aabb._min.y * pObject->position.vecScale.y);
				aabb._min.z = (aabb._min.z * pObject->position.vecScale.z);
				aabb._max.x = (aabb._max.x * pObject->position.vecScale.x);
				aabb._max.y = (aabb._max.y * pObject->position.vecScale.y);
				aabb._max.z = (aabb._max.z * pObject->position.vecScale.z);

				realcenter.x = (aabb._min.x + aabb._max.x)*0.5;
				realcenter.y = (aabb._min.y + aabb._max.y)*0.5;
				realcenter.z = (aabb._min.z + aabb._max.z)*0.5;
				realcenter.w = 1.0;
			}
		}

	}
	return(realcenter);
}

float GetLowestY(int obj)
{
	if (obj <= 0) return(0.0f);

	if (t.entityprofile[t.gridentity].isebe == 0 && t.entityprofile[t.gridentity].ismarker == 0)
	{
		//Find lowest point in bounding box, and use this to adjust Y
		sObject* pObject = GetObjectData(obj);
		if (pObject)
		{

			GGMATRIX matARotation;
			GGVECTOR3 box1;
			GGMATRIX matRotateX, matRotateY, matRotateZ;
			if (pObject->position.bFreeFlightRotation)
			{
				matARotation = pObject->position.matFreeFlightRotate;
			}
			else
			{
				//ZXY
				GGMatrixRotationX(&matRotateX, GGToRadian(pObject->position.vecRotate.x));	// x rotation
				GGMatrixRotationY(&matRotateY, GGToRadian(pObject->position.vecRotate.y));	// y rotation
				GGMatrixRotationZ(&matRotateZ, GGToRadian(pObject->position.vecRotate.z));	// z rotation
				matARotation = matRotateX * matRotateY * matRotateZ;
			}
			if (pObject->position.bApplyPivot)
			{
				matARotation *= pObject->position.matPivot;
			}

			AABB aabb;
			aabb._min.x = pObject->collision.vecMin.x;
			aabb._min.y = pObject->collision.vecMin.y;
			aabb._min.z = pObject->collision.vecMin.z;
			aabb._max.x = pObject->collision.vecMax.x;
			aabb._max.y = pObject->collision.vecMax.y;
			aabb._max.z = pObject->collision.vecMax.z;

			box1.x = aabb._min.x; box1.y = aabb._min.y; box1.z = aabb._min.z;
			GGVec3TransformCoord(&box1, &box1, &matARotation);
			aabb._min.x = box1.x; aabb._min.y = box1.y; aabb._min.z = box1.z;
			box1.x = aabb._max.x; box1.y = aabb._max.y; box1.z = aabb._max.z;
			GGVec3TransformCoord(&box1, &box1, &matARotation);
			aabb._max.x = box1.x; aabb._max.y = box1.y; aabb._max.z = box1.z;

			aabb._min.x = (aabb._min.x * pObject->position.vecScale.x);
			aabb._min.y = (aabb._min.y * pObject->position.vecScale.y);
			aabb._min.z = (aabb._min.z * pObject->position.vecScale.z);
			aabb._max.x = (aabb._max.x * pObject->position.vecScale.x);
			aabb._max.y = (aabb._max.y * pObject->position.vecScale.y);
			aabb._max.z = (aabb._max.z * pObject->position.vecScale.z);

			float fLowestPoint = aabb._min.y;
			if (aabb._max.y < aabb._min.y)
				fLowestPoint = aabb._max.y;

			return(fLowestPoint);
		}
	}
	return(0.0f);
}

void ApplyPivotToGridEntity(void)
{
	/*LB: messes up smart move system and also introduces sometimes unwanted object shifting, allow user to choose position, do not autoate it (for now)
	int iRealObjectMoveMode = iObjectMoveMode;
	if (iObjectMoveModeDropSystem > 0) iRealObjectMoveMode = 0;
	if (bExtractFixPivot && t.gridentityobj > 0 && iRealObjectMoveMode == 2) // LB: only find surface can use this as Y needs constantly resetting to allow the +=
	{
		//PE: Only use pivot on non markers and not on ebe.
		if (t.entityprofile[t.gridentity].isebe == 0 && t.entityprofile[t.gridentity].ismarker == 0)
		{
			//Find lowest point in bounding box, and use this to adjust Y
			sObject* pObject = GetObjectData(t.gridentityobj);
			if (pObject)
			{
				GGMATRIX matARotation;
				GGVECTOR3 box1;
				GGMATRIX matRotateX, matRotateY, matRotateZ;
				if (pObject->position.bFreeFlightRotation)
				{
					matARotation = pObject->position.matFreeFlightRotate;
				}
				else
				{
					//ZXY
					GGMatrixRotationX(&matRotateX, GGToRadian(pObject->position.vecRotate.x));	// x rotation
					GGMatrixRotationY(&matRotateY, GGToRadian(pObject->position.vecRotate.y));	// y rotation
					GGMatrixRotationZ(&matRotateZ, GGToRadian(pObject->position.vecRotate.z));	// z rotation
					matARotation = matRotateX * matRotateY * matRotateZ;
				}
				if (pObject->position.bApplyPivot)
				{
					matARotation *= pObject->position.matPivot;
				}

				AABB aabb;
				aabb._min.x = pObject->collision.vecMin.x;
				aabb._min.y = pObject->collision.vecMin.y;
				aabb._min.z = pObject->collision.vecMin.z;
				aabb._max.x = pObject->collision.vecMax.x;
				aabb._max.y = pObject->collision.vecMax.y;
				aabb._max.z = pObject->collision.vecMax.z;

				box1.x = aabb._min.x; box1.y = aabb._min.y; box1.z = aabb._min.z;
				GGVec3TransformCoord(&box1, &box1, &matARotation);
				aabb._min.x = box1.x; aabb._min.y = box1.y; aabb._min.z = box1.z;
				box1.x = aabb._max.x; box1.y = aabb._max.y; box1.z = aabb._max.z;
				GGVec3TransformCoord(&box1, &box1, &matARotation);
				aabb._max.x = box1.x; aabb._max.y = box1.y; aabb._max.z = box1.z;

				aabb._min.x = (aabb._min.x * pObject->position.vecScale.x);
				aabb._min.y = (aabb._min.y * pObject->position.vecScale.y);
				aabb._min.z = (aabb._min.z * pObject->position.vecScale.z);
				aabb._max.x = (aabb._max.x * pObject->position.vecScale.x);
				aabb._max.y = (aabb._max.y * pObject->position.vecScale.y);
				aabb._max.z = (aabb._max.z * pObject->position.vecScale.z);

				float fLowestPoint = aabb._min.y;
				if (aabb._max.y < aabb._min.y)
					fLowestPoint = aabb._max.y;

				if (fLowestPoint < 0)
					t.gridentityposy_f += fabs(fLowestPoint);
			}
		}
	}
	*/
}

bool bUseEditorOutlineSelection(void) { return pref.iEnableEditorOutlineSelection; }
float fGetHighlightThickness(void) { return pref.fHighLightThickness; }
int iGetMouseClickState(void) { return t.inputsys.mclick; }
int iGetgrideditselect(void) { return t.grideditselect; }

//#########################################
//#### Template for new docking window ####
//#########################################

void ProcessTemplateWindow(void)
{
	//Make sure to setup the docking settings search: DockBuilderDockWindow
	//To open window set bTemplate_Window = true;
	//Remember: MAXVERSION should be increased when you add a new window.

	bool bTemplate_Window = false; //This should be moved to the top of code.

	if (refresh_gui_docking == 0 && !bTemplate_Window)
	{
		//Make sure window is setup in docking space.
		ImGui::Begin("Template Window##MustBeUnique", &bTemplate_Window, iGenralWindowsFlags);
		ImGui::End();
	}

	if (!bTemplate_Window)
		return;

	int wflags = ImGuiTreeNodeFlags_DefaultOpen;

	ImGui::Begin("Template Window##MustBeUnique", &bTemplate_Window, iGenralWindowsFlags);

	if (ImGui::StyleCollapsingHeader("Help With Template", wflags)) {

		ImGui::Indent(10);
		ImGui::PushItemWidth(-10);
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

		//All you gui stuff goes here.
		ImGui::TextCenter("Heading use TextCenter");

		//Float Slider Template.
		static float fFloatSliderTest = 1000.0f; //1000.0f would be center (50) in this sample.
		if (ImGui::MaxSliderInputFloat("##templatefloatinput", &fFloatSliderTest, 0.0, 2000.0, "All Sliders should use this code."))
		{
		}

		//Add a pencil to a gadget.
		//ImGuiWindow* window = ImGui::GetCurrentWindow(); //PE: Add a pencil to all color gadgets.
		//ID3D11ShaderResourceView* lpTexture = GetImagePointerView(TOOL_PENCIL);
		//ImVec2 vDrawPos = { ImGui::GetCursorScreenPos().x + (ImGui::GetContentRegionAvail().x - 30.0f) ,ImGui::GetCursorScreenPos().y - (ImGui::GetFontSize()*1.5f) - 3.0f };
		//if(lpTexture)
		//	window->DrawList->AddImage((ImTextureID)lpTexture, vDrawPos, vDrawPos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1, 1, 1, 1)));

		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
		ImGui::PopItemWidth();
		ImGui::Indent(-10);
	}


	if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
		//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
		ImGui::Text("");
		ImGui::Text("");
	}

	ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
	if (ImGui::IsMouseHoveringRect(bbwin.Min, bbwin.Max))
	{
		bImGuiGotFocus = true; //Must set bImGuiGotFocus so if you type "w" in a imgui widget , editor dont move forward.
	}
	if (ImGui::IsAnyItemFocused()) {
		bImGuiGotFocus = true;
	}

	ImGui::End();
}

//#####

#ifdef LBBUGTRACKING
void GetDeviceID(LPSTR pKey)
{
	DWORD serial;
	GetVolumeInformationA("C:\\", NULL, 0, &serial, NULL, NULL, NULL, 0);
	unsigned int result[5];
	SHA1 sha;
	sha.Input((unsigned char*)&serial, 4);
	sha.Result(&(result[0]));
	sprintf(pKey, "%08X%08X%08X%08X%08X", result[0], result[1], result[2], result[3], result[4]);
}
void EncDec(uint8_t* pData, uint32_t length)
{
	if (length == 0) return;
	cstr sKey, sKey2;
	char pKey[1024];
	GetDeviceID(pKey);
	strcat(pKey, "N");
	strcat(pKey, "C");
	strcat(pKey, "Y");
	strcat(pKey, "f");
	strcat(pKey, "e");
	strcat(pKey, "3");
	strcat(pKey, "j");
	strcat(pKey, "n");
	strcat(pKey, "b");
	strcat(pKey, "J");
	sKey = pKey;
	uint8_t* pCipher = new uint8_t[SHA256::DIGEST_SIZE];
	uint32_t keyCount = 0;
	uint32_t currLength = 0;
	while (currLength < length)
	{
		sKey2 = sKey;
		char pNum[32];
		_itoa(keyCount, pNum, 10);
		sKey2 += pNum;
		memset(pCipher, 0, SHA256::DIGEST_SIZE);
		SHA256 ctx = SHA256();
		ctx.init();
		ctx.update((uint8_t*)sKey2.Get(), sKey2.Len());
		ctx.final(pCipher);
		for (int i = 0; i < SHA256::DIGEST_SIZE; i++)
		{
			pData[currLength] ^= pCipher[i];
			currLength++;
			if (currLength >= length) break;
		}
		keyCount++;
	}
}
#endif

struct BugReport
{
	//time_t CreateTime;
	char cCreatedAt[32];
	char cTitle[256];
	char cDescription[4096];
	char cReply[4096];
	int iStatus;
};
static std::vector<BugReport *> sBugList;
bool g_bBugTrackerConnected = false;
int g_iUserID = 0;
cstr g_sHashToken = "";

int CLB(ImGuiTextEditCallbackData* data)
{
	float textWidth = ImGui::CalcTextSize(data->Buf).x;
	float controlWidth = *(float*)data->UserData;
	if (textWidth > controlWidth)
	{
		int iCurrPos = data->CursorPos;
		while (data->Buf[iCurrPos] != ' ' && iCurrPos > 0) iCurrPos--;
		if (iCurrPos > 0 && data->Buf[iCurrPos] == ' ' && data->Buf[iCurrPos+1] != '\n') data->InsertChars(iCurrPos+1, "\n");
		data->BufDirty = true;
	}
	return data->BufTextLen;
}

void ProcessBugReporting(void)
{
	static char cBugTitle[256];
	static char cBugDescription[4096];
	static char cBugDescriptionCopy[4096];
	static bool bIncludeScreenShot = true;
	static bool bIncludesystemSpecs = true;
	static int iReportBugProcessing = 0;

	if (refresh_gui_docking == 0 && !bBug_Reporting_Window)
	{
		//Make sure window is setup in docking space.
		ImGui::Begin("Bug Reporting System##BugReportingWindow", &bBug_Reporting_Window, iGenralWindowsFlags);
		ImGui::End();
	}

	static bool bLastBugStatus = false;
	if (bLastBugStatus != bBug_Reporting_Window || bBug_RefreshBugList ==true)
	{
		//Window just open , reset variables.
		strcpy(cBugTitle, "");
		strcpy(cBugDescription, "");
		//bIncludeScreenShot = true; // keep these preferences from the user
		//bIncludesystemSpecs = true;
		bLastBugStatus = bBug_Reporting_Window;
		if (sBugList.size() == 0 || bBug_RefreshBugList==true)
		{
			GetBugReport();
		}
		iReportBugProcessing = 0;
		bBug_RefreshBugList = false;
	}

	if (!bBug_Reporting_Window)
		return;

	int wflags = ImGuiTreeNodeFlags_DefaultOpen;

	if (ImGui::Begin("Bug Reporting System##BugReportingWindow", &bBug_Reporting_Window, iGenralWindowsFlags) == true)
	{
		if (g_bBugTrackerConnected == false)
		{
			if (ImGui::StyleCollapsingHeader("Help With Bugs", wflags))
			{
				ImGui::Indent(10);
				ImGui::PushItemWidth(-10);
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::TextWrapped("This Bug Tracker System enables you to submit any bugs you find, creates a record of the bugs you have raised and shows you updates when the bugs you have identified are dealt with.");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::TextWrapped("Click the button below to link your account at the TheGameCreators with your GitHub account.");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				if (ImGui::StyleButton("Link Your GitHub Account", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					ExecuteFile("https://www.thegamecreators.com/github/link", "", "", 0);
				}
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::TextWrapped("If you do not have a GitHub account you can register for free by clicking the button below.");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				if (ImGui::StyleButton("Create GitHub Account", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					ExecuteFile("http://github.com/", "", "", 0);
				}
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::TextWrapped("If you do not have an account with TheGameCreators you can register for free by clicking the button below.");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				if (ImGui::StyleButton("Create Account", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					ExecuteFile("https://www.thegamecreators.com/", "", "", 0);
				}
			}
		}
		else
		{
			if (ImGui::StyleCollapsingHeader("Help With Bugs", wflags))
			{
				ImGui::Indent(10);
				ImGui::PushItemWidth(-10);

				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

				ImGui::TextWrapped("If you have found a problem with any functionailty found in the software, you can report it to the development team.");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::TextWrapped("First, ensure this is not a feature request, which you can submit by clicking this button.");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				if (ImGui::StyleButton("Feature Requests", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					ExecuteFile("https://github.com/TheGameCreators/GameGuruRepo/issues/new", "", "", 0);
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Click here to visit our issues board to make a feature request");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::TextWrapped("Also, ensure it is not a general request for help and advice, which you can get by visiting the forum here:");
				if (ImGui::StyleButton("GameGuru Forums", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					ExecuteFile("https://forum.game-guru.com/board/1", "", "", 0);
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Click here to visit the GameGuru forums");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::PopItemWidth();
				ImGui::Indent(-10);
			}

			if (ImGui::StyleCollapsingHeader("Report A Bug", wflags))
			{
				ImGui::Indent(10);
				ImGui::PushItemWidth(-10);
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

				ImGui::TextCenter("Your Bug Title");
				ImGui::InputText("##NameBugReport", &cBugTitle[0], 256);
				if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Please give your bug a name");
				if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

				//Add pencil
				ImGuiWindow* window = ImGui::GetCurrentWindow(); //PE: Add a pencil to all color gadgets.
				void* lpTexture = GetImagePointer(TOOL_PENCIL);
				ImVec2 vDrawPos = { ImGui::GetCursorScreenPos().x + (ImGui::GetContentRegionAvail().x - 30.0f) ,ImGui::GetCursorScreenPos().y - (ImGui::GetFontSize()*1.5f) - 3.0f };
				if (lpTexture)
					window->DrawList->AddImage((ImTextureID)lpTexture, vDrawPos, vDrawPos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1, 1, 1, 1)));

				ImGui::TextCenter("Your Bug Description");

				float TextHeight = ImGui::GetFontSize()*7.5f;
				float w = ImGui::CalcItemWidth();
				ImGui::InputTextMultiline("##cBugDescription", &cBugDescription[0], 4096, ImVec2(0, TextHeight), ImGuiInputTextFlags_CallbackAlways, CLB, &(w));
				if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Please enter a detailed step by step description of how to reproduce this bug");
				if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

				//Add pencil
				window = ImGui::GetCurrentWindow(); //PE: Add a pencil to all color gadgets.
				lpTexture = GetImagePointer(TOOL_PENCIL);
				vDrawPos = { ImGui::GetCursorScreenPos().x + (ImGui::GetContentRegionAvail().x - 30.0f) ,ImGui::GetCursorScreenPos().y - (TextHeight)-3.0f };
				if (lpTexture)
					window->DrawList->AddImage((ImTextureID)lpTexture, vDrawPos, vDrawPos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1, 1, 1, 1)));

				//Need additional Server Side Code - GitHub will shortly allow attachments it is said
				//ImGui::Checkbox("Include current screenshot",&bIncludeScreenShot);
				//if (ImGui::IsItemHovered()) ImGui::SetTooltip("Tick if you wish to include a screenshot with your bug");

				ImGui::Checkbox("Include my system specs", &bIncludesystemSpecs);
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Tick to include my own system specifications with the bug report");

				if (ImGui::StyleButton("Submit Bug Report", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					//Start processing bug report.
					iReportBugProcessing = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("When you click submit, your bug will be reported to TGC");

				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::PopItemWidth();
				ImGui::Indent(-10);
			}
			if (ImGui::StyleCollapsingHeader("Track My Bugs", wflags))
			{
				ImGui::Indent(10);
				ImGui::PushItemWidth(-10);
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

				// drop down filter modes
				const char* filtermodes[] = { "Your Outstanding Issues", "Your Completed Issues", "All Issues" };
				static int filter_current_type_selection = 0;
				if (ImGui::Combo("##combostaticIssuesFilter", &filter_current_type_selection, filtermodes, IM_ARRAYSIZE(filtermodes)))
				{
					// set filter mode = filter_current_type_selection
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Use filter dropdown to choose which issues to see");

				float ListBoxHeight = ImGui::GetFontSize()*16.0f;
				float fAvailableX = ImGui::GetContentRegionAvailWidth();

				/*
				if (ImGui::ListBoxHeader("##BugListBox", ImVec2(0, ListBoxHeight)) == true)
				{
					int i = 0;
					for (auto item : sBugList)
					{
						bool bIsSelected = false;
						ImGui::PushID(i);
						if (ImGui::Selectable(item->cTitle, bIsSelected))
						{
							break;
						}
						ImGui::PopID();
						i++;
					}
					ImGui::ListBoxFooter();
				}
				*/
				if (ImGui::ListBoxHeader("##BugListBox", ImVec2(0, ListBoxHeight)) == true)
				{
					ImGui::Columns(3, "buglistcolumns3", false);  //false no border
					ImGui::SetColumnOffset(0, 0.0f);
					ImGui::SetColumnOffset(1, ImGui::GetFontSize()*4.0f);
					ImGui::SetColumnOffset(2, fAvailableX - (20.0f + 18.0f + ImGui::GetCurrentWindow()->ScrollbarSizes.x));
					ImGui::Indent(-2);
					for (auto item : sBugList)
					{
						if (item)
						{
							int iIcon = MEDIA_REFRESH; //Unknown
							if (item->iStatus == 1)
								iIcon = MEDIA_RECORD;
							if (item->iStatus == 2)
								iIcon = MEDIA_RECORDPROCESSING;
							if (item->iStatus == 3)
								iIcon = MEDIA_RECORDING;

							// operate filter
							if (filter_current_type_selection == 0 && item->iStatus == 3) continue;
							if (filter_current_type_selection == 1 && item->iStatus != 3) continue;

							char buffer[80];
							strcpy(buffer, item->cCreatedAt);

							ImGui::Text(buffer);

							ImGui::NextColumn();

							bool bIsSelected = false;
							if (ImGui::Selectable(item->cTitle, bIsSelected))
							{
								// get issue number
								char pThisIssueNumber[6];
								memcpy(pThisIssueNumber, item->cTitle + 1, 6);
								pThisIssueNumber[5] = 0;
								for (int n = 0; n < strlen(pThisIssueNumber); n++)
									if (pThisIssueNumber[n] == ' ') pThisIssueNumber[n] = 0;

								// assemble new URL to exact issue
								char pURLToIssue[1024];
								strcpy(pURLToIssue, "https://github.com/TheGameCreators/GameGuruRepo/issues/");
								strcat(pURLToIssue, pThisIssueNumber);

								// handle selection
								ExecuteFile(pURLToIssue, "", "");
							}
							if (ImGui::IsItemHovered())
							{
								ImGui::BeginTooltip();
								ImGui::Indent(10);
								ImGui::PushItemWidth(-10);
								ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

								ImGui::Text("%s", item->cTitle);
								ImGui::Separator();
								ImGui::TextWrapped(item->cDescription);
								ImGui::Separator();

								ImGui::ImgBtn(iIcon, ImVec2(16, 16), ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false);
								ImGui::SameLine();
								ImGui::Text(" Status: ");
								ImGui::SameLine();
								if (item->iStatus == 1)
									ImGui::Text("The bug has been submitted. ");
								if (item->iStatus == 2)
									ImGui::Text("We have been able to reproduce this. ");
								if (item->iStatus == 3)
									ImGui::Text("The bug has been fixed. ");

								// no need for this
								//ImGui::Separator();
								//ImGui::Text("Reply: %s", item->cReply);

								ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

								ImGui::PopItemWidth();
								ImGui::Indent(-10);
								ImGui::EndTooltip();
							}

							ImGui::NextColumn();

							ImGui::ImgBtn(iIcon, ImVec2(16, 16), ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false);
							if (ImGui::IsItemHovered())
							{
								LPSTR pTooltip = "";
								if (item->iStatus == 1) pTooltip = "The bug has been submitted.";
								if (item->iStatus == 2)	pTooltip = "We have been able to reproduce this. ";
								if (item->iStatus == 3)	pTooltip = "The bug has been fixed. ";
								ImGui::SetTooltip("%s", pTooltip);
							}

							ImGui::NextColumn();
						}
					}
					ImGui::Columns(1);
					ImGui::Indent(2);
					ImGui::ListBoxFooter();
				}

				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::PopItemWidth();
				ImGui::Indent(-10);
			}

			if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0)
			{
				//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				ImGui::Text("");
				ImGui::Text("");
			}

			// bug submission process
			if (iReportBugProcessing > 0)
			{
				if (iReportBugProcessing == 1)
				{
					// Validate data before processing
					LPSTR pErrorMsg = "";
					if (strlen(cBugTitle) == 0) pErrorMsg = "Please enter your bug title";
					if (strlen(cBugDescription) == 0) pErrorMsg = "Please enter your bug description";
					if (strlen(pErrorMsg) == 0)
					{
						// remove any /n insertions from cBugDescription
						LPSTR pDst = cBugDescription;
						for (LPSTR pSrc = cBugDescription; pSrc <= cBugDescription + sizeof(cBugDescription); pSrc++)
						{
							if (pSrc > cBugDescription && *(pSrc - 1) == ' ' && *pSrc == '\n')
							{
								// we inserted this to get IMGUI to multi-line wrap! So now remove it
							}
							else
							{
								*pDst = *pSrc;
								pDst++;
							}
						}

						// first make a copy of desc
						strcpy(cBugDescriptionCopy, cBugDescription);

						// if ticked sys specs, add this now
						if (bIncludesystemSpecs == true)
						{
							// if no specs found
							char pSystemSpecs[1024];
							strcpy(pSystemSpecs, "DXDIAG required!");

							// delete any old report
							cstr pDXDiagReport = g.mydocumentsdir_s + "\\GameGuruApps\\GameGuruMAX\\dxdiagreport.txt";
							if (FileExist(pDXDiagReport.Get())) DeleteFileA(pDXDiagReport.Get());

							// copy dxdiag bat to mydocs
							cstr pDXDiagSrc = g.fpscrootdir_s + "\\dxdiagsystemspecs.bat";
							cstr pDXDiagSystemScan = g.mydocumentsdir_s + "\\GameGuruApps\\GameGuruMAX\\dxdiagsystemspecs.bat";
							CopyFileA(pDXDiagSrc.Get(), pDXDiagSystemScan.Get(), FALSE);

							// get system specs from users machine
							LPSTR pOldDir = GetDir();
							SetCurrentDirectoryA(g.mydocumentsdir_s.Get());
							SetCurrentDirectoryA("GameGuruApps");
							SetCurrentDirectoryA("GameGuruMAX");
							int iStatusValue = ExecuteFile("dxdiagsystemspecs.bat", "", "", 1, 1);
							SetDir(pOldDir);

							// load in new report
							if (FileExist(pDXDiagReport.Get()))
							{
								// parse out the lines we are interested in
								strcpy(pSystemSpecs, "");
								std::vector<cstr> dxdiagreport;
								LoadArray(pDXDiagReport.Get(), dxdiagreport);
								for (int line = 0; line < dxdiagreport.size(); line++)
								{
									LPSTR pThisLine = dxdiagreport[line].Get();
									for (int iFields = 0; iFields < 10; iFields++)
									{
										LPSTR pLabel = NULL;
										if (iFields == 0) pLabel = "Operating System: ";
										if (iFields == 1) pLabel = "Language: ";
										if (iFields == 2) pLabel = "System Model: ";
										if (iFields == 3) pLabel = "Processor: ";
										if (iFields == 4) pLabel = "Memory: ";
										if (iFields == 5) pLabel = "Windows Dir: ";
										if (iFields == 6) pLabel = "DirectX Version: ";
										if (iFields == 7) pLabel = "Card name: ";
										if (iFields == 8) pLabel = "Dedicated Memory: ";
										if (iFields == 9) pLabel = "Current Mode: ";
										LPSTR pFound = strstr(pThisLine, pLabel);
										if (pFound)
										{
											// exclude if characters found preceding the label
											bool bFoundChars = false;
											for (LPSTR pPtr = pFound - 1; pPtr > pThisLine; pPtr--)
												if (pPtr >= pThisLine && *pPtr != ' ')
													bFoundChars = true;
											if (bFoundChars == true) continue;

											// get to field data
											pFound += strlen(pLabel);

											// add to system specs
											strcat(pSystemSpecs, pLabel);
											strcat(pSystemSpecs, pFound);
											strcat(pSystemSpecs, "\n");
										}
									}
								}
								dxdiagreport.clear();
							}

							strcat(cBugDescription, "\n");
							strcat(cBugDescription, "\n");
							strcat(cBugDescription, "System Specs:\n");
							strcat(cBugDescription, pSystemSpecs);
						}

						// submit bug report to server
						// Create Issue
						// URL : https://www.thegamecreators.com/api/github/issues/create
						// Method: POST
						// Parameters :
						// title - This is the title of the issue and is required
						// body - This is the body text of the issue and is required, it does not support HTML but does support the special markup that GitHub uses for issues if you want to dead up on that here is the documentation https ://guides.github.com/features/mastering-markdown/ it will allow you to do things like embed images and make text bold so worth adding
						char m_szPostData[1024];
						memset(m_szPostData, 0, sizeof(m_szPostData));
						strcpy(m_szPostData, "title=");
						strcat(m_szPostData, cBugTitle);
						strcat(m_szPostData, "&body=");
						strcat(m_szPostData, cBugDescription);
						strcat(m_szPostData, "&labels[0]=max");
						strcat(m_szPostData, "&labels[1]=bug");
						DWORD dwDataReturnedSize = 0;
						LPSTR pDataReturned = NULL;
						char szAuthHeader[1024];
						sprintf(szAuthHeader, "public-api-auth-token: %d:%s", g_iUserID, g_sHashToken.Get());
						UINT iError = OpenURLForGETPOST("www.thegamecreators.com", &pDataReturned, &dwDataReturnedSize, szAuthHeader, m_szPostData, "POST", "/api/github/issues/create");
						if (iError <= 0 && *pDataReturned != 0 && strchr(pDataReturned, '{') != 0)
						{
							// to know when the data ends
							LPSTR pEndOfReturnedData = pDataReturned + dwDataReturnedSize;

							// error or success
							char pSuccessMarker[1024];
							strcpy(pSuccessMarker, Chr(34));
							strcat(pSuccessMarker, "success");
							strcat(pSuccessMarker, Chr(34));
							if (strstr(pDataReturned, pSuccessMarker) != NULL)
							{
								// success - all okay
								iReportBugProcessing++;
							}
							else
							{
								// failed to submit
								pErrorMsg = pDataReturned;
							}
						}

						// restore desc as we dont need system spec in local bug list item
						strcpy(cBugDescription, cBugDescriptionCopy);
					}
					// report error if found
					if (strlen(pErrorMsg) > 0)
					{
						MessageBoxA(NULL, pErrorMsg, "Bug Tracker Error", MB_OK);
						iReportBugProcessing = 0;
					}
				}
				if (iReportBugProcessing == 2)
				{
					// Do screenshot here (if supported)
					// next stage
					iReportBugProcessing++;
				}
				if (iReportBugProcessing == 3)
				{
					// Display "Bug has successful been added, Thanks"
					MessageBoxA(NULL, "Bug has successful been added", "Bug Tracking System", MB_OK);

					// just refresh bug list
					bBug_RefreshBugList = true;

					// End processing.
					iReportBugProcessing = 0;
				}
			}
		}

		// ensure IMGUI focus maintained
		ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
		if (ImGui::IsMouseHoveringRect(bbwin.Min, bbwin.Max))
		{
			bImGuiGotFocus = true;
		}
		if (ImGui::IsAnyItemFocused())
		{
			bImGuiGotFocus = true;
		}

		ImGui::End();
	}
}

LPSTR GetCommentFromIssue( LPSTR pIssueNumber )
{
	// string to return
	LPSTR pCommentToReturn = NULL;

	// get comment from server
	char m_szGETURL[1024];
	strcpy(m_szGETURL, "/api/github/issue/");
	strcat(m_szGETURL, pIssueNumber);
	strcat(m_szGETURL, "/comments?");
	strcat(m_szGETURL, "page=1"); // page number starting with 1
	DWORD dwDataReturnedSize = 0;
	LPSTR pDataReturned = NULL;
	char szAuthHeader[1024];
	sprintf(szAuthHeader, "public-api-auth-token: %d:%s", g_iUserID, g_sHashToken.Get());
	UINT iError = OpenURLForGETPOST("www.thegamecreators.com", &pDataReturned, &dwDataReturnedSize, szAuthHeader, NULL, "GET", m_szGETURL);
	if (iError <= 0 && *pDataReturned != 0 && strchr(pDataReturned, '{') != 0)
	{
		// to know when the data ends
		LPSTR pEndOfReturnedData = pDataReturned + dwDataReturnedSize;

		// create string to return 
		pCommentToReturn = new char[dwDataReturnedSize+1];
		memset(pCommentToReturn, 0, dwDataReturnedSize);

		// now thin this out to only show comment bodies
		char pSpeechMark[2];
		strcpy(pSpeechMark, Chr(34));
		char pBodyMarker[1024];
		strcpy(pBodyMarker, pSpeechMark);
		strcat(pBodyMarker, "body");
		strcat(pBodyMarker, pSpeechMark);
		strcat(pBodyMarker, ":");
		strcat(pBodyMarker, pSpeechMark);
		LPSTR pBodyPtr = strstr(pDataReturned, pBodyMarker);
		if (pBodyPtr)
		{
			pBodyPtr += strlen(pBodyMarker);
			LPSTR pBodyEndPtr = strstr(pBodyPtr, pSpeechMark);
			if (pBodyEndPtr)
			{
				int iOneCommentSize = pBodyEndPtr - pBodyPtr;
				LPSTR pOneComment = new char[iOneCommentSize + 1];
				memcpy(pOneComment, pBodyPtr, iOneCommentSize);
				pOneComment[iOneCommentSize] = 0;
				strcat(pCommentToReturn, "Comment: ");
				strcat(pCommentToReturn, pOneComment);
				strcat(pCommentToReturn, "\n");
				delete pOneComment;
			}
		}
	}

	// free data returned from GET call
	if (pDataReturned)
	{
		delete pDataReturned;
		pDataReturned = NULL;
	}

	// success, return
	return pCommentToReturn;
}

void GetBugReport(void)
{
	// always assume link is not established (link confirmed below)
	g_bBugTrackerConnected = false;

	// clear old bug list
	if (sBugList.size() > 0)
	{
		//Free old list.
		for (int i = 0; i < sBugList.size(); i++)
			SAFE_DELETE(sBugList[i]);
	}
	sBugList.clear();

	#ifdef LBBUGTRACKING
	// find file containing this users ID and hash
	char pData[260];
	memset(pData, 0, sizeof(pData));
	char defaultWriteFolder[260];
	if ((SHGetFolderPathA(NULL, CSIDL_PROFILE, NULL, 0, &defaultWriteFolder[0])) >= 0)
	{
		cstr hashfilename = defaultWriteFolder;
		hashfilename += "\\AppData\\Local\\AGKApps\\TheGameCreators\\GameGuruMAXUpdater\\";
		hashfilename += "internaldata";
		FILE* hashfile = GG_fopen(hashfilename.Get(), "rb");
		if (hashfile)
		{
			// read contents of internaldata file
			size_t size = fread(&pData, 1, sizeof(pData), hashfile);
			fclose(hashfile);

			// if wrong size, cannot authenticate
			if (size < 74)
			{
				// cannot authenticate
				return;
			}

			// decrypt it
			EncDec((uint8_t*)pData, size);

			cstr sData = (char*)pData;
			cstr sData2 = (char*)(pData + 64); // data without message hash
			cstr sMAC, sUserID;
			sData = sData.Left(64); // extract message hash	
			LPSTR pData2 = sData2.Get();
			LPSTR pColon = strstr(pData2, ":");
			int colon = 0;
			if (pColon)
			{
				colon = pColon - pData2;
			}
			if (colon < 0)
			{
				// could not find the user/hash separator
				return;
			}
			sUserID = sData2.Left(colon-1);
			g_iUserID = sUserID.Val();
			g_sHashToken = sData2.Right(sData2.Len()-colon-1);
		}
	}

	// Get all your bug here via the TGC API (user connects their GitHub account via their TGC account!)
	// populate bug list with items this user created
	char m_szGETURL[1024];
	strcpy(m_szGETURL, "/api/github/issues?");
	strcat(m_szGETURL, "state=open"); // "open", "closed", or "all"
	strcat(m_szGETURL, "&filter=created"); // "assigned", "created" or "all"
	strcat(m_szGETURL, "&page=1"); // page number starting with 1
	DWORD dwDataReturnedSize = 0;
	LPSTR pDataReturned = NULL;
	char szAuthHeader[1024];
	sprintf(szAuthHeader, "public-api-auth-token: %d:%s", g_iUserID, g_sHashToken.Get());
	UINT iError = OpenURLForGETPOST("www.thegamecreators.com", &pDataReturned, &dwDataReturnedSize, szAuthHeader, NULL, "GET", m_szGETURL);
	if (iError <= 0 && *pDataReturned != 0 && strchr(pDataReturned, '{') != 0)
	{
		// toi know when the data ends
		LPSTR pEndOfReturnedData = pDataReturned + dwDataReturnedSize;

		// ensure we have success, which means full connection and ready to get bug list
		char pFindString[256];
		strcpy(pFindString, Chr(34));
		strcat(pFindString, "status");
		strcat(pFindString, Chr(34));
		strcat(pFindString, ":");
		strcat(pFindString, Chr(34));
		strcat(pFindString, "success");
		strcat(pFindString, Chr(34));
		LPSTR pSuccessPtr = strstr(pDataReturned, pFindString);
		if (pSuccessPtr == NULL)
		{
			// user has likely not registered their Github account with their tgc account
			// main UI will allow user to do this before trying again here
		}
		else
		{
			// link confirmed 
			g_bBugTrackerConnected = true;

			// populate bug list with items this user created
			// find = \"https:\\/\\/api.github.com\\/repos\\/TheGameCreators\\/GameGuruRepo\\/issues\\/
			char pIssueMarker[1024];
			strcpy(pIssueMarker, Chr(34)); // " speech mark
			strcat(pIssueMarker, "https:");
			strcat(pIssueMarker, Chr(92)); // backslash
			strcat(pIssueMarker, "/");
			strcat(pIssueMarker, Chr(92)); // backslash
			strcat(pIssueMarker, "/api.github.com");
			strcat(pIssueMarker, Chr(92)); // backslash
			strcat(pIssueMarker, "/repos");
			strcat(pIssueMarker, Chr(92)); // backslash
			strcat(pIssueMarker, "/TheGameCreators");
			strcat(pIssueMarker, Chr(92)); // backslash
			strcat(pIssueMarker, "/GameGuruRepo");
			strcat(pIssueMarker, Chr(92)); // backslash
			strcat(pIssueMarker, "/issues");
			strcat(pIssueMarker, Chr(92)); // backslash
			strcat(pIssueMarker, "/");
			char pSpeechMark[2];
			strcpy(pSpeechMark, Chr(34)); // " speech mark
			char pCommaMark[2];
			strcpy(pCommaMark, ","); // comma

			// pull out all the bugs from the successful retrieval of the bug list
			LPSTR pIssueBody = pSuccessPtr;
			LPSTR pCurrentPos = pIssueBody;
			bool bHaveIssues = true;
			while (bHaveIssues == true)
			{
				// fields per issue
				char pIssueNumber[32];
				char pIDNumber[32];
				char pNumber[32];
				char pTitle[512];
				char pDesc[10240];
				char pCreatedAt[32];
				char pLabels[512];		

				// look for main issue marker 
				int iDataSize = 0;
				LPSTR pFoundIssue = strstr(pCurrentPos, pIssueMarker);
				if (pFoundIssue)
				{
					// issue number
					pCurrentPos = pFoundIssue + strlen(pIssueMarker);
					LPSTR pIssueNumberEnd = strstr(pCurrentPos, pSpeechMark);
					if (pIssueNumberEnd)
					{
						iDataSize = pIssueNumberEnd - pCurrentPos;
						memcpy(pIssueNumber, pCurrentPos, iDataSize);
						pIssueNumber[iDataSize] = 0;
						pCurrentPos += iDataSize;
					}

					// id
					char pIDMarker[32];
					strcpy(pIDMarker, pSpeechMark);
					strcat(pIDMarker, "id");
					strcat(pIDMarker, pSpeechMark);
					strcat(pIDMarker, ":");
					LPSTR pFoundID = strstr(pCurrentPos, pIDMarker);
					if (pFoundID)
					{
						pCurrentPos = pFoundID + strlen(pIDMarker);
						LPSTR pIDEnd = strstr(pCurrentPos, pCommaMark);
						if (pIDEnd)
						{
							iDataSize = pIDEnd - pCurrentPos;
							memcpy(pIDNumber, pCurrentPos, iDataSize);
							pIDNumber[iDataSize] = 0;
							pCurrentPos += iDataSize;
						}
					}

					// number
					char pNumberMarker[32];
					strcpy(pNumberMarker, pSpeechMark);
					strcat(pNumberMarker, "number");
					strcat(pNumberMarker, pSpeechMark);
					strcat(pNumberMarker, ":");
					LPSTR pFoundNumber = strstr(pCurrentPos, pNumberMarker);
					if (pFoundNumber)
					{
						pCurrentPos = pFoundNumber + strlen(pNumberMarker);
						LPSTR pNumberEnd = strstr(pCurrentPos, pCommaMark);
						if (pNumberEnd)
						{
							iDataSize = pNumberEnd - pCurrentPos;
							memcpy(pNumber, pCurrentPos, iDataSize);
							pNumber[iDataSize] = 0;
							pCurrentPos += iDataSize;
						}
					}

					// title
					char pTitleMarker[32];
					strcpy(pTitleMarker, pSpeechMark);
					strcat(pTitleMarker, "title");
					strcat(pTitleMarker, pSpeechMark);
					strcat(pTitleMarker, ":");
					strcat(pTitleMarker, pSpeechMark);
					LPSTR pFoundTitle = strstr(pCurrentPos, pTitleMarker);
					if (pFoundTitle)
					{
						pCurrentPos = pFoundTitle + strlen(pTitleMarker);
						LPSTR pTitleEnd = strstr(pCurrentPos, pSpeechMark);
						if (pTitleEnd)
						{
							iDataSize = pTitleEnd - pCurrentPos;
							memcpy(pTitle, pCurrentPos, iDataSize);
							pTitle[iDataSize] = 0;
							pCurrentPos += iDataSize;
						}
					}

					// determine what created_at marker looks like so we can stop looking for labels
					char pCreatedMarker[32];
					strcpy(pCreatedMarker, pSpeechMark);
					strcat(pCreatedMarker, "created_at");
					strcat(pCreatedMarker, pSpeechMark);
					strcat(pCreatedMarker, ":");
					strcat(pCreatedMarker, pSpeechMark);

					// labels
					strcpy(pLabels, "");
					LPSTR pLabelMarker = "labels\\/";
					bool bWhileWeHaveLabels = true;
					while (bWhileWeHaveLabels==true)
					{
						LPSTR pFoundLabel = strstr(pCurrentPos, pLabelMarker);
						LPSTR pFoundCreatedAt = strstr(pCurrentPos, pCreatedMarker);
						if (pFoundLabel == NULL || pFoundCreatedAt <= pFoundLabel)
						{
							// no more labels, leave label loop
							bWhileWeHaveLabels = false;
						}
						else
						{
							// add this label
							if (pFoundLabel)
							{
								pCurrentPos = pFoundLabel + strlen(pLabelMarker);
								LPSTR pLabelsEnd = strstr(pCurrentPos, pSpeechMark);
								if (pLabelsEnd)
								{
									char pOneLabel[1024];
									iDataSize = pLabelsEnd - pCurrentPos;
									memcpy(pOneLabel, pCurrentPos, iDataSize);
									pOneLabel[iDataSize] = 0;
									if (strlen(pLabels) > 0) strcat(pLabels, ":");
									strcat(pLabels, pOneLabel);
									pCurrentPos += iDataSize;
								}
							}
						}
					}

					// createdat
					LPSTR pFoundCreated = strstr(pCurrentPos, pCreatedMarker);
					if (pFoundCreated)
					{
						pCurrentPos = pFoundCreated + strlen(pCreatedMarker);
						LPSTR pCreatedEnd = pCurrentPos + 10;//YYYY-MM-DD strstr(pCurrentPos, pSpeechMark);
						if (pCreatedEnd)
						{
							iDataSize = pCreatedEnd - pCurrentPos;
							memcpy(pCreatedAt, pCurrentPos, iDataSize);
							pCreatedAt[iDataSize] = 0;
							pCurrentPos += iDataSize;
						}
					}

					// body is the first comment (main description)
					char pBodyMarker[32];
					strcpy(pBodyMarker, pSpeechMark);
					strcat(pBodyMarker, "body");
					strcat(pBodyMarker, pSpeechMark);
					strcat(pBodyMarker, ":");
					strcat(pBodyMarker, pSpeechMark);
					LPSTR pFoundBodyDesc = strstr(pCurrentPos, pBodyMarker);
					if (pFoundBodyDesc)
					{
						pCurrentPos = pFoundBodyDesc + strlen(pBodyMarker);
						LPSTR pBodyDescEnd = strstr(pCurrentPos, pSpeechMark);
						if (pBodyDescEnd)
						{
							iDataSize = pBodyDescEnd - pCurrentPos;
							if (iDataSize >= 4095) iDataSize = 4095;
							memcpy(pDesc, pCurrentPos, iDataSize);
							pDesc[iDataSize] = 0;
							pCurrentPos += iDataSize;
						}
					}

					// add issue to list if pass the filters
					if (strstr(pLabels, "Max") != NULL && strstr(pLabels, "enhancement") == NULL)
					{
						// prepare bug item
						BugReport * br = new BugReport;
						strcpy(br->cCreatedAt, pCreatedAt + 2); // chop YYYY into YY
						sprintf(br->cTitle,"#%s %s", pIssueNumber, pTitle);
						strcpy(br->cReply, pLabels);

						// main body description
						strcpy(br->cDescription, pDesc);
						for (int n = 0; n < strlen(br->cDescription); n++)
						{
							// replace unwanted stuff from body description
							if (br->cDescription[n + 0] == '\\' && br->cDescription[n + 1] == 'r' && br->cDescription[n + 2] == '\\' && br->cDescription[n + 3] == 'n')
							{
								br->cDescription[n + 0] = '.';
								br->cDescription[n + 1] = ' ';
								br->cDescription[n + 2] = ' ';
								br->cDescription[n + 3] = ' ';
							}
							if (br->cDescription[n + 0] == '\\' && br->cDescription[n + 1] == 'n')
							{
								br->cDescription[n + 0] = ' ';
								br->cDescription[n + 1] = ' ';
							}
							if (strnicmp(br->cDescription + n, "[image](", 8) == NULL)
							{
								// remove image reference
								bool bReplaceWithSpaces = true;
								for (int nn = n; nn < strlen(br->cDescription); nn++)
								{
									if (br->cDescription[n + 0] == ')' && br->cDescription[n + 1] == '\\' && br->cDescription[n + 2] == 'r' && br->cDescription[n + 3] == '\\' && br->cDescription[n + 4] == 'n')
									{
										br->cDescription[nn + 0] = ' ';
										br->cDescription[nn + 1] = ' ';
										br->cDescription[nn + 2] = ' ';
										br->cDescription[nn + 3] = ' ';
										break;
									}
									else
									{
										br->cDescription[nn] = ' ';
									}
								}
							}
							if (strnicmp(br->cDescription + n, "System Specs:", 13) == NULL)
							{
								// remove system specs from end (own PC)
								for (int nn = n; nn < strlen(br->cDescription); nn++)
									br->cDescription[nn] = ' ';
							}
						}
						// now remove all extra spaces to compress body desc to summary sentence
						LPSTR pWritePtr = br->cDescription;
						for (LPSTR pReadPtr = br->cDescription; pReadPtr < br->cDescription+4096; pReadPtr++)
						{
							if (*(pReadPtr + 0) == ' ' && *(pReadPtr + 1) == ' ')
							{
								// ignore extra space
							}
							else
							{
								// keep character
								*pWritePtr = *pReadPtr; 
								pWritePtr++; 
							}
						}
						*pWritePtr = 0;

						// determine status from label
						br->iStatus = 1; //reported
						if (strstr(pLabels, "fixed") != NULL || strstr(pLabels, "Fixed") != NULL)
						{
							if (strstr(pLabels, "confirmation") != NULL)
								br->iStatus = 2; //confirmed
							else
								br->iStatus = 3; //fixed
						}

						// add to bug list
						sBugList.push_back(br);
					}
				}
				else
				{
					// no more issues found
					bHaveIssues = false;
				}
			}
		}
	}
	if (pDataReturned)
	{
		delete pDataReturned;
		pDataReturned = NULL;
	}
	#endif //LBBUGTRACKING
}


ImVec2 Convert3DTo2D(float x, float y, float z)
{
	// take wicked viewproj and convert 3D XYZ to screenspace XY
	XMFLOAT3 thisPos = XMFLOAT3(x, y, z);
	XMVECTOR vecPos = XMLoadFloat3(&thisPos);
	wiCanvas canvas = master.masterrenderer;
	canvas.dpi = 96.0f; //PE: Always use default dpi. 2D coords is not using dpi scaling.
	float screenW = canvas.GetLogicalWidth();
	float screenH = canvas.GetLogicalHeight();
	wiScene::CameraComponent &camera = wiScene::GetCamera();
	XMMATRIX V = camera.GetView();
	XMMATRIX P = camera.GetProjection();
	XMMATRIX W = XMMatrixIdentity();
	XMVECTOR screen2D = XMVector3Project(vecPos, 0, 0, screenW, screenH, 0.0f, 1.0f, P, V, W);
	if (screen2D.m128_f32[2] >= 0.0f )
		return(ImVec2(screen2D.m128_f32[0], screen2D.m128_f32[1]));
	else
		return(ImVec2(-999999,-999999));
}

void GetRubberbandLowHighValues(void)
{
	//PE: Find clipping rect.
	float fLowX = 999999.0, fLowY = 999999.0, fLowZ = 999999.0;
	float fHighX = -999999.0, fHighY = -999999.0, fHighZ = -999999.0;
	for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
	{
		int e = g.entityrubberbandlist[i].e;
		if (e > 0)
		{
			//Think i need the bounding box here.
			AABB aabb;
			sObject* pObject = GetObjectData(t.entityelement[e].obj);
			if (pObject && ObjectExist(t.entityelement[e].obj))
			{
				GGMATRIX matARotation;
				GGVECTOR3 box1;
				GGMATRIX matRotateX, matRotateY, matRotateZ;
				if (pObject->position.bFreeFlightRotation)
				{
					matARotation = pObject->position.matFreeFlightRotate;
				}
				else
				{
					//ZXY
					GGMatrixRotationX(&matRotateX, GGToRadian(pObject->position.vecRotate.x));	// x rotation
					GGMatrixRotationY(&matRotateY, GGToRadian(pObject->position.vecRotate.y));	// y rotation
					GGMatrixRotationZ(&matRotateZ, GGToRadian(pObject->position.vecRotate.z));	// z rotation
					matARotation = matRotateX * matRotateY * matRotateZ;
				}
				if (pObject->position.bApplyPivot)
				{
					matARotation *= pObject->position.matPivot;
				}

				aabb._min.x = pObject->collision.vecMin.x;
				aabb._min.y = pObject->collision.vecMin.y;
				aabb._min.z = pObject->collision.vecMin.z;
				aabb._max.x = pObject->collision.vecMax.x;
				aabb._max.y = pObject->collision.vecMax.y;
				aabb._max.z = pObject->collision.vecMax.z;

				box1.x = aabb._min.x; box1.y = aabb._min.y; box1.z = aabb._min.z;
				GGVec3TransformCoord(&box1, &box1, &matARotation);
				aabb._min.x = box1.x; aabb._min.y = box1.y; aabb._min.z = box1.z;
				box1.x = aabb._max.x; box1.y = aabb._max.y; box1.z = aabb._max.z;
				GGVec3TransformCoord(&box1, &box1, &matARotation);
				aabb._max.x = box1.x; aabb._max.y = box1.y; aabb._max.z = box1.z;

				aabb._min.x = (aabb._min.x * pObject->position.vecScale.x);
				aabb._min.y = (aabb._min.y * pObject->position.vecScale.y);
				aabb._min.z = (aabb._min.z * pObject->position.vecScale.z);
				aabb._max.x = (aabb._max.x * pObject->position.vecScale.x);
				aabb._max.y = (aabb._max.y * pObject->position.vecScale.y);
				aabb._max.z = (aabb._max.z * pObject->position.vecScale.z);

				if (t.entityelement[e].x + aabb._min.x < fLowX) fLowX = t.entityelement[e].x + aabb._min.x;
				if (t.entityelement[e].x + aabb._min.x > fHighX) fHighX = t.entityelement[e].x + aabb._min.x;
				if (t.entityelement[e].y + aabb._min.y < fLowY) fLowY = t.entityelement[e].y + aabb._min.y;
				if (t.entityelement[e].y + aabb._min.y > fHighY) fHighY = t.entityelement[e].y + aabb._min.y;
				if (t.entityelement[e].z + aabb._min.z < fLowZ) fLowZ = t.entityelement[e].z + aabb._min.z;
				if (t.entityelement[e].z + aabb._min.z > fHighZ) fHighZ = t.entityelement[e].z + aabb._min.z;
				if (t.entityelement[e].x + aabb._max.x < fLowX) fLowX = t.entityelement[e].x + aabb._max.x;
				if (t.entityelement[e].x + aabb._max.x > fHighX) fHighX = t.entityelement[e].x + aabb._max.x;
				if (t.entityelement[e].y + aabb._max.y < fLowY) fLowY = t.entityelement[e].y + aabb._max.y;
				if (t.entityelement[e].y + aabb._max.y > fHighY) fHighY = t.entityelement[e].y + aabb._max.y;
				if (t.entityelement[e].z + aabb._max.z < fLowZ) fLowZ = t.entityelement[e].z + aabb._max.z;
				if (t.entityelement[e].z + aabb._max.z > fHighZ) fHighZ = t.entityelement[e].z + aabb._max.z;

			}

			if (t.entityelement[e].x < fLowX) fLowX = t.entityelement[e].x;
			if (t.entityelement[e].y < fLowY) fLowY = t.entityelement[e].y;
			if (t.entityelement[e].z < fLowZ) fLowZ = t.entityelement[e].z;
			if (t.entityelement[e].x > fHighX) fHighX = t.entityelement[e].x;
			if (t.entityelement[e].y > fHighY) fHighY = t.entityelement[e].y;
			if (t.entityelement[e].z > fHighZ) fHighZ = t.entityelement[e].z;
		}
	}
	//PE: Convert fLowX to screencords.
	if (fHighX > -999998.0 && fLowX < 999998.0)
	{
		ImVec2 vLowValue = Convert3DTo2D(fLowX, fLowY, fLowZ);
		ImVec2 vHighValue = Convert3DTo2D(fHighX, fHighY, fHighZ);
		if (vLowValue.x < vHighValue.x)
		{
			fLastRubberBandX1 = vLowValue.x;
			fLastRubberBandX2 = vHighValue.x;
		}
		else
		{
			fLastRubberBandX2 = vLowValue.x;
			fLastRubberBandX1 = vHighValue.x;
		}
		if (vLowValue.y < vHighValue.y)
		{
			fLastRubberBandY1 = vLowValue.y;
			fLastRubberBandY2 = vHighValue.y;
		}
		else
		{
			fLastRubberBandY2 = vLowValue.y;
			fLastRubberBandY1 = vHighValue.y;
		}

		//Expand Y.
		fLastRubberBandY1 *= 0.8;
		fLastRubberBandY2 *= 1.2;

		//Adjust to fit better.
		fLastRubberBandX1 -= 40.f;
		fLastRubberBandY1 -= 40.f;
		fLastRubberBandX2 += 40.f;
		fLastRubberBandY2 += 40.f;
	}
}

void DragDrop_DeleteEntityCursor(void)
{
	// prevent deleting them, and instead instruct user to ungroup the objects first
	bool bContinueWithDelete = true; //PE: Changed to true , we should be able to delete normal objects.
	if (current_selected_group >= 0 && vEntityGroupList[current_selected_group][0].iGroupID != -1)
	{
		// do not delete 'key' objects that are part of group
		strcpy(cTriggerMessage, "Cannot delete a parent group. First ungroup objects, then you can delete them all.");
		bTriggerMessage = true;
		bContinueWithDelete = false;
	}
	if (bContinueWithDelete == true)
	{
		//PE: Delete entity cursor.
		//Delete any associated waypoint/trigger zone
		t.waypointindex = t.grideleprof.trigger.waypointzoneindex;
		if (t.waypointindex > 0)
		{
			t.w = t.waypoint[t.waypointindex].start;
			waypoint_delete();
		}
		t.grideleprof.trigger.waypointzoneindex = 0;
		//  delete grid entity object and reset
		t.gridentitydelete = 0;
		if (t.gridentityobj > 0)
		{
			DeleteObject(t.gridentityobj);
			t.gridentityobj = 0;
		}
		t.refreshgrideditcursor = 1;
		t.gridentity = 0;
		t.gridentityposoffground = 0;
		t.gridentityusingsoftauto = 0;
		t.gridentitysurfacesnap = 1 - g.gdisablesurfacesnap;
		#ifdef WICKEDENGINE
		// MAX handles its own positioning system
		t.gridentityautofind = 0;
		#else
		t.gridentityautofind = 1;
		#endif
		t.inputsys.dragoffsetx_f = 0;
		t.inputsys.dragoffsety_f = 0;
		editor_refreshentitycursor();
		t.widget.pickedObject = 0;

		bool bDisableRubberBandMoving = false;
		#ifdef WICKEDENGINE
		if (current_selected_group >= 0 && group_editing_on)
		{
			bDisableRubberBandMoving = true;
		}
		bDraggingActive = false;
		#endif
		if (!bDisableRubberBandMoving)
		{
			// if rubberband selection, delete all in selection
			gridedit_deleteentityrubberbandfrommap();
		}
		// flag also used to restore highlighting behavior
		t.gridentityextractedindex = 0;

		// when place down, ensure waypoint not affected until release mouse button
		t.mclickpressed = 1;
		t.selstage = 1;
	}
}


void DragDrop_CheckTrashcanDrop(ImRect bb)
{
	if (pref.iEnableDragDropEntityMode && !bDraggingActive)
	{
		//Allow Trash drag drop, even when not dragging.
		//Reverse action, so you need to release mouse to delete, to prevent accidental deleting.
		if (t.gridentity != 0 || t.gridentityobj != 0)
		{
			if (ImGui::IsMouseHoveringRect(bb.Min, bb.Max, false))
			{
				if (!ImGui::IsMouseDown(0))
				{
					ImGui::BeginTooltip();
					ImGui::ImgBtn(TOOL_TRASHCAN, ImVec2(48, 48), ImVec4(1.0, 1.0, 1.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors);
					ImGui::EndTooltip();
					bTrashcanIconActive = true;
				}
				else
				{
					DragDrop_DeleteEntityCursor();
				}
			}
		}
	}
	if (pref.iEnableDragDropEntityMode && bDraggingActive)
	{
		if (t.gridentity != 0 || t.gridentityobj != 0)
		{
			if (ImGui::IsMouseHoveringRect(bb.Min, bb.Max, false))
			{
				if (ImGui::IsMouseDown(0))
				{
					//ImGui::SetT   ooltip("%s", "Remove");
					ImGui::BeginTooltip();
					ImGui::ImgBtn(TOOL_TRASHCAN, ImVec2(48, 48), ImVec4(1.0, 1.0, 1.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false,false, bBoostIconColors);
					ImGui::EndTooltip();
					bTrashcanIconActive = true;
				}
				else {
					DragDrop_DeleteEntityCursor();
				}
			}
		}
	}
}

void DragCameraMovement(void)
{
	#ifdef DIRECTIONALCAMERASCROLLING
	// this is a nice method, but probably not ideal for everyone (and you can easily overshoot)
	// so decided to go with the pan method which has more finer controls for camera management
	static int iActivateCount = 0;
	if (pref.iDragCameraMovement && t.ebe.on == 0 && t.inputsys.xmouse != 500000  && t.grideditselect == 5 && t.gridentity == 0 && t.widget.activeObject == 0 && t.inputsys.keyshift == 0)
	{
		static ImVec2 vStartPos = { 0,0 };
		if (ImGui::IsMouseDown(0))
		{
			if (iActivateCount < 5) //PE: Give priority to object selection.
			{
				iActivateCount++;
				return;
			}
			static float fOldX = 0.0f, fOldY = 0.0f;
			if (!bDragCameraActive)
			{
				vStartPos = ImGui::GetMousePos();
				bDragCameraActive = true;
				fOldX = 0.0f;
			}
			ImVec2 vPos = ImGui::GetMousePos();
			ImVec2 vDiff = (vStartPos - vPos) * 0.60;
			//Draw line.
			{
				ImGuiViewport* mainviewport = ImGui::GetMainViewport();
				if (mainviewport)
				{
					ImDrawList* dl = ImGui::GetForegroundDrawList(mainviewport);
					if (dl)
					{
						dl->AddLine(vStartPos, vPos, ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 0.8)), 3.0f);
					}
				}
			}

			GGVECTOR3 vCamPos = GetCameraPosition();
			float fMoveSpeed = 8192.0f;
			float fCamDistance = (vCamPos.y*2.0f);
			if (fCamDistance < 50.0f) fCamDistance = 50.0f;

			vDiff = vDiff / fMoveSpeed * fCamDistance;

			float fmove = ImLerp(vDiff.x, fOldX, 0.25f);
			fmove *= g.timeelapsed_f;
			MoveCameraLeft(0, fmove);

			t.cx_f = t.editorfreeflight.c.x_f = GetCameraPosition().x;
			t.editorfreeflight.c.y_f = GetCameraPosition().y;
			t.cy_f = t.editorfreeflight.c.z_f = GetCameraPosition().z;
			fOldX = fmove;

			fmove = ImLerp(vDiff.y, fOldY, 0.25f);
			fmove *= g.timeelapsed_f;
			MoveCameraUp(0, fmove);

			t.cx_f = t.editorfreeflight.c.x_f = GetCameraPosition().x;
			t.editorfreeflight.c.y_f = vCamPos.y;
			t.cy_f = t.editorfreeflight.c.z_f = GetCameraPosition().z;
			fOldY = fmove;


		}
		else
		{
			bDragCameraActive = false;
			iActivateCount = 0;
		}
	}
	else
	{
		iActivateCount = 0;
	}
	#endif
}

#include "BuildingEditor/BuildingEditor.h"
void MouseLeftDragXZPanning(void)
{
	#ifdef BUILDINGEDITOR
	if (BuildingEditor::isActive())
		return;
	#endif	
	static int iActivateCount = 0;
	static bool bPanningActive = false;
	if (1)
	{
		static ImVec2 vStartPos = { 0,0 };
		static bool bRestoreMouseAfterXZPan = false;
		bool bOkayToGo = false;
		if (bPanningActive == true) bOkayToGo = true;
		if (t.onedrag == 0 && bPanningActive == false && pref.iDragCameraMovement && t.ebe.on == 0 && t.inputsys.xmouse != 500000 && t.grideditselect == 5 && t.gridentity == 0 && t.widget.activeObject == 0 && t.inputsys.keyshift == 0 && t.inputsys.keycontrol == 0 && bDotObjectDragging==false ) bOkayToGo = true;
		if (ImGui::IsMouseDown(0) && bOkayToGo == true)
		{
			//PE: Give priority to object selection
			if (iActivateCount < 5) 
			{
				iActivateCount++;
				return;
			}

			//PE: Must call it each frame.
			ImGui::SetMouseCursor(ImGuiMouseCursor_Pan);

			// New mouse drag camera system relies on actual ray casts
			// to terrain to get exact XZ coordinates for the drag
			static float fTerrainLastHitX = 0.0f;
			static float fTerrainLastHitZ = 0.0f;
			float fTerrainHitX, fTerrainHitY, fTerrainHitZ;
			if (WickedCall_GetPick(&fTerrainHitX, &fTerrainHitY, &fTerrainHitZ, NULL, NULL, NULL, NULL, GGRENDERLAYERS_NORMAL | GGRENDERLAYERS_TERRAIN) == true)
			{
				if (bPanningActive==false)
				{
					bPanningActive = true;
					bDragCameraActive = true;
					fTerrainLastHitX = fTerrainHitX;
					fTerrainLastHitZ = fTerrainHitZ;
					if (bRestoreMouseAfterXZPan == false && ImGui::GetMouseCursor() == ImGuiMouseCursor_Arrow)
					{
						bRestoreMouseAfterXZPan = true;
						ImGui::SetMouseCursor(ImGuiMouseCursor_Pan);
					}
				}
				float fDifferenceX = fTerrainHitX - fTerrainLastHitX;
				float fDifferenceZ = fTerrainHitZ - fTerrainLastHitZ;
				//LB: prevent moving TOO fast such as grabbing terrain in extreme distance and shifting
				if (fabs(fDifferenceX) + fabs(fDifferenceZ) > 100.0f)
				{
					float fDist = sqrt((fabs(fDifferenceX)*fabs(fDifferenceX)) + (fabs(fDifferenceZ)*fabs(fDifferenceZ)));
					fDifferenceX = (fDifferenceX / fabs(fDist)) * 100.0f;
					fDifferenceZ = (fDifferenceZ / fabs(fDist)) * 100.0f;
				}
				fDifferenceX *= 1.8; //Move a bit faster.
				fDifferenceZ *= 1.8; //Move a bit faster.

				//PE: If we move in-out of water we can get some huge differences.
				if (fabs(fDifferenceX) + fabs(fDifferenceZ) < 6000.0f)
				{
					if (fabs(fDifferenceX) + fabs(fDifferenceZ) != 0.0f)
					{
						bPanningActive = false;
						// LB: also need to close this down or we end up locked in constant drag
						bDragCameraActive = false;
						if (bRestoreMouseAfterXZPan == true)
						{
							bRestoreMouseAfterXZPan = false;
							ImGui::SetMouseCursor(ImGuiMouseCursor_Arrow);
						}
					}
					t.cx_f = t.editorfreeflight.c.x_f = (t.editorfreeflight.c.x_f - fDifferenceX);
					t.cy_f = t.editorfreeflight.c.z_f = (t.editorfreeflight.c.z_f - fDifferenceZ);
				}
			}
			fTerrainLastHitX = fTerrainHitX;
			fTerrainLastHitZ = fTerrainHitZ;
		}
		else
		{
			if (bPanningActive == true)
			{
				bPanningActive = false;
				bDragCameraActive = false;
				if (bRestoreMouseAfterXZPan == true)
				{
					bRestoreMouseAfterXZPan = false;
					ImGui::SetMouseCursor(ImGuiMouseCursor_Arrow);
				}
			}
			iActivateCount = 0;
		}
	}
	else
	{
		iActivateCount = 0;
	}
}

void MouseWheelYPanning(void)
{
	static bool bPanningActive = false;
	static ImVec2 vStartPos = { 0,0 };
	static bool bRestoreMouseAfterYPan = false;
	if (ImGui::IsMouseDown(2))
	{
		if (bRestoreMouseAfterYPan ==false && ImGui::GetMouseCursor() == ImGuiMouseCursor_Arrow)
		{
			bRestoreMouseAfterYPan = true;
			ImGui::SetMouseCursor(ImGuiMouseCursor_Pan);
		}

		// New system for Camera Panning (Y) is to pan across the camera lens plane
		// so left/right is left and right for the camera operator, and up/down lifts and lowers the camera operator
	}
	else
	{
		bPanningActive = false;
		if (bRestoreMouseAfterYPan == true)
		{
			bRestoreMouseAfterYPan = false;
			ImGui::SetMouseCursor(ImGuiMouseCursor_Arrow);
		}
	}
}

cStr cLastLibraryList = "";

//PE: TODO - g_LibraryFileList[] should be an array so we can have many on the screen at the same times.
//PE: TODO - get image width height from actual images so we dont lock it to widethumb format only.
//PE: This will be used for many different image selection types, Behavior,Images,Sound? ...
void SortFilesListForLibraryType()
{
	std::vector<sLibraryList> SortFileList;
	SortFileList.clear();
	SortFileList.resize(g_LibraryFileList.size());
	int iSort = 0;
	for (int i = 0; i < 3 ; i++)
	{
		for (int a = 0; a < g_LibraryFileList.size() ; a++)
		{
			if (g_LibraryFileList[a].iType == i)
			{
				SortFileList[iSort++] = g_LibraryFileList[a];
			}
		}
	}
	g_LibraryFileList = SortFileList;
}
void GetFilesListForLibrary(char *path, bool bCreateThumbs, int win, int iThumbWidth, int iThumbHeight, int SortType)
{
	if (!path) return;
	int uniqueId = 16000;

	if (cLastLibraryList != path)
	{
		cLastLibraryList = path;
		//Free any old thumbs.
		for (int n = 0; n < g_LibraryFileList.size(); n++)
		{
			if (g_LibraryFileList[n].iImage > 0 && ImageExist(g_LibraryFileList[n].iImage))
			{
				image_setlegacyimageloading(true);
				DeleteImage(g_LibraryFileList[n].iImage);
				image_setlegacyimageloading(false);
				g_LibraryFileList[n].iImage = 0;
			}
		}
		g_LibraryFileList.clear();
		LPSTR pOldDir = GetDir();
		SetDir(path);
		ChecklistForFiles();
		SetDir(pOldDir);
		for (int c = 0; c < ChecklistQuantity(); c++)
		{
			cStr cFile = cStr(ChecklistString(1 + c));
			bool bIsImage = false;
			if (cFile != "." && cFile != "..")
			{
				cstr sTmp = ChecklistString(1 + c);
				if (pestrcasestr(sTmp.Get(), ".png"))
					bIsImage = true;
				if (!bIsImage && pestrcasestr(sTmp.Get(), ".jpg"))
					bIsImage = true;
				if (!bIsImage && pestrcasestr(sTmp.Get(), ".jpeg"))
					bIsImage = true;
				if (!bIsImage && pestrcasestr(sTmp.Get(), ".dds"))
					bIsImage = true;
				if (!bIsImage && pestrcasestr(sTmp.Get(), ".bmp"))
					bIsImage = true;
				if (bIsImage)
				{
					sLibraryList vTmp;
					vTmp.cDescription = "";
					vTmp.cName = cStr(sTmp);
					vTmp.cPath = cStr(path);
					vTmp.cFile = cStr(path) + cFile;
					vTmp.iType = 0;
					vTmp.cProject = "";
					vTmp.bProjectExists = false;

					//Check if we got a description file.
					std::string sDescFile = vTmp.cFile.Get();
					
					replaceAll(sDescFile, ".bmp", "");
					replaceAll(sDescFile, ".dds", "");
					replaceAll(sDescFile, ".jpg", "");
					replaceAll(sDescFile, ".jpeg", "");
					replaceAll(sDescFile, ".png", "");
					sDescFile = sDescFile + ".txt";
					std::ifstream t(sDescFile);
					std::string str((std::istreambuf_iterator<char>(t)),std::istreambuf_iterator<char>());
					if (str.length() > 0)
					{
						if (pestrcasestr(str.c_str(), "(rating:0)"))
						{
							replaceAll(str, "(rating:0)", "");
							vTmp.iType = 0;
						}
						else if (pestrcasestr(str.c_str(), "(rating:1)"))
						{
							replaceAll(str, "(rating:1)", "");
							vTmp.iType = 1;
						}
						else if (pestrcasestr(str.c_str(), "(rating:2)"))
						{
							replaceAll(str, "(rating:2)", "");
							vTmp.iType = 2;
						}

						char *find = (char *) pestrcasestr(str.c_str(), "(project:");
						if (find)
						{
							std::string remove = "(project:";
							find += 9;
							char project[512];
							if (strlen(find) < 500)
							{
								strcpy(project, find);
								char *find2 = (char *)pestrcasestr(project, ")");
								if (find2)
								{
									*find2 = 0;

									remove = remove + project;
									remove = remove + ")";
									replaceAll(str, remove, "");
									vTmp.cProject = project;

									// quick check to see if the folder exists
									char pProjFolderFile[MAX_PATH];					
									strcpy(pProjFolderFile, "projectbank\\");
									strcat(pProjFolderFile, vTmp.cProject.Get());
									strcat(pProjFolderFile, "\\project.dat");
									GG_GetRealPath(pProjFolderFile, false);
									if(FileExist(pProjFolderFile)==1)
										vTmp.bProjectExists = true;
									else
										vTmp.bProjectExists = false;
								}
							}
						}

						//PE: The rest is the pure description.
						vTmp.cDescription = str.c_str();

					}

					g_LibraryFileList.push_back(vTmp);
				}
			}
		}

		if (bCreateThumbs)
		{
			SetDir(pOldDir);
			for (int n = 0; n < g_LibraryFileList.size(); n++)
			{
				//PE: Skip cached thumbs for now.
				CreateBackBufferCacheName(g_LibraryFileList[n].cFile.Get(), iThumbWidth, iThumbHeight);
				g_LibraryFileList[n].iImage = 0;
				if (1==2 && FileExist(BackBufferCacheName.Get()))
				{
					SetMipmapNum(1); //PE: mipmaps not needed.
					image_setlegacyimageloading(true);
					if (FileExist(BackBufferCacheName.Get()))
					{
						LoadImage((char *)BackBufferCacheName.Get(), uniqueId + n);
					}
					if (ImageExist(uniqueId + n))
						g_LibraryFileList[n].iImage = uniqueId + n;
					image_setlegacyimageloading(false);
					SetMipmapNum(-1);
				}
				else
				{
					SetMipmapNum(1); //PE: mipmaps not needed.
					image_setlegacyimageloading(true);
					//Create thumb.
					//LoadImage((char *)g_LibraryFileList[n].cFile.Get(), uniqueId + n, 0, 8192); //Test
					LoadImageSize((char *)g_LibraryFileList[n].cFile.Get(), uniqueId + n, iThumbWidth, iThumbHeight);
					if (1==2 && ImageExist(uniqueId + n))
					{
						//Image
						//Save thumb.
						SaveImage(BackBufferCacheName.Get(), uniqueId + n);
						DeleteImage(uniqueId + n);
						LoadImage((char *)BackBufferCacheName.Get(), uniqueId + n); //Reload new and delete old.

						// resume thumbbank copy mode
						extern bool g_bThumbBankCopyMode;
						g_bThumbBankCopyMode = true;
					}
					if (ImageExist(uniqueId + n))
						g_LibraryFileList[n].iImage = uniqueId + n;
					image_setlegacyimageloading(false);
					SetMipmapNum(-1);
				}
				BackBufferCacheName = "";
			}
		}
		SetDir(pOldDir);
		if (SortType == 1) SortFilesListForLibraryType();
	}
}

cstr ComboFilesListForLibrary(char *currentselection, int columns, int iFixedWidth, bool bRemoveExtension)
{
	cstr sReturnComboName = currentselection;
	cstr sDisplayName = sReturnComboName;
	if (bRemoveExtension)
	{
		char *find = (char *) pestrcasestr(sDisplayName.Get(), ".");
		if (find)
		{
			int iPos = find - sDisplayName.Get();
			if(iPos > 0 && iPos < 1024)
				sDisplayName = Left(sDisplayName.Get(), iPos);
		}
	}
	if (ImGui::BeginCombo("##ComboFilesListForLibrary", sDisplayName.Get(), ImGuiComboFlags_HeightLargest))
	{
		bool is_selected = (sReturnComboName == "None");
		if (ImGui::Selectable("None", is_selected)) {
			sReturnComboName = "None";
		}
		if (is_selected) ImGui::SetItemDefaultFocus();

		bool bUseImage = false;
		float fImageWidth = (ImGui::GetContentRegionAvailWidth() - 10.0f) * 0.5;
		if(iFixedWidth > 0)
			fImageWidth = iFixedWidth;
		fImageWidth -= 5.0f;
		float fImageRatio = fImageWidth / 512.0f;
		if(g_LibraryFileList.size() > 0 && g_LibraryFileList[0].iImage > 0 && ImageExist(g_LibraryFileList[0].iImage) )
			bUseImage = true;

		int columns_count = 0;
		for (int n = 0; n < g_LibraryFileList.size(); n++)
		{
			is_selected = (sReturnComboName == g_LibraryFileList[n].cName);

			if (bUseImage && g_LibraryFileList[n].iImage > 0 && ImageExist(g_LibraryFileList[n].iImage))
			{
				ImVec2 iThumbSize = { (float)512.0*fImageRatio, (float)288.0*fImageRatio };
				if (is_selected)
				{
					ImGuiWindow* window = ImGui::GetCurrentWindow();
					ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
					ImVec2 padding = { 1.0, 1.0 };
					const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + iThumbSize);
					window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
				}
				if (ImGui::ImgBtn(g_LibraryFileList[n].iImage, iThumbSize, ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false,false))
				{
					sReturnComboName = g_LibraryFileList[n].cName;
					ImGui::CloseCurrentPopup();
				}
				if (columns > 0)
				{
					if (++columns_count < columns)
						ImGui::SameLine();
					else
						columns_count = 0;
				}
				else
				{
					//Default to 2 columns
					if (n % 2 == 0)
						ImGui::SameLine();
				}
			}
			else if (ImGui::Selectable(g_LibraryFileList[n].cName.Get(), is_selected)) {
				sReturnComboName = g_LibraryFileList[n].cName;
			}
			if (is_selected) ImGui::SetItemDefaultFocus();
		}
		ImGui::EndCombo();
	}
	return sReturnComboName;
}

int GetImageIDFilesListForLibrary(cstr & currentselection)
{
	for (int n = 0; n < g_LibraryFileList.size(); n++)
	{
		if (currentselection == g_LibraryFileList[n].cName)
		{
			if (ImageExist(g_LibraryFileList[n].iImage))
				return(g_LibraryFileList[n].iImage);
			return(0);
		}
	}
	return(0);
}

int GetEntryFilesListForLibrary(cstr & currentselection)
{
	for (int n = 0; n < g_LibraryFileList.size(); n++)
	{
		if (currentselection == g_LibraryFileList[n].cName)
		{
			return(n);
		}
	}
	return(-1);
}

cstr ListboxFilesListForLibrary(char *currentselection, int columns, int iFixedWidth, bool bRemoveExtension, bool bIncludeNone, char *filter)
{
	cstr sReturnComboName = currentselection;
	if (columns <= 0) columns = 2; //Default to 2.

	bool bUseImage = false;
	float fImageWidth = (ImGui::GetContentRegionAvailWidth() - 10.0f - 18.0f ) / columns; //ImGui::GetCurrentWindow()->ScrollbarSizes.x
	if (iFixedWidth > 0)
		fImageWidth = iFixedWidth;
	fImageWidth -= 5.0f;
	fImageWidth -= 6.0f; //Due to now using Columns add spacing.

	float fImageRatio = fImageWidth / 512.0f;
	if (g_LibraryFileList.size() > 0 && g_LibraryFileList[0].iImage > 0 && ImageExist(g_LibraryFileList[0].iImage))
		bUseImage = true;

	float box_height = (((float)288.0*fImageRatio) * 2.0) + 6.0f;
	box_height += ImGui::GetFontSize() * 5.0;

	ImGui::BeginChild("##ListboxFilesListForLibrary", ImVec2(ImGui::GetContentRegionAvail().x - 4.0, box_height), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
	ImGui::Indent(2);
	if(1)
	{
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 3));
		bool is_selected = false;

		//if (bIncludeNone)
		//{
		//	is_selected = (sReturnComboName == "None");
		//	if (ImGui::StyleButton("No Backdrop", ImVec2(ImGui::GetContentRegionAvail().x - 10.0, 0)))
		//	{
		//		sReturnComboName = "None";
		//	}
		//	if (is_selected) ImGui::SetItemDefaultFocus();
		//}

		ImGui::Columns(columns, "ListboxFilesListForLibrarycolumns", false);  //false no border

		int columns_count = 0;
		for (int n = 0; n < g_LibraryFileList.size(); n++)
		{
			is_selected = (sReturnComboName == g_LibraryFileList[n].cName);

			cstr sDisplayName = g_LibraryFileList[n].cName;
			if (bRemoveExtension)
			{
				char *find = (char *)pestrcasestr(sDisplayName.Get(), ".");
				if (find)
				{
					int iPos = find - sDisplayName.Get();
					if (iPos > 0 && iPos < 1024)
						sDisplayName = Left(sDisplayName.Get(), iPos);
				}
			}
			bool bVisible = true;
			if (filter)
			{
				bVisible = false;
				cstr sfilter = filter;
				char *p = strtok(sfilter.Get(), ",");
				while (p)
				{
					if(p[0] == '*')
						bVisible = true;
					else if (pestrcasestr(g_LibraryFileList[n].cName.Get(), p))
						bVisible = true;
					p = strtok(NULL, ",");
				}
			}
			if (bVisible)
			{
				if (bUseImage && g_LibraryFileList[n].iImage > 0 && ImageExist(g_LibraryFileList[n].iImage))
				{
					ImVec2 iThumbSize = { (float)512.0*fImageRatio, (float)288.0*fImageRatio };
					if (is_selected)
					{
						ImGuiWindow* window = ImGui::GetCurrentWindow();
						ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
						ImVec2 padding = { 1.0, 1.0 };
						const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + iThumbSize);
						window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
					}
					if (ImGui::ImgBtn(g_LibraryFileList[n].iImage, iThumbSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
					{
						sReturnComboName = g_LibraryFileList[n].cName;
					}

					ImGui::Text(sDisplayName.Get());

					ImGui::NextColumn();
				}
				else if (ImGui::Selectable(sDisplayName.Get(), is_selected))
				{
					sReturnComboName = g_LibraryFileList[n].cName;
				}
				if (is_selected) ImGui::SetItemDefaultFocus();
			}
		}
		ImGui::Columns(1);
	}
	ImGui::Indent(-2);
	ImGui::EndChild();
	return sReturnComboName;
}


bool bRemoveVideoInNextFrame = false;
int iWelcomeVideoID = -1;
bool bWelcomeVideoMaximized = false;
bool bTriggerEditDemoGame = false;

cstr ListboxFilesListForWelcomeScreen(char *currentselection, int columns, int iFixedWidth, bool bRemoveExtension, bool bIncludeNone, char *filter, float fbox_height, bool bDisplayDesc,bool bUseFullScreen)
{
	cstr sReturnComboName = currentselection;
	if (columns <= 0) columns = 2; //Default to 2.
	if (bDisplayDesc) columns++;

	float fImageWidth = (ImGui::GetContentRegionAvailWidth() - 10.0f - 18.0f) / columns; //ImGui::GetCurrentWindow()->ScrollbarSizes.x
	if (iFixedWidth > 0)
		fImageWidth = iFixedWidth;
	fImageWidth -= 5.0f;
	fImageWidth -= 6.0f; //Due to now using Columns add spacing.

	float fImageRatio = fImageWidth / 512.0f;

	float box_height = (((float)288.0*fImageRatio) * 5.0) + 10.0f;
	box_height += ImGui::GetFontSize() * 8.0;
	if (fbox_height > 0) box_height = fbox_height;

	//ImGui::BeginChild("##ListboxFilesListForWelcome", ImVec2(ImGui::GetContentRegionAvail().x - 4.0, box_height), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
	ImGui::BeginChild("##ListboxFilesListForWelcome", ImVec2(ImGui::GetContentRegionAvail().x - 2.0, box_height), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
	ImGui::Indent(2);
	if (1)
	{
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 3));
		bool is_selected = false;
		float total_width = ImGui::GetContentRegionAvailWidth();
		ImGui::Columns(columns, "ListboxFilesListForWelcomecolumns", false);  //false no border

		if (bDisplayDesc)
		{
			ImGui::SetColumnOffset(0, 0.0f);
			ImGui::SetColumnOffset(1, total_width * 0.34); //Right 60% size.
			fImageRatio = (ImGui::GetContentRegionAvailWidth()-2.0f) / 512.0f;
		}

		int columns_count = 0;
		for (int n = 0; n < 10; n++) //Display max 12 games.
		{
			int TextureID = WELCOME_FILLERROUNDED;
			cStr sName = "";
			ImVec4 alpha = { 1.0f,1.0f,1.0f,0.15f };

			if (n < g_LibraryFileList.size())
			{
				if (g_LibraryFileList[n].iImage > 0 && ImageExist(g_LibraryFileList[n].iImage))
				{
					TextureID = g_LibraryFileList[n].iImage;
				}
				sName = g_LibraryFileList[n].cName;
				alpha = { 1.0f,1.0f,1.0f,1.0f };
			}


			is_selected = (sReturnComboName == sName);

			cstr sDisplayName = sName;
			if (bRemoveExtension && n < g_LibraryFileList.size())
			{
				char *find = (char *)pestrcasestr(sDisplayName.Get(), ".");
				if (find)
				{
					int iPos = find - sDisplayName.Get();
					if (iPos > 0 && iPos < 1024)
						sDisplayName = Left(sDisplayName.Get(), iPos);
				}
			}
			bool bVisible = true;
			if (filter && n < g_LibraryFileList.size())
			{
				bVisible = false;
				cstr sfilter = filter;
				char *p = strtok(sfilter.Get(), ",");
				while (p)
				{
					if (p[0] == '*')
						bVisible = true;
					else if (pestrcasestr(g_LibraryFileList[n].cName.Get(), p))
						bVisible = true;
					p = strtok(NULL, ",");
				}
			}
			if (bVisible)
			{
				ImVec2 iThumbSize = { (float)512.0*fImageRatio, (float)288.0*fImageRatio };
				if (is_selected)
				{
					ImGuiWindow* window = ImGui::GetCurrentWindow();
					ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
					ImVec2 padding = { 1.0, 1.0 };
					const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + iThumbSize);
					window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
				}

				ImGuiWindow* window = ImGui::GetCurrentWindow();
				ImRect image_bb(window->DC.CursorPos, window->DC.CursorPos + iThumbSize);

				if (ImGui::ImgBtn(TextureID, iThumbSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255)*alpha, ImColor(255, 255, 255, 200)*alpha, ImColor(255, 255, 255, 200)*alpha, 0, 0, 0, 0, false, false, false))
				{
					if(n < g_LibraryFileList.size())
						sReturnComboName = g_LibraryFileList[n].cName;
				}

				if (ImGui::IsItemHovered())
				{
					if (ImGui::IsMouseDoubleClicked(0))
					{
						if (n < g_LibraryFileList.size())
						{
							sReturnComboName = g_LibraryFileList[n].cName;
							bTriggerEditDemoGame = true;
						}
					}
				}
				static int triggerEndVideo = 0;
				if (n < g_LibraryFileList.size() && ImGui::IsItemHovered() && g_LibraryFileList[n].timer++ > 50)
				{
					if (iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID))
					{
						float fVideoW = 0;
						float fVideoH = 0;
						float animU = 1.0;
						float animV = 1.0;
						void* lpVideoTexture = NULL;
						lpVideoTexture = GetAnimPointerTexture(iWelcomeVideoID);
						if (lpVideoTexture != NULL)
						{
							fVideoW = GetAnimWidth(iWelcomeVideoID);
							fVideoH = GetAnimHeight(iWelcomeVideoID);
							SetRenderAnimToImage(iWelcomeVideoID, true);
							animU = GetAnimU(iWelcomeVideoID);
							animV = GetAnimV(iWelcomeVideoID);
							ImVec2 uv0 = ImVec2(0, 0);
							ImVec2 uv1 = ImVec2(animU, animV);
							window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));
						}

						float fdone = GetAnimPercentDone(iWelcomeVideoID) / 100.0f;
						if (fdone > 0.5)
							triggerEndVideo = 1;
						if (triggerEndVideo > 0 && (fdone == 0.0f || fdone >= 1.0f))
						{
							//End loop.
							//PE: Loop dont work, at some point the player breaks and flicker, just restart everyting.
							//void SetVideoPositionPlay(float seconds);
							//SetVideoPositionPlay(0.0);
							//ResumeAnim(iWelcomeVideoID);
							//Try stopping and starting.
							//StopAnimation(iWelcomeVideoID);
							//PlaceAnimation(iWelcomeVideoID, -1, -1, -1, -1);
							//SetRenderAnimToImage(iWelcomeVideoID, true);
							//PlayAnimation(iWelcomeVideoID);
							//SetVideoVolume(100);
							g_LibraryFileList[n].timer = 0;
							bRemoveVideoInNextFrame = true;
							triggerEndVideo = 0;
						}
					}
					else
					{
						//Load video.
						std::string sVideoFile = g_LibraryFileList[n].cFile.Get();
						replaceAll(sVideoFile, ".png", ".mp4");
						if (FileExist((LPSTR) sVideoFile.c_str()))
						{
							iWelcomeVideoID = 0;
							for (int i = 1; i <= 32; i++)
							{
								if (AnimationExist(i) == 0) { iWelcomeVideoID = i; break; }
							}

							if (iWelcomeVideoID > 0)
							{
								if (LoadAnimation((LPSTR) sVideoFile.c_str(), iWelcomeVideoID, g.videoprecacheframes, g.videodelayedload, 1) == false)
								{
									iWelcomeVideoID = -999;
								}
								if (iWelcomeVideoID > 0)
								{
									PlaceAnimation(iWelcomeVideoID, -1, -1, -1, -1);
									SetRenderAnimToImage(iWelcomeVideoID, true);
									PlayAnimation(iWelcomeVideoID);
									SetVideoVolume(100);
								}
							}
						}
						else
						{
							g_LibraryFileList[n].timer = 0; //Failed.
							triggerEndVideo = 0;
						}
					}
				}
				else
				{
					if (n < g_LibraryFileList.size() && !ImGui::IsItemHovered())
					{
						if (g_LibraryFileList[n].timer > 0 && iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID)) {
							bRemoveVideoInNextFrame = true;
							triggerEndVideo = 0;
						}
						g_LibraryFileList[n].timer = 0;
					}
				}
				//zombie cellar demo - level1.mp4
				if (!bDisplayDesc)
					ImGui::Text(sDisplayName.Get());
				if (bDisplayDesc)
				{
					if (n < g_LibraryFileList.size())
					{
						ImGui::SetWindowFontScale(1.4);
						char UniqueString[256];
						ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 1.0f, 1.00f));
						if (g_LibraryFileList[n].iType == 2)
						{
							ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.0f, 0.0f, 1.00f));
							ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.6f, 0.0f, 0.0f, 0.75f));
							ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.6f, 0.0f, 0.0f, 1.00f));
							sprintf(UniqueString, "Design Complexity: Developer##%d", n);
						}
						else if (g_LibraryFileList[n].iType == 1)
						{
							ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.7f, 0.0f, 1.00f));
							ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.8f, 0.7f, 0.0f, 0.75f));
							ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.8f, 0.7f, 0.0f, 1.00f));
							sprintf(UniqueString, "Design Complexity: Advanced##%d", n);
						}
						else
						{
							ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.0f, 0.6f, 0.0f, 1.00f));
							ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.0f, 0.6f, 0.0f, 0.75f));
							ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.0f, 0.6f, 0.0f, 1.00f));
							sprintf(UniqueString, "Design Complexity: Standard##%d", n);
						}

						if (ImGui::StyleButton(UniqueString, ImVec2(iThumbSize.x, 0.0f)))
						{
							//Select Game
							if (n < g_LibraryFileList.size())
								sReturnComboName = g_LibraryFileList[n].cName;
						}

						ImGui::PopStyleColor(4);

						ImGui::SetWindowFontScale(1.0);
					}
				}

				ImGui::NextColumn();
				if (is_selected) ImGui::SetItemDefaultFocus();

				if (bDisplayDesc)
				{
					if (n < g_LibraryFileList.size())
					{
						//Overlay rating.
						char UniqueString[256];
						sprintf(UniqueString, "##ListboxFilesDescriptionBox%d", n);
						ImGui::BeginChild(UniqueString, ImVec2(ImGui::GetContentRegionAvailWidth() - 2.0f, iThumbSize.y+38.0f), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
						ImGui::SetWindowFontScale(1.8);
						ImVec4 textcol = ImGui::GetStyleColorVec4(ImGuiCol_Button);
						textcol.w = 1.0;
						ImGui::PushStyleColor(ImGuiCol_Text, textcol);
						ImGui::Text(sDisplayName.Get());
						ImGui::PopStyleColor();
						//ImGui::Separator();
						ImGui::SetWindowFontScale(1.2);
						if (bUseFullScreen) ImGui::SetWindowFontScale(1.5);
						ImGui::TextWrapped(g_LibraryFileList[n].cDescription.Get());
						ImGui::SetWindowFontScale(1.0);
						ImGui::EndChild();
					}
					ImGui::NextColumn();
				}
			}
		}
		ImGui::Columns(1);
	}
	ImGui::Indent(-2);
	ImGui::EndChild();
	return sReturnComboName;
}

cstr ListboxFilesListForWelcomeScreen_v2(char *currentselection, int columns, int iFixedWidth, bool bRemoveExtension, bool bIncludeNone, char *filter, float fbox_height, bool bDisplayDesc, bool bUseFullScreen)
{
	cstr sReturnComboName = currentselection;
	if (columns <= 0) columns = 2; //Default to 2.
	if (bDisplayDesc) columns++;

	float fImageWidth = (ImGui::GetContentRegionAvailWidth() - 10.0f - 18.0f) / columns; //ImGui::GetCurrentWindow()->ScrollbarSizes.x
	if (iFixedWidth > 0)
		fImageWidth = iFixedWidth;
	fImageWidth -= 5.0f;
	fImageWidth -= 6.0f; //Due to now using Columns add spacing.

	float fImageRatio = fImageWidth / 512.0f;

	float box_height = (((float)288.0*fImageRatio) * 5.0) + 10.0f;
	box_height += ImGui::GetFontSize() * 8.0;
	if (fbox_height > 0) box_height = fbox_height;

	//ImGui::BeginChild("##ListboxFilesListForWelcome", ImVec2(ImGui::GetContentRegionAvail().x - 4.0, box_height), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
	ImGui::BeginChild("##ListboxFilesListForWelcome", ImVec2(ImGui::GetContentRegionAvail().x - 2.0, box_height), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
	ImGui::Indent(2);
	if (1)
	{
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 3));
		bool is_selected = false;
		float total_width = ImGui::GetContentRegionAvailWidth();
		ImGui::Columns(columns, "ListboxFilesListForWelcomecolumns", false);  //false no border

		if (bDisplayDesc)
		{
			ImGui::SetColumnOffset(0, 0.0f);
			ImGui::SetColumnOffset(1, total_width * 0.34); //Right 60% size.
			fImageRatio = (ImGui::GetContentRegionAvailWidth() - 2.0f) / 512.0f;
		}

		int columns_count = 0;
		for (int n = 0; n < g_LibraryFileList.size(); n++) // Display max 12 games.
		{
			int TextureID = WELCOME_FILLERROUNDED;
			cStr sName = "";
			ImVec4 alpha = { 1.0f,1.0f,1.0f,0.15f };

			if (n < g_LibraryFileList.size())
			{
				if (g_LibraryFileList[n].iImage > 0 && ImageExist(g_LibraryFileList[n].iImage))
				{
					TextureID = g_LibraryFileList[n].iImage;
				}
				sName = g_LibraryFileList[n].cName;
				alpha = { 1.0f,1.0f,1.0f,1.0f };
			}


			is_selected = (sReturnComboName == sName);

			cstr sDisplayName = sName;
			if (bRemoveExtension && n < g_LibraryFileList.size())
			{
				char *find = (char *)pestrcasestr(sDisplayName.Get(), ".");
				if (find)
				{
					int iPos = find - sDisplayName.Get();
					if (iPos > 0 && iPos < 1024)
						sDisplayName = Left(sDisplayName.Get(), iPos);
				}
			}
			bool bVisible = true;
			if (filter && n < g_LibraryFileList.size())
			{
				bVisible = false;
				cstr sfilter = filter;
				char *p = strtok(sfilter.Get(), ",");
				while (p)
				{
					if (p[0] == '*')
						bVisible = true;
					else if (pestrcasestr(g_LibraryFileList[n].cName.Get(), p))
						bVisible = true;
					p = strtok(NULL, ",");
				}
			}
			if (bVisible)
			{
				ImVec2 iThumbSize = { (float)512.0*fImageRatio, (float)288.0*fImageRatio };
				if (is_selected)
				{
					ImGuiWindow* window = ImGui::GetCurrentWindow();
					ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
					ImVec2 padding = { 1.0, 1.0 };
					const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + iThumbSize);
					window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
				}

				ImGuiWindow* window = ImGui::GetCurrentWindow();
				ImRect image_bb(window->DC.CursorPos, window->DC.CursorPos + iThumbSize);
				ImVec2 vTopLeftCorner = ImGui::GetCursorPos();

				if (ImGui::ImgBtn(TextureID, iThumbSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255)*alpha, ImColor(255, 255, 255, 200)*alpha, ImColor(255, 255, 255, 200)*alpha, 0, 0, 0, 0, false, false, false))
				{
					if (n < g_LibraryFileList.size())
						sReturnComboName = g_LibraryFileList[n].cName;
				}

				// add not available image over thumb if project not exist
				extern bool g_bFreeTrialVersion;
				if (g_bFreeTrialVersion == true)
				{
					if (g_LibraryFileList[n].bProjectExists == false)
					{
						// place grey layer on thumb to show object not available
						ImVec2 vOldPos = ImGui::GetCursorPos();
						ImGui::SetCursorPos(vTopLeftCorner);
						ImGui::SetItemAllowOverlap();
						ImGui::ImgBtn(FREETRIAL_NOTAVAILABLE, iThumbSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors);
						ImGui::SetCursorPos(vOldPos);
					}
				}

				if (ImGui::IsItemHovered())
				{
					if (ImGui::IsMouseDoubleClicked(0))
					{
						if (n < g_LibraryFileList.size())
						{
							sReturnComboName = g_LibraryFileList[n].cName;
							bTriggerEditDemoGame = true;

							if (iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID)) {
								bRemoveVideoInNextFrame = true;
							}
						}
					}
				}
				static int triggerEndVideo = 0;
				if (n < g_LibraryFileList.size() && ImGui::IsItemHovered() && g_LibraryFileList[n].timer++ > 50)
				{
					if (iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID))
					{
						float fVideoW = 0;
						float fVideoH = 0;
						float animU = 1.0;
						float animV = 1.0;
						void* lpVideoTexture = NULL;
						lpVideoTexture = GetAnimPointerTexture(iWelcomeVideoID);
						if (lpVideoTexture != NULL)
						{
							fVideoW = GetAnimWidth(iWelcomeVideoID);
							fVideoH = GetAnimHeight(iWelcomeVideoID);
							SetRenderAnimToImage(iWelcomeVideoID, true);
							animU = GetAnimU(iWelcomeVideoID);
							animV = GetAnimV(iWelcomeVideoID);
							ImVec2 uv0 = ImVec2(0, 0);
							ImVec2 uv1 = ImVec2(animU, animV);
							window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));
						}

						float fdone = GetAnimPercentDone(iWelcomeVideoID) / 100.0f;
						if (fdone > 0.5)
							triggerEndVideo = 1;
						if (triggerEndVideo > 0 && (fdone == 0.0f || fdone >= 1.0f))
						{
							//End loop.
							//PE: Loop dont work, at some point the player breaks and flicker, just restart everyting.
							//void SetVideoPositionPlay(float seconds);
							//SetVideoPositionPlay(0.0);
							//ResumeAnim(iWelcomeVideoID);
							//Try stopping and starting.
							//StopAnimation(iWelcomeVideoID);
							//PlaceAnimation(iWelcomeVideoID, -1, -1, -1, -1);
							//SetRenderAnimToImage(iWelcomeVideoID, true);
							//PlayAnimation(iWelcomeVideoID);
							//SetVideoVolume(100);
							g_LibraryFileList[n].timer = 0;
							bRemoveVideoInNextFrame = true;
							triggerEndVideo = 0;
						}
					}
					else
					{
						//Load video.
						std::string sVideoFile = g_LibraryFileList[n].cFile.Get();
						replaceAll(sVideoFile, ".png", ".mp4");
						if (FileExist((LPSTR)sVideoFile.c_str()))
						{
							iWelcomeVideoID = 0;
							for (int i = 1; i <= 32; i++)
							{
								if (AnimationExist(i) == 0) { iWelcomeVideoID = i; break; }
							}

							if (iWelcomeVideoID > 0)
							{
								if (LoadAnimation((LPSTR)sVideoFile.c_str(), iWelcomeVideoID, g.videoprecacheframes, g.videodelayedload, 1) == false)
								{
									iWelcomeVideoID = -999;
								}
								if (iWelcomeVideoID > 0)
								{
									PlaceAnimation(iWelcomeVideoID, -1, -1, -1, -1);
									SetRenderAnimToImage(iWelcomeVideoID, true);
									PlayAnimation(iWelcomeVideoID);
									SetVideoVolume(100);
								}
							}
						}
						else
						{
							g_LibraryFileList[n].timer = 0; //Failed.
							triggerEndVideo = 0;
						}
					}
				}
				else
				{
					if (n < g_LibraryFileList.size() && !ImGui::IsItemHovered())
					{
						if (g_LibraryFileList[n].timer > 0 && iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID)) {
							bRemoveVideoInNextFrame = true;
							triggerEndVideo = 0;
						}
						g_LibraryFileList[n].timer = 0;
					}
				}

				if(1)
				{
					if (n < g_LibraryFileList.size())
					{
						ImGui::SetWindowFontScale(1.4);
						char UniqueString[256];
						ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 1.0f, 1.00f));
						if (g_LibraryFileList[n].iType == 2)
						{
							ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.0f, 0.0f, 1.00f));
							ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.6f, 0.0f, 0.0f, 0.75f));
							ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.6f, 0.0f, 0.0f, 1.00f));
							//sprintf(UniqueString, "Design Complexity: Developer##%d", n);
							sprintf(UniqueString, "Design Complexity: Developer");
						}
						else if (g_LibraryFileList[n].iType == 1)
						{
							ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.7f, 0.0f, 1.00f));
							ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.8f, 0.7f, 0.0f, 0.75f));
							ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.8f, 0.7f, 0.0f, 1.00f));
							//sprintf(UniqueString, "Design Complexity: Advanced##%d", n);
							sprintf(UniqueString, "Design Complexity: Advanced");
						}
						else
						{
							ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.0f, 0.6f, 0.0f, 1.00f));
							ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.0f, 0.6f, 0.0f, 0.75f));
							ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.0f, 0.6f, 0.0f, 1.00f));
							//sprintf(UniqueString, "Design Complexity: Standard##%d", n);
							sprintf(UniqueString, "Design Complexity: Standard");
						}

						if (ImGui::StyleButton(sDisplayName.Get(), ImVec2(iThumbSize.x, 0.0f)))
						{
							//Select Game
							if (n < g_LibraryFileList.size())
								sReturnComboName = g_LibraryFileList[n].cName;
						}
						if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", UniqueString);

						ImGui::PopStyleColor(4);

						ImGui::SetWindowFontScale(1.0);
					}
				}

				ImGui::NextColumn();
				if (is_selected) ImGui::SetItemDefaultFocus();

				if (bDisplayDesc)
				{
					if (n < g_LibraryFileList.size())
					{
						//Overlay rating.
						char UniqueString[256];
						sprintf(UniqueString, "##ListboxFilesDescriptionBox%d", n);
						ImGui::BeginChild(UniqueString, ImVec2(ImGui::GetContentRegionAvailWidth() - 2.0f, iThumbSize.y + 38.0f), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
						ImGui::SetWindowFontScale(1.8);
						ImVec4 textcol = ImGui::GetStyleColorVec4(ImGuiCol_Button);
						textcol.w = 1.0;
						ImGui::PushStyleColor(ImGuiCol_Text, textcol);
						ImGui::Text(sDisplayName.Get());
						ImGui::PopStyleColor();
						//ImGui::Separator();
						ImGui::SetWindowFontScale(1.2);
						if (bUseFullScreen) ImGui::SetWindowFontScale(1.5);
						ImGui::TextWrapped(g_LibraryFileList[n].cDescription.Get());
						ImGui::SetWindowFontScale(1.0);
						ImGui::EndChild();
					}
					ImGui::NextColumn();
				}
			}
		}
		ImGui::Columns(1);
	}
	ImGui::Indent(-2);
	ImGui::EndChild();
	return sReturnComboName;
}
#ifdef WICKEDENGINE
struct ProjectSortData
{
	std::string writeDate;
	std::string folderName;
	//int imageID;
	//std::string imageName;
};

// Compare two ProjectSortData by date.
bool CompareFileDates(const ProjectSortData& file0, const ProjectSortData& file1)
{
	if (file0.writeDate.compare(file1.writeDate) > 0) return true; // date2 comes before date1 (change required)

	return false; // date1 comes before date2 or they are the same (no change required)
}
// Compare two ProjectSortData by name.
bool CompareFileNames(const ProjectSortData& file0, const ProjectSortData& file1)
{
	cstr a ((char*)file0.folderName.c_str());
	cstr b ((char*)file1.folderName.c_str());

	if (strcmp(a.Lower().Get(), b.Lower().Get()) < 0) return true;

	return false;
}

// Fill in Project Sort Data so it can be sorted by write time later.
void GetProjectSortData (std::vector<ProjectSortData>& output)
{
	LPSTR pOldDir = GetDir();

	char destination[MAX_PATH];
	strcpy(destination, "projectbank\\");
	GG_GetRealPath(destination, 1); // Get actual path to write folder.

	SetDir(destination);
	ChecklistForFiles();
	SetDir(pOldDir);
	for (int c = 1; c <= ChecklistQuantity(); c++)
	{
		if (ChecklistValueA(c) != 0)
		{
			// only folders
			cstr folder = ChecklistString(c);
			if (folder != "." && folder != "..")
			{
				char project[MAX_PATH];
				strcpy(project, destination);
				strcat(project, folder.Get());
				strcat(project, "\\project.dat");

				ProjectSortData data;
				data.folderName = std::string(folder.Get());
				wchar_t filePath[MAX_PATH];
				MultiByteToWideChar(CP_UTF8, 0, &project[0], -1, filePath, MAX_PATH);

				HANDLE hFile = CreateFile(filePath, GENERIC_READ, FILE_SHARE_READ, NULL,
					OPEN_EXISTING, 0, NULL);

				if (hFile != INVALID_HANDLE_VALUE)
				{
					// Get the last write time for this file.

					FILETIME ftCreate, ftAccess, ftWrite;
					SYSTEMTIME stUTC, stLocal;

					// Retrieve the file times for the file.
					if (GetFileTime(hFile, &ftCreate, &ftAccess, &ftWrite))
					{
						TCHAR wWriteTime[MAX_PATH];

						// Convert the last-write time to local time.
						FileTimeToSystemTime(&ftWrite, &stUTC);
						SystemTimeToTzSpecificLocalTime(NULL, &stUTC, &stLocal);

						// Build a string showing the date and time.
						StringCchPrintf(wWriteTime, MAX_PATH,
							TEXT("%02d/%02d/%d  %02d:%02d:%02d"),
							stLocal.wMonth, stLocal.wDay, stLocal.wYear,
							stLocal.wHour, stLocal.wMinute, stLocal.wSecond);

						// Convert from wide char.
						char writeTime[MAX_PATH];
						WideCharToMultiByte(CP_UTF8, 0, &wWriteTime[0], MAX_PATH, &writeTime[0], MAX_PATH, NULL, NULL); 
						data.writeDate = std::string(writeTime);
						output.push_back(data);
					}
				}

				CloseHandle(hFile);					
			}
		}
	}
	SetDir(pOldDir);
}

void SortProjects(int iProjectSortMode)
{
	if (projectbank_list.size() == 0)
		return;

	std::vector<ProjectSortData> sortData;
	GetProjectSortData(sortData);

	//// Attach image IDs to the project data so its new order can be determined.
	//for (int i = 0; i < sortData.size(); i++)
	//{
	//	//sortData[i].imageID = projectbank_imageid[i];
	//	//sortData[i].imageName = projectbank_image[i];
	//}
	//projectbank_imageid.clear();
	//projectbank_image.clear();
	
	// Perform the sort.
	switch (iProjectSortMode)
	{
	case 0: // Newest
	{
		std::sort(sortData.begin(), sortData.end(), CompareFileDates);
		break;
	}
	case 1: // Oldest
	{
		std::sort(sortData.begin(), sortData.end(), CompareFileDates);
		std::reverse(sortData.begin(), sortData.end());
		break;
	}
	case 2: // A-Z
	{
		std::sort(sortData.begin(), sortData.end(), CompareFileNames);
		break;
	}
	case 3: // Z-A
	{
		std::sort(sortData.begin(), sortData.end(), CompareFileNames);
		std::reverse(sortData.begin(), sortData.end());
		break;
	}
	}

	// Set the new order of project names.
	projectbank_list.clear();
	//projectbank_list_exist.clear();
	for (int i = 0; i < sortData.size(); i++)
	{
		projectbank_list.push_back(sortData[i].folderName);
		projectbank_imageid[i] = 0;
	}
}

void GetProjectThumbnails()
{
	projectbank_image.clear();
	projectbank_imageid.resize(projectbank_list.size());
	
	for (int i = 0; i < projectbank_list.size(); i++)
	{
		if (!pestrcasestr((char *)projectbank_list[i].c_str(), "_backup_"))
		{
			char project[MAX_PATH];
			strcpy(project, "projectbank\\");
			strcat(project, projectbank_list[i].c_str());
			strcat(project, "\\project.dat");

			FILE* projectfile = GG_fopen(project, "rb");
			if (projectfile)
			{
				//size_t size = fread(&smallcheckproject, 1, sizeof(smallcheckproject), projectfile);
				//PE: Need full load now, as we can have Game Settings.
				size_t size = fread(&checkproject, 1, sizeof(checkproject), projectfile);

				char sig[12] = "Storyboard\0";
				if (checkproject.sig[0] == 'S' && checkproject.sig[8] == 'r')
				{
					cstr bestfound = "";
					//Valid Sig - Cleanup old project.
					if (strlen(checkproject.game_thumb) > 0 && FileExist(checkproject.game_thumb))
					{
						bestfound = checkproject.game_thumb;
					}
					else
					{
						for (int i = 0; i < STORYBOARD_MAXNODES; i++) //SMALL_STORYBOARD_MAXNODES
						{
							if (checkproject.Nodes[i].used)
							{
								if (checkproject.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
								{
									//Splash if no level found.
									if (bestfound == "")
									{
										if (!pestrcasestr(checkproject.Nodes[i].thumb, "editors\\uiv3\\"))
										{
											//custom use.
											bestfound = checkproject.Nodes[i].thumb;
										}
									}
								}
								if (checkproject.Nodes[i].type == STORYBOARD_TYPE_SCREEN)
								{
									if (pestrcasestr(checkproject.Nodes[i].title, "title screen"))
									{
										//Splash if no level found.
										if (!pestrcasestr(checkproject.Nodes[i].thumb, "editors\\templates\\"))
										{
											//custom use.
											bestfound = checkproject.Nodes[i].thumb;
										}
									}
								}
								//PE: Try finding level that loading.lua is pointing to ?
								if (checkproject.Nodes[i].type == STORYBOARD_TYPE_LEVEL)
								{
									if (strlen(checkproject.Nodes[i].level_name) > 0)
									{
										CreateBackBufferCacheName(checkproject.Nodes[i].level_name, 512, 288);
										if (CreateProjectCacheName(checkproject.gamename, BackBufferCacheName.Get()) &&
											FileExist(ProjectCacheName.Get()))
										{
											bestfound = ProjectCacheName.Get();
											break;
										}
										else if (FileExist(BackBufferCacheName.Get()))
										{
											bestfound = BackBufferCacheName.Get();
											break;
										}
									}
								}

							}
						}
					}
					projectbank_image.push_back(bestfound.Get());
				}
				else
				{
					projectbank_image.push_back(""); //Just use CLICK HERE.
				}
				fclose(projectfile);
			}
			else
			{
				//PE: Was missing if not found. https://github.com/TheGameCreators/GameGuruRepo/issues/1722
				projectbank_image.push_back(""); //Just use CLICK HERE.
			}
		}
		else
		{
			projectbank_image.push_back(""); //Backup just use CLICK HERE.
		}
	}
}
#endif

void Welcome_Screen(void)
{
	bool bDisplayAsModal = false; //true;
	bool bStopVideo = false;
	bool bAutoPlayVideo = true;

	static bool bIntroScreenDone = false;
	static bool bResizeWelcome = false;
	static bool bCheckIntroScreenDone = true;

	extern bool bSpecialEditorFromStandalone;
	
	if (bCheckIntroScreenDone)
	{
		extern bool bSpecialStandalone;
		if (!pref.iDisplayIntroScreen || bSpecialStandalone)
		{
			bIntroScreenDone = true;
		}
		bCheckIntroScreenDone = false;

		#ifdef WICKEDENGINE
		void CheckForNewUpdateWicked(void);
		CheckForNewUpdateWicked(); //PE: Check if update process is done, and ask if user like to update.
		#endif
	}

	if (bRemoveVideoInNextFrame)
	{
		if (iWelcomeVideoID > 0) {
			if (AnimationExist(iWelcomeVideoID))
			{
				if (AnimationPlaying(iWelcomeVideoID))
					StopAnimation(iWelcomeVideoID);
				DeleteAnimation(iWelcomeVideoID);
				iWelcomeVideoID = 0;
			}
		}
		bRemoveVideoInNextFrame = false;
	}
	#ifdef WICKEDENGINE
	extern bool bEnsureIntroVideoIsNotRun;
	if (!bIntroScreenDone && !bSpecialEditorFromStandalone && bEnsureIntroVideoIsNotRun==false)
	#else
	if (!bIntroScreenDone)
	#endif // WICKEDENGINE
	{
		//bDisplayAsModal = false;

		//##################################
		//#### New welcome page for EA. ####
		//##################################

		ImGuiViewport* viewport = ImGui::GetMainViewport();

		// Window Size control
		ImVec2 WindowSize = ImVec2(54 * ImGui::GetFontSize(), 50 * ImGui::GetFontSize());
		if (viewport->Size.x < 1900)
		{
			//PE: Reduce size on smaller screens.
			//WindowSize = ImVec2(32 * ImGui::GetFontSize(), 34 * ImGui::GetFontSize()); was too thin on my NUC test PC, a little wider will be nice
			WindowSize = ImVec2(42 * ImGui::GetFontSize(), 34 * ImGui::GetFontSize());
		}

		if (refresh_gui_docking == 0)
		{
			// large blank dummy screen
			if (!bDisplayAsModal)
			{
				ImGui::SetNextWindowViewport(viewport->ID);
				ImGui::SetNextWindowSize(viewport->Size, ImGuiCond_Always);
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				ImGui::Begin("##DummyWelcome Screen##WelcomeScreenWindow", &bWelcomeScreen_Window, ImGuiWindowFlags_None | ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoChangeZOrder | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoNavFocus | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
				ImGui::End();
			}

			// regular window for welcome screen
			ImGui::SetNextWindowViewport(viewport->ID);
			ImGui::SetNextWindowSize(WindowSize, ImGuiCond_Always);
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bool bTmp = true;
			ImGui::Begin("Welcome Screen##WelcomeScreenWindow", &bTmp, 0);
			ImGui::End();
		}
		else if (bWelcomeScreen_Window)
		{
			//PE: Hide everything in the background (wicked 3D stuff).
			ImGuiWindow* toolbarwindow = ImGui::FindWindowByName("Toolbar");
			ImVec4 monitor_col = ImVec4(0, 0, 0, 1.0);
			if (!bDisplayAsModal && toolbarwindow && toolbarwindow->DrawList)
			{
				toolbarwindow->DrawList->PushClipRect(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(0, 40), true);
				ImGuiWindow* stastuswindow = ImGui::FindWindowByName("Statusbar");
				monitor_col = ImGui::GetStyle().Colors[ImGuiCol_WindowBg] * ImVec4(0.8, 0.8, 0.8, 0.8);
				monitor_col.w = 1.0;
				toolbarwindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 40), ImGui::GetColorU32(monitor_col));
				if (stastuswindow && stastuswindow->DrawList) stastuswindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 40), ImGui::GetColorU32(monitor_col));
				toolbarwindow->DrawList->PopClipRect();
				monitor_col = ImVec4(0, 0, 0, 1.0);
			}
			else
			{
				if (toolbarwindow) toolbarwindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 1), ImGui::GetColorU32(monitor_col));
			}
			static int iHideWindowForFrames = 8;
			if (iHideWindowForFrames > 0)
			{
				iHideWindowForFrames--;
				return;
			}
			if (gbWelcomeSystemActive)
			{
				return;
			}

			// welcome screen window
			if (bDisplayAsModal)
			{
				ImGui::OpenPopup("Welcome Screen##WelcomeScreenWindowModal");
			}
			if (!bDisplayAsModal)
			{
				ImGui::SetNextWindowViewport(viewport->ID);
				ImGui::SetNextWindowSize(viewport->Size, ImGuiCond_Always);
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				ImGui::Begin("##DummyWelcome Screen##WelcomeScreenWindow", &bWelcomeScreen_Window, ImGuiWindowFlags_None | ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoChangeZOrder | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoNavFocus | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
				ImGui::End();
			}

			// set the window size
			ImGui::SetNextWindowViewport(viewport->ID);
			ImGui::SetNextWindowSize(WindowSize, ImGuiCond_Once);

			/* this does not seem to do anything, already set the correct window size above and this code is skipped after initial 'bad' window sizes
			static int iWelcomeStateChanged = -1; //Always trigger on first.
			if (iWelcomeStateChanged != bWelcomeVideoMaximized)
			{
				if (bWelcomeVideoMaximized)
				{
					ImGui::SetNextWindowSize(WindowSize * ImVec2(1.8, 1.3), ImGuiCond_Always);
				}
				else
				{
					//ImGui::SetNextWindowSize(WindowSize, ImGuiCond_Always);
					ImGui::SetNextWindowSize(WindowSize * ImVec2(1.6, 1.3), ImGuiCond_Always);
				}
				iWelcomeStateChanged = bWelcomeVideoMaximized;
			}
			*/

			// by always centering the window, we ensure the intro video stays in the middle
			//if (bDisplayAsModal)
			//	ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			//else
			//	ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);

			if (bDisplayAsModal)
				ImGui::BeginPopupModal("Welcome Screen##WelcomeScreenWindowModal", &bWelcomeScreen_Window, ImGuiWindowFlags_None | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
			else
				ImGui::Begin("Welcome Screen##WelcomeScreenWindow", &bWelcomeScreen_Window, ImGuiWindowFlags_None | ImGuiWindowFlags_NoMove  | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);


			ImGui::Indent(10);

			//if (!bWelcomeVideoMaximized) maximise disabled for EA
			{
				//PE: Now in both modes, so can close welcome and it will load last used project.
				if ( g_iDevToolsOpen >= 2) //PE: Rick - never a back but - !bWelcomeNoBackButton ||
				{
					ImVec2 vCurPos = ImGui::GetCursorPos();
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 6.0f));
					float fFontSize = ImGui::GetFontSize();
					int icon_size = ImGui::GetFontSize()*3.0;
					ImVec2 VIconSize = { (float)icon_size, (float)icon_size };
					if (ImGui::ImgBtn(TOOL_GOBACK, VIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
					{
						bIntroScreenDone = true;
						bResizeWelcome = true;
						bStopVideo = true;

						//PE: New default to object mode.
						bForceKey = true;
						csForceKey = "o";

						//bWelcomeScreen_Window = false;
					}
					if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Close");
					ImGui::SetCursorPos(vCurPos);
				}

				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 6.0f));
				ImGui::Text("");
				ImGui::SetWindowFontScale(2.2);
				ImGui::TextCenter("WELCOME TO GAMEGURU MAX!");
				ImGui::SetWindowFontScale(1.4);
				ImGui::TextCenter("GameGuru MAX is still in development - this is an Early Access version");
				ImGui::TextCenter("Regular updates will be released until we reach full release.");
				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");
				ImGui::Separator();
			}
			ImGui::Text("");

			//################
			//#### Video. ####
			//################
			ImGui::Indent(10);

			static bool bWelcomeVideoInit = false;
			static int iWelcomeFindFirstFrame = 0;
			static bool bWelcomeResumePossible = false;
			static bool bWelcomeVideoPerccentStart = false;
			static int iWelcomeVideoDelayExecute = 0;

			cstr sWelcomeVideoFile = "tutorialbank\\9901-introduction-video.mp4";

			ImVec4 oldImGuiCol_ChildWindowBg = ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg];
			{
				bool bInit = false;

				switch (iWelcomeVideoDelayExecute)
				{
				case 1: //Play restart
				{
					iWelcomeVideoDelayExecute = 0;
					StopAnimation(iWelcomeVideoID);
					PlayAnimation(iWelcomeVideoID);
					SetRenderAnimToImage(iWelcomeVideoID, true);
					UpdateAllAnimation();
					Sleep(50); //Sleep so we get a video texture in the next call.
					UpdateAllAnimation();
					SetVideoVolume(100.0);
					bWelcomeResumePossible = false;
					break;
				}
				case 2: //Resume
				{
					iWelcomeVideoDelayExecute = 0;
					ResumeAnim(iWelcomeVideoID);
					break;
				}
				case 3: //Pause
				{
					iWelcomeVideoDelayExecute = 0;
					PauseAnim(iWelcomeVideoID);
					bWelcomeResumePossible = true;
					break;
				}
				default:
					break;
				}

				if (iWelcomeFindFirstFrame > 0)
				{
					SetVideoVolume(0.1);
					if (iWelcomeFindFirstFrame == 2)
					{
						PauseAnim(iWelcomeVideoID);
						bWelcomeResumePossible = false;
					}
					//PE: Set back volume delayed or we hear a small amount of noise.
					if (iWelcomeFindFirstFrame == 1)
					{
						SetVideoVolume(100.0);
					}
					iWelcomeFindFirstFrame--;
				}

				if (iWelcomeVideoID > 0)
				{
					if (!AnimationExist(iWelcomeVideoID))
					{
						bInit = true;
					}
				}

				if (!bWelcomeVideoInit || bInit)
				{
					if (iWelcomeVideoID > 0)
					{
						if (AnimationExist(iWelcomeVideoID))
						{
							if (AnimationPlaying(iWelcomeVideoID))
								StopAnimation(iWelcomeVideoID);

							DeleteAnimation(iWelcomeVideoID);
							iWelcomeVideoID = 0;
						}
					}

					iWelcomeVideoID = 0;
					t.text_s = Lower(Right(sWelcomeVideoFile.Get(), 4));
					if (t.text_s == ".ogv" || t.text_s == ".mp4")
					{
						//PE: Use first available.
						iWelcomeVideoID = 32;
						for (int i = 1; i <= 32; i++)
						{
							if (AnimationExist(i) == 0) { iWelcomeVideoID = i; break; }
						}
						if (LoadAnimation(sWelcomeVideoFile.Get(), iWelcomeVideoID, g.videoprecacheframes, g.videodelayedload, 1) == false)
						{
							iWelcomeVideoID = -999;
						}
					}
					if (iWelcomeVideoID > 0)
					{
						if (bAutoPlayVideo)
						{
							bWelcomeVideoPerccentStart = true;
							iWelcomeVideoDelayExecute = 1;
						}
					}
					bWelcomeVideoInit = true;
				}

				float fRatio = 1.0f / ((float)GetDesktopWidth() / (float)GetDesktopHeight());

				float fVideoW = 0;
				float fVideoH = 0;
				float animU = 1.0;
				float animV = 1.0;
				void* lpVideoTexture = NULL;
				if (!(iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID) && AnimationPlaying(iWelcomeVideoID)))
				{
					bool bLogo = true;
					if (bWelcomeResumePossible)
					{
						lpVideoTexture = GetAnimPointerTexture(iWelcomeVideoID);
						if (lpVideoTexture != NULL)
						{
							fVideoW = GetAnimWidth(iWelcomeVideoID);
							fVideoH = GetAnimHeight(iWelcomeVideoID);
							SetRenderAnimToImage(iWelcomeVideoID, true);
							animU = GetAnimU(iWelcomeVideoID);
							animV = GetAnimV(iWelcomeVideoID);
							bLogo = false;
						}
					}
					if (bLogo)
					{
						lpVideoTexture = GetImagePointer(WELCOME_VIDEO);
						fVideoW = ImageWidth(WELCOME_VIDEO);
						fVideoH = ImageHeight(WELCOME_VIDEO);
					}
				}
				else
				{
					lpVideoTexture = GetAnimPointerTexture(iWelcomeVideoID);
					if (lpVideoTexture == NULL)
					{
						lpVideoTexture = GetImagePointer(WELCOME_VIDEO);
						fVideoW = ImageWidth(WELCOME_VIDEO);
						fVideoH = ImageHeight(WELCOME_VIDEO);
					}
					else
					{
						fVideoW = GetAnimWidth(iWelcomeVideoID);
						fVideoH = GetAnimHeight(iWelcomeVideoID);
						SetRenderAnimToImage(iWelcomeVideoID, true);
						animU = GetAnimU(iWelcomeVideoID);
						animV = GetAnimV(iWelcomeVideoID);
					}
				}
				if (bWelcomeVideoInit && iWelcomeVideoID > 0 && lpVideoTexture)
				{
					fRatio = 1.0f / (fVideoW / fVideoH);
				}

				float videoboxheight = (ImGui::GetContentRegionAvail().x - 20.0) * fRatio;

				oldImGuiCol_ChildWindowBg = ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg];
				ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg] = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
				ImGui::BeginChild("Welcome Video##WelcomeVideo", ImVec2(ImGui::GetContentRegionAvail().x - 20.0, videoboxheight), true, iGenralWindowsFlags);
				ImGuiWindow* window = ImGui::GetCurrentWindow();
				ImRect image_bb(window->DC.CursorPos, window->DC.CursorPos + ImGui::GetContentRegionAvail());
				if (lpVideoTexture) {
					ImVec2 uv0 = ImVec2(0, 0);
					ImVec2 uv1 = ImVec2(animU, animV);
					window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));
				}

				if (!(iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID) && AnimationPlaying(iWelcomeVideoID)))
				{
					//Display a play button.
					ImVec2 vOldPos = ImGui::GetCursorPos();
					float fPlayButSize = ImGui::GetContentRegionAvail().x * 0.10;
					float fCenterX = (ImGui::GetContentRegionAvail().x*0.5) - (fPlayButSize*0.5);
					float fCenterY = (videoboxheight*0.5) - (fPlayButSize*0.5);
					ImGui::SetCursorPos(ImVec2(fCenterX, fCenterY));
					ImVec4 vColorFade = { 1.0,1.0,1.0,0.5 };
					if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(fPlayButSize, fPlayButSize), ImColor(255, 255, 255, 0), drawCol_normal*vColorFade, drawCol_hover*vColorFade, drawCol_Down*vColorFade, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
					{
						bWelcomeVideoPerccentStart = true;
						if (bWelcomeResumePossible)
						{
							iWelcomeVideoDelayExecute = 2; //resume
						}
						else
						{
							iWelcomeVideoDelayExecute = 1; //play - restart.
						}
					}
					if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Play");

					ImGui::SetCursorPos(vOldPos);
				}

				/* disable double click to maximise for EA
				if (ImGui::IsMouseHoveringRect(image_bb.Min, image_bb.Max))
				{
					if (ImGui::IsMouseDoubleClicked(0))
					{
						bWelcomeVideoMaximized = 1 - bWelcomeVideoMaximized;
					}
				}
				*/

				ImGui::EndChild();
				ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg] = oldImGuiCol_ChildWindowBg;

				if (iWelcomeVideoID > 0)
				{
					if (AnimationExist(iWelcomeVideoID))
					{
						//ImGui::SameLine();
						float fdone = GetAnimPercentDone(iWelcomeVideoID) / 100.0f;
						if (!bWelcomeVideoPerccentStart) fdone = 0.0f;

						static int triggerEndVideo = 0;
						if (fdone > 0.5)
							triggerEndVideo = 1;
						if (bAutoPlayVideo && triggerEndVideo > 0 && (fdone == 0.0f || fdone >= 1.0f))
						{
							//Auto close and goto welcome screen.
							bIntroScreenDone = true;
							bResizeWelcome = true;
							bStopVideo = true;
						}
						//ImGui::ProgressBar(fdone, ImVec2(ImGui::GetContentRegionAvail().x - 20, 6), "");
						ImVec2 rstart = ImGui::GetWindowPos() + ImGui::GetCursorPos();
						ImGui::ProgressBar(fdone, ImVec2(ImGui::GetContentRegionAvail().x - 20, 8), "");
						ImVec2 rend = ImGui::GetWindowPos() + ImGui::GetCursorPos() + ImVec2(ImGui::GetContentRegionAvail().x - 20.0,0.0);
						if(ImGui::IsMouseClicked(0) && ImGui::IsMouseHoveringRect(rstart, rend))
						{
							float GetVideoDuration();
							void SetVideoPositionPause(float seconds);
							void SetVideoPositionPlay(float seconds);

							ImVec2 mpos = ImGui::GetMousePos() - rstart;
							ImVec2 rwidth = rend - rstart;
							float percent = 100.0 / (rwidth.x / mpos.x);
							float videolength = GetVideoDuration();
							float vpercent = videolength / 100.0f;
							SetVideoPositionPlay( (vpercent * percent) * 0.95 ); //PE: Make it a bit lower as this is thread running so before actual pause there is a little playing.
							ResumeAnim(iWelcomeVideoID);
							bWelcomeResumePossible = false;
							triggerEndVideo = 0;
						}
						#define MEDIAICONSIZE 20

						if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
						{
							bWelcomeVideoPerccentStart = true;
							if (bWelcomeResumePossible)
							{
								iWelcomeVideoDelayExecute = 2; //resume
							}
							else
							{
								iWelcomeVideoDelayExecute = 1; //play - restart.
							}
						}
						if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Play");
						ImGui::SameLine();
						if (ImGui::ImgBtn(MEDIA_PAUSE, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
						{
							iWelcomeVideoDelayExecute = 3; // pause
						}
						if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Pause");
						ImGui::SameLine();
						if (ImGui::ImgBtn(MEDIA_REFRESH, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
						{
							bWelcomeVideoPerccentStart = true;
							iWelcomeVideoDelayExecute = 1; //play - restart.
						}
						if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Restart");

						/* disable min/ax button to keep intro video simple
						if (!bWelcomeVideoMaximized)
						{
							ImGui::SameLine();
							ImGui::SetCursorPos(ImVec2((ImGui::GetCursorPosX() + ImGui::GetContentRegionAvail().x) - 40.0, ImGui::GetCursorPosY()));
							if (ImGui::ImgBtn(MEDIA_MAXIMIZE, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true, false, false, false, false, bBoostIconColors))
							{
								bWelcomeVideoMaximized = true;
							}
							if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Maximize");
						}
						else
						{
							ImGui::SameLine();
							ImGui::SetCursorPos(ImVec2((ImGui::GetCursorPosX() + ImGui::GetContentRegionAvail().x) - 40.0, ImGui::GetCursorPosY()));
							if (ImGui::ImgBtn(MEDIA_MINIMIZE, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true, false, false, false, false, bBoostIconColors))
							{
								bWelcomeVideoMaximized = false;
							}
							if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Minimize");
						}
						*/
					}
				}
			}
			ImGui::Indent(-10);

			//#################
			//#### Buttons ####
			//#################
			/* button removed in design, perhaps add to welcome screen ?
			
			float fFontSize = ImGui::GetFontSize();
			ImGui::SetWindowFontScale(1.4);
			float fContentWidth = ImGui::GetContentRegionAvailWidth() - 20.0f;
			float fButWidth = fContentWidth * 0.5;
			ImVec2 vCurPos = ImGui::GetCursorPos();
			ImGui::SetCursorPos(vCurPos + ImVec2(0.0, 12));
			if (ImGui::StyleButton("Create a new game project", ImVec2(fButWidth, 0)))
			{
				//
				//bWelcomeScreen_Window = false;
				//bStoryboardWindow = true;
				strcpy(pref.cLastUsedStoryboardProject, "");
				bStoryboardInitNodes = false; //Just init again.
				bStoryboardFirstRunSetInitPos = false;
				process_storeboard(true); //Init a new project.
				bTriggerSaveAsAfterNewLevel = true;
				bTriggerSaveAs = true;
				strcpy(SaveProjectAsName, "");
				strcpy(SaveProjectAsError, "");
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Create a new game project");

			if (bTriggerSaveAs)
			{
				ImGui::SetWindowFontScale(1.0);
				int iCreateRet = save_create_storyboard_project();
				if (iCreateRet == 1)
				{
					//PE: New project created.
					bWelcomeScreen_Window = false;
					bStoryboardWindow = true;
				}
				ImGui::SetWindowFontScale(1.4);
			}

			ImGui::SetCursorPos(vCurPos + ImVec2(fButWidth + 10.0, 12));
			if (ImGui::StyleButton("Load an existing game project", ImVec2(fButWidth, 0)))
			{
				bWelcomeScreen_Window = false;
				bStoryboardWindowOpenLoad = true;
				bStoryboardWindow = true;
				bOpenProjectsFromWelcome = true;
				iDelayTriggerOpenProject = 3; //PE: Need to be delayed to get on top.
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Load an existing game project");

			ImGui::SetWindowFontScale(1.0);

			ImGui::Text("");
			*/
			
			ImGui::SetWindowFontScale(1.2);

			if (1)
			{
				bool bTmp = 1 - pref.iDisplayIntroScreen;
				float fTextWidth = ImGui::CalcTextSize("Hide intro video next time").x + 20.0f;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvailWidth() - 10.0) * 0.5) - (fTextWidth * 0.5), 0));
				if (ImGui::Checkbox("Hide intro video next time", &bTmp))
				{
					pref.iDisplayIntroScreen = 1 - bTmp;
				}

			}
			//Skip button
			ImGui::SameLine();
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvailWidth() - 180.0), 0.0));
			if (ImGui::StyleButton(" SKIP ", ImVec2(160.0f, 0)))
			{
				bIntroScreenDone = true;
				bResizeWelcome = true;
				bStopVideo = true;
				//bWelcomeScreen_Window = false;
			}

			ImGui::SetWindowFontScale(1.0);

			/*
			if (1)
			{
				//PE: Reverse.
				bool bTmp = 1 - pref.iDisplayWelcomeScreen;
				float fTextWidth = ImGui::CalcTextSize("Tick to skip welcome screen and start editing the last edited game project and level").x + 20.0f;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvailWidth() - 10.0) * 0.5) - (fTextWidth * 0.5), 0));
				if (ImGui::Checkbox("Tick to skip welcome screen and start editing the last edited game project and level", &bTmp))
				{
					pref.iDisplayWelcomeScreen = 1 - bTmp;
				}
			}
			else
			{
				bool bTmp = pref.iDisplayWelcomeScreen;
				float fTextWidth = ImGui::CalcTextSize("Untick to skip welcome screen and resume last edited game project").x + 20.0f;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvailWidth() - 10.0) * 0.5) - (fTextWidth * 0.5), 0));
				if (ImGui::Checkbox("Untick to skip welcome screen and resume last edited game project", &bTmp))
				{
					pref.iDisplayWelcomeScreen = bTmp;
				}
			}
			*/

			ImGui::Indent(-10);

			bImGuiGotFocus = true;

			if (bDisplayAsModal)
				ImGui::EndPopup();
			else
				ImGui::End();

			if (!bWelcomeScreen_Window || bStopVideo)
			{
				//PE: Close down everything.
				bWelcomeVideoInit = false;
				bRemoveVideoInNextFrame = true;
			}

		}
		//Intro Video End
	}
	else
	{
		bool bUseFullScreen = true;
		//Welcome Screen Start
		//ImVec2 vWindowSize = ImVec2(94 * ImGui::GetFontSize(), 57 * ImGui::GetFontSize());
		ImVec2 vWindowSize = ImVec2(104 * ImGui::GetFontSize(), 59 * ImGui::GetFontSize());
		float tab_box_height = 630.0f;

		static cstr sCurrentGame = "";
		if (refresh_gui_docking == 0)
		{
			if (!bDisplayAsModal)
			{
				ImGui::SetNextWindowViewport(viewport->ID);
				ImGui::SetNextWindowSize(viewport->Size, ImGuiCond_Always);
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				ImGui::Begin("##DummyWelcome Screen##WelcomeScreenWindow", &bWelcomeScreen_Window, ImGuiWindowFlags_None | ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoChangeZOrder | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoNavFocus | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
				ImGui::End();
			}

			ImGui::SetNextWindowViewport(viewport->ID);
			ImGui::SetNextWindowSize(vWindowSize, ImGuiCond_Always);
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bool bTmp = true;
			ImGui::Begin("Welcome Screen##WelcomeScreenWindow", &bTmp, 0);
			ImGui::End();
		}
		else if (bWelcomeScreen_Window)
		{
			static std::string current_project_selected = "";
			static int current_project_id = -1;
			static int iCurrentOpenTab = 0;

			static std::string current_tutorial_selected = "";
			static int current_tutorial_id = -1;


			//PE: Hide everything in the background (wicked 3D stuff).
			ImGuiWindow* toolbarwindow = ImGui::FindWindowByName("Toolbar");//ImGui::GetCurrentWindow();
			ImVec4 monitor_col = ImVec4(0, 0, 0, 1.0); //Black for now.
			if (1)
			{
				if (!bDisplayAsModal && toolbarwindow && toolbarwindow->DrawList)
				{
					toolbarwindow->DrawList->PushClipRect(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(0, 40), true);
					ImGuiWindow* stastuswindow = ImGui::FindWindowByName("Statusbar");//ImGui::GetCurrentWindow();
					//monitor_col = ImGui::GetStyle().Colors[ImGuiCol_WindowBg];
					monitor_col = ImGui::GetStyle().Colors[ImGuiCol_WindowBg] * ImVec4(0.8, 0.8, 0.8, 0.8);
					monitor_col.w = 1.0;
					toolbarwindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 40), ImGui::GetColorU32(monitor_col));
					if (stastuswindow && stastuswindow->DrawList) stastuswindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 40), ImGui::GetColorU32(monitor_col));
					//monitor_col = ImGui::GetStyle().Colors[ImGuiCol_ModalWindowDimBg]; //ImGuiCol_WindowBg
					//toolbarwindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 40), ImGui::GetColorU32(monitor_col));
					//if (stastuswindow && stastuswindow->DrawList) stastuswindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 40), ImGui::GetColorU32(monitor_col));
					toolbarwindow->DrawList->PopClipRect();
					monitor_col = ImVec4(0, 0, 0, 1.0); //Black for now.
				}
				else
				{
					if (toolbarwindow) toolbarwindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 1), ImGui::GetColorU32(monitor_col));
				}
			}
			GetFilesListForLibrary("tutorialbank\\games\\", true, 0, 1024, 576,1); //Get games list and create thumbs.

			if (!bWelcomeScreen_Init)
			{
				if (g_LibraryFileList.size() > 0)
				{
					//sCurrentGame = g_LibraryFileList[0].cName; //First game seleted by default.
					sCurrentGame = "Escape from the Zombie Cellar.png"; //For now default to zombie cellar demo - level1.png
				}
				bWelcomeScreen_Init = true;
				#ifdef WICKEDENGINE
				void CheckForNewUpdateWicked(void);
				CheckForNewUpdateWicked(); //PE: Check if update process is done, and ask if user like to update.
				#endif
			}

			if (bDisplayAsModal)
				ImGui::OpenPopup("Welcome Screen##WelcomeScreenWindow");


			ImGuiViewport* viewport = ImGui::GetMainViewport();

			//PE: Dummy window to disable background clicks.
			if (!bDisplayAsModal)
			{
				ImGui::SetNextWindowViewport(viewport->ID);
				ImGui::SetNextWindowSize(viewport->Size, ImGuiCond_Always);
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				ImGui::Begin("##DummyWelcome Screen##WelcomeScreenWindow", &bWelcomeScreen_Window, ImGuiWindowFlags_None | ImGuiWindowFlags_NoBackground  | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoChangeZOrder | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoNavFocus | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
				ImGui::End();
			}

			ImGui::SetNextWindowViewport(viewport->ID);

			if (bResizeWelcome)
			{
				ImGui::SetNextWindowSize(vWindowSize, ImGuiCond_Always);
			}
			else
			{
				ImGui::SetNextWindowSize(vWindowSize, ImGuiCond_Once);
			}
			if (bDisplayAsModal)
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			else
			{
				if (bResizeWelcome)
					ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				else
					ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
			}
			if (bResizeWelcome) bResizeWelcome = false;

			//PE: Test
			if (bUseFullScreen)
			{
				ImGui::SetNextWindowSize(viewport->Size, ImGuiCond_Always);
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				if (viewport->Size.x < 1800.0)
				{
					//PE: Cant use fullscreen font sizes.
					bUseFullScreen = false;
				}
			}

			if (bDisplayAsModal)
				ImGui::BeginPopupModal("Welcome Screen##WelcomeScreenWindow", &bWelcomeScreen_Window, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
			else
				ImGui::Begin("Welcome Screen##WelcomeScreenWindow", &bWelcomeScreen_Window, ImGuiWindowFlags_None | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
			ImGui::Indent(10);


			//PE: Playing maximized must be on top.
			ImGuiWindow* welcome_window = ImGui::GetCurrentWindow();
			void CheckWindowsOnTop(ImGuiWindow* storyboard_window);
			CheckWindowsOnTop(welcome_window);

			cstr sDisplayName = sCurrentGame;
			char *find = (char *)pestrcasestr(sDisplayName.Get(), ".");
			if (find)
			{
				int iPos = find - sDisplayName.Get();
				if (iPos > 0 && iPos < 1024)
					sDisplayName = Left(sDisplayName.Get(), iPos);
			}

			bool bTriggerRereadDescription = false;
			if (cLastProjectList != "projectbank\\")
			{
				bTriggerRereadDescription = true;
			}
			GetProjectList("projectbank\\", true); //PE: Moved here before any use of images.

			bool bUseProject = false;
			bool bUseTutorial = false;
			if (iCurrentOpenTab == 1 && current_project_selected != "" && current_project_id >= 0)
			{
				bUseProject = true;
			}
			if (iCurrentOpenTab == 3 && current_tutorial_selected != "" && current_tutorial_id >= 0)
			{
				bUseTutorial = true;
			}

			//PE: Moved this after swap , need to be moved to before next "if (bUseTutorial)" , if we swap around again.
			if (!bUseTutorial)
			{
				if (current_tutorial_id >= 0)
				{
					iStopAndFreeThisVideo = current_tutorial_id;
					cstr title = "";
					std::map<std::string, std::string>::iterator it;
					int iFind = 0;
					for (it = tutorial_description.begin(); it != tutorial_description.end(); ++it)
					{
						if (current_tutorial_id == iFind) break;
						iFind++;
					}
					if (it != tutorial_description.end())
					{
						title = it->first.c_str();
						void SmallTutorialVideoCheckStop(char *tutorial);
						SmallTutorialVideoCheckStop(title.Get());
					}

					current_tutorial_id = -1;
				}
			}

			void* lpTexture = GetImagePointer(WELCOME_HEADER);
			ImVec2 vHeaderDim = { 1200.0f,150.0f };
			if (iWelcomeHeaderType == 3) vHeaderDim = { 1500.0f,150.0f };
			if (lpTexture)
			{
				ImGuiWindow* window = ImGui::GetCurrentWindow();
				//PE: Right align header, with black background.
				ImVec2 header_pos = ImGui::GetWindowPos() + ImVec2(ImGui::GetWindowSize().x- vHeaderDim.x, 0.0);
				window->DrawList->AddRectFilled(ImGui::GetWindowPos(), ImGui::GetWindowPos()+ImVec2(ImGui::GetWindowSize().x,150.0f), ImGui::GetColorU32(monitor_col));
				if (iWelcomeHeaderType == 2)
				{
					ImVec2 header_pos_left = ImGui::GetWindowPos() + ImVec2(70, 0);
					window->DrawList->AddImage((ImTextureID)lpTexture, header_pos_left, header_pos_left + vHeaderDim, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 0.9)));
				}
				else if (iWelcomeHeaderType == 3)
				{
					ImVec2 header_pos_center = ImGui::GetWindowPos() + ImVec2((ImGui::GetWindowSize().x*0.5) - (vHeaderDim.x*0.5), 0.0);
					window->DrawList->AddImage((ImTextureID)lpTexture, header_pos_center, header_pos_center + vHeaderDim, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
				}
				else
				{
					window->DrawList->AddImage((ImTextureID)lpTexture, header_pos, header_pos + vHeaderDim, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 0.9)));
				}
			}

			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 6.0f));

			ImVec2 vCurPos = ImGui::GetCursorPos();

			if (iWelcomeHeaderType == 2)
			{
				ImGui::SetWindowFontScale(2.0);
				ImGui::SetCursorPos(ImVec2(0, (vHeaderDim.y*0.5) - (ImGui::GetFontSize()*0.5)));
				ImGui::TextCenter("GameGuru MAX Hub");
			}
			ImGui::SetWindowFontScale(1.0);

			float fFontSize = ImGui::GetFontSize();

			ImGui::SetWindowFontScale(1.0);

			//PE: Moved here after swap.
			// Display a button that allows the user to exit the welcome screen window.
			// Store the previous cursor position so that it can be reset (adding the below button at the start of the window causes it to appear faded and i'm not sure why).
			ImVec2 vPrevCursorPos(ImGui::GetCursorPos());
			ImGui::SetCursorPos(ImVec2(12.0f, 10.0f));
			if (g_iDevToolsOpen >= 2) //PE: Rick - never a back but - !bWelcomeNoBackButton ||
			{
				if (ImGui::ImgBtn(TOOL_GOBACK, ImVec2(ImGui::GetFontSize() * 4.0f, ImGui::GetFontSize() * 4.0f), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(180, 180, 180, 180),
					ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false, false, false, false))
				{
					bWelcomeScreen_Window = false;
					if (current_tutorial_id >= 0) iStopAndFreeThisVideo = current_tutorial_id;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Exit GameGuru MAX Hub");
			}
			// Reset the cursor position to not interfere with the rest of the menu.
			ImGui::SetCursorPos(vPrevCursorPos);



			ImGui::SetCursorPos(ImVec2(0, vHeaderDim.y));

			float fButWidth = 150.0f;

			float fTotalContentWidth = ImGui::GetContentRegionAvailWidth();

			ImGui::Columns(2, "WelcomeScreencolumns2", false);  //false no border

			//ImGui::SetColumnOffset(0, 0.0f);
			//ImGui::SetColumnOffset(1, fTotalContentWidth * 0.4 ); //Right 60% size.

			//PE: swap.
			ImGui::SetColumnOffset(0, 0.0f);
			ImGui::SetColumnOffset(1, fTotalContentWidth * 0.6); //Right 40% size.


			//#############################
			//######## SWAP Column ########
			//#############################

			ImGui::Text("");
			//ImGui::Text("");

			if (bUseFullScreen || viewport->Size.x < 1800.0)
				tab_box_height = ImGui::GetWindowSize().y - 82.0f - ImGui::GetCursorPosY(); //76.0 , 72.0

			ImGuiWindow* window = ImGui::GetCurrentWindow();
			ImGuiContext& gui = *GImGui;
			ImVec2 TabStartPos = window->DC.CursorPos;

			ImGui::SetWindowFontScale(1.2);
			if (ImGui::BeginTabBar("welcomescreentabbar"))
			{
				int tabflags = 0;

				ImRect rect;
				rect.Min = TabStartPos;
				rect.Max = rect.Min + ImGui::TabItemCalcSize(" Demo Games ", false);
				TabStartPos.x += ImGui::TabItemCalcSize(" Demo Games ", false).x + gui.Style.ItemInnerSpacing.x;

				if (ImGui::BeginTabItem(" Demo Games ", NULL, tabflags))
				{
					iCurrentOpenTab = 0;

					//if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Demo Games you can edit and play");

					if (g_LibraryFileList.size() > 0)
					{

						ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + 3.0, ImGui::GetCursorPosY() + 6.0));

						//					ID3D11ShaderResourceView* lpTexture = GetImagePointerView(TOOL_ENT_FILTER);
						//					if (lpTexture)
						//					{
						//						ImVec2 vImagePos = ImGui::GetCursorPos();
						//						ImGuiWindow* window = ImGui::GetCurrentWindow();
						//						ImVec2 search_icon_pos = ImGui::GetWindowPos() + vImagePos + ImVec2(-5.0, -2.0);
						//						window->DrawList->AddImage((ImTextureID)lpTexture, search_icon_pos, search_icon_pos + ImVec2(20, 20), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
						//						ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + 22.0, ImGui::GetCursorPosY()));
						//					}
						ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3.0));

						/* No filter in design.
						static bool bFilterAll = true, bFilterShooter = true;
						cstr filters = "";
						ImGui::Checkbox("All", &bFilterAll);
						ImGui::SameLine();
						ImGui::Checkbox("Shooters", &bFilterShooter);
						if (bFilterAll) filters = "*,";
						if (bFilterShooter) filters = filters + "Shooter,";
						ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3.0));
						*/


						//cstr cRet = ListboxFilesListForWelcomeScreen(sCurrentGame.Get(), 3, -1, true, false, filters.Get(),0,false);
						//cstr cRet = ListboxFilesListForWelcomeScreen(sCurrentGame.Get(), 1, -1, true, false, filters.Get(), tab_box_height,true);
						ImGui::SetWindowFontScale(1.0);
						cstr cRet = ListboxFilesListForWelcomeScreen_v2(sCurrentGame.Get(), 3, -1, true, false, NULL, tab_box_height, false, bUseFullScreen);
						if (cRet != sCurrentGame)
						{
							//Game changed.
							sCurrentGame = cRet;
						}
					}

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}
					ImGui::EndTabItem();
				}
				if (ImGui::IsMouseHoveringRect(rect.Min, rect.Max)) ImGui::SetTooltip("%s", "Demo Games you can edit and play");

				ImGui::SetWindowFontScale(1.2);

				rect.Min = TabStartPos;
				rect.Max = rect.Min + ImGui::TabItemCalcSize(" My Games ", false);
				TabStartPos.x += ImGui::TabItemCalcSize(" My Games ", false).x + gui.Style.ItemInnerSpacing.x;

				static bool bCheckForAnyProjectFiles = true;
				int tabflagsMyGames = 0;

				if (bCheckForAnyProjectFiles)
				{
					extern bool bReturnToWelcome;
					if (projectbank_list.size() > 0 && !bReturnToWelcome)
					{
						tabflagsMyGames = ImGuiTabItemFlags_SetSelected;
					}
					bCheckForAnyProjectFiles = false;
				}

				if (ImGui::BeginTabItem(" My Games ", NULL, tabflagsMyGames))
				{
					ImGui::SetWindowFontScale(0.99f);

					ImGui::Indent(10);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(905.0f, 6.0f));
					ImGui::Text("Sort Projects: ");
					ImGui::SameLine();
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, -2.0f));
					
					const char* pProjectSortModes[] = { "Most Recent", "Least Recent", "A-Z", "Z-A" };
					int iProjectSortMode = pref.iProjectSortMode;

					int comboflags = ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge;
					ImGui::PushItemWidth(110);
					if (ImGui::BeginCombo("##ComboProjectSort", pProjectSortModes[iProjectSortMode], comboflags))
					{
						for (int i = 0; i < 4; i++)
						{
							bool is_selected = (iProjectSortMode == i);
							if (ImGui::Selectable(pProjectSortModes[i], is_selected)) 
							{
								if (i != iProjectSortMode)
								{
									pref.iProjectSortMode = iProjectSortMode = i;
									SortProjects(iProjectSortMode);
									bResetProjectThumbnails = true;
									break;
								}
							}
						}

						ImGui::EndCombo();
					}

					ImGui::Indent(-10);
					ImGui::SetWindowFontScale(1.0f);
					ImGui::PopItemWidth();
					

					//PE: Always have a selection.
					if (current_project_selected == "" && projectbank_list.size() > 0)
					{
						current_project_id = 0;
						current_project_selected = projectbank_list[0];
					}

					iCurrentOpenTab = 1;
					//My Games.
					bool bTriggerLoad = false;

					ImGui::SetWindowFontScale(1.0);
					ImGui::BeginChild("##MyGamesProjectsForWelcome", ImVec2(ImGui::GetContentRegionAvail().x - 2.0, tab_box_height), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
					ImGui::Indent(2);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 6));
					float total_width = ImGui::GetContentRegionAvailWidth();
					ImGui::Columns(3, "MyGamesProjectsForWelcomecolumns", false);  //false no border

					float colwidth = ImGui::GetContentRegionAvailWidth(); //padding.
					float fRatio = colwidth / 512.0f;
					ImVec2 iThumbSize = { (float)512.0*fRatio, (float)288.0*fRatio };
					int iCount = projectbank_list.size();
					if (iCount < 9) iCount = 9; //PE: Always display min. 9 empty slots.
					for (int i = 0; i < iCount; i++)
					{
						if (i >= projectbank_list.size())
						{
							if (i == projectbank_list.size())
							{
								ImVec2 cursorPos = ImGui::GetCursorPos();
								int iTextureID = WELCOME_FILLERROUNDED;
								ImVec4 alpha = { 1.0f,1.0f,1.0f,0.15f };
								if(ImGui::ImgBtn(iTextureID, ImVec2(iThumbSize.x, iThumbSize.y + 36.0), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255)*alpha, ImColor(255, 255, 255, 255)*alpha,
									ImColor(255, 255, 255, 255)*alpha, 0, 0, 0, 0, false, false, false, false, true))
								{
									// The first available empty slot should also serve as a Create new game project button.
									strcpy(pref.cLastUsedStoryboardProject, "");
									bStoryboardInitNodes = false; //Just init again.
									bStoryboardFirstRunSetInitPos = false;
									process_storeboard(true); //Init a new project.
									bTriggerSaveAsAfterNewLevel = true;
									bTriggerSaveAs = true;
									strcpy(SaveProjectAsName, "");
									strcpy(SaveProjectAsError, "");
								}
								ImVec2 buttonSize(iThumbSize.x / 4.f, iThumbSize.y / 4.f + 36.0f);
								ImGui::SetCursorPos(cursorPos + ImVec2(iThumbSize.x / 2.f - 3.35f, iThumbSize.y / 2.f + 18.f - 3.35f) - buttonSize / 2);
								if (ImGui::ImgBtn(KEY_SEPARATOR, buttonSize, ImColor(255.0f, 255.0f, 255.0f, 0.0f), ImColor(220, 220, 220, 220),
									ImColor(220, 220, 220, 180), ImColor(220, 220, 220, 150), 0, 0, 0, 0, false, false, false, false, true))
								{

								}
								if (ImGui::IsItemHovered())ImGui::SetTooltip("Create a new game project");
							}
							else
							{
								//PE: Filler.
								int iTextureID = WELCOME_FILLERROUNDED;
								ImVec4 alpha = { 1.0f,1.0f,1.0f,0.15f };
								if (ImGui::ImgBtn(iTextureID, ImVec2(iThumbSize.x, iThumbSize.y + 36.0), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255)*alpha, ImColor(255, 255, 255, 200)*alpha, ImColor(255, 255, 255, 200)*alpha, 0, 0, 0, 0, false, false, false, false, true))
								{
									//
								}
							}

							
							ImGui::NextColumn();
						}
						else
						{
							if (!ImageExist(projectbank_imageid[i]) || bResetProjectThumbnails) //STORYBOARD_THUMBS + 800 + i))
							{
								if (bResetProjectThumbnails)
								{
									bResetProjectThumbnails = false;

									// After sorting, the thumbnails can be out of order but not safe to delete them before here.
									for (int i = 0; i < projectbank_imageid.size(); i++)
									{
										if (ImageExist(STORYBOARD_THUMBS + 800 + i)) DeleteImage(STORYBOARD_THUMBS + 800 + i);
									}
									GetProjectThumbnails();
								}

								if (projectbank_imageid[i] != BOX_CLICK_HERE)
								{
									if (ImageExist(STORYBOARD_THUMBS + 800 + i)) DeleteImage(STORYBOARD_THUMBS + 800 + i);
								}
								if (projectbank_image[i] == "")
								{
									//Click Here.
									projectbank_imageid[i] = BOX_CLICK_HERE;
								}
								else
								{
									//PE: Load in thumb.
									image_setlegacyimageloading(true);
									LoadImageSize((char *)projectbank_image[i].c_str(), STORYBOARD_THUMBS + 800 + i, 512, 288);
									image_setlegacyimageloading(false);
									if (!ImageExist(STORYBOARD_THUMBS + 800 + i))
									{
										//Fail click here.
										projectbank_imageid[i] = BOX_CLICK_HERE;
									}
									else
									{
										projectbank_imageid[i] = STORYBOARD_THUMBS + 800 + i;
									}
								}
							}

							if (!pestrcasestr((char *)projectbank_list[i].c_str(), "_backup_"))
							{
								ImGui::PushID(564231 + i);
								int TextureID = BOX_CLICK_HERE;
								if (ImageExist(projectbank_imageid[i])) TextureID = projectbank_imageid[i];

								if (current_project_selected == projectbank_list[i])
								{
									//PE: Highlight by name.
									current_project_id = i; //PE: If adding new project, make sure current_project_id match name.
									if (1)
									{
										ImGuiWindow* window = ImGui::GetCurrentWindow();
										ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
										ImVec2 padding = { 1.0, 1.0 };
										const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + iThumbSize);
										window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
									}

								}
								if (ImGui::ImgBtn(TextureID, iThumbSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false, false, true))
								{
									current_project_selected = projectbank_list[i];
									current_project_id = i;
								}
								ImGui::PopID();

								if (ImGui::IsItemHovered())
								{
									if (ImGui::IsMouseDoubleClicked(0))
									{
										current_project_selected = projectbank_list[i];
										current_project_id = i;
										bTriggerLoad = true;
									}
								}
								ImGui::SetWindowFontScale(1.4);
								if (ImGui::StyleButton(projectbank_list[i].c_str(), ImVec2(colwidth, 0.0f)))
								{
									current_project_selected = projectbank_list[i];
									current_project_id = i;
									//bTriggerLoad = true;
								}
								//PE: Need pencil for edit.
								ImGui::SameLine();
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(-35.0, 3.0));
								ImGui::SetItemAllowOverlap();
								ImGui::PushID(464231 + i);
								if (ImGui::ImgBtn(TOOL_PENCIL, ImVec2(22, 22), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false, false, true))
								{
									current_project_selected = projectbank_list[i];
									current_project_id = i;
									bTriggerLoad = true;
								}
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Edit The Game Project");
								ImGui::PopID();

								ImGui::SetWindowFontScale(1.0);
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 8));
								ImGui::NextColumn();

							}
						}
					}

					// Sort the projects initially.
					if (bSortProjects)
					{
						bSortProjects = false;
						SortProjects(iProjectSortMode);
						bResetProjectThumbnails = true;
					}

					//PE: No trigger load here, moved to other column.
					if (bTriggerLoad)
					{
						//Load and start storyboard.
						TriggerLoadGameProject = current_project_selected.c_str();
						bWelcomeScreen_Window = false;
						bStoryboardWindow = true;
						if (current_tutorial_id >= 0) iStopAndFreeThisVideo = current_tutorial_id;
					}

					ImGui::Columns(1);
					ImGui::Indent(-2);

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}

					ImGui::EndChild();

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}
					ImGui::EndTabItem();
				}
				if (ImGui::IsMouseHoveringRect(rect.Min, rect.Max)) ImGui::SetTooltip("%s", "My Games");


				if (1) //Disable all other tabs.
				{
					ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
				}

				ImGui::SetWindowFontScale(1.2);

				/* LB: removed for the EA release - content needs more work
				//PE: We cant use the normal tooptip when tabs are disabled so...
				rect.Min = TabStartPos;
				rect.Max = rect.Min + ImGui::TabItemCalcSize(" How to Make a Game ", false);
				TabStartPos.x += ImGui::TabItemCalcSize(" How to Make a Game ", false).x + gui.Style.ItemInnerSpacing.x;
				ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
				if (ImGui::BeginTabItem(" How to Make a Game ", NULL, tabflags))
				{
					ImGui::EndTabItem();
				}
				ImGui::PopStyleVar();
				if (ImGui::IsMouseHoveringRect(rect.Min, rect.Max)) ImGui::SetTooltip("%s", "How to Make a Game (Coming Soon)");
				*/

				ImGui::PopItemFlag(); //PE: Enable this tab.

				rect.Min = TabStartPos;
				rect.Max = rect.Min + ImGui::TabItemCalcSize(" Tutorials ", false);
				TabStartPos.x += ImGui::TabItemCalcSize(" Tutorials ", false).x + gui.Style.ItemInnerSpacing.x;
				if (ImGui::BeginTabItem(" Tutorials ", NULL, tabflags))
				{
					char* tutorial_order[] = { "9901-introduction-video.mp4", "0101-getting-started.mp4", "0701-game-storyboard.mp4", "0501-terrain-generator.mp4", "0502-terrain-height-maps.mp4", "0201-level-editor.mp4", "0202-particle-editor.mp4", "0203-animation-library.mp4", "0301-object-library.mp4" , "0801-character-creator.mp4" ,"0601-terrain-editing.mp4", "0401-objects-grouping.mp4" };

					iCurrentOpenTab = 3;

					ImGui::SetWindowFontScale(1.0);
					ImGui::BeginChild("##MyGamesTutorialsForWelcome", ImVec2(ImGui::GetContentRegionAvail().x - 2.0, tab_box_height), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
					ImGui::Indent(2);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 6));
					float total_width = ImGui::GetContentRegionAvailWidth();
					ImGui::Columns(3, "MyGamesTutorialsForWelcomecolumns", false);  //false no border

					float colwidth = ImGui::GetContentRegionAvailWidth(); //padding.
					float fRatio = colwidth / 512.0f;
					ImVec2 iThumbSize = { (float)512.0*fRatio, (float)288.0*fRatio };
					int old_current_tutorial_id = current_tutorial_id;
					for (int i = 0; i < ARRAYSIZE(tutorial_order); i++)
					{
						int iTutorialID = -1;
						cstr cTitle = "";

						//PE: Find next tutorial.
						if (tutorial_videos.size() > 0)
						{
							int il = 0;
							for (std::map<std::string, std::string>::iterator it = tutorial_videos.begin(); it != tutorial_videos.end(); ++it)
							{
								if (it->first.length() > 0)
								{
									if (strstr(it->second.c_str(), tutorial_order[i]) != 0)
									{
										cTitle = it->first.c_str();
										cSmallVideoPath = it->second.c_str();
										iTutorialID = il;
										break;
									}
								}
								il++;
							}
						}

						if (iTutorialID >= 0)
						{
							//PE: Always have a selection.
							if (current_tutorial_selected == "")
							{
								current_tutorial_id = iTutorialID;
								current_tutorial_selected = tutorial_order[i];
							}

							SmallTutorialThumbLoad(iTutorialID);

							if (ImageExist(iSmallVideoThumbnail[iTutorialID]))
							{
								ImGui::PushID(565231 + i);
								int TextureID = iSmallVideoThumbnail[iTutorialID];

								if (current_tutorial_selected == tutorial_order[i])
								{
									//PE: Highlight by name.
									current_tutorial_id = iTutorialID;
									if (1)
									{
										ImGuiWindow* window = ImGui::GetCurrentWindow();
										ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
										ImVec2 padding = { 1.0, 1.0 };
										const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + iThumbSize);
										window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
									}

								}
								if (ImGui::ImgBtn(TextureID, iThumbSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false, false, true))
								{
									current_tutorial_selected = tutorial_order[i];
									current_tutorial_id = iTutorialID;
									if (old_current_tutorial_id >= 0)
									{
										iStopAndFreeThisVideo = old_current_tutorial_id;
									}

								}
								ImGui::PopID();

								ImGui::SetWindowFontScale(1.4);

								char *find = strstr(cTitle.Get(), "-");
								if (find) find++;
								if (find && find[0] == ' ') find++;
								else find = cTitle.Get();

								if (ImGui::StyleButton(find, ImVec2(colwidth, 0.0f)))
								{
									if (old_current_tutorial_id >= 0)
									{
										iStopAndFreeThisVideo = old_current_tutorial_id;
									}

									current_tutorial_selected = tutorial_order[i];
									current_tutorial_id = iTutorialID;
								}

								ImGui::SetWindowFontScale(1.0);
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 8));
								ImGui::NextColumn();

							}
						}
					}

					ImGui::Columns(1);
					ImGui::Indent(-2);

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}

					ImGui::EndChild();

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}
					ImGui::EndTabItem();
				}
				if (ImGui::IsMouseHoveringRect(rect.Min, rect.Max)) ImGui::SetTooltip("%s", "Tutorials");

				ImGui::SetWindowFontScale(1.2);

				rect.Min = TabStartPos;
				rect.Max = rect.Min + ImGui::TabItemCalcSize(" User Guide ", false);
				TabStartPos.x += ImGui::TabItemCalcSize(" User Guide ", false).x + gui.Style.ItemInnerSpacing.x;
				if (ImGui::BeginTabItem(" User Guide ", NULL, tabflags))
				{
					iCurrentOpenTab = 4;
					ImGui::Text("");
					ImGui::SetWindowFontScale(2.0);
					ImGui::TextCenter("GameGuru MAX User Guide");
					ImGui::SetWindowFontScale(1.0);
					ImGui::Text("");
					ImGui::Text("");
					float descwidth = ImGui::GetContentRegionAvail().x*0.60;
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5)- (descwidth*0.5), 0));

					float oldChildBorderSize = gui.Style.ChildBorderSize;
					gui.Style.ChildBorderSize = 10.0;
					ImVec2 oldFramePadding = gui.Style.FramePadding;
					gui.Style.FramePadding = ImVec2(10.0,10.0);
					float guide_height = tab_box_height - 380.0;
					if (guide_height < 375.0) guide_height = 375.0;
					ImGui::BeginChild("##MyUserGuideForWelcome", ImVec2(descwidth - 2.0, guide_height), true, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
					ImGui::Indent(10);
					ImGui::Text("");
					ImGui::SetWindowFontScale(2.0);
					ImGui::TextWrapped("The GameGuru MAX online user guide is a comprehensive guide to the software.");
					ImGui::Text("");
					ImGui::TextWrapped("With easy left side navigation and instant search at the top, you can easily find the advice and help you are looking for.");
					ImGui::Text("");
					ImGui::TextWrapped("Regular updates will ensure the guide is up to date and offering the best advice to new and experienced game developers.");
					ImGui::SetWindowFontScale(1.0);
					ImGui::Text("");
					ImGui::Indent(-10);
					ImGui::EndChild();

					gui.Style.ChildBorderSize = oldChildBorderSize;
					gui.Style.FramePadding = oldFramePadding;
					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}

					ImGui::EndTabItem();
				}
				if (ImGui::IsMouseHoveringRect(rect.Min, rect.Max)) ImGui::SetTooltip("%s", "User Guide");


				ImGui::SetWindowFontScale(1.2);

				rect.Min = TabStartPos;
				rect.Max = rect.Min + ImGui::TabItemCalcSize(" Live Streams & Social ", false);
				TabStartPos.x += ImGui::TabItemCalcSize(" Live Streams & Social ", false).x + gui.Style.ItemInnerSpacing.x;
				if (ImGui::BeginTabItem(" Live Streams & Social ", NULL, tabflags))
				{
					ImGui::SetWindowFontScale(2.0);
					ImGui::TextCenter("GameGuru MAX Socials");
					ImGui::SetWindowFontScale(1.0);

					//const char* items_social_header[] = { "OFFICIAL FORUMS","TWITTER", "INSTAGRAM", "TIKTOK" , "FACEBOOK","DISCORD" };
					//const char* items_social_header[] = { "OFFICIAL FORUMS", "TIKTOK" , "FACEBOOK", "DISCORD" };
					const char* items_social_header[] = { "OFFICIAL FORUMS", "FACEBOOK", "DISCORD" };
					const char* items_social_desc[] = {
						"The online forums are a great place to learn and ask questions",
						//"Keep up to date with announcements by following our official Twitter account",
						//"Follow us on Instagram to see new images and news",
						//"Watch vidoes and updates on our official TikTok channel" ,
						"Follow us at our official GameGuru MAX Facebook page",
						"Join the conversation with other users of GameGuru MAX on Discord" };
					const char* items_social_link[] = {
						"https://bit.ly/MAXForum",
						//"https://bit.ly/MAXTwitter",
						//"https://bit.ly/MAXInstagram",
						//"https://bit.ly/MAXTikTok" ,
						"https://bit.ly/MAXMeta",
						"https://bit.ly/MAX_Discord" };
					//const int items_social_thumb[] = { HUB_FORUM,HUB_TWITTER, HUB_INSTAGRAM, HUB_TIKTOK,HUB_FACEBOOK,HUB_DISCORD };
					//const int items_social_thumb[] = { HUB_FORUM, HUB_TIKTOK, HUB_FACEBOOK, HUB_DISCORD };
					const int items_social_thumb[] = { HUB_FORUM, HUB_FACEBOOK, HUB_DISCORD };

					iCurrentOpenTab = 5;

					ImGui::SetWindowFontScale(1.0);
					//ImVec2 vWidthOfSocialsArea = ImVec2(ImGui::GetContentRegionAvail().x - 2.0, tab_box_height);
					//ImVec2 vWidthOfSocialsArea = ImVec2((ImGui::GetContentRegionAvail().x*0.66f) - 2.0, tab_box_height);
					ImVec2 vWidthOfSocialsArea = ImVec2(ImGui::GetContentRegionAvail().x - 2.0, tab_box_height);
					//float fIntendAmount = (ImGui::GetContentRegionAvail().x*0.33f) / 2.0f;
					float fIntendAmount = 0.0f;
					ImGui::Indent(fIntendAmount);
					ImGui::BeginChild("##MySocialsForWelcome", vWidthOfSocialsArea, false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
					ImGui::Indent(2);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 6));
					float total_width = ImGui::GetContentRegionAvailWidth();
					//ImGui::Columns(3, "MySocialsForWelcomecolumns", false);  //false no border
					//ImGui::Columns(2, "MySocialsForWelcomecolumns", false);  //false no border
					ImGui::Columns(3, "MySocialsForWelcomecolumns", false);  //false no border

					float colwidth = ImGui::GetContentRegionAvailWidth(); //padding.
					float fRatio = colwidth / 512.0f;
					ImVec2 iThumbSize = { (float)512.0*fRatio, (float)288.0*fRatio };
					
					char child[MAX_PATH];
					for (int i = 0; i < IM_ARRAYSIZE(items_social_thumb); i++)
					{
						sprintf(child, "##JustaSocialFrame%d", i);
						ImGui::BeginChild(child, ImVec2(iThumbSize.x-8.0, iThumbSize.x - 60.0), true, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings);

						ImGui::SetWindowFontScale(1.6);
						ImGui::TextCenter(items_social_header[i]);
						ImGui::SetWindowFontScale(1.0);

						int TextureID = items_social_thumb[i];
						if (!ImageExist(TextureID))
						{
							TextureID = BOX_CLICK_HERE;
						}

						ImGui::PushID(554231 + i);
						float wthumb = iThumbSize.x - 120.0;
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvailWidth()*0.5)-(wthumb*0.5)-3.0, 0.0f));
						if (ImGui::ImgBtn(TextureID, ImVec2(wthumb, wthumb), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false, false, true))
						{
							ExecuteFile( (LPSTR) items_social_link[i], "", "", 0);
						}
						ImGui::PopID();

						ImGui::EndChild();

						ImGui::SetWindowFontScale(1.2);
						ImGui::TextWrapped(items_social_desc[i]);
						ImGui::SetWindowFontScale(1.0);

						ImGui::SetWindowFontScale(1.0);
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 8));
						ImGui::NextColumn();
					}

					ImGui::Columns(1);
					ImGui::Indent(-2);

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}

					ImGui::EndChild();
					ImGui::Indent(-fIntendAmount);

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}


					ImGui::EndTabItem();
				}
				if (ImGui::IsMouseHoveringRect(rect.Min, rect.Max)) ImGui::SetTooltip("%s", "Live Streams & Social");

				ImGui::EndTabBar();
			}
			ImGui::SetWindowFontScale(1.0);

			//#############################
			//######## SWAP Column ########
			//#############################

			ImGui::NextColumn();

			ImGui::Text("");

			float fContentWidth = ImGui::GetContentRegionAvailWidth() - 10.0f;
			//static float WelcomeFrameHeight = ImGui::GetWindowSize().y - 82.0f - ImGui::GetCursorPosY(); //76.0 , 72.0
			float WelcomeFrameHeight = ImGui::GetWindowSize().y - 82.0f - ImGui::GetCursorPosY(); //76.0 , 72.0
			ImGui::BeginChild("##JustaFrameWelcome", ImVec2(fContentWidth+4.0, WelcomeFrameHeight), true, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings);
			ImGui::Indent(2);
			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3.0));

			float fRatio = 288.0f / 512.0f;
			float right_margin = 9.0;
			ImVec2 vPreviewSize = { (fContentWidth - right_margin) , (fContentWidth - right_margin) * fRatio };
			float fImageWidth = 460;
			float fImageHeight = 215;
			
			if (iCurrentOpenTab == 4)
			{
				int iTextureID = HUB_USERGUIDE;
				if (!ImageExist(iTextureID)) iTextureID = WELCOME_FILLERROUNDED;

				ImGui::SetWindowFontScale(1.0);
				if (iTextureID > 0)
				{
					if (ImGui::ImgBtn(iTextureID, ImVec2(vPreviewSize.x, vPreviewSize.x + 17.0f), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
					{
						//ExecuteFile("https://gameguru-max.document360.io/docs/test-topic", "", "", 0);
						ExecuteFile("https://bit.ly/MAXUserGuide", "", "", 0);
					}
				}
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.2);

			}
			else if (iCurrentOpenTab == 5)
			{
				//LoadImage("editors\\uiv3\\hub-livebroadcasts.png", HUB_LIVEBROADCAST);
				//hub-website.png
				float image_size_sub_x = 310.0;
				if (vPreviewSize.x - image_size_sub_x < 250.0) image_size_sub_x += vPreviewSize.x - image_size_sub_x- 250.0;
				int iTextureID = HUB_WEBSITE;
				if (!ImageExist(iTextureID)) iTextureID = WELCOME_FILLERROUNDED;
				float ratio = 394.0 / 700.0;
				ImGui::SetWindowFontScale(1.0);
				if (iTextureID > 0)
				{
					ImGui::SetWindowFontScale(1.4);
					ImGui::TextCenter("Official Website");
					ImGui::SetWindowFontScale(1.0);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(image_size_sub_x*0.5, 0.0));
					if (ImGui::ImgBtn(iTextureID, ImVec2(vPreviewSize.x - image_size_sub_x, (vPreviewSize.x- image_size_sub_x) * ratio), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
					{
						/*ExecuteFile("https://www.game-guru.com/max", "", "", 0);*/
						ExecuteFile("https://bit.ly/MAXWebsite", "", "", 0);
					}
					ImGui::SetWindowFontScale(1.4);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(image_size_sub_x*0.5, 0.0));
					if (ImGui::StyleButton("Click Here to Visit The Website", ImVec2(vPreviewSize.x - image_size_sub_x, 0)))
					{
						/*ExecuteFile("https://www.game-guru.com/max", "", "", 0);*/
						ExecuteFile("https://bit.ly/MAXWebsite", "", "", 0);
					}
					ImGui::SetWindowFontScale(1.0);
					ImGui::Text("");
				}

				iTextureID = HUB_LIVEBROADCAST;
				if (!ImageExist(iTextureID)) iTextureID = WELCOME_FILLERROUNDED;

				ImGui::SetWindowFontScale(1.4);
				ImGui::TextCenter("Weekly Live Stream");
				ImGui::SetWindowFontScale(1.0);
				if (iTextureID > 0)
				{
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(image_size_sub_x*0.5, 0.0));
					if (ImGui::ImgBtn(iTextureID, ImVec2(vPreviewSize.x - image_size_sub_x, (vPreviewSize.x - image_size_sub_x) * ratio), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
					{
						/*ExecuteFile("https://www.youtube.com/channel/UC1q1e3Q9IKMk4nDlAGb_5Jg", "", "", 0);*/
						ExecuteFile("https://bit.ly/MAXYouTubeChannel", "", "", 0);
					}
				}
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);

				cstr desc = "Every week we broadcast a live stream showing the latest GameGuru MAX developments and news. Join us live and ask our dev team your burning questions!";
				{
					ImGui::Indent(2);
					ImVec2 cp = ImGui::GetCursorPos();
					ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.f, 0.f));
					ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));
					ImGui::BeginChild("##JustaFrameForLiveBroadcastDescription", ImVec2(fContentWidth-8.0, WelcomeFrameHeight - cp.y - 4.0), false, ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings);
					ImGui::TextWrapped(desc.Get());
					ImGui::Text("");
					ImGui::TextCenter("Time: 7pm GMT / 2pm ET / 11am PST.");
					ImGui::PopStyleVar(2);
					ImGui::EndChild();
					ImGui::Indent(-2);
				}
				ImGui::SetWindowFontScale(1.2);

			}
			else if (bUseTutorial)
			{

				cstr title = "";
				cstr description = "Testing description.";

				std::map<std::string, std::string>::iterator it;
				int iFind = 0;
				for (it = tutorial_description.begin(); it != tutorial_description.end(); ++it)
				{
					if (current_tutorial_id == iFind) break;
					iFind++;
				}
				if (it != tutorial_description.end()) {
					title = it->first.c_str();
					description = it->second.c_str();
				}
				//ImGui::Indent(10);
				//SmallTutorialVideo(cShowTutorial.Get(), my_combo_itemsp, my_combo_items, iVideoSection);
				SmallTutorialVideo(title.Get(), NULL, 0, SECTION_MAX_HUB);

				//ImGui::Indent(-10);
				if (bLastSmallVideoPlayerMaximized)
				{
					int iTextureID = iSmallVideoThumbnail[current_tutorial_id];
					if (iTextureID > 0)
					{
						if (ImGui::ImgBtn(iTextureID, vPreviewSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
						{
							//Click ?
						}
					}
				}
				ImGui::SetWindowFontScale(1.8);

				char *find = strstr(title.Get(), "-");
				if (find) find++;
				if (find && find[0] == ' ') find++;
				else find = title.Get();

				if (pref.current_style == 25)
				{
					//PE: Only blue style have different color, dont match on other styles.
					ImVec4 textcol = ImGui::GetStyleColorVec4(ImGuiCol_Button);
					textcol.w = 1.0;
					ImGui::PushStyleColor(ImGuiCol_Text, textcol);
					ImGui::Text(find);
					ImGui::PopStyleColor();
				}
				else
				{
					ImGui::Text(find);
				}
				ImGui::SetWindowFontScale(1.2);

				if (description.Len() > 0)
				{
					if (bUseFullScreen) ImGui::SetWindowFontScale(1.5);
					ImGui::Indent(-2);
					ImVec2 cp = ImGui::GetCursorPos();
					ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.f, 0.f));
					ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));
					ImGui::BeginChild("##JustaFrameForTutorialDescription", ImVec2(fContentWidth, WelcomeFrameHeight - cp.y - 4.0), false, ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings);
					ImGui::TextWrapped(description.Get());
					ImGui::PopStyleVar(2);
					ImGui::EndChild();
					ImGui::Indent(2);
					ImGui::SetWindowFontScale(1.2);
				}
				else
				{
					//ImGui::TextWrapped("Description:");
				}

			}
			else if (bUseProject)
			{
				//lpTexture
				//sDisplayName
				int iTextureID = BOX_CLICK_HERE;
				if (ImageExist(projectbank_imageid[current_project_id])) iTextureID = projectbank_imageid[current_project_id];

				if (iTextureID > 0)
				{
					if (current_project_selected.length() > 0)
					{
						ImGuiWindow* window = ImGui::GetCurrentWindow();
						ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
						ImVec2 padding = { 1.0, 1.0 };
						const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + vPreviewSize);
						window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
					}

					if (ImGui::ImgBtn(iTextureID, vPreviewSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
					{
						//Click ?
					}
				}
				ImGui::SetWindowFontScale(1.4);
				float fButWidth = fContentWidth * 0.25 - right_margin;
				ImVec2 vCurPos = ImGui::GetCursorPos();
				ImGui::SetCursorPos(vCurPos + ImVec2(fButWidth*0.5, 12));
				if (ImGui::StyleButton("Play Game", ImVec2(fButWidth, 0)))
				{
					//PE: Play - Load and start storyboard, also start play process.
					TriggerLoadGameProject = current_project_selected.c_str();
					bWelcomeScreen_Window = false;
					bStoryboardWindow = true;
					iStoryboardExecuteKey = ' ';
					if (current_tutorial_id >= 0)
					{
						iStopAndFreeThisVideo = current_tutorial_id;
					}

				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Play The Game");
				ImGui::SetCursorPos(vCurPos + ImVec2(fButWidth*0.5 + fButWidth + fButWidth, 12));
				if (ImGui::StyleButton("Edit Game", ImVec2(fButWidth, 0)))
				{
					//PE: Edit - Load and start storyboard.
					TriggerLoadGameProject = current_project_selected.c_str();
					bWelcomeScreen_Window = false;
					bStoryboardWindow = true;
					if (current_tutorial_id >= 0) iStopAndFreeThisVideo = current_tutorial_id;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Edit The Game");
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 8));

				ImGui::SetWindowFontScale(1.8);
				if (pref.current_style == 25)
				{
					//PE: Only blue style have different color, dont match on other styles.
					ImVec4 textcol = ImGui::GetStyleColorVec4(ImGuiCol_Button);
					textcol.w = 1.0;
					ImGui::PushStyleColor(ImGuiCol_Text, textcol);
					ImGui::Text(current_project_selected.c_str());
					ImGui::PopStyleColor();
				}
				else
				{
					ImGui::Text(current_project_selected.c_str());
				}
				ImGui::SetWindowFontScale(1.2);

				//PE: Need a tmp read of storyboard to get the correct desc...
				static std::string last_current_project_selected = "##";
				static std::string game_description = "";
				static std::string game_developer_description = "";
				if (current_project_selected != last_current_project_selected || bTriggerRereadDescription)
				{
					game_description = "";
					game_developer_description = "";
					if (load_checkproject_storyboard( (char *) current_project_selected.c_str() ))
					{
						game_description = checkproject.game_description;
						game_developer_description = checkproject.game_developer_desc;
					}
					last_current_project_selected = current_project_selected;
					bTriggerRereadDescription = false;
				}
				if (game_description.length() > 0)
				{
					if(bUseFullScreen) ImGui::SetWindowFontScale(1.2);
					ImGui::Indent(-2);
					ImVec2 cp = ImGui::GetCursorPos();
					ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.f, 0.f));
					ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));
					ImGui::BeginChild("##JustaFrameForDescription", ImVec2(fContentWidth, WelcomeFrameHeight-cp.y-4.0), false, ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings);
					ImGui::TextWrapped(game_description.c_str());

					if (game_developer_description.length() > 0)
					{
						ImGui::SetWindowFontScale(1.5);
						ImGui::Text("");
						if (pref.current_style == 25)
						{
							ImVec4 textcol = ImGui::GetStyleColorVec4(ImGuiCol_Button);
							textcol.w = 1.0;
							ImGui::PushStyleColor(ImGuiCol_Text, textcol);
							ImGui::Text("Game Developer");
							ImGui::PopStyleColor();
						}
						else
						{
							ImGui::Text("Game Developer");
						}
						ImGui::SetWindowFontScale(1.2);
						ImGui::Text(game_developer_description.c_str());
					}

					ImGui::PopStyleVar(2);
					ImGui::EndChild();
					ImGui::Indent(2);
					ImGui::SetWindowFontScale(1.2);
				}
				else
				{
					//ImGui::TextWrapped("Description:");
					//ImGui::TextWrapped("A huge description to test if everything is fine here with wrapping and all 1234567890 mega text desc here now! A huge description to test if everything is fine here with wrapping and all 1234567890 mega text desc here now! A huge description to test if everything is fine here with wrapping and all 1234567890 mega text desc here now! A huge description to test if everything is fine here with wrapping and all 1234567890 mega text desc here now! mega text desc here now! A huge description to test if everything is fine here with wrapping and all 1234567890 mega text desc here now!");
				}
			}
			else
			{

				int iFileListEntry = GetEntryFilesListForLibrary(sCurrentGame);
				if (g_LibraryFileList.size() > 0)
				{
					ImGuiWindow* window = ImGui::GetCurrentWindow();
					ImRect image_bb(window->DC.CursorPos, window->DC.CursorPos + vPreviewSize);

					int iTextureID = GetImageIDFilesListForLibrary(sCurrentGame);
					if (iTextureID > 0)
					{
						if (current_project_selected.length() > 0)
						{
							ImGuiWindow* window = ImGui::GetCurrentWindow();
							ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
							ImVec2 padding = { 1.0, 1.0 };
							const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + vPreviewSize);
							window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
						}

						if (ImGui::ImgBtn(iTextureID, vPreviewSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
						{
							//Click ?
						}
					}
					//#### VIDEO START ####
					static int triggerEndVideo = 0;
					static int iVideoTriggerTimer = 0;
					int n = iFileListEntry;

					if (n < g_LibraryFileList.size() && ImGui::IsItemHovered() && iVideoTriggerTimer++ > 30)
					{
						if (iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID))
						{
							float fVideoW = 0;
							float fVideoH = 0;
							float animU = 1.0;
							float animV = 1.0;
							void* lpVideoTexture = NULL;
							lpVideoTexture = GetAnimPointerTexture(iWelcomeVideoID);
							if (lpVideoTexture != NULL)
							{
								fVideoW = GetAnimWidth(iWelcomeVideoID);
								fVideoH = GetAnimHeight(iWelcomeVideoID);
								SetRenderAnimToImage(iWelcomeVideoID, true);
								animU = GetAnimU(iWelcomeVideoID);
								animV = GetAnimV(iWelcomeVideoID);
								ImVec2 uv0 = ImVec2(0, 0);
								ImVec2 uv1 = ImVec2(animU, animV);
								window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));
							}

							float fdone = GetAnimPercentDone(iWelcomeVideoID) / 100.0f;
							if (fdone > 0.5)
								triggerEndVideo = 1;
							if (triggerEndVideo > 0 && (fdone == 0.0f || fdone >= 1.0f))
							{
								//End loop.
								//PE: Loop dont work, at some point the player breaks and flicker, just restart everyting.
								//void SetVideoPositionPlay(float seconds);
								//SetVideoPositionPlay(0.0);
								//ResumeAnim(iWelcomeVideoID);
								//Try stopping and starting.
								//StopAnimation(iWelcomeVideoID);
								//PlaceAnimation(iWelcomeVideoID, -1, -1, -1, -1);
								//SetRenderAnimToImage(iWelcomeVideoID, true);
								//PlayAnimation(iWelcomeVideoID);
								//SetVideoVolume(100);
								iVideoTriggerTimer = 0;
								bRemoveVideoInNextFrame = true;
								triggerEndVideo = 0;
							}
						}
						else
						{
							//Load video.
							std::string sVideoFile = g_LibraryFileList[n].cFile.Get();
							replaceAll(sVideoFile, ".png", ".mp4");
							if (FileExist((LPSTR)sVideoFile.c_str()))
							{
								iWelcomeVideoID = 0;
								for (int i = 1; i <= 32; i++)
								{
									if (AnimationExist(i) == 0) { iWelcomeVideoID = i; break; }
								}

								if (iWelcomeVideoID > 0)
								{
									if (LoadAnimation((LPSTR)sVideoFile.c_str(), iWelcomeVideoID, g.videoprecacheframes, g.videodelayedload, 1) == false)
									{
										iWelcomeVideoID = -999;
									}
									if (iWelcomeVideoID > 0)
									{
										PlaceAnimation(iWelcomeVideoID, -1, -1, -1, -1);
										SetRenderAnimToImage(iWelcomeVideoID, true);
										PlayAnimation(iWelcomeVideoID);
										SetVideoVolume(100);
									}
								}
							}
							else
							{
								iVideoTriggerTimer = 0; //Failed.
								triggerEndVideo = 0;
							}
						}
					}
					else
					{
						if (n < g_LibraryFileList.size() && !ImGui::IsItemHovered())
						{
							if (iVideoTriggerTimer > 0 && iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID)) {
								bRemoveVideoInNextFrame = true;
								triggerEndVideo = 0;
							}
							iVideoTriggerTimer = 0;
						}
					}
					//#### VIDEO END ####

					// Project Exists if can get dev description
					extern bool g_bFreeTrialVersion;
					bool bProjectExistsAndValidToUse = false;
					static std::string sDevDescription = "";
					if (iFileListEntry >= 0) 
						if (g_LibraryFileList[iFileListEntry].bProjectExists==true) 
							bProjectExistsAndValidToUse = true;

					// Play and Edit Buttons
					ImGui::SetWindowFontScale(1.4);
					float fButWidth = fContentWidth * 0.25 - right_margin;
					ImVec2 vCurPos = ImGui::GetCursorPos();
					ImGui::SetCursorPos(vCurPos + ImVec2(fButWidth*0.5, 12));
					ImVec4 vTextColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
					LPSTR pPlayTextTip = "Play The Game";
					LPSTR pEditTextTip = "Edit The Game";
					if (bProjectExistsAndValidToUse == false)
					{
						if (g_bFreeTrialVersion == true)
						{
							vTextColor = ImVec4(0.9f, 0.9f, 0.9f, 0.5f);
							pPlayTextTip = "Upgrade to the full version to play this demo game";
							pEditTextTip = "Upgrade to the full version to edit this demo game";
						}
					}
					ImGui::PushStyleColor(ImGuiCol_Text, vTextColor);
					if (ImGui::StyleButton("Play Game", ImVec2(fButWidth, 0)))
					{
						if (bProjectExistsAndValidToUse == true)
						{
							bool bUseProjectName = false;
							if (iFileListEntry >= 0)
							{
								if (g_LibraryFileList[iFileListEntry].cProject.Len() > 0)
								{
									if (load_checkproject_storyboard((char *)g_LibraryFileList[iFileListEntry].cProject.Get()))
									{
										//Success use this project name.
										bUseProjectName = true;
									}
								}
							}
							if (bUseProjectName)
							{
								//PE: Launch real standalone, that will return to storyboard when done.
								extern bool g_bCascadeQuitFlag;
								g_bCascadeQuitFlag = true;
								PostQuitMessage(0);
								SetCurrentDirectoryA("..\\");
								char par[MAX_PATH];
								sprintf(par, "project=2%s", g_LibraryFileList[iFileListEntry].cProject.Get());
								ExecuteFile("GameGuruMAX.exe", par, "", 0);
								Sleep(500);
								ExitProcess(0);
							}
							else
							{
								cstr filetoload = cstr("mapbank\\") + sDisplayName + cstr(".fpm");
								strcpy(cDirectOpen, filetoload.Get());
								iLaunchAfterSync = 7; //Direct load.
								iSkibFramesBeforeLaunch = 5;
								bLaunchTestGameAfterLoad = true;
								bWelcomeScreen_Window = false;
								if (current_tutorial_id >= 0) iStopAndFreeThisVideo = current_tutorial_id;
							}
						}
						else
						{
							if (g_bFreeTrialVersion == true)
							{
								extern bool bFreeTrial_Window;
								bFreeTrial_Window = true;
							}
						}
					}
					ImGui::PopStyleColor();
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", pPlayTextTip);
					ImGui::PushStyleColor(ImGuiCol_Text, vTextColor);
					ImGui::SetCursorPos(vCurPos + ImVec2(fButWidth*0.5 + fButWidth + fButWidth, 12));
					if (ImGui::StyleButton("Edit Game", ImVec2(fButWidth, 0)) || bTriggerEditDemoGame)
					{
						if (bProjectExistsAndValidToUse == true)
						{
							bool bUseProjectName = false;
							if (iFileListEntry >= 0)
							{
								if (g_LibraryFileList[iFileListEntry].cProject.Len() > 0)
								{
									if (load_checkproject_storyboard((char *)g_LibraryFileList[iFileListEntry].cProject.Get()))
									{
										//Success use this project name.
										bUseProjectName = true;
									}
								}
							}
							if (bUseProjectName)
							{
								//PE: Edit - Load and start storyboard.
								TriggerLoadGameProject = g_LibraryFileList[iFileListEntry].cProject.Get();
								bWelcomeScreen_Window = false;
								bStoryboardWindow = true;
								if (current_tutorial_id >= 0) iStopAndFreeThisVideo = current_tutorial_id;
							}
							else
							{
								cstr filetoload = cstr("mapbank\\") + sDisplayName + cstr(".fpm");
								strcpy(cDirectOpen, filetoload.Get());
								iLaunchAfterSync = 7; //Direct load.
								iSkibFramesBeforeLaunch = 5;
								bWelcomeScreen_Window = false;
								if (current_tutorial_id >= 0) iStopAndFreeThisVideo = current_tutorial_id;
							}
						}
						else
						{
							if (g_bFreeTrialVersion == true && bTriggerEditDemoGame == false)
							{
								extern bool bFreeTrial_Window;
								bFreeTrial_Window = true;
							}
						}
						bTriggerEditDemoGame = false;
					}
					ImGui::PopStyleColor();
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", pEditTextTip);

					// Project Descriptions and Text
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 8));
					ImGui::SetWindowFontScale(1.8);
					ImVec4 textcol = ImGui::GetStyleColorVec4(ImGuiCol_Button);
					textcol.w = 1.0;
					ImGui::PushStyleColor(ImGuiCol_Text, textcol);
					ImGui::Text(sDisplayName.Get());
					ImGui::PopStyleColor();

					ImGui::SetWindowFontScale(1.2);
					if (iFileListEntry >= 0)
					{
						if (g_LibraryFileList[iFileListEntry].cDescription.Len() > 0)
						{
							if (bUseFullScreen) ImGui::SetWindowFontScale(1.5);
							ImGui::TextWrapped(g_LibraryFileList[iFileListEntry].cDescription.Get());
							ImGui::SetWindowFontScale(1.2);
							static cstr sPrevGame = "";
							if (strcmp(sPrevGame.Get(), sCurrentGame.Get()) != 0)
							{
								sDevDescription = "";
								sPrevGame = sCurrentGame;
								if (sCurrentGame.Len() > 0)
								{
									// Extract the game developer description from the project.dat file.
									char projectname[MAX_PATH];
									strcpy(projectname, sCurrentGame.Get());
									projectname[strlen(projectname) - 4] = 0;
									char project[MAX_PATH];
									strcpy(project, "projectbank\\");
									strcat(project, projectname);
									strcat(project, "\\project.dat");
							
									FILE* projectfile = GG_fopen(project, "rb");
									if (projectfile)
									{
										tempProjectData.game_developer_desc[0] = 0;
										size_t size = fread(&tempProjectData, 1, sizeof(tempProjectData), projectfile);
										//Valid pref:
										fclose(projectfile);
										if(strlen(tempProjectData.game_developer_desc) > 0)
											sDevDescription = tempProjectData.game_developer_desc;

										// Text wrapping is saved into the project data, so unwrap it so it can be wrapped by ImGui at larger font sizes.
										for (int i = 0; i < sDevDescription.length(); i++)
										{
											if (sDevDescription[i] == '\n')
											{
												sDevDescription[i] = ' ';
											}
										}
									}
								}
							}
							if (sDevDescription.length() > 0)
							{
								ImGui::Spacing();
								ImGui::SetWindowFontScale(1.8);
								if (pref.current_style == 25)
								{
									ImVec4 textcol = ImGui::GetStyleColorVec4(ImGuiCol_Button);
									textcol.w = 1.0;
									ImGui::PushStyleColor(ImGuiCol_Text, textcol);
									ImGui::Text("Game Developer");
									ImGui::PopStyleColor();
								}
								else
								{
									ImGui::Text("Game Developer");
								}
								ImGui::SetWindowFontScale(1.5f);
								ImGui::TextWrapped(sDevDescription.c_str());
								ImGui::SetWindowFontScale(1.2);
							}
						}
						ImGui::PushStyleColor(ImGuiCol_Text, textcol);
						ImGui::PopStyleColor();
					}
				}
			}

			vPreviewSize = { fContentWidth , fContentWidth * fRatio };


			ImGui::Text("");

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetWindowSize().y - 72.0f));

			ImGui::Indent(-2);
			ImGui::EndChild();

			ImGui::SetWindowFontScale(2.0); //1.4

			if (iCurrentOpenTab == 4)
			{
				if (ImGui::StyleButton("View the User Guide", ImVec2(vPreviewSize.x + 4.0, fFontSize*2.6))) //*2.0
				{
					//Goto
					/*ExecuteFile("https://gameguru-max.document360.io/docs/test-topic", "", "", 0);*/
					ExecuteFile("https://bit.ly/MAXUserGuide", "", "", 0);
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "View the GameGuru MAX User Guide online"); //Weekly Live Stream
			}
			else if (iCurrentOpenTab == 5)
			{
				if (ImGui::StyleButton("Click here to view the GameGuru MAX YouTube Channel", ImVec2(vPreviewSize.x + 4.0, fFontSize*2.6))) //*2.0
				{
					//Goto
					/*ExecuteFile("https://www.youtube.com/channel/UC1q1e3Q9IKMk4nDlAGb_5Jg", "", "", 0);*/
					ExecuteFile("https://bit.ly/MAXYouTubeChannel", "", "", 0);
				
				}
				//if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click here to view the GameGuru MAX YouTube Channel"); //Weekly Live Stream
			}
			else
			{
				//Changed to project based.
				if (ImGui::StyleButton("Create a New Game Project", ImVec2(vPreviewSize.x+4.0, fFontSize*2.6))) //*2.0
				{
					strcpy(pref.cLastUsedStoryboardProject, "");
					bStoryboardInitNodes = false; //Just init again.
					bStoryboardFirstRunSetInitPos = false;
					process_storeboard(true); //Init a new project.
					bTriggerSaveAsAfterNewLevel = true;
					bTriggerSaveAs = true;
					strcpy(SaveProjectAsName, "");
					strcpy(SaveProjectAsError, "");
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Create a new game project");

				if (bTriggerSaveAs)
				{
					ImGui::SetWindowFontScale(1.0);
					int iCreateRet = save_create_storyboard_project();
					if (iCreateRet == 1)
					{
						//PE: New project created.
						bWelcomeScreen_Window = false;
						bStoryboardWindow = true;
						if (current_tutorial_id >= 0) iStopAndFreeThisVideo = current_tutorial_id;
					}
					if (iCreateRet == 2)
					{
						bTriggerSaveAsAfterNewLevel = false;
						bTriggerSaveAs = false;
					}
					ImGui::SetWindowFontScale(2.0); //1.4
				}

			}

			ImGui::SetWindowFontScale(1.0);

			//###########################################################
			//#### SWAP TOOL_GOBACK was here "Exit GameGuru MAX Hub" ####
			//###########################################################


#ifdef USEWELCOMESCREEN
			if (projectbank_list.size() > 0)
			{
				/*
				bool bTmp = 1 - pref.iDisplayWelcomeScreen;
				float fTextWidth = ImGui::CalcTextSize("Tick to skip welcome screen and start editing the last edited game project and level").x + 20.0f;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvailWidth() - 10.0) * 0.5) - (fTextWidth * 0.5), 0));
				if (ImGui::Checkbox("Tick to skip welcome screen and start editing the last edited game project and level", &bTmp))
				{
					pref.iDisplayWelcomeScreen = 1 - bTmp;
				}
				*/
				//PE: From Rick Hover - "Tick this to skip the Welcome Screen to start editing your current game project" , But its the same text as above so...

				//PE: Hub
				bool bTmp = 1 - pref.iDisplayWelcomeScreen;
				float fTextWidth = ImGui::CalcTextSize("Tick to skip GameGuru MAX Hub and start editing the last edited game project and level").x + 20.0f;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvailWidth() - 10.0) * 0.5) - (fTextWidth * 0.5), 0));
				if (ImGui::Checkbox("Tick to skip GameGuru MAX Hub and start editing the last edited game project and level", &bTmp))
				{
					pref.iDisplayWelcomeScreen = 1 - bTmp;
				}

			}
			//bool bTmp = pref.iDisplayWelcomeScreen;
			//if (ImGui::Checkbox("Untick to skip welcome screen in future", &bTmp))
			//{
			//	pref.iDisplayWelcomeScreen = bTmp;
			//}
#endif


			ImGui::SetWindowFontScale(1.0);
			ImGui::Columns(1);

			ImGui::Indent(-10);

			bImGuiGotFocus = true;

			if (bDisplayAsModal)
				ImGui::EndPopup();
			else
				ImGui::End();
		}
	}

}

void About_Screen(void)
{
	ImGuiWindowFlags ex_window_flags = ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking;
	if (refresh_gui_docking == 0)
	{
		if (iAboutLogoType == 2)
			ImGui::SetNextWindowSize(ImVec2(52 * ImGui::GetFontSize(), 39 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver
		else
			ImGui::SetNextWindowSize(ImVec2(52 * ImGui::GetFontSize(), 30 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver
		ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
		bool bAlwaysTrue = true;
		ImGui::Begin("##About##AboutWindow", &bAlwaysTrue, ex_window_flags);
		ImGui::End();
	}
	else if (bAbout_Window)
	{
		if (bAbout_Window_First_Run)
		{
			if (iAboutLogoType == 2)
				ImGui::SetNextWindowSize(ImVec2(52 * ImGui::GetFontSize(), 39 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver
			else
				ImGui::SetNextWindowSize(ImVec2(52 * ImGui::GetFontSize(), 30 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bAbout_Window_First_Run = false;
		}

		ImGui::Begin("##About##AboutWindow", &bAbout_Window, ex_window_flags);

		ImGui::Text("");

		float fRegionWidth = ImGui::GetWindowContentRegionWidth();
		float img_w = ImageWidth(ABOUT_LOGO);
		float img_h = ImageHeight(ABOUT_LOGO);

		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((fRegionWidth*0.5) - (img_w*0.5), 0.0f));

		ImGui::ImgBtn(ABOUT_LOGO, ImVec2(img_w, img_h), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), 0, 0, 0, 0, false);

		ImGui::TextCenter("");
		char pBuildText[1024];
		sprintf(pBuildText, "Version: %s", g.version_s.Get());
		ImGui::TextCenter(pBuildText);
		ImGui::TextCenter("");

		ImGui::SetWindowFontScale(1.25);
		ImGui::TextCenter("(c) Copyright 2020-2022 The Game Creators Ltd. All Rights Reserved");
		ImGui::SetWindowFontScale(1.0);
		ImGui::TextCenter("GameGuru MAX, TheGameCreators, and their respective logos are trademarks or registred trademarks of The Game Creators Ltd.");
		
		ImGui::Text("");
		ImGui::Text("");
		ImVec2 cp = ImGui::GetCursorPos() + ImVec2(fRegionWidth*0.5 , 0.0f);
		ImGui::SetCursorPos(cp + ImVec2(-200.0f, 0.0f));
		if (ImGui::StyleButton("View Credits", ImVec2(100.0f, 0.0f))) {
			bCredits_Window = true;
			bAbout_Window = false;
			bCredits_Window_First_Run = true;
		}
		ImGui::SameLine();
		ImGui::SetCursorPos(cp + ImVec2(100.0f, 0.0f));
		if (ImGui::StyleButton("OK", ImVec2(100.0f, 0.0f))) {
			bAbout_Window = false;
		}
		ImGui::Text("");

		bImGuiGotFocus = true;

		cstr title = "About";
		float fTextSize = ImGui::CalcTextSize(title.Get()).x;
		float xcenter = (ImGui::GetWindowSize().x*0.5) - (fTextSize*0.5);
		ImVec2 titlebar_pos = ImGui::GetWindowPos() + ImVec2(xcenter, 4);
		ImGuiWindow* window = ImGui::GetCurrentWindow();

		ImGui::End();

		//Render title bar after End. end fill titlebar.
		ImGuiContext& g = *GImGui;
		window->DrawList->AddText(g.Font, g.FontSize, titlebar_pos, ImGui::GetColorU32(ImGuiCol_Text), title.Get());

	}

	//Credits window.
	if (refresh_gui_docking == 0)
	{
		ImGui::SetNextWindowSize(ImVec2(32 * ImGui::GetFontSize(), 52 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver
		ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
		bool bAlwaysTrue = true;
		ImGui::Begin("##Credits##AboutWindow", &bAlwaysTrue, ex_window_flags);
		ImGui::End();
	}
	else if (bCredits_Window)
	{

		if (bCredits_Window_First_Run)
		{
			ImGui::SetNextWindowSize(ImVec2(32 * ImGui::GetFontSize(), 52 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bCredits_Window_First_Run = false;
		}

		ImGui::Begin("##Credits##AboutWindow", &bCredits_Window, ex_window_flags);

		ImGui::Text("");
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, 8.0f));

		float fRegionWidth = ImGui::GetWindowContentRegionWidth();

		ImGui::SetWindowFontScale(1.5);
		ImGui::TextCenter("Programming Team");
		ImGui::SetWindowFontScale(1.0);
		ImGui::Text("");
		ImGui::TextCenter("Lee Bamber");
		ImGui::TextCenter("Preben Eeriksen");
		ImGui::TextCenter("Mike Johnson");
		ImGui::TextCenter("Paul Johnston");
		ImGui::TextCenter("Zak Judges");
		ImGui::TextCenter("Maciej Dowbor");
		ImGui::Text("");

		ImGui::SetWindowFontScale(1.5);
		ImGui::TextCenter("Art & Media Team");
		ImGui::SetWindowFontScale(1.0);
		ImGui::Text("");
		ImGui::TextCenter("Mark Blosser");
		ImGui::TextCenter("Martin Oliver");
		ImGui::TextCenter("Glynn Taylor");
		ImGui::TextCenter("Peter Jovanovic");
		ImGui::TextCenter("Ugur Gokus");
		ImGui::TextCenter("Ispas Gabriela Cristina");
		ImGui::TextCenter("Volkov Studio");
		ImGui::Text("");

		ImGui::SetWindowFontScale(1.5);
		ImGui::TextCenter("Design Team");
		ImGui::SetWindowFontScale(1.0);
		ImGui::Text("");
		ImGui::TextCenter("Lee Bamber");
		ImGui::TextCenter("Richard Vanner");
		ImGui::TextCenter("Meash Meakin");
		ImGui::TextCenter("Stuart Scott");
		
		ImGui::Text("");
		ImGui::SetWindowFontScale(1.5);
		ImGui::TextCenter("Wicked Engine");
		ImGui::SetWindowFontScale(1.0);
		ImGui::Text("");
		ImGui::TextCenter("Janos Turanszki");
		ImGui::TextCenter("www.wickedengine.net");

		ImGui::Text("");
		ImGui::Text("");
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((fRegionWidth*0.5) - (100.0f*0.5), 0.0f));
		if (ImGui::StyleButton("OK", ImVec2(100.0f, 0.0f))) {
			bCredits_Window = false;
			bAbout_Window = false;
		}

		bImGuiGotFocus = true;

		cstr title = "GameGuru MAX Credits";
		float fTextSize = ImGui::CalcTextSize(title.Get()).x;
		float xcenter = (ImGui::GetWindowSize().x*0.5) - (fTextSize*0.5);
		ImVec2 titlebar_pos = ImGui::GetWindowPos() + ImVec2(xcenter, 4);
		ImGuiWindow* window = ImGui::GetCurrentWindow();

		ImGui::End();

		//Render title bar after End. end fill titlebar.
		ImGuiContext& g = *GImGui;
		window->DrawList->AddText(g.Font, g.FontSize, titlebar_pos, ImGui::GetColorU32(ImGuiCol_Text), title.Get());

	}

}

#endif //WICKED

#endif //VRTECH

void FixEulerZInverted(float &ax, float &ay, float &az)
{
	if (ax < 0.0f) ax += 360.0f;
	if (ay < 0.0f) ay += 360.0f;
	if (az < 0.0f) az += 360.0f;
	if (ax > 360.0f) ax -= 360.0f;
	if (ay > 360.0f) ay -= 360.0f;
	if (az > 360.0f) az -= 360.0f;
	bool bZFlipped = false, bXFlipped = false, bXDeadPos = false , bZDeadPos = false;
	if (az >= 179.5f && az <= 180.5f) bZFlipped = true; // 180
	if (ax >= 179.5f && ax <= 180.5f) bXFlipped = true; // 180
	if (ax >= 89.5f && ax <= 90.5f) bXDeadPos = true; // 90
	if (az >= 299.5f && az <= 300.5f) bZDeadPos = true; // 300 Got a 299.7 , so lowered to 299.5.
	if (bZFlipped && bXFlipped)
	{
		//PE: When both z and x flipped it count backward, so 180-ay = real Y without x,z.
		ax = 0.0f;
		az = 0.0f;
		ay = (180.0 - ay);
	}
	else if (!bXDeadPos && bZFlipped)
	{
		ax -= 180.0f;
		ay = (180.0 - ay);
		az = 0.0f;
	}
	else if (bXDeadPos && bZDeadPos)
	{
		//Y dont change. z is just moved to x
		ax = az + 90;
		az = 0.0f;
	}
	if (ax < 0.0f) ax += 360.0f;
	if (ay < 0.0f) ay += 360.0f;
	if (az < 0.0f) az += 360.0f;
	if (ax > 360.0f) ax -= 360.0f;
	if (ay > 360.0f) ay -= 360.0f;
	if (az > 360.0f) az -= 360.0f;
	return;
}

void SetStartPositionsForRubberBand(int iActiveObj)
{
	// for multiple objects
	if (g.entityrubberbandlist.size() > 0)
	{
		// for each object in the selection
		for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
		{
			int e = g.entityrubberbandlist[i].e;
			int tobj = t.entityelement[e].obj;
			if (tobj > 0)
			{
				if (ObjectExist(tobj) == 1)
				{
					// store starting position and orientation of objects
					g.entityrubberbandlist[i].x = ObjectPositionX(tobj) - ObjectPositionX(iActiveObj);
					g.entityrubberbandlist[i].y = ObjectPositionY(tobj) - ObjectPositionY(iActiveObj);
					g.entityrubberbandlist[i].z = ObjectPositionZ(tobj) - ObjectPositionZ(iActiveObj);
					if (t.entityelement[e].quatmode == 1)
					{
						g.entityrubberbandlist[i].quatAngle = GGQUATERNION(t.entityelement[e].quatx, t.entityelement[e].quaty, t.entityelement[e].quatz, t.entityelement[e].quatw);
					}
					else
					{
						GGQUATERNION QuatAroundX, QuatAroundY, QuatAroundZ;
						GGQuaternionRotationAxis(&QuatAroundX, &GGVECTOR3(1, 0, 0), GGToRadian(ObjectAngleX(tobj)));
						GGQuaternionRotationAxis(&QuatAroundY, &GGVECTOR3(0, 1, 0), GGToRadian(ObjectAngleY(tobj)));
						GGQuaternionRotationAxis(&QuatAroundZ, &GGVECTOR3(0, 0, 1), GGToRadian(ObjectAngleZ(tobj)));
						g.entityrubberbandlist[i].quatAngle = QuatAroundX * QuatAroundY * QuatAroundZ;
					}
				}
			}
		}
	}
}

void RotateAndMoveRubberBand(int iActiveObj, float fMovedActiveObjectX, float fMovedActiveObjectY, float fMovedActiveObjectZ, GGQUATERNION quatRotationEvent )//float fMovedActiveObjectRX, float fMovedActiveObjectRY, float fMovedActiveObjectRZ)
{
	// for multiple objects
	if (g.entityrubberbandlist.size() > 0)
	{
		// for each object in the selection
		for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
		{
			int e = g.entityrubberbandlist[i].e;
			int tobj = t.entityelement[e].obj;
			if (tobj > 0 && t.entityelement[e].editorlock == 0)
			{
				if (ObjectExist(tobj) == 1)
				{
					if (tobj != iActiveObj)
					{
						// this object rotyation quat
						GGQUATERNION quatThisOrientation = g.entityrubberbandlist[i].quatAngle;

						// apply the rotation event to the object angle
						GGQUATERNION quatNewOrientation;
						GGQuaternionMultiply(&quatNewOrientation, &quatThisOrientation, &quatRotationEvent);

						// rotate this object with final quat and get new entity rotation eulers
						RotateObjectQuat(tobj, quatNewOrientation.x, quatNewOrientation.y, quatNewOrientation.z, quatNewOrientation.w);
						
						// final angles
						t.entityelement[e].rx = WrapValue(ObjectAngleX(tobj));
						t.entityelement[e].ry = WrapValue(ObjectAngleY(tobj));
						t.entityelement[e].rz = WrapValue(ObjectAngleZ(tobj));

						// and store the quat
						entity_updatequat(e, quatNewOrientation.x, quatNewOrientation.y, quatNewOrientation.z, quatNewOrientation.w);

						// apply the rotation event to the position
						GGVECTOR3 positionalOffset;
						positionalOffset.x = g.entityrubberbandlist[i].x;
						positionalOffset.y = g.entityrubberbandlist[i].y;
						positionalOffset.z = g.entityrubberbandlist[i].z;
						GGMATRIX matRotatePositions;
						GGMatrixRotationQuaternion(&matRotatePositions, &quatRotationEvent);
						GGVec3TransformCoord(&positionalOffset, &positionalOffset, &matRotatePositions);

						// if object was static, flag that static object moved
						if (t.entityelement[e].staticflag == 1) g.projectmodifiedstatic = 1;

						// put new adjusted positions back
						t.entityelement[e].x = ObjectPositionX(iActiveObj) + positionalOffset.x;
						t.entityelement[e].y = ObjectPositionY(iActiveObj) + positionalOffset.y;
						t.entityelement[e].z = ObjectPositionZ(iActiveObj) + positionalOffset.z;

						// update entity to new offset position if any movement
						t.entityelement[e].x = t.entityelement[e].x + fMovedActiveObjectX;
						t.entityelement[e].y = t.entityelement[e].y + fMovedActiveObjectY;
						t.entityelement[e].z = t.entityelement[e].z + fMovedActiveObjectZ;

						// finally update latest object position
						PositionObject(tobj, t.entityelement[e].x, t.entityelement[e].y, t.entityelement[e].z);

						// update light data for spot
						if (t.entityelement[e].eleprof.usespotlighting)	lighting_refresh();

						// move zones and lights if in group
						widget_movezonesandlights(e);
					}
				}
			}
		}
	}
}

#ifdef WICKEDENGINE
void SetLightShaftState(bool bState)
{
	if (master_renderer) master_renderer->setLightShaftsEnabled(bState);
}
bool GetLightShaftState(void)
{
	if (master_renderer) return master_renderer->getLightShaftsEnabled();
	return false;
}

bool GetLensFlareState()
{
	if (master_renderer) return master_renderer->getLensFlareEnabled();
	return false;
}
void SetLensFlareState(bool bState)
{
	if (master_renderer) master_renderer->setLensFlareEnabled(bState);
}

void editor_toggle_element_vis(bool bIsVisible)
{
	if (t.game.gameisexe == 1) return; //PE: This trigger a 7018 error in standalone. from DrawLogicNodes();

	// hide all markers from view: win zones, player start, image zones etc.
	for (t.e = 1; t.e <= g.entityelementlist; t.e++)
	{
		t.entid = t.entityelement[t.e].bankindex;
		t.obj = t.entityelement[t.e].obj;
		if (t.obj > 0)
		{
			if (ObjectExist(t.obj) == 1)
			{
				if (t.entityprofile[t.entid].ismarker)
				{
					if (bIsVisible)
					{
						ShowObject(t.obj);
					}
					else
					{
						HideObject(t.obj);
					}
				}
			}
		}
	}

	// hide show waypoints
	if (bIsVisible)
	{
		for (t.waypointindex = 1; t.waypointindex <= g.waypointmax; t.waypointindex++)
		{
			t.obj = g.editorwaypointoffset + t.waypointindex;
			if (ObjectExist(t.obj) == 1)
			{
				ShowObject(t.obj);
				t.waypoint[t.waypointindex].active = 1;
			}
		}
	}
	else
	{
		for (t.waypointindex = 1; t.waypointindex <= g.waypointmax; t.waypointindex++)
		{
			t.obj = g.editorwaypointoffset + t.waypointindex;
			if (ObjectExist(t.obj) == 1)
			{
				HideObject(t.obj);
			}
		}

		if (ObjectExist(g.editorwaypointoffset + 0) == 1) 
		{
			HideObject(g.editorwaypointoffset + 0);
		}
	}

	// hide show relational lines
	extern bool g_bDotsAreVisible;
	if (t.showeditorelements)
	{
		if (g_bDotsAreVisible==false)
		{
			DrawLogicNodes(true);
			g_bDotsAreVisible = true;
		}
	}
	else
	{
		if (g_bDotsAreVisible==true)
		{
			DrawLogicNodes(false);
			g_bDotsAreVisible = false;
		}
	}

	//  Deactivate widget if still in effect
	if (!bIsVisible)
	{
		widget_switchoff();

		//  Deactivate floating selection of entity
		if (t.grideditselect != 5 && t.grideditselect != 4)
		{
			if (t.grideditselect != 5) HideObject(t.editor.objectstartindex + 5);
			t.gridentity = 0; t.gridentityposoffground = 0;
			t.gridentityusingsoftauto = 0;
			t.gridentitysurfacesnap = 1 - g.gdisablesurfacesnap;
			#ifdef WICKEDENGINE
			// MAX handles its own positioning system
			t.gridentityautofind = 0;
			#else
			t.gridentityautofind = 1;
			#endif
			t.inputsys.dragoffsetx_f = 0;
			t.inputsys.dragoffsety_f = 0;
		}
	}
	//  Update entity cursor? (delete many of these as it WAS old shroud updater!)
	t.refreshgrideditcursor = 1;

	//  Update clipboard items based on mode
	//editor_cutcopyclearstate();

	//  Waypoint visibility
	if (t.grideditselect != t.lastgrideditselect)
	{
		t.lastgrideditselect = t.grideditselect;
		if (t.grideditselect == 6)
		{
			waypoint_showallpaths();
		}
		else
		{
			if (t.inputsys.dowaypointview == 0)
			{
				waypoint_showallpaths();
			}
			else
			{
				waypoint_hideallpaths();
			}
		}
	}

#ifdef WICKEDENGINE
	// clear any gridentity light if gridentity no longer used
	if (t.gridentity == 0)
	{
		if (t.gridentitywickedlightindex > 0)
		{
			WickedCall_DeleteLight(t.gridentitywickedlightindex);
			t.gridentitywickedlightindex = 0;
		}
	}
#endif
	// editor refresh
	//ditor_refresheditmarkers();
}


bool DoTreeNodeEntity(int masterid)
{

	for (int i = 1; i < t.entityelement.size(); i++)
	{
		bool bValid = true;
		if (t.entityelement[i].iIsSmarkobjectDummyObj == 1) bValid = false;
		if (bValid)
		{
			if (masterid > 0 && t.entityelement[i].bankindex == masterid || (t.widget.pickedEntityIndex == i && t.gridentity == masterid))
			{

				char cName[512];
				strcpy(cName, t.entityprofileheader[masterid].desc_s.Get());
				if(t.entityelement[i].eleprof.name_s.Len()  > 0 )
					strcpy(cName, t.entityelement[i].eleprof.name_s.Get());

				ImGuiTreeNodeFlags node_flags = ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_OpenOnArrow; //Got sub selections.

				node_flags = ImGuiTreeNodeFlags_Leaf; //No sub selections.

				bool bSelected = false;
				//Find selection here.
				if (bSelected)
					node_flags |= ImGuiTreeNodeFlags_Selected;
				else
					node_flags &= ~ImGuiTreeNodeFlags_Selected;

				ImGui::PushItemWidth(-20.0); //PE: Room for a icon.


				std::string treename = "#" + std::to_string(i);
				if (t.widget.pickedEntityIndex == i && t.gridentity == masterid)
					treename = treename + " (Cursor) " + cName;
				else
					treename = treename + " " + cName;
				//treename[0] = toupper(treename[0]);
				bool TreeNodeOpen = ImGui::TreeNodeEx((void*)(intptr_t)(i + 90000), node_flags, treename.c_str());
				ImGui::PopItemWidth();

				//PE: Select on mouse release.
				if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(0))
				{
					//PE: Find object in scene. and move camera. and select to cursor.
					if (t.entityelement[i].obj > 0)
					{
						t.widget.pickedEntityIndex = i;
						t.widget.pickedObject = t.entityelement[t.widget.pickedEntityIndex].obj;
						g.entityrubberbandlist.clear();

						bEditorInFreeFlightMode = true; //PE: Must be in freeflight mode.
						t.editorfreeflight.mode = 1;

						int group = isEntityInGroupList(t.widget.pickedEntityIndex);
						if (group >= 0)
						{
							//PE: Add all groups with entity to rubberband.
							CheckGroupListForRubberbandSelections(t.widget.pickedEntityIndex);
						}

						float zoom = ObjectSize(t.entityelement[i].obj, 1)*2.0;
						if (zoom < 30.0f) zoom = 30.0f;
						float realcamy = ObjectSizeY(t.entityelement[i].obj, 1) * 0.75;
						float camy = realcamy;
						if (camy < 30.0f) camy = 30.0f;

						if (t.entityprofile[masterid].ismarker > 0)
						{
							//Markers, just move a bit away.
							zoom = 100.0;
							camy = 50.0;
						}
						//PE: Move camera keep camera Y.
						//float camy = CameraPositionY(0);
						PositionCamera(t.entityelement[i].x, t.entityelement[i].y, t.entityelement[i].z);
						PointCamera(t.entityelement[i].x, t.entityelement[i].y, t.entityelement[i].z);
						MoveCamera(0, -zoom);
						PositionCamera(CameraPositionX(0), t.entityelement[i].y + camy, CameraPositionZ(0));
						PointCamera(t.entityelement[i].x, t.entityelement[i].y + (realcamy*0.5), t.entityelement[i].z);
						t.editorfreeflight.c.x_f = CameraPositionX();
						t.editorfreeflight.c.y_f = CameraPositionY();
						t.editorfreeflight.c.z_f = CameraPositionZ();
						t.editorfreeflight.c.angx_f = CameraAngleX();
						t.editorfreeflight.c.angy_f = CameraAngleY();
						//t.editorfreeflight.c.angz_f = CameraAngleZ();
						//RotateCamera(t.editorfreeflight.c.angx_f, t.editorfreeflight.c.angy_f, 0);

						t.cx_f = t.editorfreeflight.c.x_f;
						t.cy_f = t.editorfreeflight.c.z_f;
					}
				}

				if (TreeNodeOpen) {
					//ImGui::Indent(-5);
					//Display any sub nodes. smart objects.
					//ImGui::Indent(5);
					ImGui::TreePop();
				}
			}
		}
	}
	return(0);
}


void SetupDecalObject(int obj, int elementID)
{
	//SetAlphaMappingOn(obj, 100.0);
	SetObjectTransparency(obj, 6);
	SetObjectLight(obj, 0);
	sObject* pObject = g_ObjectList[obj];
	if (pObject)
	{
		//PE: SetObjectCull(t.tobj, 1); Dont work.
		//PE: iCullMode need to be zero in wicked ?
		for (int iMesh = 0; iMesh < pObject->iMeshCount; iMesh++)
		{
			if (pObject->ppMeshList[iMesh]) pObject->ppMeshList[iMesh]->iCullMode = 0;
		}
		WickedCall_SetObjectCullmode(pObject);
		WickedCall_SetObjectCastShadows(pObject, false); //PE: No shadows on particles for now.

		if(!t.entityelement[elementID].eleprof.bCustomWickedMaterialActive) // ZJ: Only reset this if not using custom materials for this decal.
		{
			//PE: Use unlit shader.
			for (int iMesh = 0; iMesh < pObject->iMeshCount; iMesh++)
			{
				sMesh* pMesh = pObject->ppMeshList[iMesh];
				if (pMesh)
				{
					pMesh->mMaterial.Diffuse.r = 1.5;
					pMesh->mMaterial.Diffuse.g = 1.5;
					pMesh->mMaterial.Diffuse.b = 1.5;
					pMesh->mMaterial.Diffuse.a = 1.0;

					pMesh->mMaterial.Diffuse.a = 1.0;
					pMesh->mMaterial.Emissive.r = 1.0;
					pMesh->mMaterial.Emissive.g = 1.0;
					pMesh->mMaterial.Emissive.b = 1.0;
					pMesh->mMaterial.Emissive.a = 1.0;

					wiScene::MeshComponent* mesh = wiScene::GetScene().meshes.GetComponent(pMesh->wickedmeshindex);
					if (mesh)
					{
						uint64_t materialEntity = mesh->subsets[0].materialID;
						wiScene::MaterialComponent* pObjectMaterial = wiScene::GetScene().materials.GetComponent(materialEntity);
						if (pObjectMaterial)
						{
							pObjectMaterial->SetReflectance(0.0f);
							pObjectMaterial->shaderType = wiScene::MaterialComponent::SHADERTYPE_UNLIT; //PE: Yes 1:1 mapping and no light,env...
							pObjectMaterial->SetDirty(true);
						}
					}
					WickedCall_SetMeshMaterial(pMesh);
					if (elementID > 0)
					{
						WickedCall_SetMeshAlpha(pMesh, t.entityelement[elementID].fDecalOpacity * 100.0);
					}
				}
			}
		}
	}
}

// Sets the contents of a file in local app data with the path to the writable area.
// Used by the Updater to backup the writable area.
void SetUpdaterWritePathFile(char* sContents)
{
	cstr sUpdaterWritePath = defaultWriteFolder;
	sUpdaterWritePath += "writepath.ini";
	if (FileOpen(1)) CloseFile(1);
	if (FileExist(sUpdaterWritePath.Get())) DeleteAFile(sUpdaterWritePath.Get());
	OpenToWrite(1, sUpdaterWritePath.Get());
	WriteString(1, sContents);
	CloseFile(1);
}

void loadMarketplaceData(int* ggMaxDlc, cstr* ggMaxLink, int* sketchfabDlc, cstr* sketchfabLink, int* shockwaveDlc, cstr* shockwaveLink, int* communityDlc, cstr* communityLink, int* gcStoreDlc, cstr* gcStoreImageURL, cstr* gcStoreLink)
{
	#ifdef WICKEDENGINE
	std::ifstream fileRead;
	nlohmann::json jsonFile;
	int numOfPromoItems = 8;

	fileRead.open("editors\\marketplace\\MarketplaceData.json");
	if (fileRead.is_open())
	{
		fileRead >> jsonFile;
		numOfPromoItems = jsonFile["numberOfPromotionalItems"];
		std::string mainDir = jsonFile["mainMarketplaceDirectory"];
		std::string imageName = "";
		std::string link = "";
		std::string fullImageDir = "";

		//Have to convert strings to chars for LoadImage() to take it in
		char converter[254];

		for (int i = 0; i < numOfPromoItems; i++)
		{
			//GG MAX DLC
			//Thumb
			ggMaxDlc[i] = MARKETPLACE_ICONS + i;
			imageName = jsonFile["ggMaxDLC"][i]["imageName"];
			fullImageDir = mainDir + imageName;
			strcpy(converter, fullImageDir.c_str());
			LoadImage(converter, ggMaxDlc[i]);

			//Link
			if (g_bUpdateAppAvailable) { link = jsonFile["ggMaxDLC"][i]["tgcLink"]; } //Checks if the user is on steam
			else { link = jsonFile["ggMaxDLC"][i]["steamLink"]; }
			strcpy(converter, link.c_str());
			ggMaxLink[i] = converter;

			//Sketchfab DLC
			//Thumb
			sketchfabDlc[i] = MARKETPLACE_ICONS + i + numOfPromoItems;
			imageName = jsonFile["sketchfabDLC"][i]["imageName"];
			fullImageDir = mainDir + imageName;
			strcpy(converter, fullImageDir.c_str());
			LoadImage(converter, sketchfabDlc[i]);

			//Link
			link = jsonFile["sketchfabDLC"][i]["websiteLink"];
			strcpy(converter, link.c_str());
			sketchfabLink[i] = converter;

			//Shockwave DLC
			//Thumb
			shockwaveDlc[i] = MARKETPLACE_ICONS + i + (numOfPromoItems * 2);
			imageName = jsonFile["shockwaveDLC"][i]["imageName"];
			fullImageDir = mainDir + imageName;
			strcpy(converter, fullImageDir.c_str());
			LoadImage(converter, shockwaveDlc[i]);

			//Link
			link = jsonFile["shockwaveDLC"][i]["websiteLink"];
			strcpy(converter, link.c_str());
			shockwaveLink[i] = converter;

			//Community DLC
			//Thumb
			communityDlc[i] = MARKETPLACE_ICONS + i + (numOfPromoItems * 3);
			imageName = jsonFile["communityDLC"][i]["imageName"];
			fullImageDir = mainDir + imageName;
			strcpy(converter, fullImageDir.c_str());
			LoadImage(converter, communityDlc[i]);

			//Link
			link = jsonFile["communityDLC"][i]["websiteLink"];
			strcpy(converter, link.c_str());
			communityLink[i] = converter;

			//Game Creator Store DLC
			gcStoreDlc[i] = MARKETPLACE_ICONS + i + (numOfPromoItems * 4);
		}
	}
	fileRead.close();

	// additional system can replace the fixed 'Game Creator Store DLC' if a live connection can be had
	bool bUpdateGameCreatorStoreLive = true;
	if (bUpdateGameCreatorStoreLive)
	{
		// needed data reserve
		char pDataReturned[132000];
		char pDatatmp[132000];
		char cUrl[10240];

		// list we need
		std::vector<cstr> ItemName;
		std::vector<cstr> ItemURL;
		std::vector<cstr> ItemImage;

		// call API to get featured items in list
		memset(pDataReturned, 0, sizeof(pDataReturned));
		memset(pDatatmp, 0, sizeof(pDatatmp));
		DWORD dwDataReturnedSize = 0;
		sprintf(cUrl, "/api/max/featured/products");

		// access features list from store server
		UINT iError = StoreOpenURLForDataOrFile(NULL, pDataReturned, &dwDataReturnedSize, "", "GET", cUrl, NULL);
		if (iError <= 0 && *pDataReturned != 0 && strchr(pDataReturned, '{') != 0)
		{
			char* pChop = NULL;
			if ((pChop = (char *)pestrcasestr(pDataReturned, "{\"status\":\"success\"")) != NULL)
			{
				// data we need from each entry
				char pItemName[1024];
				char pStoreURL[1024];
				char pThumbURL[10240];

				// go through all items until no more names
				while (ItemName.size() < 8)
				{
					int iResultCount = 0;
					char pSearchForToken[256];
					strcpy(pSearchForToken, "\"name\"\0");
					if (pChop)
					{
						pChop = strstr(pChop, pSearchForToken);
						if (pChop)
						{
							pChop += strlen(pSearchForToken) + 2;
							strcpy(pDatatmp, pChop);
							char* pFindEnd = strstr(pDatatmp, "\"\0");
							if (pFindEnd)
							{
								pDatatmp[pFindEnd - pDatatmp] = 0;
								if (strlen(pDatatmp) < 256)
								{
									strcpy(pItemName, pDatatmp);
									iResultCount++;
								}
								pChop = pFindEnd + 1;
							}
							strcpy(pSearchForToken, "\"thumbnail_url\"\0");
							pChop = strstr(pChop, pSearchForToken);
							if (pChop)
							{
								pChop += strlen(pSearchForToken) + 2;
								strcpy(pDatatmp, pChop);
								char* pFindEnd = strstr(pDatatmp, "\"\0");
								pDatatmp[pFindEnd - pDatatmp] = 0;
								if (strlen(pDatatmp) < 10240)
								{
									strcpy(pThumbURL, pDatatmp);
									iResultCount++;
								}
								pChop = pFindEnd + 1;
							}
							if (pChop)
							{
								strcpy(pSearchForToken, "\"store_url\"\0");
								pChop = strstr(pChop, pSearchForToken);
								if (pChop)
								{
									pChop += strlen(pSearchForToken) + 2;
									strcpy(pDatatmp, pChop);
									char* pFindEnd = strstr(pDatatmp, "\"\0");
									pDatatmp[pFindEnd - pDatatmp] = 0;
									if (strlen(pDatatmp) < 256)
									{
										strcpy(pStoreURL, pDatatmp);
										iResultCount++;
									}
									pChop = pFindEnd + 1;
								}
							}
							if (iResultCount == 3)
							{
								// add results if valid
								ItemName.push_back(pItemName);
								ItemURL.push_back(pStoreURL);
								ItemImage.push_back(pThumbURL);
							}
						}
						else
						{
							// no more item names, leave now
							break;
						}
					}
					else
					{
						// less than eight
						break;
					}
				}
			}
		}

		// go through ItemImage list and fill gcStoreImageURL
		int iMaximumOfEight = ItemImage.size();
		if (iMaximumOfEight > 8) iMaximumOfEight = 8;
		for (int i = 0; i < iMaximumOfEight; i++)
		{
			// ItemName not carried back
			gcStoreLink[i] = ItemURL[i] + "?r=tgc";
			gcStoreImageURL[i] = ItemImage[i];
		}
	}

	#endif // WICKEDENGINE
}

#endif //Wickedengine

#ifdef WICKEDENGINE
int current_icon_set = -1;
bool bTriggerIconSetChange = false;

void SetIconSet(bool bInstant)
{
	//PE: This need to be done as the first, or we could change a image that is already on screen (crash).
	bTriggerIconSetChange = true;
	if (bInstant) SetIconSetCheck(bInstant);
}
void SetIconSetCheck(bool bInstant)
{
	if (bInstant == false && !bTriggerIconSetChange) return;
	
	bTriggerIconSetChange = false;

	//PE: These should be change when changing style.
	if (current_icon_set != pref.current_style)
	{
		SetMipmapNum(1); //PE: mipmaps not needed.
		image_setlegacyimageloading(true);
		if (pref.current_style == 25 || pref.current_style == 3)
		{
			LoadImage("editors\\uiv3\\entity_particle.png", ENTITY_PARTICLE);
			LoadImage("editors\\uiv3\\entity_light.png", ENTITY_LIGHT);
			LoadImage("editors\\uiv3\\entity_win.png", ENTITY_WIN);
			LoadImage("editors\\uiv3\\entity_image.png", ENTITY_IMAGE);
			LoadImage("editors\\uiv3\\entity_music.png", ENTITY_MUSIC);
			LoadImage("editors\\uiv3\\entity_sound.png", ENTITY_SOUND);
			LoadImage("editors\\uiv3\\entity_text.png", ENTITY_TEXT);
			LoadImage("editors\\uiv3\\entity_video.png", ENTITY_VIDEO);
			LoadImage("editors\\uiv3\\entity_start.png", ENTITY_START);
			LoadImage("editors\\uiv3\\entity_checkpoint.png", ENTITY_CHECKPOINT); //
			LoadImage("editors\\uiv3\\shooter_flag.png", ENTITY_FLAG); //
			LoadImage("editors\\uiv3\\shooter_guns.png", ENTITY_GUNS); // Not used anymore?
			LoadImage("editors\\uiv3\\shooter_ammo.png", ENTITY_AMMO); // Not used anymore?
			LoadImage("editors\\uiv3\\shooter_enemies.png", ENTITY_ENEMIES); // Not used anymore?
			LoadImage("editors\\uiv3\\shooter_allies.png", ENTITY_ALLIES); // Not used anymore?
			LoadImage("editors\\uiv3\\entity_triggerzone.png", ENTITY_TRIGGERZONE);


			LoadImage("editors\\uiv3\\ccp-hat.png", CCP_HAT);
			LoadImage("editors\\uiv3\\ccp-feet.png", CCP_FEET);
			LoadImage("editors\\uiv3\\ccp-legs.png", CCP_LEGS);
			LoadImage("editors\\uiv3\\ccp-body.png", CCP_BODY);
			LoadImage("editors\\uiv3\\ccp-glasses.png", CCP_GLASSES);
			LoadImage("editors\\uiv3\\ccp-beard.png", CCP_BEARD);
			LoadImage("editors\\uiv3\\ccp-hair.png", CCP_HAIR);
			LoadImage("editors\\uiv3\\ccp-head.png", CCP_HEAD);
			LoadImage("editors\\uiv3\\ccp-tattoo.png", CCP_TATTOO);

			LoadImage("editors\\uiv3\\filetype-script.png", FILETYPE_SCRIPT);

		}
		else
		{
			LoadImage("editors\\uiv3\\entity_particle2.png", ENTITY_PARTICLE);
			LoadImage("editors\\uiv3\\entity_light2.png", ENTITY_LIGHT);
			LoadImage("editors\\uiv3\\entity_win2.png", ENTITY_WIN);
			LoadImage("editors\\uiv3\\entity_image2.png", ENTITY_IMAGE);
			LoadImage("editors\\uiv3\\entity_music2.png", ENTITY_MUSIC);
			LoadImage("editors\\uiv3\\entity_sound2.png", ENTITY_SOUND);
			LoadImage("editors\\uiv3\\entity_text2.png", ENTITY_TEXT);
			LoadImage("editors\\uiv3\\entity_video2.png", ENTITY_VIDEO);
			LoadImage("editors\\uiv3\\entity_start2.png", ENTITY_START);
			LoadImage("editors\\uiv3\\entity_checkpoint2.png", ENTITY_CHECKPOINT); //
			LoadImage("editors\\uiv3\\shooter_flag2.png", ENTITY_FLAG); //
			LoadImage("editors\\uiv3\\shooter_guns2.png", ENTITY_GUNS);
			LoadImage("editors\\uiv3\\shooter_ammo2.png", ENTITY_AMMO);
			LoadImage("editors\\uiv3\\shooter_enemies2.png", ENTITY_ENEMIES);
			LoadImage("editors\\uiv3\\shooter_allies2.png", ENTITY_ALLIES);
			LoadImage("editors\\uiv3\\entity_triggerzone2.png", ENTITY_TRIGGERZONE);

			LoadImage("editors\\uiv3\\ccp-hat2.png", CCP_HAT);
			LoadImage("editors\\uiv3\\ccp-feet2.png", CCP_FEET);
			LoadImage("editors\\uiv3\\ccp-legs2.png", CCP_LEGS);
			LoadImage("editors\\uiv3\\ccp-body2.png", CCP_BODY);
			LoadImage("editors\\uiv3\\ccp-glasses2.png", CCP_GLASSES);
			LoadImage("editors\\uiv3\\ccp-beard2.png", CCP_BEARD);
			LoadImage("editors\\uiv3\\ccp-hair2.png", CCP_HAIR);
			LoadImage("editors\\uiv3\\ccp-head2.png", CCP_HEAD);
			LoadImage("editors\\uiv3\\ccp-tattoo2.png", CCP_TATTOO);

			LoadImage("editors\\uiv3\\filetype-script2.png", FILETYPE_SCRIPT);

		}
		current_icon_set = pref.current_style;
		image_setlegacyimageloading(false);
		SetMipmapNum(-1);
	}
	//----
}

int get_gameisexe(void)
{
	return(t.game.gameisexe);
}

#ifdef STORYBOARD

#define STORYBOARD_INCLUDE_LOADGAME //PE: Not ready yet, also missing "in between game menu" graphics/music setup ...

#define STORYBOARD_SAVE_MESSAGE "Do you wish to save your game project first ?"
#define STORYBOARD_YSTART 30

//PE: Undo redo will be hole structure copy.
//#define STORYBOARD_UNDO_MAX 10
//StoryboardStruct Storyboard_Undo[STORYBOARD_UNDO_MAX];
//int iStoryboardUndoIndex = 0;

//PE: Not needed in save struct.
int StoryboardiActiveLinksId[STORYBOARD_MAXNODES];
int StoryboardiActiveLinksIdFrom[STORYBOARD_MAXNODES];

void reset_single_node(int node)
{
	int i = node;
	//PE: Dont touch id's they are reused.
	Storyboard.Nodes[i].used = false;
	Storyboard.Nodes[i].type = 0;
	if (ImageExist(Storyboard.Nodes[i].thumb_id)) DeleteImage(Storyboard.Nodes[i].thumb_id);
	Storyboard.Nodes[i].restore_position = ImVec2(0, 0);
	Storyboard.Nodes[i].iEditEnable = true;
	strcpy(Storyboard.Nodes[i].title, "");
	strcpy(Storyboard.Nodes[i].levelnumber, "");
	strcpy(Storyboard.Nodes[i].thumb, "");
	strcpy(Storyboard.Nodes[i].lua_name, "");
	strcpy(Storyboard.Nodes[i].level_name, "");
	//Each filler have its own, so can count it down later.
	Storyboard.Nodes[i].screen_backdrop_transparent = false;
	
	for (int l = 0; l < 19; l++) Storyboard.Nodes[i].iFiller20[l] = 0;
	for (int l = 0; l < 20; l++) Storyboard.Nodes[i].fFiller20[l] = 0.0;
	for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
	{
		for (int ll = 0; ll < 20; ll++) Storyboard.Nodes[i].iFillerMaxOutputs20[ll][l] = 0.0;
		for (int ll = 0; ll < 20; ll++) strcpy(Storyboard.Nodes[i].FillerCharMaxOutput20[ll][l],"");
		strcpy(Storyboard.Nodes[i].output_action[l], "");
		strcpy(Storyboard.Nodes[i].output_title[l], "");
		Storyboard.Nodes[i].output_linkto[l] = 0;
		Storyboard.Nodes[i].output_can_link_to_type[l] = 0;
		strcpy(Storyboard.Nodes[i].input_title[l], "");
		strcpy(Storyboard.Nodes[i].input_action[l], "");
	}

	//Screen
	strcpy(Storyboard.Nodes[i].screen_title, "");
	strcpy(Storyboard.Nodes[i].screen_music, "");
	Storyboard.Nodes[i].screen_grid_size = 0;
	strcpy(Storyboard.Nodes[i].screen_backdrop, "");
	Storyboard.Nodes[i].screen_back_color = ImVec4(0.0,0.0,0.0,1.0);
	Storyboard.Nodes[i].screen_backdrop_placement = 2; // center,stretch,zoom. PE: Default to zoom.
	strcpy(Storyboard.Nodes[i].screen_thumb, "");
	for(int ll = 0 ; ll < 10 ; ll++ )
		Storyboard.Nodes[i].screen_backdrop_ratio_placement[ll] = 0; // 0=1920x1080 center,stretch,zoom. 1=1366x768 center,stretch,zoom ...

	//Editor.
	for (int ll = 0; ll < STORYBOARD_MAXWIDGETS; ll++)
	{
		Storyboard.Nodes[i].widget_used[ll] = 0;
		strcpy(Storyboard.Nodes[i].widget_label[ll],"");
		Storyboard.Nodes[i].widget_size[ll] = ImVec2(1.0, 1.0); // size zoom.
		Storyboard.Nodes[i].widget_pos[ll] = ImVec2(0, 0);
		strcpy(Storyboard.Nodes[i].widget_normal_thumb[ll], "");
		strcpy(Storyboard.Nodes[i].widget_highlight_thumb[ll], "");
		strcpy(Storyboard.Nodes[i].widget_selected_thumb[ll], ""); //only for state change button, checkbox ...
		strcpy(Storyboard.Nodes[i].widget_click_sound[ll], "");
		Storyboard.Nodes[i].widget_action[ll] = 0; // 0=none ...
		strcpy(Storyboard.Nodes[i].widget_font[ll], "Default Font");
		Storyboard.Nodes[i].widget_font_color[ll] = ImVec4(1.0, 1.0, 1.0, 1.0);
		Storyboard.Nodes[i].widget_font_size[ll] = 1.0;
		Storyboard.Nodes[i].widget_type[ll] = 0; // 0=none,but,text,image,video...
		Storyboard.Nodes[i].widget_layer[ll] = 0;
		Storyboard.Nodes[i].widget_output_pin[ll] = 0; //off,level,screen.
		strcpy(Storyboard.Nodes[i].widget_name[ll], "");
		Storyboard.Nodes[i].widget_read_only[ll] = 0; //off,level,screen.
		
		Storyboard.NodeSliderValues[i][ll] = 0.0;
	}

	Storyboard.NodeRadioButtonSelected[i] = -1;
}

int iLoadGameNodeID = 3;
int iTitleScreenNodeID = 1;
int iGamePausedNodeID = 8;
int iSaveGameNodeID = 9;
int iGraphicsNodeID = 10;
int iSoundsNodeID = 11;

int iControlNodeID = 12;

int iLoadingScreenNodeID = 2;
int iAboutScreenNodeID = 4;
int iGameWonScreenNodeID = 5;
int iGameLostScreenNodeID = 6;



void storeboard_init_nodes(float area_width, float node_width, float node_height)
{
	if (bStoryboardInitNodes) return;
	bStoryboardInitNodes = true;

	iLoadGameNodeID = 3;
	iTitleScreenNodeID = 1;
	iGamePausedNodeID = 8;
	iSaveGameNodeID = 9;
	iGraphicsNodeID = 10;
	iSoundsNodeID = 11;

	int iUniqueIds = STORYBOARD_THUMBS;
	//PE: init nodes.
	strcpy(Storyboard.gamename,""); //Start with no name,
	Storyboard.iStoryboardVersion = STORYBOARDVERSION;
	Storyboard.iChanged = false;
	Storyboard.vEditorPanning = ImVec2(0.0f, 0.0f);

	strcpy(Storyboard.game_icon, "");
	strcpy(Storyboard.game_thumb, "");
	strcpy(Storyboard.game_description, "Game Description");
	strcpy(Storyboard.game_world_edge_text, "You cannot leave the area of play");
	strcpy(Storyboard.game_developer_desc, "");

	Storyboard.project_readonly = 0;

	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		reset_single_node(i);

		StoryboardiActiveLinksId[i] = 0;
		StoryboardiActiveLinksIdFrom[i] = 0;

		//PE: Setup Id's
		Storyboard.Nodes[i].id = iUniqueIds;
		Storyboard.Nodes[i].thumb_id = iUniqueIds;

		for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
		{
			Storyboard.Nodes[i].input_id[l] = iUniqueIds + 1000 + (1000 * l);
			Storyboard.Nodes[i].output_id[l] = iUniqueIds + 1000 + (1000 * l) + 500;
		}

		for (int l = 0; l < STORYBOARD_MAXWIDGETS; l++)
		{
			Storyboard.Nodes[i].widget_normal_thumb_id[l] = iUniqueIds + 1000 + (1000 * l) + 600;
			Storyboard.Nodes[i].widget_highlight_thumb_id[l] = iUniqueIds + 1000 + (1000 * l) + 700;
			Storyboard.Nodes[i].widget_selected_thumb_id[l] = iUniqueIds + 1000 + (1000 * l) + 800;
		}
		Storyboard.Nodes[i].screen_backdrop_id = iUniqueIds + 500;

		iUniqueIds++;
	}
	
	Storyboard.game_thumb_id = STORYBOARD_THUMBS + 420;
	Storyboard.game_icon_id = STORYBOARD_THUMBS + 421;

	//####

	//PE: Add default nodes.
	int node = 0;

	//0 Default splash screen.
	Storyboard.Nodes[node].used = true;
	Storyboard.Nodes[node].type = STORYBOARD_TYPE_SPLASH;
	Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5-(node_width*0.5)-((node_width + NODE_WIDTH_PADDING)*4.0), STORYBOARD_YSTART +(node_height+ NODE_HEIGHT_PADDING)*node);
	Storyboard.Nodes[node].iEditEnable = true;
	strcpy(Storyboard.Nodes[node].title, "Splash Screen");
	strcpy(Storyboard.Nodes[node].thumb, "editors\\uiv3\\loadingsplash-ea.jpg");
	strcpy(Storyboard.Nodes[node].lua_name, ""); //No script.
	//No input.
	//Output.
	strcpy(Storyboard.Nodes[node].output_title[0], " Connect to Scene ");
	strcpy(Storyboard.Nodes[node].output_action[0], "loadscene"); //Not defined this yet.
	Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
	Storyboard.Nodes[node].output_linkto[0] = Storyboard.Nodes[1].input_id[0]; //Link To:  node id.

	node++;

	iTitleScreenNodeID = node;
	//1 Default title screen
	Storyboard.Nodes[node].used = true;
	Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
	Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5)-((node_width + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING)*0);
	Storyboard.Nodes[node].iEditEnable = true;
	strcpy(Storyboard.Nodes[node].title, "Title Screen");
	strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_title.lua.png");
	strcpy(Storyboard.Nodes[node].lua_name, "title.lua");
	strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\title.png");

	//Input.
	strcpy(Storyboard.Nodes[node].input_title[0], " Input ");

	//Output.
	strcpy(Storyboard.Nodes[node].output_title[0], " START GAME -> Connect to Level ");
	strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
	Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
	Storyboard.Nodes[node].output_linkto[0] = Storyboard.Nodes[2].input_id[0];

	#ifdef STORYBOARD_INCLUDE_LOADGAME
	strcpy(Storyboard.Nodes[node].output_title[1], " LOAD GAME -> Connect to Scene ");
	strcpy(Storyboard.Nodes[node].output_action[1], "loadscene"); //Not defined this yet.
	Storyboard.Nodes[node].output_can_link_to_type[1] = STORYBOARD_TYPE_SCREEN;
	Storyboard.Nodes[node].output_linkto[1] = Storyboard.Nodes[iLoadGameNodeID].input_id[0];
	#endif

	strcpy(Storyboard.Nodes[node].output_title[2], " ABOUT -> Connect to Scene ");
	strcpy(Storyboard.Nodes[node].output_action[2], "loadscene"); //Not defined this yet.
	Storyboard.Nodes[node].output_can_link_to_type[2] = STORYBOARD_TYPE_SCREEN;
	Storyboard.Nodes[node].output_linkto[2] = Storyboard.Nodes[4].input_id[0];

	//strcpy(Storyboard.Nodes[node].output_title[3], " QUIT GAME -> Connect to Scene ");
	//strcpy(Storyboard.Nodes[node].output_action[3], "quitgame"); //Not defined this yet.
	//Storyboard.Nodes[node].output_can_link_to_type[3] = STORYBOARD_TYPE_SCREEN;
	//Storyboard.Nodes[node].output_linkto[3] = 0;


	/*
		int widget_output_pin[STORYBOARD_MAXWIDGETS]; //off,level,screen. SAME AS Action.
	*/

	int button = 0;

	strcpy(Storyboard.Nodes[node].widget_label[button], "START");
	Storyboard.Nodes[node].widget_used[button] = 1;
	Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
	Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0,1.0); //Only for scaling. else but image size.
	Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20.0 + 10.0); //Pos in percent. using pivot center on X only.
	Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_STARTGAME;
	Storyboard.Nodes[node].widget_layer[button] = 0;
	Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
	strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
	strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
	strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
	strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
	strcpy(Storyboard.Nodes[node].widget_name[button], "start"); //Also add "-hover.png" ...
	
	button++;

	#ifdef STORYBOARD_INCLUDE_LOADGAME

	strcpy(Storyboard.Nodes[node].widget_label[button], "LOAD GAME");
	Storyboard.Nodes[node].widget_used[button] = 1;
	Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
	Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
	Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20.0 + 20.0); //Pos in percent. using pivot center on X only.
	Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN;
	Storyboard.Nodes[node].widget_layer[button] = 0;
	Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
	strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
	strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
	strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
	strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
	strcpy(Storyboard.Nodes[node].widget_name[button], "load-game"); //Also add "-hover.png" ...

	button++;

	#endif

	strcpy(Storyboard.Nodes[node].widget_label[button], "ABOUT");
	Storyboard.Nodes[node].widget_used[button] = 1;
	Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
	Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
	#ifdef STORYBOARD_INCLUDE_LOADGAME
	Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20.0 + 30.0); //Pos in percent. using pivot center on X only.
	#else
	Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20.0 + 20.0); //Pos in percent. using pivot center on X only.
	#endif
	Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN;
	Storyboard.Nodes[node].widget_layer[button] = 0;
	Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
	strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
	strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
	strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
	strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
	strcpy(Storyboard.Nodes[node].widget_name[button], "about"); //Also add "-hover.png" ...

	button++;

	strcpy(Storyboard.Nodes[node].widget_label[button], "QUIT GAME");
	Storyboard.Nodes[node].widget_used[button] = 1;
	Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
	Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
	#ifdef STORYBOARD_INCLUDE_LOADGAME
	Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20.0 + 40.0); //Pos in percent. using pivot center on X only.
	#else
	Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20.0 + 30.0); //Pos in percent. using pivot center on X only.
	#endif
	Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_EXITGAME;
	Storyboard.Nodes[node].widget_layer[button] = 0;
	Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
	strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
	strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
	strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
	strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
	strcpy(Storyboard.Nodes[node].widget_name[button], "quit-game"); //Also add "-hover.png" ...

	node++;

	//iLoadingScreenNodeID = node; // 2
	iLoadingScreenNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);

	node++;

	iLoadGameNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	//Storyboard.Nodes[iTitleScreenNodeID].output_linkto[2] = Storyboard.Nodes[iLoadGameNodeID].input_id[0];

	node++;

	iAboutScreenNodeID = node;

	//4 Default About screen.
	Storyboard.Nodes[node].used = true;
	Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;

	#ifdef STORYBOARD_INCLUDE_LOADGAME
	Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 2);
	#else
	Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 1);
	#endif
	Storyboard.Nodes[node].iEditEnable = true;
	strcpy(Storyboard.Nodes[node].title, "About Screen");
	strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_about.lua.png");
	strcpy(Storyboard.Nodes[node].lua_name, "about.lua");
	strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\about.png");

	//Input.
	strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
	//No Output.

	button = 0;
	strcpy(Storyboard.Nodes[node].widget_label[button], "ABOUT GAME");
	Storyboard.Nodes[node].widget_used[button] = 1;
	Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
	Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
	Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8.0); //Pos in percent. using pivot center on X only.
	Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
	Storyboard.Nodes[node].widget_layer[button] = 0;
	Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
	strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
	strcpy(Storyboard.Nodes[node].widget_name[button], "about-title"); //Also add "-hover.png" ...

	button = 1;
	strcpy(Storyboard.Nodes[node].widget_label[button], "");
	Storyboard.Nodes[node].widget_used[button] = 1;
	Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXTAREA;
	Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
	Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20.0); //Pos in percent. using pivot center on X only.
	Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
	Storyboard.Nodes[node].widget_layer[button] = 0;
	Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
	strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
	strcpy(Storyboard.Nodes[node].widget_name[button], "about-textarea"); //Also add "-hover.png" ...

	button = 2;
	strcpy(Storyboard.Nodes[node].widget_label[button], "BACK");
	Storyboard.Nodes[node].widget_used[button] = 1;
	Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
	Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
	Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 80); //Pos in percent. using pivot center on X only.
	Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_BACK;
	Storyboard.Nodes[node].widget_layer[button] = 0;
	Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
	strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
	strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
	strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
	strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
	strcpy(Storyboard.Nodes[node].widget_name[button], "back"); //NOTE: DUP (back) - Also add "-hover.png" ...



	node++;

	iGameWonScreenNodeID = node;

	//5 Default Game Won screen.
	Storyboard.Nodes[node].used = true;
	Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
	Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5) + ((node_width + NODE_WIDTH_PADDING)*4.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 0);
	Storyboard.Nodes[node].iEditEnable = true;
	strcpy(Storyboard.Nodes[node].title, "Game Won Screen");
	strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_win.lua.png");
	strcpy(Storyboard.Nodes[node].lua_name, "win.lua");
	strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\end.png");

	//Input.
	strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
	//No Output.

	button = 0;
	strcpy(Storyboard.Nodes[node].widget_label[button], "CONTINUE");
	Storyboard.Nodes[node].widget_used[button] = 1;
	Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
	Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
	Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 80); //Pos in percent. using pivot center on X only.
	Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_CONTINUE;
	Storyboard.Nodes[node].widget_layer[button] = 0;
	Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
	strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
	strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
	strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
	strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
	strcpy(Storyboard.Nodes[node].widget_name[button], "continue"); //NOTE: DUP (continue) - Also add "-hover.png" ...

	button = 1;
	strcpy(Storyboard.Nodes[node].widget_label[button], "GAME COMPLETE");
	Storyboard.Nodes[node].widget_used[button] = 1;
	Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
	Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
	Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8.0); //Pos in percent. using pivot center on X only.
	Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
	Storyboard.Nodes[node].widget_layer[button] = 0;
	Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
	strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
	strcpy(Storyboard.Nodes[node].widget_name[button], "gamecomplete"); //Also add "-hover.png" ...

	node++;

	iGameLostScreenNodeID = node;

	//6 Default Game Over screen.
	Storyboard.Nodes[node].used = true;
	Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
	Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5) + ((node_width + NODE_WIDTH_PADDING)*4.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 1);
	Storyboard.Nodes[node].iEditEnable = true;
	strcpy(Storyboard.Nodes[node].title, "Game Over Screen");
	strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_lose.lua.png");
	strcpy(Storyboard.Nodes[node].lua_name, "lose.lua");
	strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\lost.png");

	//Input.
	strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
	//No Output.

	button = 0;
	strcpy(Storyboard.Nodes[node].widget_label[button], "CONTINUE");
	Storyboard.Nodes[node].widget_used[button] = 1;
	Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
	Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
	Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 80); //Pos in percent. using pivot center on X only.
	Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_CONTINUE;
	Storyboard.Nodes[node].widget_layer[button] = 0;
	Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
	strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
	strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
	strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
	strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
	strcpy(Storyboard.Nodes[node].widget_name[button], "continue"); //NOTE: DUP (continue) - Also add "-hover.png" ...

	button = 1;
	strcpy(Storyboard.Nodes[node].widget_label[button], "GAME OVER");
	Storyboard.Nodes[node].widget_used[button] = 1;
	Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
	Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
	Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8.0); //Pos in percent. using pivot center on X only.
	Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
	Storyboard.Nodes[node].widget_layer[button] = 0;
	Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
	strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
	strcpy(Storyboard.Nodes[node].widget_name[button], "gameover"); //Also add "-hover.png" ...

	node++;

	//7 Default Level1 screen.
	Storyboard.Nodes[node].used = true;
	Storyboard.Nodes[node].type = STORYBOARD_TYPE_LEVEL;
	Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5) + ((node_width + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 0);
	Storyboard.Nodes[node].iEditEnable = true;
	strcpy(Storyboard.Nodes[node].title, "Level 1");
	strcpy(Storyboard.Nodes[node].levelnumber, "Level 1");
	strcpy(Storyboard.Nodes[node].thumb, "");
	//Input.
	strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
	//Output.
	strcpy(Storyboard.Nodes[node].output_title[0], " GAME WON -> Connect to Scene ");
	strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
	Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
	Storyboard.Nodes[node].output_linkto[0] = Storyboard.Nodes[5].input_id[0];

	strcpy(Storyboard.Nodes[node].output_title[1], " GAME OVER -> Connect to Scene ");
	strcpy(Storyboard.Nodes[node].output_action[1], "loadlevel"); //Not defined this yet.
	Storyboard.Nodes[node].output_can_link_to_type[1] = STORYBOARD_TYPE_SCREEN;
	Storyboard.Nodes[node].output_linkto[1] = Storyboard.Nodes[6].input_id[0];

	strcpy(Storyboard.Nodes[node].output_title[2], " NEXT LEVEL -> Connect to Level ");
	strcpy(Storyboard.Nodes[node].output_action[2], "loadlevel"); //Not defined this yet.
	Storyboard.Nodes[node].output_can_link_to_type[2] = STORYBOARD_TYPE_LEVEL;
	Storyboard.Nodes[node].output_linkto[2] = 0;

	node++;

	iGamePausedNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);

	node++;

	iSaveGameNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);

	node++;

	iGraphicsNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);

	node++;

	iSoundsNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);

	node++;

	iControlNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);

	//Make sure we have the needed folders.
	char destination[MAX_PATH];
	strcpy(destination, "projectbank\\");
	GG_GetRealPath(destination, 1);
	MakeDirectory(destination);

}

int storyboard_add_missing_nodex(int node,float area_width, float node_width, float node_height, bool bForce)
{
	int orgnode = node;

	//General.
	if( strlen(Storyboard.Nodes[0].thumb) > 0 && pestrcasestr(Storyboard.Nodes[0].thumb,"loadingsplash.jpg"))
		strcpy(Storyboard.Nodes[0].thumb, "editors\\uiv3\\loadingsplash-ea.jpg");

	if (orgnode == 8)
	{
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true)
				{
					if (strcmp(Storyboard.Nodes[i].lua_name, "gamemenu.lua") == 0)
					{
						//Found it and its active.
						bValid = false;
						node = i;
						break;
					}
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}

		//Change old node label.
		if (stricmp(Storyboard.Nodes[node].widget_label[5], "SOUND LEVELS") == 0)
		{
			strcpy(Storyboard.Nodes[node].widget_label[5], "SOUND SETTINGS");
		}

		if (!bValid && Storyboard.Nodes[node].used == true && !bForce)
		{
			//PE: Current design inject the button.
			int button = 7; //new CONTROLS button id.
			if (Storyboard.Nodes[node].widget_used[button] != 1)
			{
				bool bMoved = false;
				//PE: Check if we can re arrange buttons (if still default setup).
				if (Storyboard.Nodes[node].widget_pos[1].x == 50.0 && Storyboard.Nodes[node].widget_pos[1].y == 30.0) Storyboard.Nodes[node].widget_pos[1] = ImVec2(50.0, 20.0);
				if (Storyboard.Nodes[node].widget_pos[2].x == 50.0 && Storyboard.Nodes[node].widget_pos[2].y == 40.0) Storyboard.Nodes[node].widget_pos[2] = ImVec2(50.0, 30.0);
				if (Storyboard.Nodes[node].widget_pos[3].x == 50.0 && Storyboard.Nodes[node].widget_pos[3].y == 50.0) Storyboard.Nodes[node].widget_pos[3] = ImVec2(50.0, 40.0);
				if (Storyboard.Nodes[node].widget_pos[4].x == 50.0 && Storyboard.Nodes[node].widget_pos[4].y == 60.0) Storyboard.Nodes[node].widget_pos[4] = ImVec2(50.0, 50.0);
				if (Storyboard.Nodes[node].widget_pos[5].x == 50.0 && Storyboard.Nodes[node].widget_pos[5].y == 70.0)
				{
					Storyboard.Nodes[node].widget_pos[5] = ImVec2(50.0, 60.0);
					//PE: This spot is available.
					bMoved = true;
				}

				//PE: Move back button down if possible.
				if (Storyboard.Nodes[node].widget_pos[6].x == 50.0 && Storyboard.Nodes[node].widget_pos[6].y == 80.0) Storyboard.Nodes[node].widget_pos[6] = ImVec2(50.0, 90.0);

				//PE: We do not know if buttons have been moved around so just inject where we had a spot available in old design.
				button = 7;
				strcpy(Storyboard.Nodes[node].widget_label[button], "CONTROLS"); //SOUND LEVELS
				Storyboard.Nodes[node].widget_used[button] = 1;
				Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
				Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
				if(bMoved)
					Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 70.0);
				else
					Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 80.0);
				Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN; //
				Storyboard.Nodes[node].widget_layer[button] = 0;
				Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
				strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
				strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
				strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
				strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
				strcpy(Storyboard.Nodes[node].widget_name[button], "controls"); //Also add "-hover.png" ...
			}
		}
		//8 Default GAME PAUSED
		if( bValid && (Storyboard.Nodes[node].used == false || bForce) )
		{
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5) - ((node_width + NODE_WIDTH_PADDING)*4.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 2);
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "Game Paused");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_gamemenu.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "gamemenu.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, ""); //No backdrop transparent.
			Storyboard.Nodes[node].screen_backdrop_transparent = true;

			//No Input
			//strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
			//No Output.

			int button = 0;
			strcpy(Storyboard.Nodes[node].widget_label[button], "GAME PAUSED");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_name[button], "about-title"); //Also add "-hover.png" ...

			button = 1;
			strcpy(Storyboard.Nodes[node].widget_label[button], "MAIN MENU");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_LEAVEGAME; //	//LeaveGame
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "main-menu"); //Also add "-hover.png" ...

			strcpy(Storyboard.Nodes[node].output_title[button], ""); //Empty no output pin.
			strcpy(Storyboard.Nodes[node].output_action[button], "title"); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[button] = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[node].output_linkto[button] = 0;

			button = 2;
			strcpy(Storyboard.Nodes[node].widget_label[button], "LOAD GAME");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 30.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN; //	//LeaveGame
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "load-game"); //Also add "-hover.png" ...

			strcpy(Storyboard.Nodes[node].output_title[button], ""); //Empty no output pin.
			strcpy(Storyboard.Nodes[node].output_action[button], "loadgame"); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[button] = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[node].output_linkto[button] = 0;


			button = 3;
			strcpy(Storyboard.Nodes[node].widget_label[button], "SAVE GAME");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 40.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN; //	//LeaveGame
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "save-game"); //Also add "-hover.png" ...

			strcpy(Storyboard.Nodes[node].output_title[button], ""); //Empty no output pin.
			strcpy(Storyboard.Nodes[node].output_action[button], "savegame"); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[button] = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[node].output_linkto[button] = 0;


			button = 4;
			strcpy(Storyboard.Nodes[node].widget_label[button], "GRAPHICS SETTINGS");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 50.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN; //	//LeaveGame
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "graphics-settings"); //Also add "-hover.png" ...

			strcpy(Storyboard.Nodes[node].output_title[button], ""); //Empty no output pin.
			strcpy(Storyboard.Nodes[node].output_action[button], "graphics"); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[button] = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[node].output_linkto[button] = 0;


			button = 5;
			strcpy(Storyboard.Nodes[node].widget_label[button], "SOUND SETTINGS"); //SOUND LEVELS
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 60.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN; //	//LeaveGame
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "sound-levels"); //Also add "-hover.png" ...

			strcpy(Storyboard.Nodes[node].output_title[button], ""); //Empty no output pin.
			strcpy(Storyboard.Nodes[node].output_action[button], "sounds"); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[button] = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[node].output_linkto[button] = 0;


			button = 6;
			strcpy(Storyboard.Nodes[node].widget_label[button], "RESUME GAME");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 90.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_RESUMEGAME; //ResumeGame
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "resume-game"); //Also add "-hover.png" ...

			strcpy(Storyboard.Nodes[node].output_title[button], ""); //Empty no output pin.
			strcpy(Storyboard.Nodes[node].output_action[button], ""); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[button] = STORYBOARD_ACTIONS_RESUMEGAME;
			Storyboard.Nodes[node].output_linkto[button] = 0;

			button = 7;
			strcpy(Storyboard.Nodes[node].widget_label[button], "CONTROLS"); //SOUND LEVELS
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 70.0); // 80.0 if have current design.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN; //
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls"); //Also add "-hover.png" ...

			strcpy(Storyboard.Nodes[node].output_title[button], ""); //Empty no output pin.
			strcpy(Storyboard.Nodes[node].output_action[button], "controls"); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[button] = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[node].output_linkto[button] = 0;

		}
	}
	if (orgnode == 3)
	{
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true)
				{
					if (strcmp(Storyboard.Nodes[i].lua_name, "loadgame.lua") == 0)
					{
						//Found it and its active.
						bValid = false;
						node = i;
						break;
					}
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}
		//3 Default Load Game screen.
		if (bValid && (Storyboard.Nodes[node].used == false || bForce))
		{
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
			if(bForce)
				Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 1);
			else
				Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 2);
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "Load Game Screen");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_loadgame.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "loadgame.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\loading.png");
			//Input.
			strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
			//No Output.

			int button = 0;
			strcpy(Storyboard.Nodes[node].widget_label[button], "LOAD GAME");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "load-game-title"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			for (int l = 1; l < 9; l++)
			{
				button++;
				//These should be blank and filled out using: TextCenterOnX
				strcpy(Storyboard.Nodes[node].widget_label[button], "");
				Storyboard.Nodes[node].widget_used[button] = 1;
				Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
				Storyboard.Nodes[node].widget_read_only[button] = 1;
				Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
				Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (l * 7)); //Pos in percent. using pivot center on X only.
				Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_RETURNVALUETOLUA; //Just used for a title.
				Storyboard.Nodes[node].widget_layer[button] = 0;
				Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
				strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
				strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
				strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
				strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
				strcpy(Storyboard.Nodes[node].widget_name[button], "load-game-title"); //NOTE: DUP (load-game) - Also add "-hover.png" ...
				Storyboard.Nodes[node].widget_font_size[button] = 0.5;
			}

			button++;
			strcpy(Storyboard.Nodes[node].widget_label[button], "BACK");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 90); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_BACK;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "back-load-game"); //NOTE: DUP (back) - Also add "-hover.png" ...

			//PE: re setup title output if we changed node.
			//strcpy(Storyboard.Nodes[iTitleScreenNodeID].output_title[1], " LOAD GAME -> Connect to Scene ");
			//strcpy(Storyboard.Nodes[iTitleScreenNodeID].output_action[1], "loadscene"); //Not defined this yet.
			//Storyboard.Nodes[iTitleScreenNodeID].output_can_link_to_type[1] = STORYBOARD_TYPE_SCREEN;
			//Storyboard.Nodes[iTitleScreenNodeID].output_linkto[1] = Storyboard.Nodes[node].input_id[0];

			bool bAddLoadGameButton = true;
			int iFirstFreeButton = -1;
			for (int i = 0; i < STORYBOARD_MAXWIDGETS;i++)
			{
				if (Storyboard.Nodes[iTitleScreenNodeID].widget_used[i] == 1)
				{
					if (stricmp(Storyboard.Nodes[iTitleScreenNodeID].widget_name[i], "load-game") == 0)
					{
						bAddLoadGameButton = false;
						break;
					}
				}
				else
				{
					if (iFirstFreeButton < 0) iFirstFreeButton = i;
				}
			}

			//PE: Check if "load game" button is added to title menu.
			if (bAddLoadGameButton && iFirstFreeButton >= 0)
			{
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].widget_label[iFirstFreeButton], "LOAD GAME");
				Storyboard.Nodes[iTitleScreenNodeID].widget_used[iFirstFreeButton] = 1;
				Storyboard.Nodes[iTitleScreenNodeID].widget_type[iFirstFreeButton] = STORYBOARD_WIDGET_BUTTON;
				Storyboard.Nodes[iTitleScreenNodeID].widget_size[iFirstFreeButton] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
				Storyboard.Nodes[iTitleScreenNodeID].widget_pos[iFirstFreeButton] = ImVec2(50.0, 20.0 + 40.0); //Pos in percent. using pivot center on X only.
				Storyboard.Nodes[iTitleScreenNodeID].widget_action[iFirstFreeButton] = STORYBOARD_ACTIONS_GOTOSCREEN;
				Storyboard.Nodes[iTitleScreenNodeID].widget_layer[iFirstFreeButton] = 0;
				Storyboard.Nodes[iTitleScreenNodeID].widget_font_color[iFirstFreeButton] = ImVec4(1.0, 1.0, 1.0, 1.0);
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].widget_font[iFirstFreeButton], "Default Font"); // ?
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].widget_normal_thumb[iFirstFreeButton], "editors\\templates\\buttons\\default.png");
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].widget_highlight_thumb[iFirstFreeButton], "editors\\templates\\buttons\\default-hover.png");
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].widget_selected_thumb[iFirstFreeButton], "editors\\templates\\buttons\\default-selected.png");
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].widget_name[iFirstFreeButton], "load-game"); //Also add "-hover.png" ...

				strcpy(Storyboard.Nodes[iTitleScreenNodeID].output_title[iFirstFreeButton], " LOAD GAME -> Connect to Scene ");
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].output_action[iFirstFreeButton], "loadscene"); //Not defined this yet.
				Storyboard.Nodes[iTitleScreenNodeID].output_can_link_to_type[iFirstFreeButton] = STORYBOARD_TYPE_SCREEN;
				Storyboard.Nodes[iTitleScreenNodeID].output_linkto[iFirstFreeButton] = Storyboard.Nodes[node].input_id[0];

			}

			//PE: setup output links on "game paused" screen. , they are already there so fixed output links.
			strcpy(Storyboard.Nodes[iGamePausedNodeID].output_title[0], " LOAD GAME -> Connect to Scene ");
			strcpy(Storyboard.Nodes[iGamePausedNodeID].output_action[0], "loadscene"); //Not defined this yet.
			Storyboard.Nodes[iGamePausedNodeID].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[iGamePausedNodeID].output_linkto[0] = Storyboard.Nodes[node].input_id[0];

		}
	}

	//Save game.
	if (orgnode == 9)
	{
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true)
				{
					if (strcmp(Storyboard.Nodes[i].lua_name, "savegame.lua") == 0)
					{
						//Found it and its active.
						bValid = false;
						node = i;
						break;
					}
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}
		//9 Default Save Game screen.
		if (bValid && (Storyboard.Nodes[node].used == false || bForce))
		{
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5) - ((node_width + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 1);
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "Save Game Screen");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_savegame.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "savegame.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\loading.png");

			//Input.
			strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
			//No Output.

			int button = 0;
			strcpy(Storyboard.Nodes[node].widget_label[button], "SAVE GAME");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "save-game-title"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			for (int l = 1; l < 9; l++)
			{
				button++;
				//These should be blank and filled out using: TextCenterOnX
				strcpy(Storyboard.Nodes[node].widget_label[button], "");
				Storyboard.Nodes[node].widget_used[button] = 1;
				Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
				Storyboard.Nodes[node].widget_read_only[button] = 1;
				Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
				Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (l * 7)); //Pos in percent. using pivot center on X only.
				Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_RETURNVALUETOLUA; //Just used for a title.
				Storyboard.Nodes[node].widget_layer[button] = 0;
				Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
				strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
				strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
				strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
				strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
				strcpy(Storyboard.Nodes[node].widget_name[button], "save-game-title"); //NOTE: DUP (load-game) - Also add "-hover.png" ...
				Storyboard.Nodes[node].widget_font_size[button] = 0.5;
			}

			button++;
			strcpy(Storyboard.Nodes[node].widget_label[button], "BACK");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 90); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_BACK;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "back-save-game"); //NOTE: DUP (back) - Also add "-hover.png" ...

			//PE: setup output links on "game paused" screen. , they are already there so fixed output links.
			strcpy(Storyboard.Nodes[iGamePausedNodeID].output_title[1], " SAVE GAME -> Connect to Scene ");
			strcpy(Storyboard.Nodes[iGamePausedNodeID].output_action[1], "savescene"); //Not defined this yet.
			Storyboard.Nodes[iGamePausedNodeID].output_can_link_to_type[1] = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[iGamePausedNodeID].output_linkto[1] = Storyboard.Nodes[node].input_id[0];

		}
	}


	//Graphics
	if (orgnode == 10)
	{
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true)
				{
					if (strcmp(Storyboard.Nodes[i].lua_name, "graphics.lua") == 0)
					{
						//Found it and its active.
						bValid = false;
						node = i;
						break;
					}
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}


		//PE: Change old node label.
		if (stricmp(Storyboard.Nodes[node].widget_label[4], "FOV") == 0)
		{
			strcpy(Storyboard.Nodes[node].widget_label[4], "FIELD OF VIEW");
		}

		//10 Default graphics screen
		if (bValid && (Storyboard.Nodes[node].used == false || bForce))
		{
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5) - ((node_width + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 2);
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "Graphics Settings Screen");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_graphics.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "graphics.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, "");
			Storyboard.Nodes[node].screen_backdrop_transparent = true;

			//Input.
			strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
			//No Output.

			int button = 0;
			strcpy(Storyboard.Nodes[node].widget_label[button], "GRAPHICS SETTINGS");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "graphics-game-title"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 1;
			strcpy(Storyboard.Nodes[node].widget_label[button], "LOW");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_RADIOTYPE;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button*10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "lowest"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 2;
			strcpy(Storyboard.Nodes[node].widget_label[button], "MEDIUM");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_RADIOTYPE;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "medium"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 3;
			strcpy(Storyboard.Nodes[node].widget_label[button], "HIGHEST");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_RADIOTYPE;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "highest"); //NOTE: DUP (load-game) - Also add "-hover.png" ...


			button = 4;
			strcpy(Storyboard.Nodes[node].widget_label[button], "FIELD OF VIEW");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "highest"); //NOTE: DUP (load-game) - Also add "-hover.png" ...


			button = 5;
			strcpy(Storyboard.Nodes[node].widget_label[button], "");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_SLIDER;

			int iPlayerFOVPerc = (((t.visuals.CameraFOV_f*t.visuals.CameraASPECT_f) - 20.0) / 180.0)*100.0;
			if (iPlayerFOVPerc < 0) iPlayerFOVPerc = 33; //default FOV
			if (iPlayerFOVPerc > 100) iPlayerFOVPerc = 33; //default FOV
			Storyboard.NodeSliderValues[node][button] = iPlayerFOVPerc;

			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "highest"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 6;
			strcpy(Storyboard.Nodes[node].widget_label[button], "BACK");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_BACK;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "back-save-game"); //NOTE: DUP (back) - Also add "-hover.png" ...

			//PE: setup output links on "game paused" screen. , they are already there so fixed output links.
			strcpy(Storyboard.Nodes[iGamePausedNodeID].output_title[2], " GRAPHICS SETTINGS -> Connect to Scene ");
			strcpy(Storyboard.Nodes[iGamePausedNodeID].output_action[2], "graphicsscene"); //Not defined this yet.
			Storyboard.Nodes[iGamePausedNodeID].output_can_link_to_type[2] = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[iGamePausedNodeID].output_linkto[2] = Storyboard.Nodes[node].input_id[0];

		}
	}



	//Sounds
	if (orgnode == 11)
	{
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true)
				{
					if (strcmp(Storyboard.Nodes[i].lua_name, "sounds.lua") == 0)
					{
						//Found it and its active.
						bValid = false;
						node = i;
						break;
					}
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}

		if (stricmp(Storyboard.Nodes[node].widget_label[0], "SOUND LEVELS") == 0)
		{
			strcpy(Storyboard.Nodes[node].widget_label[0], "SOUND VOLUME SETTINGS");
		}

		//11 Default sounds screen
		if (bValid && (Storyboard.Nodes[node].used == false || bForce))
		{
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5) - ((node_width + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 3);
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "Sound Settings Screen");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_sounds.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "sounds.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, "");
			Storyboard.Nodes[node].screen_backdrop_transparent = true;

			//Input.
			strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
			//No Output.

			int button = 0;
			strcpy(Storyboard.Nodes[node].widget_label[button], "SOUND VOLUME SETTINGS"); //"SOUND LEVELS"
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "sounds-game-title"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 1;
			strcpy(Storyboard.Nodes[node].widget_label[button], "SOUND EFFECTS");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "sound-effects-label"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 2;
			strcpy(Storyboard.Nodes[node].widget_label[button], "");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_SLIDER;
			Storyboard.NodeSliderValues[node][button] = 100.0;

			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "slider-bar-empty"); //NOTE: DUP (load-game) - Also add "-hover.png" ...


			button = 3;
			strcpy(Storyboard.Nodes[node].widget_label[button], "MUSIC");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "music-label"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 4;
			strcpy(Storyboard.Nodes[node].widget_label[button], "");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_SLIDER;
			Storyboard.NodeSliderValues[node][button] = 100.0;

			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "slider-bar-empty"); //NOTE: DUP (load-game) - Also add "-hover.png" ...


			button = 5;
			strcpy(Storyboard.Nodes[node].widget_label[button], "BACK");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_BACK;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "back-save-game"); //NOTE: DUP (back) - Also add "-hover.png" ...

			//PE: setup output links on "game paused" screen. , they are already there so fixed output links.
			strcpy(Storyboard.Nodes[iGamePausedNodeID].output_title[3], " SOUND SETTINGS -> Connect to Scene ");
			strcpy(Storyboard.Nodes[iGamePausedNodeID].output_action[3], "soundsscene"); //Not defined this yet.
			Storyboard.Nodes[iGamePausedNodeID].output_can_link_to_type[3] = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[iGamePausedNodeID].output_linkto[3] = Storyboard.Nodes[node].input_id[0];

		}
	}


	//Controls
	if (orgnode == 12)
	{
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true)
				{
					if (strcmp(Storyboard.Nodes[i].lua_name, "controls.lua") == 0)
					{
						//Found it and its active.
						bValid = false;
						node = i;
						break;
					}
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}

		//12 Default controls screen
		if (bValid && (Storyboard.Nodes[node].used == false || bForce))
		{
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5) - ((node_width + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 4);
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "Controls Screen");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_controls.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "controls.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, "");
			Storyboard.Nodes[node].screen_backdrop_transparent = true;

			//Input.
			strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
			//No Output.

			int button = 0;
			strcpy(Storyboard.Nodes[node].widget_label[button], "CONTROLS"); //"SOUND LEVELS"
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls-title"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 1;
			strcpy(Storyboard.Nodes[node].widget_label[button], "Movement");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(14.0, 20 ); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls-movement"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 2;
			strcpy(Storyboard.Nodes[node].widget_label[button], "W - Forward\nA - Strafe Left\nS - Back\nD - Strafe Right\nMouse - Look Around\nSpace - Jump\nShift - Run");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXTAREA;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(20.0, 30.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls-movement-textarea"); //Also add "-hover.png" ...


			button = 3;
			strcpy(Storyboard.Nodes[node].widget_label[button], "Weapons");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(47.0, 20); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls-weapons"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 4;
			strcpy(Storyboard.Nodes[node].widget_label[button], "LMB - Shoot\nRMB - Aim\nAlt - Melee Attack\nR - Reload\n1 - 9 Weapons Slots");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXTAREA;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(53.0, 30.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls-weapons-textarea"); //Also add "-hover.png" ...



			button = 5;
			strcpy(Storyboard.Nodes[node].widget_label[button], "Actions");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(76.0, 20); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls-actions"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 6;
			strcpy(Storyboard.Nodes[node].widget_label[button], "F - Flash Light\nE - Use\nEsc - Menu");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXTAREA;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(80.0, 30.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls-actions-textarea"); //Also add "-hover.png" ...



			button = 7;
			strcpy(Storyboard.Nodes[node].widget_label[button], "BACK");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_BACK;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "back-control-game"); //NOTE: DUP (back) - Also add "-hover.png" ...

			//PE: setup output links on "game paused" screen. , they are already there so fixed output links.
			strcpy(Storyboard.Nodes[iGamePausedNodeID].output_title[7], " CONTROLS -> Connect to Scene ");
			strcpy(Storyboard.Nodes[iGamePausedNodeID].output_action[7], "controls.lua"); //Not defined this yet.
			Storyboard.Nodes[iGamePausedNodeID].output_can_link_to_type[7] = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[iGamePausedNodeID].output_linkto[7] = Storyboard.Nodes[node].input_id[0];

		}
	}


	//Loading screen
	if (orgnode == 2)
	{
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true)
				{
					if (strcmp(Storyboard.Nodes[i].lua_name, "loading.lua") == 0)
					{
						//Found it and its active.
						bValid = false;
						node = i;
						break;
					}
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}

		//PE: Check if current project is missing the new text and inject it.
		if (!bValid && Storyboard.Nodes[node].used == true && !bForce )
		{
			//PE: Inject new text into current projects, where its missing.
			int button = 2;
			if (Storyboard.Nodes[node].widget_used[button] != 1)
			{
				strcpy(Storyboard.Nodes[node].widget_label[button], "When in game, press the Escape key for controls and other settings.");
				Storyboard.Nodes[node].widget_used[button] = 1;
				Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
				Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
				Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 95.0); //Pos in percent. using pivot center on X only.
				Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
				Storyboard.Nodes[node].widget_layer[button] = 0;
				Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
				Storyboard.Nodes[node].widget_font_size[button] = 0.5;
				strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
				strcpy(Storyboard.Nodes[node].widget_name[button], "loading-text"); //Also add "-hover.png" ...
			}
		}

		//2 Default Loading screen.
		if (bValid && (Storyboard.Nodes[node].used == false || bForce))
		{

			//iLoadingScreenNodeID;
			//2 Default Loading screen.
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
			Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 0);
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "Loading Screen");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_loading.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "loading.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\loading.png");

			//Input.
			strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
			//Output.
			strcpy(Storyboard.Nodes[node].output_title[0], " LOAD LEVEL -> Connect to Level ");
			strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_LEVEL;
			Storyboard.Nodes[node].output_linkto[0] = Storyboard.Nodes[7].input_id[0];

			int button = 0;

			strcpy(Storyboard.Nodes[node].widget_label[button], "LOADING LEVEL");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 80.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_name[button], "loading-text"); //Also add "-hover.png" ...

			button = 1;

			strcpy(Storyboard.Nodes[node].widget_label[button], ""); //Progressbar
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_PROGRESS;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 90.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");


			button = 2;
			strcpy(Storyboard.Nodes[node].widget_label[button], "When in game, press the Escape key for controls and other settings.");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 95.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			Storyboard.Nodes[node].widget_font_size[button] = 0.5;
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_name[button], "loading-text"); //Also add "-hover.png" ...

		}
	}

	return(node);
}

int ImGui_GetWindowOrder(ImGuiWindow* window)
{
	ImGuiContext& g = *GImGui;
	for (int i = g.WindowsFocusOrder.Size - 1; i >= 0; i--)
		if (g.WindowsFocusOrder[i] == window)
			return i;
	return(-1);
}

int iZOrderIsSorting = 0;
void CheckWindowsOnTop(ImGuiWindow* storyboard_window)
{
	//PE: We need special attension on window that need to be placed on top of storyboard as its fullscreen.
	if (iZOrderIsSorting > 0)
	{
		iZOrderIsSorting--;
		return;
	}

	int storyboard_idx = ImGui_GetWindowOrder(storyboard_window);
	if (storyboard_idx < 0) return;
	int secondscreen_idx = -1;

	//PE: From Small Tutorials Videos, check this directly as there can be many, but only one at the same time.
	if (bLastSmallVideoPlayerMaximized)
	{
		ImGuiWindow* win = ImGui::FindWindowByName("Tutorial Video##VideosMaxSize");
		if (win)
		{
			bool bSwitchOrder = false;
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx) bSwitchOrder = true;
			//if (!bSwitchOrder && secondscreen_idx > 0 && settings_idx < secondscreen_idx) bSwitchOrder = true; //On top of second window.
			if (bSwitchOrder)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "Tutorial Video##VideosMaxSize");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
		}
	}


	if (bAbout_Window)
	{

		
		ImGuiWindow* win = ImGui::FindWindowByName("##Credits##AboutWindow");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "##Credits##AboutWindow");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
			secondscreen_idx = settings_idx;
		}

		win = ImGui::FindWindowByName("##About##AboutWindow");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "##About##AboutWindow");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
			secondscreen_idx = settings_idx;
		}
	}

	/*
	if (bTriggerOpenProject)
	{
		ImGuiWindow* win = ImGui::FindWindowByName("Open Project##Storyboard");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "Open Project##Storyboard");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
			secondscreen_idx = settings_idx;
		}
	}
	*/

	#ifdef RPG_GAMES
	if (bRPGSetup_Window)
	{
		ImGuiWindow* win = ImGui::FindWindowByName("RPG setup##MustBeUnique");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "RPG setup##MustBeUnique");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
			secondscreen_idx = settings_idx;
		}
	}
	#endif

	if (bPreferences_Window)
	{
		ImGuiWindow* win = ImGui::FindWindowByName("Settings");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "Settings");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
			secondscreen_idx = settings_idx;
		}
	}

	if (bEditGameSettings)
	{
		ImGuiWindow* win = ImGui::FindWindowByName("Edit Game Settings##Storyboard");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "Edit Game Settings##Storyboard");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
			secondscreen_idx = settings_idx;
		}
	}
	//"Edit Game Settings##Storyboard"

	if (bExternal_Entities_Window)
	{
		ImGuiWindow* win = ImGui::FindWindowByName("##Object Library ExternalWindow");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "##Object Library ExternalWindow");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
			secondscreen_idx = settings_idx;
		}
	}

	if (bInfo_Window)
	{
		ImGuiWindow* win = ImGui::FindWindowByName("Information##InformationWindow");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "Information##InformationWindow");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
			secondscreen_idx = settings_idx;
		}
	}

	//PE: Tutorial video.
	if (bVideoPlayerMaximized)
	{
		ImGuiWindow* win = ImGui::FindWindowByName("Tutorial Video##Videos2MaxSize");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "Tutorial Video##Videos2MaxSize");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
		}
	}
}

bool bPopModalStoryboard = false;
bool bStoryboardWindowLast = false;
int iLastPrefStyle = -1;
int iWaitForNewLevel = 0;
int iWaitForNewScreenshot = 0;
int iWaitFor2DEditor = 0;
int iWaitFor2DEditorNode = -1;
int iNewLevelNode = -1;
int iScreenshotNode = -1;
bool bDuplicateLevel = false;
int iDuplicateNode = false;
bool bRenameLevel = false;
int iRenameNode = false;

bool bBlockNextMouseCheck = false;
int iFakeLoadGameTest = 0;
bool bStartLoadingGame = false;
int iExecuteMenuCommand = 0;

#define INCLUDE_GAME_SETTINGS

void process_storeboard(bool bInitOnly)
{
	bool bModal = false; //Use a modal window.

	//Emulate standalone.
	static bool bTestStandalone = false;
	static int iFramesBeforeEmulate = 0;
	static char startpage[255], lastpage[255], playerrors[255] = "\0";

	if (!bInitOnly)
	{
		if (bStoryboardWindowLast != bStoryboardWindow || iLastPrefStyle != pref.current_style)
		{
			//PE: Map each time we enter.
			mapNodeStyle();
			bStoryboardWindowLast = bStoryboardWindow;
			iLastPrefStyle = pref.current_style;
		}
	}

	if (!bStoryboardWindow && !bInitOnly)
	{
		if (!bWelcomeScreen_Window && (pref.iDisplayWelcomeScreen == 0 || pref.iLastInStoryboard == 0 ) && bTriggerWhatsNewInStoryboard)
		{
			if (g.gshowannouncements == 1)
			{
				if (g_iWelcomeLoopPage == WELCOME_ANNOUNCEMENTS)
				{
					if (gbWelcomeSystemActive == false)
					{
						welcome_init(1);
						welcome_init(2);
					}
					bool welcome_get_change_log(void);
					if (welcome_get_change_log() == true)
					{
						welcome_runloop(WELCOME_ANNOUNCEMENTS);
						iTriggerWelcomeSystemStuff = 99; //PE: Start welcome system.
					}

					welcome_init(0);
				}
				bTriggerWhatsNewInStoryboard = false;
			}
		}
	}

	if (bStoryboardWindow || bInitOnly)
	{

		//PE: setup fixed ID's
		Storyboard.game_thumb_id = STORYBOARD_THUMBS + 420;
		Storyboard.game_icon_id = STORYBOARD_THUMBS + 421;

		if (!bInitOnly)
		{
			//PE: You cant get here, without level has already asked you to save changes, so always disable project save flag here.
			g.projectmodified = 0; gridedit_changemodifiedflag();
			g.projectmodifiedstatic = 0;
		}

		if (!bInitOnly)
		{
			if (gbWelcomeSystemActive)
			{
				//PE: Hide everything in the background (wicked 3D stuff).
				ImGuiWindow* window = ImGui::FindWindowByName("Toolbar");//ImGui::GetCurrentWindow();
				ImVec4 monitor_col = ImVec4(0, 0, 0, 1.0); //Black for now.
				window->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 1), ImGui::GetColorU32(monitor_col));
				return;
			}
			else
			{
				static int iHideWindowForFrames = 8;
				if (iHideWindowForFrames > 0)
				{
					iHideWindowForFrames--;
					//PE: Hide everything in the background (wicked 3D stuff).
					ImGuiWindow* window = ImGui::FindWindowByName("Toolbar");//ImGui::GetCurrentWindow();
					ImVec4 monitor_col = ImVec4(0, 0, 0, 1.0); //Black for now.
					window->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 1), ImGui::GetColorU32(monitor_col));
					return;
				}
				if (bTriggerWhatsNewInStoryboard)
				{
					if (g.gshowannouncements == 1)
					{
						//bAddWhatNewToMenu = true;
						//welcome_init(1);
						//welcome_init(0);
						//welcome_show(WELCOME_ANNOUNCEMENTS);
						if (g_iWelcomeLoopPage == WELCOME_ANNOUNCEMENTS)
						{
							if (gbWelcomeSystemActive == false)
							{
								welcome_init(1);
								welcome_init(2);
							}
							bool welcome_get_change_log(void);
							if (welcome_get_change_log() == true)
							{
								welcome_runloop(WELCOME_ANNOUNCEMENTS);
								iTriggerWelcomeSystemStuff = 99; //PE: Start welcome system.
							}

							welcome_init(0);
						}
						bTriggerWhatsNewInStoryboard = false;
					}
				}
			}
		}

		pref.iLastInStoryboard = true;
		int isize = sizeof(Storyboard); //Test.

		//PE: Use full available area.
		int preview_size_x = ImGui::GetMainViewport()->Size.x - 300.0;
		int preview_size_y = ImGui::GetMainViewport()->Size.y - 60.0;
		float fNodeWidth = 180.0f;
		float fNodeHeight = 130.0f;
		float fImgRatio = fNodeWidth/512.0;
		ImVec2 iThumbSize = ImVec2(fNodeWidth, 288.0 * fImgRatio);
		static int iLastHoveredId = -1;
		static int iLastHoveredNodeId = -1;

		//PE: Only execute this one time.
		static bool bInitStartupProject = true;
		if (bStoryboardInitNodes && bInitStartupProject)
		{
			static int iDelayLoadFrames = 2;
			if (iDelayLoadFrames == 0)
			{
				extern bool bSpecialEditorFromStandalone;
				if (bSpecialEditorFromStandalone)
				{
					extern char cSpecialStandaloneProject[MAX_PATH];
					load_storyboard(cSpecialStandaloneProject);
					iGamePausedNodeID = storyboard_add_missing_nodex(8, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iLoadGameNodeID = storyboard_add_missing_nodex(3, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iSaveGameNodeID = storyboard_add_missing_nodex(9, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iGraphicsNodeID = storyboard_add_missing_nodex(10, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iSoundsNodeID = storyboard_add_missing_nodex(11, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iControlNodeID = storyboard_add_missing_nodex(12, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iLoadingScreenNodeID = storyboard_add_missing_nodex(2, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					
					//Nothing could have changed we are going directly to storyboard.
					g.projectmodified = 0;
					g.projectmodifiedstatic = 0;
				}
				else if (!pref.iDisplayWelcomeScreen)
				{
					if (strlen(pref.cLastUsedStoryboardProject) > 0)
					{
						load_storyboard(pref.cLastUsedStoryboardProject);
						iGamePausedNodeID = storyboard_add_missing_nodex(8, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
						iLoadGameNodeID = storyboard_add_missing_nodex(3, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
						iSaveGameNodeID = storyboard_add_missing_nodex(9, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
						iGraphicsNodeID = storyboard_add_missing_nodex(10, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
						iSoundsNodeID = storyboard_add_missing_nodex(11, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
						iControlNodeID = storyboard_add_missing_nodex(12, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
						iLoadingScreenNodeID = storyboard_add_missing_nodex(2, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
						
						//Nothing could have changed we are going directly to storyboard.
						g.projectmodified = 0;
						g.projectmodifiedstatic = 0;

					}
				}
				bInitStartupProject = false;
			}
			else iDelayLoadFrames--;
		}

		static int iStoryboardAdvancedChanged = -1;

		if (bInitOnly) iStoryboardAdvancedChanged = -1; //PE: Make sure to reload after new project on welcome screen.
		if (!bInitOnly)
		{
			if (!bStoryboardInitNodes)
			{
				iStoryboardAdvancedChanged = pref.iStoryboardAdvanced;
			}
			if (iStoryboardAdvancedChanged != pref.iStoryboardAdvanced)
			{
				//PE: If we get a change we must reload the project.
				if (strlen(Storyboard.gamename) > 0)
				{
					load_storyboard(Storyboard.gamename);
					iGamePausedNodeID = storyboard_add_missing_nodex(8, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iLoadGameNodeID = storyboard_add_missing_nodex(3, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iSaveGameNodeID = storyboard_add_missing_nodex(9, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iGraphicsNodeID = storyboard_add_missing_nodex(10, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iSoundsNodeID = storyboard_add_missing_nodex(11, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iControlNodeID = storyboard_add_missing_nodex(12, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iLoadingScreenNodeID = storyboard_add_missing_nodex(2, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					
				}
				else
				{
					//We got a empty level , setup everything again.
					bStoryboardInitNodes = false; //Just init again.
					bStoryboardFirstRunSetInitPos = false;
					strcpy(pref.cLastUsedStoryboardProject, "");
					bTriggerSaveAsAfterNewLevel = true;
					bTriggerSaveAs = true;
					strcpy(SaveProjectAsName, "");
					strcpy(SaveProjectAsError, "");
				}
				iStoryboardAdvancedChanged = pref.iStoryboardAdvanced;
			}
		}

		storeboard_init_nodes(preview_size_x, fNodeWidth, fNodeHeight+20.0);

		if (bInitOnly) return;

		if (TriggerLoadGameProject != "")
		{
			load_storyboard((char *)TriggerLoadGameProject.Get());
			iGamePausedNodeID = storyboard_add_missing_nodex(8, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
			iLoadGameNodeID = storyboard_add_missing_nodex(3, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
			iSaveGameNodeID = storyboard_add_missing_nodex(9, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
			iGraphicsNodeID = storyboard_add_missing_nodex(10, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
			iSoundsNodeID = storyboard_add_missing_nodex(11, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
			iControlNodeID = storyboard_add_missing_nodex(12, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
			iLoadingScreenNodeID = storyboard_add_missing_nodex(2, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
			
			TriggerLoadGameProject = "";
			bTriggerSaveAsAfterNewLevel = false;
			bTriggerSaveAs = false;
		}

		static bool bGotAThumb = false;
		/* Move to terrain generator
		if (iWaitForNewLevel > 0)
		{
			static char NewLevelName[256] = "\0";
			static char NewLevelError[256] = "\0";
			//Window still active ?
			if (!bProceduralLevel)
			{

				if (iWaitForNewLevel == 2 && iNewLevelNode >= 0)
				{
					bGotAThumb = false;
					//Grab any thumbs created.
					if (ImageExist(STORYBOARD_THUMBS + 402)) DeleteImage(STORYBOARD_THUMBS + 402);

					if (FileExist("thumbbank\\lastnewlevel.jpg"))
					{
						image_setlegacyimageloading(true);
						//STORYBOARD_THUMBS + 401
						//LoadImageSize("thumbbank\\lastnewlevel.jpg", Storyboard.Nodes[iNewLevelNode].thumb_id, 512, 288);
						LoadImageSize("thumbbank\\lastnewlevel.jpg", STORYBOARD_THUMBS + 402, 512, 288);
						image_setlegacyimageloading(false);
						//if (ImageExist(Storyboard.Nodes[iNewLevelNode].thumb_id))
						if(ImageExist(STORYBOARD_THUMBS + 402))
							bGotAThumb = true;
					}
				}
				//Window closed, continue.
				if (iWaitForNewLevel == 1 && iNewLevelNode >= 0)
				{
					static int popwinheight = 0;
					if (popwinheight > 800 || iSkibFramesBeforeLaunch > 0)
					{
						ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Always);
					}

					//Ask to save new level.
					ImGui::OpenPopup("Save New Level#Storyboard");

					ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
					bool bSaveNewLevelWindow = true;
					if (ImGui::BeginPopupModal("Save New Level#Storyboard", &bSaveNewLevelWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
					{
						popwinheight = ImGui::GetWindowSize().y;
						ImGui::Indent(10);
						ImGui::Text("");
						ImGui::SetWindowFontScale(1.4);
						ImGui::TextCenter("Save New Level As");
						ImGui::Separator();
						if (bGotAThumb && ImageExist(STORYBOARD_THUMBS + 402))
						{
							ImGui::ImgBtn(STORYBOARD_THUMBS + 402, ImVec2(512,288), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false);
							ImGui::Separator();
						}
						else
						{
							ImGui::Dummy(ImVec2(512, 10));
						}
						ImGui::SetWindowFontScale(1.0);
						ImGui::TextWrapped("You have just created a new level, to save this level please give it a name and click 'save'");
						ImGui::Text("");
						if (strlen(NewLevelError) > 0)
						{
							ImGui::Text(NewLevelError);
							ImGui::Text("");
						}
						ImGui::Text("Level Name");
						ImGui::PushItemWidth(-10);
						ImGui::InputText("##NewLevelNameStoryboard", NewLevelName, 250, ImGuiInputTextFlags_None); //ImGuiInputTextFlags_None ImGuiInputTextFlags_ReadOnly
						ImGui::PopItemWidth();

						ImGui::Text("");

						ImGui::SetWindowFontScale(1.4);
						if (ImGui::StyleButton("Save Level", ImVec2(ImGui::GetContentRegionAvail().x*0.5 - 20.0f, 0.0f)))
						{
							if (strlen(NewLevelName) > 0)
							{
								char tmp[MAX_PATH];
								strcpy(tmp, g.mysystem.mapbankAbs_s.Get());
								//Relative.
								char *find = (char *) pestrcasestr(tmp, "mapbank\\");
								if (find && find != &tmp[0]) strcpy(&tmp[0], find);
								strcat(tmp, NewLevelName);

								t.returnstring_s = tmp;

								if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) != ".fpm")  t.returnstring_s = t.returnstring_s + ".fpm";
								g.projectfilename_s = t.returnstring_s;

								bool oksave = true;
								if (FileExist(g.projectfilename_s.Get())) {
									oksave = overWriteFileBox(g.projectfilename_s.Get());
								}
								if (oksave)
								{
									//Add newly saved fpm level to recent list.
									int firstempty = -1;
									int i = 0;
									for (; i < REMEMBERLASTFILES; i++) {
										if (firstempty == -1 && strlen(pref.last_open_files[i]) <= 0)
											firstempty = i;
										if (strlen(pref.last_open_files[i]) > 0 && pestrcasestr(g.projectfilename_s.Get(), pref.last_open_files[i])) { //already there
											break;
										}
									}
									if (i >= REMEMBERLASTFILES) {
										if (firstempty == -1) {
											//No empty slots , rotate.
											for (int ii = 0; ii < REMEMBERLASTFILES - 1; ii++) {
												strcpy(pref.last_open_files[ii], pref.last_open_files[ii + 1]);
											}
											strcpy(pref.last_open_files[REMEMBERLASTFILES - 1], g.projectfilename_s.Get());
										}
										else
											strcpy(pref.last_open_files[firstempty], g.projectfilename_s.Get());
									}

									iLaunchAfterSync = 503; //Do the actualy save here.
									iSkibFramesBeforeLaunch = 3;
									strcpy(cTriggerMessage, "Saving Level ...");
									bTriggerMessage = true;

									strcpy(Storyboard.Nodes[iNewLevelNode].title, NewLevelName);
									strcpy(Storyboard.Nodes[iNewLevelNode].level_name, g.projectfilename_s.Get());

									if (bGotAThumb)
									{
										CreateBackBufferCacheName(Storyboard.Nodes[iNewLevelNode].level_name, 512, 288);
										SaveImage(BackBufferCacheName.Get(), STORYBOARD_THUMBS + 402);
										if (FileExist(BackBufferCacheName.Get()))
										{
											//Load to correct id.
											image_setlegacyimageloading(true);
											LoadImageSize(BackBufferCacheName.Get(), Storyboard.Nodes[iNewLevelNode].thumb_id, 512, 288);
											image_setlegacyimageloading(false);
											strcpy(Storyboard.Nodes[iNewLevelNode].thumb, BackBufferCacheName.Get());
										}
									}

									iWaitForNewLevel--; //Close down window.
								}
								else
								{
									//Cancel just ignore.
								}

								//strcpy(Storyboard.Nodes[node].level_name, "");
								//Overwrite ?
							}
							else
							{
								strcpy(NewLevelError, "Error: Please give your level a name before save.");
							}
						}
						ImGui::SameLine();
						if (ImGui::StyleButton("Cancel", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
						{
							//Cancel.
							iWaitForNewLevel--;
						}

						ImGui::SetWindowFontScale(1.0);
						ImGui::Text("");

						bImGuiGotFocus = true;
						ImGui::Indent(-10);
						ImGui::EndPopup();
					}

				}
				else
				{
					strcpy(NewLevelName, "");
					strcpy(NewLevelError, "");
					iWaitForNewLevel--;
				}
			}
		}
		*/

		if (iWaitFor2DEditor > 0 && iWaitFor2DEditorNode >= 0)
		{

			if (!bScreen_Editor_Window)
			{
				if (iWaitFor2DEditor == 1)
				{
					//Closed.
					if (FileExist("thumbbank\\lastnewlevel.jpg"))
					{
						image_setlegacyimageloading(true);
						//Use a tmp unique image id
						LoadImageSize("thumbbank\\lastnewlevel.jpg", STORYBOARD_THUMBS + 401, 512, 288);
						image_setlegacyimageloading(false);

						if (ImageExist(STORYBOARD_THUMBS + 401))
						{
							//Get it into the correct id.
							image_setlegacyimageloading(true);
							LoadImageSize("thumbbank\\lastnewlevel.jpg", Storyboard.Nodes[iWaitFor2DEditorNode].thumb_id, 512, 288);
							image_setlegacyimageloading(false);

							if (ImageExist(Storyboard.Nodes[iWaitFor2DEditorNode].thumb_id))
							{
								//Save into thumbbank , and save thumb filename in node.
								//PE: Needed to add Storyboard.gamename so we dont get duplicates.
								cstr name = cstr("screen_") + cstr(Storyboard.gamename) + cstr("_") + cstr(Storyboard.Nodes[iWaitFor2DEditorNode].lua_name);
								CreateBackBufferCacheName(name.Get(), 512, 288);
								SaveImage(BackBufferCacheName.Get(), Storyboard.Nodes[iWaitFor2DEditorNode].thumb_id);
								if (FileExist(BackBufferCacheName.Get()))
								{
									if (CopyToProjectFolder(BackBufferCacheName.Get()))
									{
										//PE: Use relative projectbank filename.
										strcpy(Storyboard.Nodes[iWaitFor2DEditorNode].thumb, ProjectCacheName.Get());
									}
									else
									{
										strcpy(Storyboard.Nodes[iWaitFor2DEditorNode].thumb, BackBufferCacheName.Get());
									}
								}
							}
						}
					}
					//Close down.
					iWaitFor2DEditor = 0;
					iWaitFor2DEditorNode = -1;
				}
				else
					iWaitFor2DEditor--;
			}
		}
		if (iWaitForNewScreenshot > 0 && iScreenshotNode >= 0)
		{
			//PE: Start process after a load.
			if (iSkibFramesBeforeLaunch <= 0)
			{
				//PE: Let level load settle and terrain generation finish before starting.
				if (!bProceduralLevel && iWaitForNewScreenshot == 3)
				{
					//Startup take screenshot.
					extern bool bPopModalOpenProceduralCameraMode;
					bPopModalOpenProceduralCameraMode = true;
					bProceduralLevel = true;
					iWaitForNewScreenshot = 2;
					bProceduralLevelFromStoryboard = true; //So it dont quit.
				}
				else
				{
					if (iWaitForNewScreenshot == 2)
					{
						//Now wait for screenshot window to close.
						if (!bProceduralLevel)
						{
							//Closed, check created screenshot.
							bGotAThumb = false;
							if (FileExist("thumbbank\\lastnewlevel.jpg"))
							{
								image_setlegacyimageloading(true);
								//Use a tmp unique image id
								LoadImageSize("thumbbank\\lastnewlevel.jpg", STORYBOARD_THUMBS + 401, 512, 288);
								image_setlegacyimageloading(false);
								if (ImageExist(STORYBOARD_THUMBS + 401))
									bGotAThumb = true;
							}

							if(!bGotAThumb)
							{
								//No screenshot created just quit.
								iWaitForNewScreenshot = 0;
							}
							else
							{
								iWaitForNewScreenshot = 1;
							}
						}
					}
					else if (iWaitForNewScreenshot == 1)
					{
						//Last step. ask if they like to save new screenshot.
						ImGui::OpenPopup("Screenshot#Storyboard");
						ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Once);
						static int popwinheight = 0;
						if (popwinheight > 800 || iSkibFramesBeforeLaunch > 0)
						{
							ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Always);
						}
						ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
						bool bScreenshotWindow = true;
						if (ImGui::BeginPopupModal("Screenshot#Storyboard", &bScreenshotWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
						{
							popwinheight = ImGui::GetWindowSize().y;
							ImGui::Indent(10);
							ImGui::Text("");
							ImGui::SetWindowFontScale(1.4);
							ImGui::TextCenter("Use New Screenshot ?");
							ImGui::Separator();
							if (ImageExist(STORYBOARD_THUMBS + 401))
							{
								ImGui::ImgBtn(STORYBOARD_THUMBS + 401, ImVec2(512, 288), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false);
								ImGui::Separator();
							}
							ImGui::SetWindowFontScale(1.0);

							ImGui::SetWindowFontScale(1.4);
							if (ImGui::StyleButton("Use New Screenshot", ImVec2(ImGui::GetContentRegionAvail().x*0.5 - 20.0f, 0.0f)))
							{
								//Load into node slot.
								image_setlegacyimageloading(true);
								LoadImageSize("thumbbank\\lastnewlevel.jpg", Storyboard.Nodes[iScreenshotNode].thumb_id, 512, 288);
								image_setlegacyimageloading(false);

								if (ImageExist(Storyboard.Nodes[iScreenshotNode].thumb_id))
								{
									//Save into thumbbank , and save thumb filename in node.
									CreateBackBufferCacheName(Storyboard.Nodes[iScreenshotNode].level_name, 512, 288);
									SaveImage(BackBufferCacheName.Get(), Storyboard.Nodes[iScreenshotNode].thumb_id);
									if (FileExist(BackBufferCacheName.Get()))
									{
										if (CopyToProjectFolder(BackBufferCacheName.Get()))
										{
											//PE: Use relative projectbank filename.
											strcpy(Storyboard.Nodes[iScreenshotNode].thumb, ProjectCacheName.Get());
										}
										else
										{
											strcpy(Storyboard.Nodes[iScreenshotNode].thumb, BackBufferCacheName.Get());
										}
									}
								}
								iWaitForNewScreenshot = 0;
							}
							ImGui::SameLine();
							if (ImGui::StyleButton("Cancel", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
							{
								//Cancel.
								iWaitForNewScreenshot = 0;
							}

							ImGui::SetWindowFontScale(1.0);
							ImGui::Text("");

							bImGuiGotFocus = true;
							ImGui::Indent(-10);
							ImGui::EndPopup();
						}
					}
					else
					{
						iWaitForNewScreenshot--;
					}
				}
			}

			if (iWaitForNewScreenshot == 0)
			{
				//Quit.
				iScreenshotNode = -1;
				extern bool bPopModalOpenProceduralCameraMode;
				bPopModalOpenProceduralCameraMode = false;
			}
		}



		//#########################
		//#### Duplicate Level ####
		//#########################

		static char DuplicateLevelName[256] = "\0";
		static char DuplicateLevelError[256] = "\0";
		if (bDuplicateLevel && iDuplicateNode >= 0)
		{
			//Ask to save duplicate level.
			ImGui::OpenPopup("Duplicate Level#Storyboard");
			ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Once);
			static int popwinheight = 0;
			if (popwinheight > 800 || iSkibFramesBeforeLaunch > 0)
			{
				ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Always);
			}
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bool bDuplicateLevelWindow = true;
			if (ImGui::BeginPopupModal("Duplicate Level#Storyboard", &bDuplicateLevelWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
			{
				popwinheight = ImGui::GetWindowSize().y;
				ImGui::Indent(10);
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);
				ImGui::TextCenter("Duplicate Level As");
				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);
				ImGui::Separator();
				if (ImageExist(Storyboard.Nodes[iDuplicateNode].thumb_id))
				{
					ImGui::ImgBtn(Storyboard.Nodes[iDuplicateNode].thumb_id, ImVec2(512, 288), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false);
					ImGui::Separator();
				}
				else
				{
					ImGui::Dummy(ImVec2(512, 288));
					ImGui::Separator();
				}
				ImGui::SetWindowFontScale(1.0);

				ImGui::TextWrapped("To duplicate this level, please give it a new name and click 'Save'");
				ImGui::Text("");
				if (strlen(DuplicateLevelError) > 0)
				{
					ImGui::Text(DuplicateLevelError);
					ImGui::Text("");
				}
				ImGui::Text("Duplicate Level Name");
				ImGui::PushItemWidth(-10);
				ImGui::InputText("##DuplicateLevelNameStoryboard", DuplicateLevelName, 250, ImGuiInputTextFlags_None); //ImGuiInputTextFlags_None ImGuiInputTextFlags_ReadOnly
				ImGui::PopItemWidth();

				ImGui::Text("");

				ImGui::SetWindowFontScale(1.4);
				if (ImGui::StyleButton("Save Level", ImVec2(ImGui::GetContentRegionAvail().x*0.5 - 20.0f, 0.0f)))
				{
					if (strlen(DuplicateLevelName) > 0)
					{
						char tmp[MAX_PATH];
						strcpy(tmp, g.mysystem.mapbankAbs_s.Get());
						//Relative.
						char *find = (char *)pestrcasestr(tmp, "mapbank\\");
						if (find && find != &tmp[0]) strcpy(&tmp[0], find);
						strcat(tmp, DuplicateLevelName);

						t.returnstring_s = tmp;

						if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) != ".fpm")  t.returnstring_s = t.returnstring_s + ".fpm";
						g.projectfilename_s = t.returnstring_s;

						bool oksave = true;
						if (FileExist(g.projectfilename_s.Get())) {
							oksave = overWriteFileBox(g.projectfilename_s.Get());
						}
						if (oksave)
						{
							//Add newly saved fpm level to recent list.
							int firstempty = -1;
							int i = 0;
							for (; i < REMEMBERLASTFILES; i++) {
								if (firstempty == -1 && strlen(pref.last_open_files[i]) <= 0)
									firstempty = i;
								if (strlen(pref.last_open_files[i]) > 0 && pestrcasestr(g.projectfilename_s.Get(), pref.last_open_files[i])) { //already there
									break;
								}
							}
							if (i >= REMEMBERLASTFILES) {
								if (firstempty == -1) {
									//No empty slots , rotate.
									for (int ii = 0; ii < REMEMBERLASTFILES - 1; ii++) {
										strcpy(pref.last_open_files[ii], pref.last_open_files[ii + 1]);
									}
									strcpy(pref.last_open_files[REMEMBERLASTFILES - 1], g.projectfilename_s.Get());
								}
								else
									strcpy(pref.last_open_files[firstempty], g.projectfilename_s.Get());
							}

							//PE: Find next level from nodes.
							int iNextLevel = 0, levelname = -1, iFirstNodeFree = -1;
							FindFreeLevelNode(iNextLevel, levelname, iFirstNodeFree);

							if (iFirstNodeFree >= 0)
							{
								//Create new level.
								char tmp[255];
								int node = iFirstNodeFree;
								int nodeposy = iNextLevel;
								if (levelname > 0)
								{
									sprintf(tmp, "Level %d", levelname);
									nodeposy = levelname - 1;
								}
								else
									sprintf(tmp, "Level %d", iNextLevel + 1);

								//PE: Make sure any old data is removed, also thumbs.
								reset_single_node(node);

								Storyboard.Nodes[node].used = true;
								Storyboard.Nodes[node].type = STORYBOARD_TYPE_LEVEL;
								Storyboard.Nodes[node].restore_position = ImVec2(preview_size_x*0.5 - (fNodeWidth*0.5) + ((fNodeWidth + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + ((fNodeHeight + 20.0 + NODE_HEIGHT_PADDING) * (nodeposy)));
								Storyboard.Nodes[node].iEditEnable = true;
								strcpy(Storyboard.Nodes[node].title, tmp);
								strcpy(Storyboard.Nodes[node].levelnumber, tmp);

								strcpy(Storyboard.Nodes[node].thumb, "");
								//Input.
								strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
								//Output.
								strcpy(Storyboard.Nodes[node].output_title[0], " GAME WON -> Connect to Scene ");
								strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
								Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
								Storyboard.Nodes[node].output_linkto[0] = 0;

								strcpy(Storyboard.Nodes[node].output_title[1], " GAME OVER -> Connect to Scene ");
								strcpy(Storyboard.Nodes[node].output_action[1], "loadlevel"); //Not defined this yet.
								Storyboard.Nodes[node].output_can_link_to_type[1] = STORYBOARD_TYPE_SCREEN;
								Storyboard.Nodes[node].output_linkto[1] = 0;

								strcpy(Storyboard.Nodes[node].output_title[2], " NEXT LEVEL -> Connect to Level ");
								strcpy(Storyboard.Nodes[node].output_action[2], "loadlevel"); //Not defined this yet.
								Storyboard.Nodes[node].output_can_link_to_type[2] = STORYBOARD_TYPE_LEVEL;
								Storyboard.Nodes[node].output_linkto[2] = 0;
								ImNodes::SetNodeGridSpacePos(Storyboard.Nodes[node].id, Storyboard.Nodes[node].restore_position);


								iLaunchAfterSync = 503; //Do the actualy save here.
								iSkibFramesBeforeLaunch = 3;
								strcpy(cTriggerMessage, "Saving Level ...");
								bTriggerMessage = true;

								strcpy(Storyboard.Nodes[node].title, DuplicateLevelName);
								strcpy(Storyboard.Nodes[node].level_name, g.projectfilename_s.Get());

								if (ImageExist(Storyboard.Nodes[iDuplicateNode].thumb_id))
								{
									//Save old thumb to new thumb.
									CreateBackBufferCacheName(Storyboard.Nodes[node].level_name, 512, 288);
									SaveImage(BackBufferCacheName.Get(), Storyboard.Nodes[iDuplicateNode].thumb_id);
									if (FileExist(BackBufferCacheName.Get()))
									{
										if (CopyToProjectFolder(BackBufferCacheName.Get()))
										{
											//PE: Use relative projectbank filename.
											strcpy(Storyboard.Nodes[node].thumb, ProjectCacheName.Get());
										}
										else
										{
											strcpy(Storyboard.Nodes[node].thumb, BackBufferCacheName.Get());
										}
										//PE: Load in new thumb to own id.
										SetMipmapNum(1); //PE: mipmaps not needed.
										image_setlegacyimageloading(true);
										LoadImageSize(Storyboard.Nodes[node].thumb, Storyboard.Nodes[node].thumb_id, 512, 288);
										image_setlegacyimageloading(false);
										SetMipmapNum(-1);
									}
								}
								bDuplicateLevel = false;
							}
							else
							{
								strcpy(DuplicateLevelError, "Error: Could not find a free node.");
							}
						}
						else
						{
							//Cancel just ignore.
						}

						//strcpy(Storyboard.Nodes[node].level_name, "");
						//Overwrite ?
					}
					else
					{
						strcpy(DuplicateLevelError, "Error: Please give your level a name before save.");
					}
				}
				ImGui::SameLine();
				if (ImGui::StyleButton("Cancel", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					//Cancel.
					bDuplicateLevel = false;
				}

				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");

				bImGuiGotFocus = true;
				ImGui::Indent(-10);
				ImGui::EndPopup();
			}

		}


		//######################
		//#### Rename Level ####
		//######################

		static char RenameLevelName[256] = "\0";
		static char RenameOriginalLevelName[MAX_PATH] = "\0";
		static char RenameLevelError[256] = "\0";
		if (bRenameLevel && iRenameNode >= 0)
		{
			//Ask to Rename level.
			ImGui::OpenPopup("Rename Level##Storyboard");
			ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Once);
			static int popwinheight = 0;
			if (popwinheight > 800 || iSkibFramesBeforeLaunch > 0)
			{
				ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Always);
			}
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bool bRenameLevelWindow = true;
			if (ImGui::BeginPopupModal("Rename Level##Storyboard", &bRenameLevelWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
			{
				popwinheight = ImGui::GetWindowSize().y;
				ImGui::Indent(10);
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);
				ImGui::TextCenter("Rename Level");
				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);
				ImGui::Separator();
				if (ImageExist(Storyboard.Nodes[iRenameNode].thumb_id))
				{
					ImGui::ImgBtn(Storyboard.Nodes[iRenameNode].thumb_id, ImVec2(512, 288), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false);
					ImGui::Separator();
				}
				else
				{
					ImGui::Dummy(ImVec2(512, 288));
					ImGui::Separator();
				}
				ImGui::SetWindowFontScale(1.0);

				ImGui::TextWrapped("To rename this level, please give it a new name and click 'Rename'");
				ImGui::Text("");
				if (strlen(RenameLevelError) > 0)
				{
					ImGui::Text(RenameLevelError);
					ImGui::Text("");
				}
				ImGui::Text("Rename Level To");
				ImGui::PushItemWidth(-10);
				ImGui::InputText("##RenameLevelNameStoryboard", RenameLevelName, 250, ImGuiInputTextFlags_None); //ImGuiInputTextFlags_None ImGuiInputTextFlags_ReadOnly
				ImGui::PopItemWidth();

				ImGui::Text("");

				ImGui::SetWindowFontScale(1.4);
				if (ImGui::StyleButton("Rename Level", ImVec2(ImGui::GetContentRegionAvail().x*0.5 - 20.0f, 0.0f)))
				{
					if (strlen(RenameLevelName) > 0)
					{
						char tmp[MAX_PATH];
						strcpy(tmp, g.mysystem.mapbankAbs_s.Get());
						//Relative.
						char *find = (char *)pestrcasestr(tmp, "mapbank\\");
						if (find && find != &tmp[0]) strcpy(&tmp[0], find);
						strcat(tmp, RenameLevelName);

						t.returnstring_s = tmp;

						if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) != ".fpm")  t.returnstring_s = t.returnstring_s + ".fpm";
						g.projectfilename_s = t.returnstring_s;

						bool oksave = true;
						if (FileExist(g.projectfilename_s.Get())) {
							oksave = overWriteFileBox(g.projectfilename_s.Get());
						}
						if (oksave)
						{
							//PE: Just rename level.
							//PE: Also remember thumb ?

							//PE: If level is not from doc write do not delete the original, but only make a copy.
							bool bIsInstallFolder = false;
							extern char szRootDir[MAX_PATH];
							if (pestrcasestr(RenameOriginalLevelName, szRootDir)) bIsInstallFolder = true;

							char destination[MAX_PATH];
							strcpy(destination, g.projectfilename_s.Get());
							GG_GetRealPath(destination, 1); //Resolve name. need full path.

							if (bIsInstallFolder)
							{
								CopyFileA(RenameOriginalLevelName, destination,false);
							}
							else
							{
								rename(RenameOriginalLevelName, destination);
							}

							if (FileExist(destination))
							{

								//Now setup new level name include relative only.
								strcpy(tmp, destination);
								char *find = (char *)pestrcasestr(tmp, "mapbank\\");
								if (find && find != &tmp[0]) strcpy(&tmp[0], find);
								strcpy(Storyboard.Nodes[iRenameNode].level_name, tmp);

								//Setup new title.
								std::string sLevelTitle = Storyboard.Nodes[iRenameNode].level_name;
								replaceAll(sLevelTitle, ".fpm", "");
								replaceAll(sLevelTitle, "mapbank\\", "");
								strcpy(Storyboard.Nodes[iRenameNode].title, sLevelTitle.c_str());

								bRenameLevel = false;

								//PE: Save changes if possible.
								if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
								{
									save_storyboard(Storyboard.gamename, false);
								}

							}
							else
							{
								strcpy(RenameLevelError, "Error: Rename failed no changes done.");
							}
						}
						else
						{
							//Cancel just ignore.
						}
					}
					else
					{
						strcpy(RenameLevelError, "Error: Please give your level a new name before renaming.");
					}
				}
				ImGui::SameLine();
				if (ImGui::StyleButton("Cancel", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					//Cancel.
					bRenameLevel = false;
				}

				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");

				bImGuiGotFocus = true;
				ImGui::Indent(-10);
				ImGui::EndPopup();
			}

		}


		bool bReadyToOpen = false;
		if (bTriggerOpenProject)
		{
			if (iDelayTriggerOpenProject > 0)
			{
				iDelayTriggerOpenProject--;
				if (iDelayTriggerOpenProject == 0)
				{
					strcpy(cNextWindowFocus, "Open Project##Storyboard");
					iSkibFramesBeforeLaunch = 2;
					iLaunchAfterSync = 81; //Delayed window focus.
				}
			}
			else
			{
				bReadyToOpen = true;
			}
		}
		if (bReadyToOpen)
		{
			//Open Project window.
			static char OpenProjectName[256] = "\0";
			static char OpenProjectError[256] = "\0";

			ImGui::OpenPopup("Open Project##Storyboard");
			ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Once);
			static int popwinheight = 0;
			if (popwinheight > 800 || iSkibFramesBeforeLaunch > 0)
			{
				ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Always);
			}
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bool bOpenWindow = true;
			//PE: Somehow cant get this window ontop ?
			//if (ImGui::BeginPopupModal("Open Project##Storyboard", &bOpenWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
			if (ImGui::BeginPopupModal("Open Project##Storyboard", &bOpenWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
			{
				popwinheight = ImGui::GetWindowSize().y;
				ImGui::Indent(10);
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);
				ImGui::TextCenter("Open Game Project");
				ImGui::Separator();

				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");
				ImGui::Text("Select the project to open and click 'Open Project'");
				ImGui::SameLine(); ImGui::Text(" ");
				ImGui::Text("");
				if (strlen(OpenProjectError) > 0)
				{
					ImGui::Text(OpenProjectError);
					ImGui::Text("");
				}
				//Ignore _backup files.

				GetProjectList("projectbank\\");
				static std::string current_project_selected = "";
				ImVec2 size = { ImGui::GetContentRegionAvailWidth(),0 };

				float fHeight = ImGui::GetFontSize() * 10.0;

				ImGui::Text("Projects");
				ImGui::SameLine();
				static bool bDisplayBackups = false;
				float fBoxWidth = ImGui::CalcTextSize("Display Backups").x;
				ImGui::SetCursorPosX((ImGui::GetCursorPosX() + ImGui::GetContentRegionAvail().x) - 10.0 - 30.0 - fBoxWidth);
				ImGui::Checkbox("Display Backups", &bDisplayBackups);
				ImGui::BeginChild("Projects##FileOpenStoryboard", ImVec2(ImGui::GetContentRegionAvail().x - 10.0, fHeight), true, iGenralWindowsFlags);
				bool bTriggerLoad = false;
				if (projectbank_list.size() > 0)
				{
					float fRegAvail = ImGui::GetContentRegionAvailWidth() - 10.0;
					for (int i = 0; i < projectbank_list.size(); i++)
					{
						if (bDisplayBackups || !pestrcasestr((char *)projectbank_list[i].c_str(), "_backup_"))
						{
							bool bSelected = false;
							if (current_project_selected == projectbank_list[i]) bSelected = true;
							if (ImGui::Selectable(projectbank_list[i].c_str(), bSelected))
							{
								current_project_selected = projectbank_list[i];
							}
							if(ImGui::IsItemHovered())
							{
								if (ImGui::IsMouseDoubleClicked(0))
								{
									current_project_selected = projectbank_list[i];
									bTriggerLoad = true;
								}
							}
						}
					}
				}
				else
				{
					ImGui::Text("No Projects Found.");
				}
				ImGui::EndChild();
				ImGui::PushItemWidth(-10);
				ImGui::InputText("##OpenProjectStoryboardText", (char *) current_project_selected.c_str(), 250, ImGuiInputTextFlags_ReadOnly); //ImGuiInputTextFlags_None
				ImGui::PopItemWidth();

				ImGui::Text("");

				ImGui::SetWindowFontScale(1.4);
				if (bTriggerLoad || ImGui::StyleButton("Open Project", ImVec2(ImGui::GetContentRegionAvail().x*0.5 - 20.0f, 0.0f)))
				{
					//Open
					load_storyboard( (char *) current_project_selected.c_str());
					iGamePausedNodeID = storyboard_add_missing_nodex(8, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iLoadGameNodeID = storyboard_add_missing_nodex(3, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iSaveGameNodeID = storyboard_add_missing_nodex(9, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iGraphicsNodeID = storyboard_add_missing_nodex(10, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iSoundsNodeID = storyboard_add_missing_nodex(11, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iControlNodeID = storyboard_add_missing_nodex(12, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iLoadingScreenNodeID = storyboard_add_missing_nodex(2, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					
					bTriggerOpenProject = false;
					bOpenProjectsFromWelcome = false;
				}
				ImGui::SameLine();
				if (ImGui::StyleButton("Cancel", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					//Cancel.
					bTriggerOpenProject = false;
					if (bOpenProjectsFromWelcome)
					{
						bWelcomeScreen_Window = true;
						bStoryboardWindow = false;
						bOpenProjectsFromWelcome = false;
					}
				}

				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");

				bImGuiGotFocus = true;
				ImGui::Indent(-10);
				ImGui::EndPopup();

				bBlockNextMouseCheck = true;
			}
		}
		if (bStoryboardWindowOpenLoad)
		{
			bTriggerOpenProject = true;
			bStoryboardWindowOpenLoad = false;
			bTriggerSaveAs = false;
			bTriggerSaveAsAfterNewLevel = false;
		}

		int iCreateRet = save_create_storyboard_project();
		/*
		if (bTriggerSaveAs)
		{
			//Ask to save as.

			ImGui::OpenPopup("Save As#Storyboard");
			ImGui::SetNextWindowSize(ImVec2(0, 524), ImGuiCond_Once);
			static int popwinheight = 0;
			if (popwinheight > 800 || iSkibFramesBeforeLaunch > 0)
			{
				ImGui::SetNextWindowSize(ImVec2(0, 524), ImGuiCond_Always);
			}
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bool bSaveAsWindow = true;
			if (ImGui::BeginPopupModal("Save As#Storyboard", &bSaveAsWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
			{
				popwinheight = ImGui::GetWindowSize().y;
				ImGui::Indent(10);
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);
				if (bTriggerSaveAsAfterNewLevel)
				{
					ImGui::TextCenter("Create New Game Project");
					ImGui::SetWindowFontScale(1.0);
					ImGui::Text("");
				}
				else
				{
					ImGui::TextCenter("Save Game Project As");
				}
				ImGui::Separator();

				ImGui::Dummy(ImVec2(460, 1));
				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");
				if (bTriggerSaveAsAfterNewLevel)
				{
					ImGui::Text("Please give your new game project a name and click 'save'");
				}
				else
				{
					ImGui::Text("To save your game project, please give your project a name and click 'save'");
				}
				ImGui::Text("");
				ImGui::TextWrapped("NOTE: This name will also be used as your standalone game name.");
				ImGui::Text("");
				if (strlen(SaveProjectAsError) > 0)
				{
					ImGui::Text(SaveProjectAsError);
					ImGui::Text("");
				}
				ImGui::Text("Game Project Name");
				ImGui::PushItemWidth(-10);
				if (ImGui::InputText("##SaveAsNameStoryboard", SaveProjectAsName, 250, ImGuiInputTextFlags_None))//ImGuiInputTextFlags_None ImGuiInputTextFlags_ReadOnly
				{
					//Clean name.
					std::string sCleanName = SaveProjectAsName;
					replaceAll(sCleanName, """", "");
					replaceAll(sCleanName, "\\", "");
					replaceAll(sCleanName, "/", "");
					replaceAll(sCleanName, "^", "");
					replaceAll(sCleanName, "?", "");
					replaceAll(sCleanName, "@", "");
					strcpy(SaveProjectAsName, sCleanName.c_str());
				}
				ImGui::PopItemWidth();

				ImGui::Text("");

				ImGui::SetWindowFontScale(1.4);

				bool bClicked = false;
				if (bTriggerSaveAsAfterNewLevel)
				{
					//ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2( (ImGui::GetContentRegionAvailWidth()*0.25), 0)); //Center with new header.
					bClicked = ImGui::StyleButton("Save", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f));
				}
				else
					bClicked = ImGui::StyleButton("Save As", ImVec2(ImGui::GetContentRegionAvail().x*0.5 - 20.0f, 0.0f));

				if(bClicked)
				{
					if (strlen(SaveProjectAsName) > 0)
					{
						char destination[MAX_PATH];
						strcpy(destination, "projectbank\\");
						strcat(destination, SaveProjectAsName);
						GG_GetRealPath(destination, 1);
						int bOkSave = true;
						if (PathExist(destination) == 1)
						{
							int iAction = askBoxCancel("Project already exists, do you want to overwrite ?", "Confirmation"); //1==Yes 2=Cancel 0=No
							if (iAction == 1)
							{
								//backup old folder.
								int i_loop = 1;
								char backup[MAX_PATH];
								sprintf(backup, "%s_backup_%d", destination, i_loop++);
								while (MoveFileA(destination, backup) == 0)
										sprintf(backup, "%s_backup_%d", destination, i_loop++);
							}
							else
							{
								//Cancel.
								bOkSave = false;
							}
						}
						if (bOkSave)
						{
							//Continue.
							MakeDirectory(destination);
							strcat(destination, "\\project.dat");
							strcpy(Storyboard.gamename, SaveProjectAsName);
							Storyboard.project_readonly = 0;
							save_storyboard(Storyboard.gamename, false);
							bTriggerSaveAs = false;
							bTriggerSaveAsAfterNewLevel = false;
						}
					}
					else
					{
						strcpy(SaveProjectAsError, "Error: Please give your game project a name before saving.");
					}
				}
				if (!bTriggerSaveAsAfterNewLevel)
				{
					ImGui::SameLine();
					if (ImGui::StyleButton("Cancel", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
					{
						//Cancel.
						bTriggerSaveAs = false;
						bTriggerSaveAsAfterNewLevel = false;
					}
				}
				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");

				bImGuiGotFocus = true;
				ImGui::Indent(-10);
				ImGui::EndPopup();
			}
		}
		*/

		if (!bPopModalStoryboard)
		{
			if (bModal)
				ImGui::OpenPopup("##StoryboardWindow");
		}
		static int UpdateThumbOnNode = -1;
		if (UpdateThumbOnNode >= 0)
		{
			image_setlegacyimageloading(true);
			if (Storyboard.Nodes[UpdateThumbOnNode].type == STORYBOARD_TYPE_SPLASH)
			{
				//PE: On splash load directly. Splash always get a center positons.
				bool bUseRealSplash = true;
				if ( strcmp(Storyboard.Nodes[UpdateThumbOnNode].thumb, "editors\\uiv3\\loadingsplash-ea.jpg") == 0)
				{
					LoadImage("editors\\uiv3\\user-splash-screen.png", Storyboard.Nodes[UpdateThumbOnNode].thumb_id);
					if(ImageExist(Storyboard.Nodes[UpdateThumbOnNode].thumb_id)) bUseRealSplash = false;
				}

				if(bUseRealSplash)
					LoadImage(Storyboard.Nodes[UpdateThumbOnNode].thumb, Storyboard.Nodes[UpdateThumbOnNode].thumb_id);
			}
			else
			{
				LoadImageSize(Storyboard.Nodes[UpdateThumbOnNode].thumb, Storyboard.Nodes[UpdateThumbOnNode].thumb_id, 512, 288);
			}
			image_setlegacyimageloading(false);

			UpdateThumbOnNode = -1;
		}
		if (!bStoryboardFirstRunSetInitPos)
		{

			if (Storyboard.iStoryboardVersion != STORYBOARDVERSION)
			{
				//PE: Convert old storyboard setups if needed.
				if (Storyboard.iStoryboardVersion == 100 && Storyboard.project_readonly == 0)
				{
					Storyboard.iStoryboardVersion = STORYBOARDVERSION;
					Storyboard.iChanged = true;
					//PE: Convert old thumb path to new projectbank path, and copy thumbs.
					for (int i = 0; i < STORYBOARD_MAXNODES; i++)
					{
						bool bValid = true;
						if (bValid && Storyboard.Nodes[i].used)
						{
							if (strlen(Storyboard.Nodes[i].thumb) > 0)
							{
								//CreateBackBufferCacheName(Storyboard.Nodes[i].thumb, 512, 288); //PE: Thumb is already in CacheName format.
								char *find = (char *)pestrcasestr(Storyboard.Nodes[i].thumb, "thumbbank\\");
								if (find)
								{
									if (CopyToProjectFolder(Storyboard.Nodes[i].thumb))
									{
										//PE: Use relative projectbank filename.
										if (FileExist(ProjectCacheName.Get()))
										{
											strcpy(Storyboard.Nodes[i].thumb, ProjectCacheName.Get());
										}
									}
								}
							}
							if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL)
							{
								if (strlen(Storyboard.Nodes[i].level_name) > 0)
								{
									//CreateBackBufferCacheName(Storyboard.Nodes[i].level_name, 512, 288);
									char *find = (char *)pestrcasestr(Storyboard.Nodes[i].thumb, "thumbbank\\");
									if (find)
									{
										if (CopyToProjectFolder(Storyboard.Nodes[i].thumb))
										{
											//PE: Use relative projectbank filename.
											if (FileExist(ProjectCacheName.Get()))
											{
												strcpy(Storyboard.Nodes[i].thumb, ProjectCacheName.Get());
											}
										}
									}
								}
							}
						}
					}
				}
			}
			//PE: Initial position. and initial nodes.

			if (ImageExist(Storyboard.game_icon_id)) DeleteImage(Storyboard.game_icon_id);
			if (ImageExist(Storyboard.game_thumb_id)) DeleteImage(Storyboard.game_thumb_id);
			if (strlen(Storyboard.game_thumb) > 0)
			{
				image_setlegacyimageloading(true);
				LoadImage(Storyboard.game_thumb, Storyboard.game_thumb_id);
				image_setlegacyimageloading(false);
			}
			if (strlen(Storyboard.game_icon) > 0)
			{
				image_setlegacyimageloading(true);
				//LoadImage(Storyboard.game_icon, Storyboard.game_icon_id);
				LoadImageSize(Storyboard.game_icon, Storyboard.game_icon_id, 256, 256);
				image_setlegacyimageloading(false);
			}

			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				bool bValid = true;
				if (bValid && Storyboard.Nodes[i].used)
				{

					if (ImageExist(Storyboard.Nodes[i].screen_backdrop_id)) DeleteImage(Storyboard.Nodes[i].screen_backdrop_id);
					if (strlen(Storyboard.Nodes[i].screen_backdrop) > 0)
					{
						//Backdrop.
						image_setlegacyimageloading(true);
						LoadImage(Storyboard.Nodes[i].screen_backdrop, Storyboard.Nodes[i].screen_backdrop_id);
						image_setlegacyimageloading(false);
					}

					ImNodes::SetNodeGridSpacePos(Storyboard.Nodes[i].id, Storyboard.Nodes[i].restore_position);

					if (ImageExist(Storyboard.Nodes[i].thumb_id)) DeleteImage(Storyboard.Nodes[i].thumb_id);
					if (!ImageExist(Storyboard.Nodes[i].thumb_id) && strlen(Storyboard.Nodes[i].thumb) > 0)
					{
						image_setlegacyimageloading(true);
						if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
						{
							//PE: On splash load directly. Splash always get a center positons.
							bool bUseRealSplash = true;
							if (strcmp(Storyboard.Nodes[i].thumb, "editors\\uiv3\\loadingsplash-ea.jpg") == 0)
							{
								LoadImage("editors\\uiv3\\user-splash-screen.png", Storyboard.Nodes[i].thumb_id);
								if (ImageExist(Storyboard.Nodes[i].thumb_id)) bUseRealSplash = false;
							}

							if (bUseRealSplash)

							LoadImage(Storyboard.Nodes[i].thumb, Storyboard.Nodes[i].thumb_id);
						}
						else
						{
							LoadImageSize(Storyboard.Nodes[i].thumb, Storyboard.Nodes[i].thumb_id, 512, 288);
							if (!ImageExist(Storyboard.Nodes[i].thumb_id))
							{
								//PE: Try relative path.
								char tmp[MAX_PATH];
								strcpy(tmp, Storyboard.Nodes[i].thumb);
								char *find = (char *) pestrcasestr(tmp, "\\thumbbank\\");
								if (find)
								{
									find++;
									LoadImageSize(find, Storyboard.Nodes[i].thumb_id, 512, 288);
									if (ImageExist(Storyboard.Nodes[i].thumb_id))
									{
										//PE: Update thumb path.
										strcpy(Storyboard.Nodes[i].thumb,find);
									}
									else
									{
										//Relative also failed, use default.
										if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && i == iTitleScreenNodeID)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_title.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && i == 2)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_loading.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && i == iLoadGameNodeID)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_loadgame.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && i == 4)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_about.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title,"Game Won Screen") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_win.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title, "Game Over Screen") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_lose.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title, "Game Paused") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_gamemenu.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title, "Load Game Screen") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_loadgame.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title, "Save Game Screen") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_savegame.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title, "Sound Settings Screen") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_sounds.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title, "Graphics Settings Screen") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_graphics.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title, "Controls Screen") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_controls.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}

									}
								}

							}
						}
						image_setlegacyimageloading(false);
					}
				}
			}
			if (GImNodes)
			{
				//Reset grid.
				ImNodes::EditorContextResetPanning(Storyboard.vEditorPanning);
			}

			bStoryboardFirstRunSetInitPos = true;
		}

		//#### Init Done ####

		#ifdef INCLUDE_GAME_SETTINGS

		if (bEditGameSettings)
		{
			//PE: Cant use modal, as we use the objectlib.

			int iWindowWidth = 1100;
			int iWindowHeight = 600;
			float buttonwide = 200.0f;
			//ImGui::OpenPopup("Edit Game Settings##Storyboard");
			//ImGui::SetNextWindowSize(ImVec2(iWindowWidth, iWindowHeight), ImGuiCond_Always);
			//ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			ImGui::SetNextWindowSize(ImVec2(iWindowWidth, iWindowHeight), ImGuiCond_Always);
			//static bool bUpdateWinPos = false;
			//static ImVec2 winpos = ImVec2(iWindowWidth, iWindowHeight);
			//if (bUpdateWinPos)
			//{
			//	ImGui::SetNextWindowPos(winpos,ImGuiCond_Always);
			//	bUpdateWinPos = false;
			//}
			//else
			//{
				ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
			//}
			bool bOpenWindow = true;
			//if (ImGui::BeginPopupModal("Edit Game Settings##Storyboard", &bOpenWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))

			if (ImGui::Begin("Edit Game Settings##Storyboard", &bEditGameSettings, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings))
			{
				//PE: Header look.
				ImGuiWindow* window = ImGui::GetCurrentWindow();
				float fToolbarHeight = 74.0f;
				ImVec4 style_headerback = ImGui::GetStyle().Colors[ImGuiCol_TitleBgActive];
				style_headerback.w = 1.0f;
				ImRect rHeader = { ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImVec2(ImGui::GetWindowSize().x, fToolbarHeight) };
				if(window) window->DrawList->AddRectFilled(rHeader.Min, rHeader.Max, ImGui::GetColorU32(style_headerback), 0.0f, ImDrawCornerFlags_None);

				ImVec4 style_back = ImGui::GetStyle().Colors[ImGuiCol_WindowBg] * ImVec4(0.9, 0.9, 0.9, 0.9); //A Little darker.
				style_back.w = 1.0f;


				/*
				static bool bDragTitleActive = false;
				if ( (ImGui::IsMouseHoveringRect(rHeader.Min, rHeader.Max, true) || bDragTitleActive) && ImGui::IsMouseDragging())
				{
					if (ImGui::IsMouseDragging())
					{
						float offsetx = ImGui::GetIO().MouseDelta.x;
						float offsety = ImGui::GetIO().MouseDelta.y;
						winpos += ImVec2(offsetx, offsety);
						bDragTitleActive = true;
						bUpdateWinPos = true;
					}
				}
				if (!ImGui::IsMouseDown(0))
					bDragTitleActive = false;
				*/

				ImGui::Text("");
				ImGui::SetWindowFontScale(1.8);
				ImGui::TextCenter("Editing: Game Project Settings.");
				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");

				ImVec2 vCurPos = ImGui::GetCursorPos();
				ImVec2 vIconSize = { (float)ImGui::GetFontSize()*4.0f, (float)ImGui::GetFontSize()*4.0f };
				ImGui::SetCursorPos(ImVec2(3.0f, 7.0 + 1.0f));
				ImGui::SetItemAllowOverlap();
				if (ImGui::ImgBtn(TOOL_GOBACK, vIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
				{
					bEditGameSettings = false;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Exit to Storyboard");
				ImGui::SetCursorPos(vCurPos);

				ImGui::Columns(2, "StoryboardWindowGameSettingsColumns", false);  //false no border
				ImGui::SetColumnOffset(0, 0.0f);
				ImGui::SetColumnOffset(1, (float)iWindowWidth * 0.75);


				//Storyboard.game_icon_id

				static int iChangeTab = 0;
				if (ImGui::BeginTabBar("GameSettingstabbar"))
				{
					int tabflags = 0;
					if (iChangeTab == 1)
					{
						iChangeTab = 0;
						tabflags = ImGuiTabItemFlags_SetSelected;
					}

					static bool bUpdateThumbImage = false;
					if (bUpdateThumbImage)
					{
						bUpdateThumbImage = false;
						if (ImageExist(Storyboard.game_thumb_id)) DeleteImage(Storyboard.game_thumb_id);
						if (strlen(Storyboard.game_thumb) > 0)
						{
							image_setlegacyimageloading(true);
							LoadImage(Storyboard.game_thumb, Storyboard.game_thumb_id);
							image_setlegacyimageloading(false);
						}
					}

					static bool bUpdateIconImage = false;
					if (bUpdateIconImage)
					{
						bUpdateIconImage = false;
						if (ImageExist(Storyboard.game_icon_id)) DeleteImage(Storyboard.game_icon_id);
						if (strlen(Storyboard.game_icon) > 0)
						{
							image_setlegacyimageloading(true);
							LoadImage(Storyboard.game_icon, Storyboard.game_icon_id);
							image_setlegacyimageloading(false);
						}
					}

					if (ImGui::BeginTabItem(" Thumbnail ", NULL, tabflags))
					{
						ImGui::SetWindowFontScale(1.4);
						ImGui::Text("");
						ImGui::TextCenter("Change Game Thumbnail");
						ImGui::Text("");
						ImGui::SetWindowFontScale(1.0);

						ImGui::TextCenter("For best result use a 16:9 ratio image like 1920×1080.");

						ImVec2 cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (512*0.5), 0.0f));
						ImGui::SetCursorPos(cPos);
						if (ImageExist(Storyboard.game_thumb_id))
						{
							//Need ratio here. fit to 288 height.
							ImGui::ImgBtn(Storyboard.game_thumb_id, ImVec2(512, 288), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false);
						}
						else
						{
							if (window) window->DrawList->AddRectFilled(window->DC.CursorPos, window->DC.CursorPos + ImVec2(512, 288), ImGui::GetColorU32(style_back), 0.0f, ImDrawCornerFlags_None);
							ImGui::Dummy(ImVec2(512, 288));
						}

						cstr UniqueThumbnailSelect = "##StoryboardSelectThumbnail";
						if (iSelectedLibraryStingReturnID == window->GetID(UniqueThumbnailSelect.Get()))
						{
							strcpy(Storyboard.game_thumb, sSelectedLibrarySting.Get());
							bUpdateThumbImage = true; //Update thumb.
							sSelectedLibrarySting = "";
							iSelectedLibraryStingReturnID = -1; //disable.
							Storyboard.iChanged = true;
						}


						ImGui::SetWindowFontScale(1.4);
						ImGui::Text("");

						cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
						ImGui::SetCursorPos(cPos);

						if (ImGui::StyleButton("Select a New Image", ImVec2(buttonwide, 0.0f)))
						{
							bExternal_Entities_Window = true;
							iDisplayLibraryType = 2; //Image
							iLibraryStingReturnToID = window->GetID(UniqueThumbnailSelect.Get());
							if (strlen(Storyboard.game_thumb) > 0)
							{
								sMakeDefaultSelecting = Storyboard.game_thumb;
								bSelectLibraryViewAll = true;
							}
						}
						ImGui::SetWindowFontScale(1.0);

						ImGui::EndTabItem();
					}

					tabflags = 0;
					if (iChangeTab == 2)
					{
						iChangeTab = 0;
						tabflags = ImGuiTabItemFlags_SetSelected;
					}
					if (ImGui::BeginTabItem(" Description ", NULL, tabflags))
					{
						ImGui::SetWindowFontScale(1.4);
						ImGui::Text("");
						ImGui::TextCenter("Edit Text Description");
						ImGui::Text("");
						ImGui::SetWindowFontScale(1.0);

						ImVec2 cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (512 * 0.5), 0.0f));
						ImGui::SetCursorPos(cPos);
						//PE: Need to be a little bit smaller then welcome screen that display description.

						ImGui::SetWindowFontScale(1.2);
						float width = 586.0; //480.0;
						//if (ImGui::InputTextMultiline("##Game Description", &Storyboard.game_description[0], 2048, ImVec2(480, 288), ImGuiInputTextFlags_CallbackAlways, CLB, &(width)))
						//if (ImGui::InputTextMultiline("##Game Description", &Storyboard.game_description[0], 2048, ImVec2(width, 288 ),0,NULL,(void*)-1 ) )
						if (ImGui::InputTextMultiline("##Game Description", &Storyboard.game_description[0], 2048, ImVec2(width, ImGui::GetFontSize()*19+12.0), 0, NULL, (void*)-1))
						{
							//PE: Simple Wrap input.

							char tmp[4096];
							char cmp[4096];
							strcpy(tmp, Storyboard.game_description);

							//PE: Get a avg. char wide.
							int wraparound = width / ((float) ImGui::CalcTextSize("abcdefghijkABCDEFGHIJK").x / 22.0);

							int len = strlen(tmp);
							int bBestMatch = -1;
							int count = 0;
							for (int i = 0; i < len; i++)
							{
								cmp[count] = tmp[i]; cmp[count + 1] = 0;

								if ( i > bBestMatch && tmp[i] == ' ') bBestMatch = i;
								if (tmp[i] == '\n') count = 0;

								if (count++ >= wraparound && (ImGui::CalcTextSize(cmp).x > (width - 18.0)) )
								{
									if (bBestMatch > 0)
									{
										tmp[bBestMatch] = '\n';
									}
									bBestMatch = -1;
									count = 0;
								}
							}
							strcpy(Storyboard.game_description, tmp);
							Storyboard.iChanged = true;
						}
						ImGui::SetWindowFontScale(1.0);
						ImGui::EndTabItem();
					}

					tabflags = 0;
					if (iChangeTab == 3)
					{
						iChangeTab = 0;
						tabflags = ImGuiTabItemFlags_SetSelected;
					}
					if (ImGui::BeginTabItem(" Edge of Game World ", NULL, tabflags))
					{
						ImGui::SetWindowFontScale(1.4);
						ImGui::Text("");
						ImGui::TextCenter("Edit Edge of Game World Message");
						ImGui::Text("");
						ImGui::SetWindowFontScale(1.0);

						// gameplayercontro.lua: Prompt ( "You cannot leave the area of play" )

						ImVec2 cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (512 * 0.5), 0.0f));
						ImGui::SetCursorPos(cPos);

						ImGui::PushItemWidth(512);
						if (ImGui::InputText("##game_world_edge_textStoryboardInput", Storyboard.game_world_edge_text, 512, ImGuiInputTextFlags_None))
						{
							Storyboard.iChanged = true;
						}
						ImGui::PopItemWidth();

						ImGui::EndTabItem();
					}

					tabflags = 0;
					if (iChangeTab == 4)
					{
						iChangeTab = 0;
						tabflags = ImGuiTabItemFlags_SetSelected;
					}

					if (strlen(Storyboard.gamename) > 0)
					{
						if (ImGui::BeginTabItem(" Icon ", NULL, tabflags))
						{
							cstr UniqueIconnailSelect = "##StoryboardSelectIconnail";
							if (iSelectedLibraryStingReturnID == window->GetID(UniqueIconnailSelect.Get()))
							{
								strcpy(Storyboard.game_icon, sSelectedLibrarySting.Get());
								//bUpdateIconImage = true; //Update icon.
								sSelectedLibrarySting = "";
								iSelectedLibraryStingReturnID = -1; //disable.
								Storyboard.iChanged = true;

								if (ImageExist(Storyboard.game_icon_id)) DeleteImage(Storyboard.game_icon_id);
								if (strlen(Storyboard.game_icon) > 0)
								{
									image_setlegacyimageloading(true);
									//LoadImage(Storyboard.game_icon, Storyboard.game_icon_id);
									LoadImageSize(Storyboard.game_icon, Storyboard.game_icon_id, 256, 256);
									image_setlegacyimageloading(false);
								}

								if (ImageExist(Storyboard.game_icon_id))
								{
									//Save and convert to ico.

									char projectpng[MAX_PATH];
									strcpy(projectpng, Storyboard.game_icon);
									GG_GetRealPath(projectpng, 0);

									//ffmpeg -i maxicon.png -vf scale=256:256 maxicon.ico

									extern char g_pAbsPathToConverter[MAX_PATH];
									std::string process_name = g_pAbsPathToConverter;
									replaceAll(process_name, "\\Guru-Converter.exe", "\\ffmpeg.exe");

									DARKSDK BOOL DB_ExecuteFile(HANDLE* phExecuteFileProcess, char* Operation, char* Filename, char* String, char* Path, bool bWaitForTermination);
									char parameters[MAX_PATH];

									::SetCursor(::LoadCursor(NULL, IDC_WAIT));

									for (int a = 0; a < 1; a++) //PE: (a < 6) for now only use 256x256
									{

										strcpy(parameters, "-i \"");
										strcat(parameters, projectpng);

										//Delete old ico.
										char projectico[MAX_PATH];
										strcpy(projectico, "projectbank\\");
										strcat(projectico, Storyboard.gamename);

										//PE: in MAX 256x256 is 256 colors only, so use 128x128 as main icon.
										//strcat(parameters, "\" -vf scale=256:256 \"");
										//palettegen=max_colors=256
										if (a == 0)
										{
											strcat(parameters, "\" -vf scale=256:256 \"");
											strcat(projectico, "\\project256.ico");
										}
										else if (a == 1)
										{
											strcat(parameters, "\" -vf scale=128:128 \"");
											strcat(projectico, "\\project128.ico");
										}
										else if (a == 2)
										{
											strcat(parameters, "\" -vf scale=64:64 \"");
											strcat(projectico, "\\project64.ico");
										}
										else if (a == 3)
										{
											strcat(parameters, "\" -vf scale=48:48 \"");
											strcat(projectico, "\\project32.ico");
										}
										else if (a == 4)
										{
											strcat(parameters, "\" -vf scale=32:32 \"");
											strcat(projectico, "\\project32.ico");
										}
										else
										{
											strcat(parameters, "\" -vf scale=16:16 \"");
											strcat(projectico, "\\project16.ico");
										}

										GG_GetRealPath(projectico, 1);
										DeleteFileA(projectico);

										strcat(parameters, projectico);
										strcat(parameters, "\"");

										HANDLE g_hConvertPngToIcoProcess = NULL;

										DB_ExecuteFile(&g_hConvertPngToIcoProcess, "hide", (char *)process_name.c_str(), parameters, "", true);
										int iRunning = 1;
										int timeout = 0;
										while (iRunning == 1)
										{
											iRunning = 0;
											DWORD dwStatus;
											if (GetExitCodeProcess(g_hConvertPngToIcoProcess, &dwStatus) == TRUE)
											{
												if (dwStatus == STILL_ACTIVE)
												{
													iRunning = 1;
													Sleep(1);
													if (timeout++ > 4000) iRunning = 0; //Timeout
												}
											}
										}
										CloseHandle(g_hConvertPngToIcoProcess);
										Sleep(10);
									}
									::SetCursor(::LoadCursor(NULL, IDC_ARROW));
								}
							}

							ImGui::SetWindowFontScale(1.4);
							ImGui::Text("");
							ImGui::TextCenter("Edit Game Executable Icon");
							ImGui::Text("");
							ImGui::SetWindowFontScale(1.0);

							ImGui::TextCenter("For best result use a 256x256 png image.");

							ImVec2 cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (256 * 0.5), 0.0f));
							ImGui::SetCursorPos(cPos);
							if (ImageExist(Storyboard.game_icon_id))
							{
								//Need ratio here. fit to 288 height.
								ImGui::ImgBtn(Storyboard.game_icon_id, ImVec2(256, 256), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false);
							}
							else
							{
								if (window) window->DrawList->AddRectFilled(window->DC.CursorPos, window->DC.CursorPos + ImVec2(256, 256), ImGui::GetColorU32(style_back), 0.0f, ImDrawCornerFlags_None);
								ImGui::Dummy(ImVec2(256, 256));
							}

							ImGui::SetWindowFontScale(1.4);
							ImGui::Text("");

							cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
							ImGui::SetCursorPos(cPos);

							if (ImGui::StyleButton("Select a New Icon", ImVec2(buttonwide, 0.0f)))
							{
								bExternal_Entities_Window = true;
								iDisplayLibraryType = 2; //Image
								iLibraryStingReturnToID = window->GetID(UniqueIconnailSelect.Get());
								if (strlen(Storyboard.game_icon) > 0)
								{
									sMakeDefaultSelecting = Storyboard.game_icon;
									bSelectLibraryViewAll = true;
								}
							}
							ImGui::SetWindowFontScale(1.0);

							//TEST
							#ifdef TESTICONINJECT
							if (ImGui::StyleButton("TEST -> char1.exe", ImVec2(buttonwide, 0.0f)))
							{
								void InjectIconToExe(char *icon, char *exe, int intresourcenumber);
								char projectico[MAX_PATH];
								char projectfinal_ico[MAX_PATH];
								strcpy(projectico, "projectbank\\");
								strcat(projectico, Storyboard.gamename);

								strcpy(projectfinal_ico, projectico);
								strcat(projectfinal_ico, "\\project256.ico");
								GG_GetRealPath(projectfinal_ico, 1);
								InjectIconToExe(projectfinal_ico, "c:\\DEV\\standalone\\char1\\char1.exe", 1);

								//PE: Only 256 used for now.
								/*
								strcpy(projectfinal_ico, projectico);
								strcat(projectfinal_ico, "\\project128.ico");
								GG_GetRealPath(projectfinal_ico, 1);
								InjectIconToExe(projectfinal_ico, "c:\\DEV\\standalone\\char1\\char1.exe",2);

								strcpy(projectfinal_ico, projectico);
								strcat(projectfinal_ico, "\\project64.ico");
								GG_GetRealPath(projectfinal_ico, 1);
								InjectIconToExe(projectfinal_ico, "c:\\DEV\\standalone\\char1\\char1.exe", 3);

								strcpy(projectfinal_ico, projectico);
								strcat(projectfinal_ico, "\\project48.ico");
								GG_GetRealPath(projectfinal_ico, 1);
								InjectIconToExe(projectfinal_ico, "c:\\DEV\\standalone\\char1\\char1.exe", 4);

								strcpy(projectfinal_ico, projectico);
								strcat(projectfinal_ico, "\\project32.ico");
								GG_GetRealPath(projectfinal_ico, 1);
								InjectIconToExe(projectfinal_ico, "c:\\DEV\\standalone\\char1\\char1.exe", 5);

								strcpy(projectfinal_ico, projectico);
								strcat(projectfinal_ico, "\\project16.ico");
								GG_GetRealPath(projectfinal_ico, 1);
								InjectIconToExe(projectfinal_ico, "c:\\DEV\\standalone\\char1\\char1.exe", 6);
								*/
							}
							#endif
							ImGui::EndTabItem();
						}
					}
					tabflags = 0;
					if (iChangeTab == 4)
					{
						iChangeTab = 0;
						tabflags = ImGuiTabItemFlags_SetSelected;
					}
					if (ImGui::BeginTabItem(" Game Developer ", NULL, tabflags))
					{
						ImGui::SetWindowFontScale(1.4);
						ImGui::Text("");
						ImGui::TextCenter("Game Developer Description");
						ImGui::Text("");
						ImGui::SetWindowFontScale(1.0);

						ImVec2 cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (512 * 0.5), 0.0f));
						ImGui::SetCursorPos(cPos);

						ImGui::SetWindowFontScale(1.2);
						float width = 586.0; //480.0;

						if (ImGui::InputTextMultiline("##Developer Description", &Storyboard.game_developer_desc[0], 1023, ImVec2(width, ImGui::GetFontSize() * 10 + 12.0), 0, NULL, (void*)-1))
						{
							char tmp[4096];
							char cmp[4096];
							strcpy(tmp, Storyboard.game_developer_desc);

							//PE: Get a avg. char wide.
							int wraparound = width / ((float)ImGui::CalcTextSize("abcdefghijkABCDEFGHIJK").x / 22.0);

							int len = strlen(tmp);
							int bBestMatch = -1;
							int count = 0;
							for (int i = 0; i < len; i++)
							{
								cmp[count] = tmp[i]; cmp[count + 1] = 0;

								if (i > bBestMatch && tmp[i] == ' ') bBestMatch = i;
								if (tmp[i] == '\n') count = 0;

								if (count++ >= wraparound && (ImGui::CalcTextSize(cmp).x > (width - 18.0)))
								{
									if (bBestMatch > 0)
									{
										tmp[bBestMatch] = '\n';
									}
									bBestMatch = -1;
									count = 0;
								}
							}
							strcpy(Storyboard.game_developer_desc, tmp);
							Storyboard.iChanged = true;
						}
						ImGui::SetWindowFontScale(1.0);
						ImGui::EndTabItem();
					}
					ImGui::EndTabBar();
				}
				//####

				/*
				ImGui::Indent(10);
				ImGui::Text("");
				ImVec2 cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
				cPos.y = ImGui::GetWindowSize().y - 30.0;
				ImGui::SetCursorPos(cPos);
				if (ImGui::StyleButton("Close", ImVec2(buttonwide, 0.0f)))
				{
					//Close.
					bEditGameSettings = false;
				}
				ImGui::Indent(-10);
				*/

				//####
				ImGui::NextColumn();

				if (ImGui::StyleCollapsingHeader("Game Description", ImGuiTreeNodeFlags_DefaultOpen) || iStoryboardExecuteKey != 0) //"Add New"
				{
					ImGui::Indent(10);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Change Game Thumbnail", ImVec2(buttonwide, 0.0f)))
					{
						//code
						iChangeTab = 1;
					}
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Edit Text Description", ImVec2(buttonwide, 0.0f)))
					{
						//code
						iChangeTab = 2;
					}
					ImGui::Indent(-10);
				}
				if (ImGui::StyleCollapsingHeader("In-Game Settings", ImGuiTreeNodeFlags_DefaultOpen) || iStoryboardExecuteKey != 0) //"Add New"
				{
					ImGui::Indent(10);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Edge of Game World Message", ImVec2(buttonwide, 0.0f)))
					{
						//code
						iChangeTab = 3;
					}
					ImGui::Indent(-10);
				}

				if (strlen(Storyboard.gamename) > 0)
				{
					if (ImGui::StyleCollapsingHeader("Export Settings", ImGuiTreeNodeFlags_DefaultOpen) || iStoryboardExecuteKey != 0) //"Add New"
					{
						ImGui::Indent(10);
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
						if (ImGui::StyleButton("Game Executable Icon", ImVec2(buttonwide, 0.0f)))
						{
							//code
							iChangeTab = 4;
						}
						ImGui::Indent(-10);
					}
				}
				ImGui::EndColumns();

				bImGuiGotFocus = true;
				ImGui::Indent(-10);
				//ImGui::EndPopup();
				bBlockNextMouseCheck = true;
			}
			ImGui::End();

			if (!bOpenWindow)
			{
				bEditGameSettings = false;
			}
		}
		#endif


		ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
		ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;

		static ImVec2 old_viewPortSize = { -1,-1 };
		if (old_viewPortSize.x != viewPortSize.x || old_viewPortSize.y != viewPortSize.y)
		{
			ImGui::SetNextWindowPos(viewPortPos, ImGuiCond_Always);
			ImGui::SetNextWindowSize(viewPortSize, ImGuiCond_Always);
			old_viewPortSize = viewPortSize;
		}
		else if (bModal)
		{
			ImGui::SetNextWindowPos(viewPortPos);
			ImGui::SetNextWindowSize(viewPortSize);
		}
		else
		{
			ImGui::SetNextWindowPos(viewPortPos, ImGuiCond_Once);
			ImGui::SetNextWindowSize(viewPortSize, ImGuiCond_Once);
		}

		//ImGuiWindowFlags_MenuBar , ImGuiWindowFlags_NoTitleBar, ImGuiWindowFlags_NoBringToFrontOnFocus
		if (bModal)
		{
			bPopModalStoryboard = ImGui::BeginPopupModal("##StoryboardWindow", &bStoryboardWindow, ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize); // ImGuiWindowFlags_NoScrollbar
		}
		else
		{
			ImVec4 style_winback = ImGui::GetStyle().Colors[ImGuiCol_WindowBg];
			style_winback.w = 1.0f;
			ImGui::PushStyleColor(ImGuiCol_WindowBg, style_winback);
			int flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove;
			if (!bScreen_Editor_Window) flags |= ImGuiWindowFlags_MenuBar;
			bPopModalStoryboard = ImGui::Begin("##StoryboardWindow", &bStoryboardWindow, flags); // ImGuiWindowFlags_NoScrollbar
		}
		if (bPopModalStoryboard)
		{

			if (!bProceduralLevel)
			{
				ImGuiWindow* storyboard_window = ImGui::GetCurrentWindow();
				CheckWindowsOnTop(storyboard_window);
			}

			if (bScreen_Editor_Window)
			{
				screen_editor(iScreen_Editor_Node);
			}
			else
			{
				storyboard_menubar(preview_size_x, fNodeWidth, fNodeHeight);

				float fStartWinPosY = ImGui::GetCursorPosY();

				ImGui::Columns(2, "StoryboardWindowColumns", false);  //false no border
				ImGui::SetColumnOffset(0, 0.0f);
				ImGui::SetColumnOffset(1, preview_size_x);
				ImNodesContext* gImNodes = ImNodes::GetCurrentContext();
				if (gImNodes)
				{
					gImNodes->Style.PinOffset = 6.0f;
					gImNodes->Style.PinTriangleSideLength = ImGui::GetFontSize() - 2.0;
					gImNodes->Style.PinQuadSideLength = ImGui::GetFontSize() - 4.0;
					if (bStoryboardFirstRunSetInitPos)
						Storyboard.vEditorPanning = ImNodes::EditorContextGetPanning();
				}
				static ImVec2 vTooltipPos;
				static cstr sTooltip = "";

				float fRatio = preview_size_x / 1200.0f;
				float fHeaderHeight = g_Storyboard_header_height * fRatio;

				void* lpTexture;
				
				lpTexture = GetImagePointer(STORYBOARD_HEADER);
				ImVec2 vHeaderDim = { (float)preview_size_x, fHeaderHeight };
//				static ImVec4 fade_heading = ImVec4(1.0, 1.0, 1.0, 0.5);
				static ImVec4 fade_heading = ImVec4(1.0, 1.0, 1.0, 1.0); //New header no fading.
				if (lpTexture)
				{
					ImGuiWindow* window = ImGui::GetCurrentWindow();
					ImVec2 header_pos = ImGui::GetWindowPos() + ImVec2(0.0, fStartWinPosY);
					window->DrawList->AddImage((ImTextureID)lpTexture, header_pos, header_pos + vHeaderDim, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(fade_heading));
				}
				
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, fStartWinPosY + 6.0f));

				ImVec2 vCurPos = ImGui::GetCursorPos();
				ImVec2 vIconSize = { (float)ImGui::GetFontSize()*3.5f, (float)ImGui::GetFontSize()*3.5f };
				ImGui::SetCursorPos(ImVec2(3.0f, fStartWinPosY + 1.0f));
				ImGui::SetItemAllowOverlap();
				if (ImGui::ImgBtn(TOOL_GOBACK, vIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
				{
					bool bAbort = false;
					if (Storyboard.iChanged)
					{
						if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
						{
							save_storyboard(Storyboard.gamename, false);
						}
						else
						{
							int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
							if (iAction == 1)
							{
								//Save.
								if (strlen(Storyboard.gamename) > 0)
									save_storyboard(Storyboard.gamename, false);
								else
								{
									bAbort = true;
									save_storyboard(Storyboard.gamename, true);
								}
							}
						}
					}
					if (!bAbort)
					{
						iLevelEditorFromStoryboardID = -1;
						if (pref.iDisplayWelcomeScreen == 0)
						{
							//Welcome not open , so to level editor.
							bStoryboardWindow = false;
						}
						else
						{
							//Back to welcome.
							bWelcomeScreen_Window = true;
							bStoryboardWindow = false;
							cLastProjectList = ""; //Trigger a reload of projects, if anything changed.
							bSortProjects = true;
						}
					}
				}
				if (pref.iDisplayWelcomeScreen == 0)
				{
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Exit to Level Editor");
				}
				else
				{
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Exit to GameGuru MAX Hub"); //Welcome Screen
				}
				//

				//ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, -40.0)); //PE: Without a header use this.
				ImGui::SetWindowFontScale(2.0); //1.4
				//ImGui::TextCenter("GAME STORYBOARD");
				ImGui::TextCenter(""); //New header already have this text.

				//ImGui::Text(""); //Without a header use this.

				//Display game project name in a inputtext.
//				ImGui::SetWindowFontScale(1.4);
//				float fInputWidth = 300.0;
//				ImGui::PushItemWidth(fInputWidth);
//				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(ImGui::GetContentRegionAvailWidth()*0.5 - ((fInputWidth + 16)*0.5), 28)); //Center with new header.
//				ImGui::InputText("##GamenameStoryboardInput", Storyboard.gamename, 250, ImGuiInputTextFlags_ReadOnly); //ImGuiInputTextFlags_None
//				if (ImGui::MaxIsItemFocused())
//				{
//					bImGuiGotFocus = true;
//				}
//				ImGui::PopItemWidth();
//				ImGui::SetWindowFontScale(1.0);
				//PE: changed inputtext to just displying the project name.
				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");
				ImGui::SetWindowFontScale(2.0);
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), fHeaderHeight * 0.70));
				ImGui::TextCenter(Storyboard.gamename);
				ImGui::SetWindowFontScale(1.0);

				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x, fStartWinPosY + fHeaderHeight + 6.0f));

				if (sTooltip != "")
				{
					ImVec2 cposback = ImGui::GetCursorPos();
					ImGui::SetCursorPos(vTooltipPos);
					ImGui::SetTooltip(sTooltip.Get());
					sTooltip = "";
					ImGui::SetCursorPos(cposback);
				}


				ImVec2 vNodeAreaStart = ImGui::GetCursorScreenPos();
				int iUniqueIds = STORYBOARD_THUMBS;

				//PE: Make sure if we focus another window and go back , mouse dragging is reset.
				extern bool g_bAppActiveStat;
				const ImGuiIO& io = ImGui::GetIO();
				if (!g_bAppActiveStat)
				{
					ImGuiContext& g = *GImGui;
					GImGui->IO.MousePos = ImVec2(-10000, -10000);
					g.IO.MouseDelta = ImVec2(0, 0);
					g_bAppActiveStat = true;
				}

				ImNodes::BeginNodeEditor();

				ImNodes::PushAttributeFlag(ImNodesAttributeFlags_EnableLinkDetachWithDragClick);

				for (int i = 0; i < STORYBOARD_MAXNODES; i++)
				{
					bool bValid = true;

					if (!pref.iStoryboardAdvanced && Storyboard.Nodes[i].used)
					{
						//PE: Hide nodes if not in advanced.
						if (i == iLoadGameNodeID ||
							i == iGamePausedNodeID ||
							i == iSaveGameNodeID ||
							i == iGraphicsNodeID ||
							i == iControlNodeID ||
							i == iSoundsNodeID)
							bValid = false;
					}

					if (bValid && Storyboard.Nodes[i].used)
					{
						//PE: Store current location for restore/save.
						if (bStoryboardFirstRunSetInitPos)
							Storyboard.Nodes[i].restore_position = ImNodes::GetNodeGridSpacePos(Storyboard.Nodes[i].id);

						//PE: Setup node.
						ImNodes::BeginNode(Storyboard.Nodes[i].id);

						//#### Title bar ####
						ImNodes::BeginNodeTitleBar();
						ImGui::Dummy(ImVec2(fNodeWidth, 0));
						ImVec2 cpos = ImGui::GetCursorPos();
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0, -3.0));

						ImVec2 text_size = ImGui::CalcTextSize(Storyboard.Nodes[i].title);
						if (text_size.x > fNodeWidth - 50.0)
						{
							char tmp[255];
							strncpy(tmp, Storyboard.Nodes[i].title, 19);
							tmp[19] = 0;
							strcat(tmp, "...");
							ImGui::TextUnformatted(tmp);
							if (ImGui::IsItemHovered())
							{
								vTooltipPos = ImGui::GetCursorPos();
								sTooltip = Storyboard.Nodes[i].title;
							}
						}
						else
						{
							ImGui::TextUnformatted(Storyboard.Nodes[i].title);
						}

						if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL)
						{
							//Reverse push's from BeginNodeEditor
							ImGui::PopStyleColor(); // pop child window background color
							ImGui::PopStyleVar();   // pop window padding
							ImGui::PopStyleVar();   // pop frame padding

							//Combo.
							const char* items_storyboard_level[] = { "Duplicate Level","Rename Level", "Delete Level", "Take Screenshot" };
							ImGui::SetCursorPos(ImVec2(cpos.x + fNodeWidth - 48.0f, cpos.y - 8.0));
							int selection = 0;
							char iUniqueString[255];
							sprintf(iUniqueString, "##ComboStoryboardLevels%d", i);

							int iComboEntries = 3;
							if (strlen(Storyboard.Nodes[i].level_name) > 0)
							{
								//Only screenshot if we got a level.
								iComboEntries = 4;
							}
							//ImGuiComboFlags_NoPreview
							int comboflags = ImGuiComboFlags_NoPreview | ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge;
							ImGui::PushItemWidth(20);
							if (ImGui::BeginCombo(iUniqueString, "", comboflags))
							{
								for (int n = 0; n < iComboEntries; n++)
								{
									//PE: Only display rename and duplicate if we got a name.
									if (!(iComboEntries == 3 && n <= 1))
									{
										if (ImGui::Selectable(items_storyboard_level[n], false))
										{
											Storyboard.iChanged = true;
											bBlockNextMouseCheck = true;
											selection = n;
											if (selection == 0)
											{
												//Duplicate Level.

												iDuplicateNode = i;
												bDuplicateLevel = true;
												//Load in old level if any.

												if (strlen(Storyboard.Nodes[i].level_name) > 0)
												{
													//Load and edit.
													if (stricmp(Storyboard.Nodes[i].level_name, g.projectfilename_s.Get()) == NULL)
													{
														//Already open , just start dup screen.
													}
													else
													{
														//Load level and exit to level editor.
														strcpy(cDirectOpen, Storyboard.Nodes[i].level_name);
														iLaunchAfterSync = 7; //Direct load.
														iSkibFramesBeforeLaunch = 3;
													}
												}
												strcpy(DuplicateLevelName, Storyboard.Nodes[i].title);
												strcat(DuplicateLevelName, " (copy)");
												strcpy(DuplicateLevelError, "");

											}
											if (selection == 1)
											{
												//Rename Level
												if (strlen(Storyboard.Nodes[i].level_name) > 0)
												{
													bRenameLevel = true;
													iRenameNode = i;

													//cstr importer_getfilenameonly(LPSTR pFileAndPossiblePath);
													//cstr tmp = importer_getfilenameonly(Storyboard.Nodes[i].level_name);
													std::string sLevelTitle = Storyboard.Nodes[i].level_name;
													replaceAll(sLevelTitle, ".fpm", "");
													replaceAll(sLevelTitle, "mapbank\\", "");

													char destination[MAX_PATH];
													strcpy(destination, Storyboard.Nodes[i].level_name);
													GG_GetRealPath(destination, 0); //Resolve name. need full path.
													strcpy(RenameOriginalLevelName, destination);
													strcpy(RenameLevelName, sLevelTitle.c_str());
													strcpy(RenameLevelError, "");
												}

											}
											if (selection == 2)
											{
												//Delete Level
												int iAction = askBoxCancel("This will delete the level from your storyboard, are you sure?", "Confirmation"); //1==Yes 2=Cancel 0=No
												if (iAction == 1)
												{

													//Delete any links to this level.
													for (int il = 0; il < STORYBOARD_MAXNODES; il++)
													{
														if (Storyboard.Nodes[il].used)
														{
															for (int ll = 0; ll < STORYBOARD_MAXOUTPUTS; ll++)
															{
																if (Storyboard.Nodes[il].output_linkto[ll] > 0)
																{
																	for (int a = 0; a < STORYBOARD_MAXOUTPUTS; a++)
																	{
																		//Check all inputs.
																		if (Storyboard.Nodes[i].input_id[a] > 0)
																		{
																			if (Storyboard.Nodes[il].output_linkto[ll] == Storyboard.Nodes[i].input_id[a])
																				Storyboard.Nodes[il].output_linkto[ll] = 0;
																		}
																	}
																}
															}
														}
													}
													reset_single_node(i);
													Storyboard.Nodes[i].used = false;
													bBlockNextMouseCheck = true;

												}

											}
											if (selection == 3)
											{
												//Take Screenshot.
												extern bool bPopModalOpenProceduralCameraMode;
												bPopModalOpenProceduralCameraMode = true;

												//PE: Do we need to load this level ?
												if (strlen(Storyboard.Nodes[i].level_name) > 0)
												{
													//Load and edit.
													if (stricmp(Storyboard.Nodes[i].level_name, g.projectfilename_s.Get()) == NULL)
													{
														//Already open , just start screenshot
													}
													else
													{
														//Load level and start screenshot.
														strcpy(cDirectOpen, Storyboard.Nodes[i].level_name);
														iLaunchAfterSync = 7; //Direct load.
														iSkibFramesBeforeLaunch = 5;
													}
												}

												iWaitForNewScreenshot = 10;
												iScreenshotNode = i;

												//Make sure we have a fresh thumb.
												if (FileExist("thumbbank\\lastnewlevel.jpg")) DeleteAFile("thumbbank\\lastnewlevel.jpg");

											}
										}
									}
								}
								ImGui::EndCombo();
							}
							if (ImGui::IsItemHovered()) {
								bBlockNextMouseCheck = true;
								vTooltipPos = ImGui::GetCursorPos();
								sTooltip = " Duplicate, delete or take a screen shot ";
							}
							ImGui::PopItemWidth();

							//Add push to BeginNodeEditor.
							ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(1.f, 1.f));
							ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));
							ImGui::PushStyleColor(ImGuiCol_ChildBg, GImNodes->Style.Colors[ImNodesCol_GridBackground]);

						}

						bool bExecutePencelEdit = false;
						char UniqueFileString[MAX_PATH];
						sprintf(UniqueFileString, "##GetFileStoryboard%d", i);
						ImGuiWindow* window = ImGui::GetCurrentWindow();
						int iSplashID = window->GetID(UniqueFileString);

						if (Storyboard.Nodes[i].iEditEnable)
						{
							ImGui::SetItemAllowOverlap();
							ImGui::SetCursorPos(ImVec2(cpos.x + fNodeWidth - 20.0f, cpos.y - 3.0));
							ImGui::PushID(Storyboard.Nodes[i].id + 500);

							if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
							{
								if (iSelectedLibraryStingReturnID == iSplashID)
								{
									//Update selected var.
									strcpy(Storyboard.Nodes[i].thumb, sSelectedLibrarySting.Get());
									sSelectedLibrarySting = "";
									iSelectedLibraryStingReturnID = -1; //disable.
									//Update thumb.
									UpdateThumbOnNode = i;
								}
							}

							if (ImGui::ImgBtn(TOOL_PENCIL, ImVec2(16, 16), ImColor(255, 255, 255, 0)))
							{
								bExecutePencelEdit = true;
							}
							if (ImGui::IsItemHovered())
							{
								bBlockNextMouseCheck = true;
								vTooltipPos = ImGui::GetCursorPos();
								if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
									sTooltip = " Edit Splash Screen ";
								else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN)
									sTooltip = " Edit Screen ";
								else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL)
									sTooltip = " Edit Level ";
							}
							ImGui::PopID();
						}
						ImNodes::EndNodeTitleBar();

						//#### Input attibs ####
						cpos = ImGui::GetCursorPos();
						for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
						{
							if (strlen(Storyboard.Nodes[i].input_title[l]) > 0)
							{
								int iPinId = Storyboard.Nodes[i].input_id[l];
								ImNodes::BeginInputAttribute(iPinId, ImNodesPinShape_QuadFilled);
								ImGui::Text("");
								if (iLastHoveredId == iPinId) { vTooltipPos = ImGui::GetCursorPos(); sTooltip = Storyboard.Nodes[i].input_title[l]; }
								ImNodes::EndInputAttribute();
							}

						}
						ImGui::SetCursorPos(cpos);

						//#### Preview Thumb ####
						int TextureID = BOX_CLICK_HERE; //MARKETPLACE_FILLER;
						if (ImageExist(Storyboard.Nodes[i].thumb_id))
						{
							TextureID = Storyboard.Nodes[i].thumb_id;
						}
						cpos = ImGui::GetCursorPos();

						//#### Add button so can click to edit, pencil function ####
						//ImGui::Dummy(iThumbSize);
						char UniqueButName[128];
						sprintf(UniqueButName, "##Dummy%d", i);
						if (iLastHoveredNodeId > 0 && iLastHoveredNodeId == Storyboard.Nodes[i].id)
						{
							if (ImGui::ButtonEx(UniqueButName, iThumbSize, 0))
							{
								bExecutePencelEdit = true;
							}
						}
						else
						{
							ImGui::Dummy(iThumbSize);
						}
						//#### Execute Edit With Pencil ####
						if (bExecutePencelEdit)
						{

							Storyboard.iChanged = true;

							//ImGuiWindow* window = ImGui::GetCurrentWindow();
							if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
							{
								//Edit splash.
								bExternal_Entities_Window = true;
								iDisplayLibraryType = 2;
								iLibraryStingReturnToID = iSplashID;
								if (strlen(Storyboard.Nodes[i].thumb) > 0)
								{
									sMakeDefaultSelecting = Storyboard.Nodes[i].thumb;
									bSelectLibraryViewAll = true;
								}

								if (pref.iSplashStartMessage == 0)
								{
									strcpy(cTriggerMessage, "Select the backdrop image you want to appear when your game is first launched");
									bTriggerMessage = true;
									pref.iSplashStartMessage = 1;
									iTriggerMessageDelay = 2;
									iTriggerMessageY = 1;
								}

							}
							else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN)
							{

								if (i == iTitleScreenNodeID && pref.iTitleStartMessage == 0)
								{
									pref.iTitleStartMessage = 1;
									strcpy(cTriggerMessage, "Design your game start menus");
									bTriggerMessage = true;
									iTriggerMessageDelay = 2;
									iTriggerMessageY = 1;
								}
								if (i == 2 && pref.iLoadingStartMessage == 0)
								{
									pref.iLoadingStartMessage = 1;
									strcpy(cTriggerMessage, "Create the screen shown before each level loads");
									bTriggerMessage = true;
									iTriggerMessageDelay = 2;
									iTriggerMessageY = 1;
								}
								if (i == 5 && pref.iGameWonStartMessage == 0)
								{
									pref.iGameWonStartMessage = 1;
									strcpy(cTriggerMessage, "Design the screen shown when the game is won");
									bTriggerMessage = true;
									iTriggerMessageDelay = 2;
									iTriggerMessageY = 1;
								}
								if (i == 6 && pref.iGameOverStartMessage == 0)
								{
									pref.iGameOverStartMessage = 1;
									strcpy(cTriggerMessage, "Create the screen when the player loses the game");
									bTriggerMessage = true;
									iTriggerMessageDelay = 2;
									iTriggerMessageY = 1;
								}

								bScreen_Editor_Window = true;
								iScreen_Editor_Node = i;
							}
							else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL)
							{
								//Edit level.
								CloseAllOpenTools();

								if (strlen(Storyboard.Nodes[i].level_name) > 0)
								{
									//Load and edit.
									if (stricmp(Storyboard.Nodes[i].level_name, g.projectfilename_s.Get()) == NULL)
									{
										//Already open , just exit to level editor.
										if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
										if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
										if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
										if (bEntity_Properties_Window) bEntity_Properties_Window = false;
										if (t.ebe.on == 1) ebe_hide();
										//
										bool bAbort = false;
										if (Storyboard.iChanged)
										{
											bBlockNextMouseCheck = true;
											if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
											{
												save_storyboard(Storyboard.gamename, false);
											}
											else
											{
												int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
												if (iAction == 1)
												{
													//Save.
													if (strlen(Storyboard.gamename) > 0)
														save_storyboard(Storyboard.gamename, false);
													else
													{
														bAbort = true;
														save_storyboard(Storyboard.gamename, true);
													}
												}
											}
										}
										if (!bAbort)
										{
											//Object Tools as default.
											bForceKey = true;
											csForceKey = "o";
											bTerrain_Tools_Window = false;
											Entity_Tools_Window = true;

											bStoryboardWindow = false;
											iLevelEditorFromStoryboardID = i;
										}

									}
									else
									{
										//Load level and exit to level editor.
										strcpy(cDirectOpen, Storyboard.Nodes[i].level_name);
										iLaunchAfterSync = 7; //Direct load.
										iSkibFramesBeforeLaunch = 5;
										bCloseStoryboardAfterLoad = true;
										//bStoryboardWindow = false;
										iLevelEditorFromStoryboardID = i;
									}
								}
								else
								{
									//PE: If empty node level , start level editor.
									//PE: Default to terrain tools , like when we launch Max.

									//PE: New default to object mode.
									bForceKey = true;
									csForceKey = "o";
									bTerrain_Tools_Window = false;
									Entity_Tools_Window = true;

									//bForceKey = true;
									//csForceKey = "t";
									//bForceKey2 = true;
									//csForceKey2 = "6";
									//t.inputsys.domodeterrain = 1; t.inputsys.dowaypointview = 0;
									//t.gridentitymarkersmodeonly = 0; t.grideditselect = 0;
									//t.terrain.terrainpaintermode = 6;
									//bTerrain_Tools_Window = true;
									bProceduralLevelFromStoryboard = true;
									iLaunchAfterSync = 5;
									iBlackoutForFrames = 5;
									iSkibFramesBeforeLaunch = 2;
									iWaitForNewLevel = 10;
									iNewLevelNode = i;

									//Make sure we have a fresh thumb. if generated by new level.
									if (FileExist("thumbbank\\lastnewlevel.jpg")) DeleteAFile("thumbbank\\lastnewlevel.jpg");

									//PE: Switch to normal message.
									strcpy(cTriggerMessage, "Preparing the Terrain Generator. Please wait...");
									bTriggerMessage = true;
									//PE: We need the message in this frame so.
									//bool bForceMessageNoFade = false;
									//void gridedit_triggermessagehandler(bool bForceMessageNoFade);
									//gridedit_triggermessagehandler(bForceMessageNoFade);

								}
							}
						}
						

						ImGui::SetCursorPos(cpos);
						lpTexture = GetImagePointer(TextureID);
						if (lpTexture && Storyboard.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
						{
							//Center image.
							float img_w = ImageWidth(TextureID);
							float img_h = ImageHeight(TextureID);

							if (img_w > iThumbSize.x || img_h > iThumbSize.y) {
								float fRatio = 1.0f / (img_w / img_h);
								img_w = iThumbSize.x;
								img_h = iThumbSize.x * fRatio;
								if (img_h > iThumbSize.y) {
									float fRatio = 1.0f / (img_h / img_w);
									img_h = iThumbSize.y;
									img_w = iThumbSize.y * fRatio;
								}
							}

							ImGuiWindow* window = ImGui::GetCurrentWindow();
							ImVec2 img_pos = ImGui::GetWindowPos() + cpos;

							img_pos.x += (iThumbSize.x - img_w) * 0.5;
							img_pos.y += (iThumbSize.y - img_h) * 0.5;
							window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + ImVec2(img_w, img_h), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 0.8)));

						}
						else
						{
							if (lpTexture)
							{
								ImGuiWindow* window = ImGui::GetCurrentWindow();
								ImVec2 img_pos = ImGui::GetWindowPos() + cpos;
								window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + iThumbSize, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 0.8)));
							}
						}
						//ImGui::SetCursorPos(cpos + ImVec2(0, iThumbSize.y)); Start output from top and down.

						//#### Output attibs ####
						for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
						{
							bool bValid = true;
							int iPinId = Storyboard.Nodes[i].output_id[l];
							int linkto = Storyboard.Nodes[i].output_linkto[l];
							if (!pref.iStoryboardAdvanced && strlen(Storyboard.Nodes[i].output_title[l]) > 0)
							{
								//PE: Hide nodes if not in advanced.
								if (linkto == Storyboard.Nodes[iLoadGameNodeID].input_id[0] ||
									linkto == Storyboard.Nodes[iGamePausedNodeID].input_id[0] ||
									linkto == Storyboard.Nodes[iSaveGameNodeID].input_id[0] ||
									linkto == Storyboard.Nodes[iGraphicsNodeID].input_id[0] ||
									linkto == Storyboard.Nodes[iSoundsNodeID].input_id[0] )
									bValid = false;
							}

							if (bValid && strlen(Storyboard.Nodes[i].output_title[l]) > 0)
							{
								ImNodes::BeginOutputAttribute(iPinId, ImNodesPinShape_TriangleFilled);
								ImGui::Text("");
								if (iLastHoveredId == iPinId) { vTooltipPos = ImGui::GetCursorPos(); sTooltip = Storyboard.Nodes[i].output_title[l]; }
								ImNodes::EndOutputAttribute();
							}
						}


						ImNodes::EndNode();
					}
				}


				//ImGui::BeginChild("##ChirlEntitiesLeftPanel", ImVec2(ImGui::GetWindowSize().x - 2.0f, fsy*3.0), false, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoNavInputs);
				//ImGui::ImgBtn(TextureID, iThumbSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false);

				ImNodes::PopAttributeFlag();

				std::map<int, int> no_duplicates;
				int linkid = 0;
				for (int i = 0; i < STORYBOARD_MAXNODES; i++)
				{
					bool bValid = true;

					if (!pref.iStoryboardAdvanced && Storyboard.Nodes[i].used)
					{
						//PE: Hide nodes if not in advanced.
						if (i == iLoadGameNodeID ||
							i == iGamePausedNodeID ||
							i == iSaveGameNodeID ||
							i == iGraphicsNodeID ||
							i == iSoundsNodeID)
							bValid = false;
					}

					if (bValid && Storyboard.Nodes[i].used)
					{
						for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
						{
							int linkfrom = Storyboard.Nodes[i].output_id[l];
							int linkto = Storyboard.Nodes[i].output_linkto[l];
							if (linkfrom > 0 && linkto > 0)
							{
								bool bLinkValid = true;
								if (!pref.iStoryboardAdvanced )
								{
									//PE: Hide nodes if not in advanced.
									if (linkto == Storyboard.Nodes[iLoadGameNodeID].input_id[0] ||
										linkto == Storyboard.Nodes[iGamePausedNodeID].input_id[0] ||
										linkto == Storyboard.Nodes[iSaveGameNodeID].input_id[0] ||
										linkto == Storyboard.Nodes[iGraphicsNodeID].input_id[0] ||
										linkto == Storyboard.Nodes[iSoundsNodeID].input_id[0])
										bLinkValid = false;
								}

								if (bLinkValid)
								{
									bool bVisible = true;
									int is = no_duplicates.size();
									no_duplicates.insert(std::make_pair(linkfrom, linkto));
									if (is == no_duplicates.size())
										bVisible = false;
									if (bVisible)
									{
										if (linkid < STORYBOARD_MAXNODES)
										{
											ImNodes::Link(linkid, linkfrom, linkto);
											StoryboardiActiveLinksId[linkid] = linkto;
											StoryboardiActiveLinksIdFrom[linkid] = linkfrom;
											linkid++;
										}
									}
								}
							}
						}
					}
				}
				no_duplicates.clear();


				ImNodes::MiniMap(0.15f, ImNodesMiniMapLocation_BottomRight); //PE: size,corner.
				ImNodes::EndNodeEditor();

				ImVec2 vNodeAreaEnd = ImGui::GetCursorScreenPos();
				vNodeAreaEnd.x += ImGui::GetContentRegionAvailWidth();
				if (ImGui::IsMouseHoveringRect(vNodeAreaStart, vNodeAreaEnd))
				{
					static bool bGetMouseDown = false;
					static bool bWaitOnRelease = false;
					if (!bTriggerSaveAs && !bTriggerOpenProject && !bProceduralLevel && !bBlockNextMouseCheck)
					{
						if (bWaitOnRelease && !ImGui::IsMouseDown(0))
						{
							bWaitOnRelease = false;
						}
						else
						{
							//Need a down and release to trigger.
							if (bGetMouseDown && ImGui::IsMouseReleased(0))
							{
								Storyboard.iChanged = true; //PE: Anything trigger a change in project.
								bGetMouseDown = false;
							}
							if (ImGui::IsMouseDown(0)) bGetMouseDown = true; //PE: Anything trigger a change in project.
						}
					}
					else
					{
						bWaitOnRelease = true;
						bBlockNextMouseCheck = false;
						bGetMouseDown = false;
					}
				}


				int start_attr, end_attr;
				if (ImNodes::IsLinkCreated(&start_attr, &end_attr))
				{
					bool valid_link = false; // type goes to correct type.
					int iInNode = -1, iOutNode = -1, iInAttr = -1, iOutAttr = -1;
					for (int i = 0; i < STORYBOARD_MAXNODES; i++)
					{
						if (Storyboard.Nodes[i].used)
						{
							for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
							{
								int linkfrom = Storyboard.Nodes[i].output_id[l];
								int linkto = Storyboard.Nodes[i].input_id[l];

								if (start_attr == linkfrom)
								{
									iInNode = i;
									iInAttr = l;
								}
								if (end_attr == linkto)
								{
									iOutNode = i;
									iOutAttr = l;
								}
							}
						}
					}
					if (iInNode >= 0 && iOutNode >= 0 && iInAttr >= 0 && iOutAttr >= 0)
					{
						//PE: Check if connect type match.
						if (Storyboard.Nodes[iOutNode].type == Storyboard.Nodes[iInNode].output_can_link_to_type[iInAttr])
							valid_link = true;
					}

					if (valid_link)
					{
						Storyboard.Nodes[iInNode].output_linkto[iInAttr] = end_attr;
					}
				}

				int link_id;
				if (ImNodes::IsLinkDestroyed(&link_id))
				{
					if (link_id < STORYBOARD_MAXNODES && link_id >= 0)
					{
						int linkfrom = StoryboardiActiveLinksId[link_id];
						int linkto = StoryboardiActiveLinksIdFrom[link_id];

						for (int i = 0; i < STORYBOARD_MAXNODES; i++)
						{
							if (Storyboard.Nodes[i].used)
							{
								for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
								{

									if (linkfrom == Storyboard.Nodes[i].output_linkto[l] && linkto == Storyboard.Nodes[i].output_id[l])
										Storyboard.Nodes[i].output_linkto[l] = 0;
								}
							}
						}
					}

				}

				ImGui::NextColumn();

				const ImNodesEditorContext& editor = ImNodes::EditorContextGet();
				if (gImNodes->HoveredPinIdx.HasValue() && gImNodes->HoveredPinIdx.Value() >= 0)
					iLastHoveredId = editor.Pins.Pool[GImNodes->HoveredPinIdx.Value()].Id;
				else
					iLastHoveredId = 0;

				if (!ImGui::IsMouseDown(0))
				{
					iLastHoveredNodeId = 0;
					if (gImNodes->HoveredNodeIdx.HasValue() && gImNodes->HoveredNodeIdx.Value() >= 0)
					{
						if (gImNodes->HoveredNodeIdx.Value() < editor.Nodes.Pool.Size)
							iLastHoveredNodeId = editor.Nodes.Pool[gImNodes->HoveredNodeIdx.Value()].Id;
					}
				}

				//PE: Debug
				//ImGui::Text("iLastHoveredNodeId: %ld", iLastHoveredNodeId);
				//ImGui::Text("iHoveredId: %ld", iLastHoveredId);
				//bool LeftMouseDragging = ImGui::IsMouseDragging(0, 0.0f);
				//ImGui::Text("LeftMouseDragging: %d", LeftMouseDragging);
				//ImGui::Text("ImGui::IsWindowFocused: %d", ImGui::IsWindowFocused());
				//ImGui::Text("bImGuiGotFocus: %d", bImGuiGotFocus);
				//extern bool g_bAppActiveStat;
				//ImGui::Text("g_bAppActiveStat: %d", g_bAppActiveStat);
				//ImGui::Text("io.MouseDelta: %f,%f", io.MouseDelta.x, io.MouseDelta.y);

				/* removed from design
				if (ImGui::StyleCollapsingHeader("STORYBOARD", ImGuiTreeNodeFlags_DefaultOpen))
				{
					ImGui::Indent(10);

					ImGui::SetWindowFontScale(1.0);
					ImGui::TextCenter("Game Name");
					//ImGui::TextCenter("Enter your game name here");
					ImGui::PushItemWidth(-10.0);
					ImGui::InputText("##GamenameStoryboardInput2", Storyboard.gamename, 250, ImGuiInputTextFlags_ReadOnly); //ImGuiInputTextFlags_None
					if (ImGui::MaxIsItemFocused())
					{
						bImGuiGotFocus = true;
					}
					if (strlen(Storyboard.gamename) <= 0) {
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Use 'Save Game Project As...' To Give Your Game A Name");
					}
					ImGui::PopItemWidth();
					if (strlen(Storyboard.gamename) <= 0)
					{
						if (ImGui::StyleButton("Save Game Project As...", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
						{
							CloseAllOpenToolsThatNeedSave();
							save_storyboard(Storyboard.gamename, true);
						}
					}
					ImGui::Indent(-10);
				}
				*/

				float buttonwide = 200.0f;

				if (ImGui::StyleCollapsingHeader("Add and Edit Storyboard", ImGuiTreeNodeFlags_DefaultOpen) || iStoryboardExecuteKey != 0) //"Add New"
				{
					int iAutoConnectNode = -1;
					ImGui::Indent(10);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Add New Level", ImVec2(buttonwide, 0.0f)) || iStoryboardExecuteKey == 'N')
					{
						iStoryboardExecuteKey = 0;
						//PE: Find next level from nodes.
						int iNextLevel = 0, levelname = -1, iFirstNodeFree = -1;
						FindFreeLevelNode(iNextLevel, levelname, iFirstNodeFree);

						if (iFirstNodeFree >= 0)
						{
							//Create new level.
							char tmp[255];
							int node = iFirstNodeFree;
							int nodeposy = iNextLevel;
							if (levelname > 0)
							{
								sprintf(tmp, "Level %d", levelname);
								nodeposy = levelname - 1;
							}
							else
								sprintf(tmp, "Level %d", iNextLevel + 1);

							//PE: Make sure any old data is removed, also thumbs.
							reset_single_node(node);

							Storyboard.Nodes[node].used = true;
							Storyboard.Nodes[node].type = STORYBOARD_TYPE_LEVEL;
							Storyboard.Nodes[node].restore_position = ImVec2(preview_size_x*0.5 - (fNodeWidth*0.5) + ((fNodeWidth + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + ((fNodeHeight + 20.0 + NODE_HEIGHT_PADDING) * (nodeposy)));
							Storyboard.Nodes[node].iEditEnable = true;
							strcpy(Storyboard.Nodes[node].title, tmp);
							strcpy(Storyboard.Nodes[node].levelnumber, tmp);

							strcpy(Storyboard.Nodes[node].thumb, "");
							//Input.
							strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
							//Output.
							strcpy(Storyboard.Nodes[node].output_title[0], " GAME WON -> Connect to Scene ");
							strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
							Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
							Storyboard.Nodes[node].output_linkto[0] = 0;

							strcpy(Storyboard.Nodes[node].output_title[1], " GAME OVER -> Connect to Scene ");
							strcpy(Storyboard.Nodes[node].output_action[1], "loadlevel"); //Not defined this yet.
							Storyboard.Nodes[node].output_can_link_to_type[1] = STORYBOARD_TYPE_SCREEN;
							Storyboard.Nodes[node].output_linkto[1] = 0;

							strcpy(Storyboard.Nodes[node].output_title[2], " NEXT LEVEL -> Connect to Level ");
							strcpy(Storyboard.Nodes[node].output_action[2], "loadlevel"); //Not defined this yet.
							Storyboard.Nodes[node].output_can_link_to_type[2] = STORYBOARD_TYPE_LEVEL;
							Storyboard.Nodes[node].output_linkto[2] = 0;
							ImNodes::SetNodeGridSpacePos(Storyboard.Nodes[node].id, Storyboard.Nodes[node].restore_position);
							iAutoConnectNode = node;
						}
					}
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Add Existing Level", ImVec2(buttonwide, 0.0f)) || iStoryboardExecuteKey == 'L')
					{
						iStoryboardExecuteKey = 0;
						cStr tOldDir = GetDir();
						char * cFileSelected;
						cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "fpm\0*.fpm\0", g.mysystem.mapbankAbs_s.Get(), NULL, true);
						SetDir(tOldDir.Get());
						if (cFileSelected && strlen(cFileSelected) > 0)
						{
							t.returnstring_s = cFileSelected;
							if (t.returnstring_s != "")
							{
								if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) == ".fpm")
								{

									//Only relative.
									char tmp[MAX_PATH];
									strcpy(tmp, t.returnstring_s.Get());

									//PE: Vaidate path, must be inside the mapbank to work.
									extern char szRootDir[MAX_PATH];
									extern char szWriteDir[MAX_PATH];
									extern char szWriteDirAdditional[MAX_PATH];

									bool bValidPath = false;
									int rootLen = strlen(szWriteDir);
									if (strnicmp(tmp, szWriteDir, rootLen) == 0)
									{
										bValidPath = true;
									}
									rootLen = strlen(szWriteDirAdditional);
									if (!bValidPath && strnicmp(tmp, szWriteDirAdditional, rootLen) == 0)
									{
										bValidPath = true;
									}
									rootLen = strlen(szRootDir);
									if (!bValidPath && strnicmp(tmp, szRootDir, rootLen) == 0)
									{
										bValidPath = true;
									}


									char *find = (char *)pestrcasestr(tmp, "mapbank\\");
									if (find && find != &tmp[0]) strcpy(&tmp[0], find);

									if (bValidPath && !find)
									{
										//PE: Must be located inside mapbank.
										bValidPath = false;;
									}

									if (!bValidPath)
									{
										MessageBoxA(NULL, "All levels added to storyboard must be saved inside the default 'mapbank' folder.", "Error:", 0);
									}
									if (bValidPath)
									{
										std::string sLevelPath = &tmp[0];

										//Dont actual load, just use filename.
										int iPos;
										for (iPos = strlen(tmp); iPos >= 0; iPos--)
											if (tmp[iPos] == '\\') break;
										if (iPos > 0) iPos++;
										std::string sLevelTitle = &tmp[iPos];
										replaceAll(sLevelTitle, ".fpm", "");

										//PE: Find next level from nodes.
										int iNextLevel = 0, levelname = -1, iFirstNodeFree = -1;
										FindFreeLevelNode(iNextLevel, levelname, iFirstNodeFree);

										if (iFirstNodeFree >= 0)
										{
											//Create new level.
											char tmp[255];
											int node = iFirstNodeFree;
											int nodeposy = iNextLevel;
											if (levelname > 0)
											{
												sprintf(tmp, "Level %d", levelname);
												nodeposy = levelname - 1;
											}
											else
												sprintf(tmp, "Level %d", iNextLevel + 1);

											//PE: Make sure any old data is removed, also thumbs.
											reset_single_node(node);

											Storyboard.Nodes[node].used = true;
											Storyboard.Nodes[node].type = STORYBOARD_TYPE_LEVEL;
											Storyboard.Nodes[node].restore_position = ImVec2(preview_size_x*0.5 - (fNodeWidth*0.5) + ((fNodeWidth + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + ((fNodeHeight + 20.0 + NODE_HEIGHT_PADDING) * (nodeposy)));
											Storyboard.Nodes[node].iEditEnable = true;
											strcpy(Storyboard.Nodes[node].title, sLevelTitle.c_str());
											strcpy(Storyboard.Nodes[node].level_name, sLevelPath.c_str());
											strcpy(Storyboard.Nodes[node].levelnumber, tmp);

											strcpy(Storyboard.Nodes[node].thumb, "");
											//Input.
											strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
											//Output.
											strcpy(Storyboard.Nodes[node].output_title[0], " GAME WON -> Connect to Scene ");
											strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
											Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
											Storyboard.Nodes[node].output_linkto[0] = 0;

											strcpy(Storyboard.Nodes[node].output_title[1], " GAME OVER -> Connect to Scene ");
											strcpy(Storyboard.Nodes[node].output_action[1], "loadlevel"); //Not defined this yet.
											Storyboard.Nodes[node].output_can_link_to_type[1] = STORYBOARD_TYPE_SCREEN;
											Storyboard.Nodes[node].output_linkto[1] = 0;

											strcpy(Storyboard.Nodes[node].output_title[2], " NEXT LEVEL -> Connect to Level ");
											strcpy(Storyboard.Nodes[node].output_action[2], "loadlevel"); //Not defined this yet.
											Storyboard.Nodes[node].output_can_link_to_type[2] = STORYBOARD_TYPE_LEVEL;
											Storyboard.Nodes[node].output_linkto[2] = 0;
											ImNodes::SetNodeGridSpacePos(Storyboard.Nodes[node].id, Storyboard.Nodes[node].restore_position);
											iAutoConnectNode = node;
											//Check if level already got a thumb.
											CreateBackBufferCacheName(Storyboard.Nodes[node].level_name, 512, 288);
											if (FileExist(BackBufferCacheName.Get()))
											{
												if (CopyToProjectFolder(BackBufferCacheName.Get()))
												{
													//PE: Use relative projectbank filename.
													if (FileExist(ProjectCacheName.Get()))
														BackBufferCacheName = ProjectCacheName;
												}

												//PE: Load in old thumb.
												SetMipmapNum(1); //PE: mipmaps not needed.
												image_setlegacyimageloading(true);
												LoadImageSize(BackBufferCacheName.Get(), Storyboard.Nodes[node].thumb_id, 512, 288);
												image_setlegacyimageloading(false);
												SetMipmapNum(-1); //PE: mipmaps not needed.
												if (ImageExist(Storyboard.Nodes[node].thumb_id))
												{
													//PE: Success update thumb filename.
													strcpy(Storyboard.Nodes[node].thumb, BackBufferCacheName.Get());
												}
											}
										}
									}
								}
							}
						}

					}

					#ifdef INCLUDE_GAME_SETTINGS
					if (pref.iStoryboardAdvanced)
					{
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
						if (ImGui::StyleButton("Edit Game Settings", ImVec2(buttonwide, 0.0f)))
						{
							bEditGameSettings = true;
						}
					}
					#endif
					//PE: Auto connect node.
					if (iAutoConnectNode >= 0)
					{
						for (int i = 0; i < STORYBOARD_MAXNODES; i++)
						{
							if (Storyboard.Nodes[i].used)
							{
								if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL)
								{
									if (Storyboard.Nodes[i].output_linkto[2] == 0 && i != iAutoConnectNode)
									{
										Storyboard.Nodes[i].output_linkto[2] = Storyboard.Nodes[iAutoConnectNode].input_id[0];
										break;
									}
								}
							}
						}
						iAutoConnectNode = -1;
					}

					ImGui::Indent(-10);
				}

				#ifdef RPG_GAMES
				if (ImGui::StyleCollapsingHeader("RPG Games", ImGuiTreeNodeFlags_DefaultOpen) || iStoryboardExecuteKey != 0)
				{
					ImGui::Indent(10);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("RPG Settings", ImVec2(buttonwide, 0.0f)))
					{
						bRPGSetup_Window = true;
					}
					ImGui::Indent(-10);
				}
				#endif

				if (ImGui::StyleCollapsingHeader("Play Game", ImGuiTreeNodeFlags_DefaultOpen) || iStoryboardExecuteKey != 0 )
				{
					ImGui::Indent(10);
					if (strlen(playerrors) > 0) ImGui::TextWrapped(playerrors);

					static bool bStandalone = false;
					float tw = ImGui::CalcTextSize("Standalone Test All Levels").x;
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvailWidth()*0.5) - (tw*0.5) - (ImGui::GetFrameHeight()*0.5), 0.0f));
					ImGui::Checkbox("Standalone Test All Levels", &bStandalone);
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "NOTE: This will exit the editor and start a full test standalone version of your game.");

					cstr but1 = "Normal Single Level";
					cstr but2 = "Invulnerable Single Level";

					if (bStandalone)
					{
						but1 = "Normal Standalone";
						but2 = "Invulnerable Standalone";
					}

					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton(but1.Get(), ImVec2(buttonwide, 0.0f)) || iStoryboardExecuteKey == ' ')
					{
						strcpy(playerrors, "");

						iStoryboardExecuteKey = 0;

						g.projectmodified = 0; gridedit_changemodifiedflag();
						g.projectmodifiedstatic = 0;

						//Try loading level first.
						if (strlen(Storyboard.gamename) <= 0)
						{
							BoxerInfo("You should save your game project first.", "Information");
						}
						else
						{
							FindFirstLevel(g_Storyboard_First_Level_Node, g_Storyboard_First_fpm, true);
							if (g_Storyboard_First_Level_Node == -1)
							{
								strcpy(playerrors, "You do not have any levels in your setup.");
							}
							else
							{
								bool bAbort = false;
								if (Storyboard.iChanged)
								{
									bBlockNextMouseCheck = true;
									if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
									{
										save_storyboard(Storyboard.gamename, false);
									}
									else
									{
										int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
										if (iAction == 1)
										{
											//Save.
											if (strlen(Storyboard.gamename) > 0)
												save_storyboard(Storyboard.gamename, false);
											else
											{
												bAbort = true;
												save_storyboard(Storyboard.gamename, true);
											}
										}
									}
								}
								if (!bAbort)
								{
									if (bStandalone)
									{
										Sleep(100); //PE: Write done,
										extern bool g_bCascadeQuitFlag;
										g_bCascadeQuitFlag = true;
										PostQuitMessage(0);
										SetCurrentDirectoryA("..\\");
										char par[MAX_PATH];
										sprintf(par, "project=0%s", Storyboard.gamename);
										ExecuteFile("GameGuruMAX.exe", par, "", 0);
										Sleep(500);
										ExitProcess(0);
									}
									else
									{
										g_Storyboard_Current_Level = g_Storyboard_First_Level_Node;
										strcpy(g_Storyboard_Current_fpm, g_Storyboard_First_fpm);

										if (g.projectfilename_s != g_Storyboard_First_fpm)
										{
											//Load level if not already loaded.
											strcpy(cDirectOpen, g_Storyboard_First_fpm);
											iLaunchAfterSync = 7; //Direct load.
											iSkibFramesBeforeLaunch = 2;
											iFramesBeforeEmulate = 10;
										}
										else
										{
											iFramesBeforeEmulate = 2;
										}
										g.projectfilename_s = g_Storyboard_First_fpm;
										bTestStandalone = true;
										strcpy(startpage, "title");
										strcpy(lastpage, "title");
										strcpy(playerrors, "");
									}
								}
							}
						}


					}
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton(but2.Get(), ImVec2(buttonwide, 0.0f)) || iStoryboardExecuteKey == '!' )
					{
						strcpy(playerrors, "");

						iStoryboardExecuteKey = 0;
						 //Try loading level first.
						if (strlen(Storyboard.gamename) <= 0)
						{
							BoxerInfo("You should save your game project first.", "Information");
						}
						else
						{
							FindFirstLevel(g_Storyboard_First_Level_Node, g_Storyboard_First_fpm, true);
							if (g_Storyboard_First_Level_Node == -1)
							{
								strcpy(playerrors, "You do not have any levels in your setup.");
							}
							else
							{
								bool bAbort = false;
								if (Storyboard.iChanged)
								{
									bBlockNextMouseCheck = true;
									if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
									{
										save_storyboard(Storyboard.gamename, false);
									}
									else
									{
										int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
										if (iAction == 1)
										{
											//Save.
											if (strlen(Storyboard.gamename) > 0)
												save_storyboard(Storyboard.gamename, false);
											else
											{
												bAbort = true;
												save_storyboard(Storyboard.gamename, true);
											}
										}
									}
								}
								if (!bAbort)
								{
									if (bStandalone)
									{
										extern bool g_bCascadeQuitFlag;
										g_bCascadeQuitFlag = true;
										PostQuitMessage(0);
										SetCurrentDirectoryA("..\\");
										char par[MAX_PATH];
										sprintf(par, "project=1%s", Storyboard.gamename);
										ExecuteFile("GameGuruMAX.exe", par, "", 0);
										Sleep(500);
										ExitProcess(0);
									}
									else
									{
										g_Storyboard_Current_Level = g_Storyboard_First_Level_Node;
										strcpy(g_Storyboard_Current_fpm, g_Storyboard_First_fpm);

										if (g.projectfilename_s != g_Storyboard_First_fpm)
										{
											//Load level if not already loaded.
											strcpy(cDirectOpen, g_Storyboard_First_fpm);
											iLaunchAfterSync = 7; //Direct load.
											iSkibFramesBeforeLaunch = 2;
											iFramesBeforeEmulate = 10;
										}
										else
										{
											iFramesBeforeEmulate = 2;
										}
										g.projectfilename_s = g_Storyboard_First_fpm;
										bTestStandalone = true;
										strcpy(startpage, "title");
										strcpy(lastpage, "title");
										strcpy(playerrors, "");
										bStartInvulnerableMode = true;
									}
								}
							}
						}
					}
					ImGui::Indent(-10);
				}
				if (ImGui::StyleCollapsingHeader("Export Game", ImGuiTreeNodeFlags_DefaultOpen) || iStoryboardExecuteKey != 0)
				{
					ImGui::Indent(10);
					static char errors[256] = "\0";
					if (strlen(errors) > 0) ImGui::TextWrapped(errors);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Save Standalone Game", ImVec2(buttonwide, 0.0f)) || iStoryboardExecuteKey == 'E')
					{
						strcpy(errors, "");

						//PE: Deselect any objects, if we load a level with less entityties then t.widget.pickedEntityIndex it will crash.
						t.widget.pickedEntityIndex = 0;
						t.gridentity = 0;

						iStoryboardExecuteKey = 0;
						//PE: We need to store a list of levels to generate,
						if (strlen(Storyboard.gamename) <= 0)
						{
							BoxerInfo("You should save your game project before making a standalone.", "Information");
						}
						else
						{
							CloseAllOpenTools();
							int iRet = AskSaveBeforeNewAction();
							if (iRet != 2)
							{
								g.bUseStoryBoardSetup = true;
								FindFirstLevel(g_Storyboard_First_Level_Node, g_Storyboard_First_fpm, true);
								if (g_Storyboard_First_Level_Node == -1)
								{
									strcpy(errors, "You do not have any levels in your setup.");
								}
								else
								{
									bool bAbort = false;
									if (Storyboard.iChanged)
									{
										bBlockNextMouseCheck = true;
										if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
										{
											save_storyboard(Storyboard.gamename, false);
										}
										else
										{
											int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
											if (iAction == 1)
											{
												//Save.
												if (strlen(Storyboard.gamename) > 0)
													save_storyboard(Storyboard.gamename, false);
												else
												{
													bAbort = true;
													save_storyboard(Storyboard.gamename, true);
												}
											}
										}
									}
									if (!bAbort)
									{

										g_Storyboard_Current_Level = g_Storyboard_First_Level_Node;
										strcpy(g_Storyboard_Current_fpm, g_Storyboard_First_fpm);

										if (g.projectfilename_s != g_Storyboard_First_fpm)
										{
											//Load level if not already loaded.
											strcpy(cDirectOpen, g_Storyboard_First_fpm);
											iLaunchAfterSync = 7; //Direct load.
											iSkibFramesBeforeLaunch = 2;
											//PE: Delay open standalone.
											bLaunchSaveStandalonefterLoad = true;
										}
										else
										{									
											//PE: Already loaded directly to export.
											bExport_Standalone_Window = true;
										}
										g.projectfilename_s = g_Storyboard_First_fpm;

										//Use fullpath to levels.
										char destination[MAX_PATH];
										strcpy(destination, g.projectfilename_s.Get());
										GG_GetRealPath(destination, 1);
										g.projectfilename_s = destination;
									}
								}
							}
						}
					}
					ImGui::Indent(-10);
				}

				if(bModal)
					ControlAdvancedSetting(pref.iStoryboardAdvanced, "advanced storyboard features", &bStoryboardWindow);
				else
					ControlAdvancedSetting(pref.iStoryboardAdvanced, "advanced storyboard features", NULL);

				if (pref.iStoryboardAdvanced)
				{
					//Advanced options.
				}

				if (!pref.bHideTutorials)
				{
					if (ImGui::StyleCollapsingHeader("Tutorial", ImGuiTreeNodeFlags_DefaultOpen))
					{
						ImGui::Indent(10);
						char* my_combo_itemsp[] = { NULL };
						int my_combo_items = 0;
						int iVideoSection = 0;
						cstr cShowTutorial = "0701 - Game Storyboard";
						my_combo_itemsp[0] = "0701 - Game Storyboard";
						my_combo_items = 1;
						iVideoSection = SECTION_STORYBOARD;//LB: SECTION_SCULPT_TERRAIN;
						SmallTutorialVideo(cShowTutorial.Get(), my_combo_itemsp, my_combo_items, iVideoSection);
						float but_gadget_size = ImGui::GetFontSize()*12.0;
						float w = ImGui::GetWindowContentRegionWidth() - 10.0;
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
						ImGui::Indent(-10);
					}
				}

				// insert a keyboard shortcut component into panel
				UniversalKeyboardShortcut(eKST_Storyboard);

				ImGui::Columns(1);
			}

			if (bModal)
				ImGui::EndPopup();
			else
				ImGui::End();
		}

		if (!bModal) ImGui::PopStyleColor();

		if (!bPopModalStoryboard)
		{
			//Close down everything.
		}

		//Emulate standalone.
		bool bBlackOut = false;
		if (iFramesBeforeEmulate > 0)
		{
			iFramesBeforeEmulate--;
			//PE: Hide everything.
			if (iFramesBeforeEmulate < 4)
			{
				bBlackOut = true;
			}
		}
		else
		{
			if (bStartLoadingGame)
			{
				if (iFakeLoadGameTest-- > 0)
				{
					strcpy(lastpage, startpage);
					strcpy(startpage, "loading");
					int iret = screen_editor(-1, true, startpage);
				}
				else
				{
					bTestStandalone = false;
					bStartLoadingGame = false;
					bFakeStandaloneTest = true;
					//Start test game.
					iLaunchAfterSync = 1;
					bBlackOut = true;
				}
			}
			else if (bTestStandalone)
			{
				int iret = screen_editor(-1, true, startpage);
				//STORYBOARD_ACTIONS_GOTOLEVEL
				if (iret == STORYBOARD_ACTIONS_CONTINUE)
				{
					//Restart
					strcpy(startpage, "title");
					strcpy(lastpage, "title");
					strcpy(playerrors, "");
				}
				if (iret == STORYBOARD_ACTIONS_BACK)
				{
					strcpy(startpage, lastpage);
				}
				if (iret == STORYBOARD_ACTIONS_EXITGAME)
				{
					bTestStandalone = false;
				}
				if (iret == STORYBOARD_ACTIONS_STARTGAME)
				{
					bStartLoadingGame = true;
					iFakeLoadGameTest = 100;
				}
				if (iret == STORYBOARD_ACTIONS_GOTOSCREEN)
				{
					if (strlen(t.game.pSwitchToPage) == 0)
					{
						strcpy(lastpage, startpage);
						strcpy(startpage, "loading");
					}
					else
					{
						strcpy(lastpage, startpage);
						strcpy(startpage, t.game.pSwitchToPage);
					}
				}
			}
		}
		if (bBlackOut)
		{
			ImGuiViewport* mainviewport = ImGui::GetMainViewport();
			if (mainviewport)
			{
				ImDrawList* drawlist = ImGui::GetForegroundDrawList(mainviewport);
				if (drawlist)
				{
					ImVec4 monitor_col = ImVec4(0.0, 0.0, 0.0, 1.0 - t.postprocessings.fadeinvalue_f); //Fade in.
					drawlist->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(40.0f, 40.0f), ImGui::GetColorU32(monitor_col));
				}
			}
		}

	}
	else
	{
		pref.iLastInStoryboard = false;
	}
}


extern bool bTriggerTerrainSaveAsWindow;
int iTerrainSaveAsProcess = 0;

int save_level_as( void )
{
	int iRet = 0;
	static bool bGotAThumb = false;
	static int iSetKeyboardFocusHere = 10;
	if (iNewLevelNode < 0) return(0);

	if (bTriggerTerrainSaveAsWindow)
	{
		static char NewLevelName[256] = "\0";
		static char NewLevelError[256] = "\0";

		if (iTerrainSaveAsProcess == 0)
		{
			bGotAThumb = false;
			//Grab any thumbs created.
			if (ImageExist(STORYBOARD_THUMBS + 402)) DeleteImage(STORYBOARD_THUMBS + 402);

			if (FileExist("thumbbank\\lastnewlevel.jpg"))
			{
				image_setlegacyimageloading(true);
				LoadImageSize("thumbbank\\lastnewlevel.jpg", STORYBOARD_THUMBS + 402, 512, 288);
				image_setlegacyimageloading(false);
				if (ImageExist(STORYBOARD_THUMBS + 402))
					bGotAThumb = true;
			}
			strcpy(NewLevelName, "");
			strcpy(NewLevelError, "");
			iSetKeyboardFocusHere = 10;
			iTerrainSaveAsProcess++;
		}
		
		if (iTerrainSaveAsProcess == 1)
		{
			static int popwinheight = 0;
			if (popwinheight > 800 || iSkibFramesBeforeLaunch > 0)
			{
				ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Always);
			}

			//Ask to save new level.
			ImGui::OpenPopup("Save New Level##Storyboard");

			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bool bSaveNewLevelWindow = true;

			ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings;
			if (bDigAHoleToHWND) window_flags |= ImGuiWindowFlags_ForceRender;

			if (ImGui::BeginPopupModal("Save New Level##Storyboard", &bSaveNewLevelWindow, window_flags))
			{
				ImGuiWindow* bwindow = ImGui::GetCurrentWindow(); // ImGui::FindWindowByName("Save New Level##Storyboard");
				if (bDigAHoleToHWND)
				{
					if (bwindow)
					{
						bwindow->DrawList->AddCallback((ImDrawCallback)10, NULL); //force render.
						ImVec4 style_winback = ImGui::GetStyle().Colors[ImGuiCol_WindowBg];
						style_winback.w = 1.0f;
						ImGui::GetCurrentWindow()->DrawList->AddRectFilled(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize(), ImGui::GetColorU32(style_winback), 0.0f, ImDrawCornerFlags_None);
					}
				}
				popwinheight = ImGui::GetWindowSize().y;
				ImGui::Indent(10);
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);
				ImGui::TextCenter("Save New Level As");
				ImGui::Separator();
				if (bGotAThumb && ImageExist(STORYBOARD_THUMBS + 402))
				{
					ImGui::ImgBtn(STORYBOARD_THUMBS + 402, ImVec2(512, 288), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false);
					ImGui::Separator();
				}
				else
				{
					ImGui::Dummy(ImVec2(512, 10));
				}
				ImGui::SetWindowFontScale(1.0);
				ImGui::TextWrapped("You have just created a new level, to save this level please give it a name and click 'save'");
				ImGui::Text("");
				if (strlen(NewLevelError) > 0)
				{
					ImGui::Text(NewLevelError);
					ImGui::Text("");
				}
				ImGui::Text("Level Name");
				ImGui::PushItemWidth(-10);
				if (iSetKeyboardFocusHere > 0)
				{
					iSetKeyboardFocusHere--;
					ImGui::SetKeyboardFocusHere();
				}
				bool bTriggerReturnSave = false;
				if (ImGui::InputText("##NewLevelNameStoryboard", NewLevelName, 250, ImGuiInputTextFlags_EnterReturnsTrue)) //ImGuiInputTextFlags_None ImGuiInputTextFlags_ReadOnly
				{
					bTriggerReturnSave = true;
				}
				ImGui::PopItemWidth();

				ImGui::Text("");

				ImGui::SetWindowFontScale(1.4);
				if (ImGui::StyleButton("Save Level", ImVec2(ImGui::GetContentRegionAvail().x*0.5 - 20.0f, 0.0f)) || bTriggerReturnSave )
				{
					if (strlen(NewLevelName) > 0)
					{
						char tmp[MAX_PATH];
						strcpy(tmp, g.mysystem.mapbankAbs_s.Get());
						//Relative.
						char *find = (char *)pestrcasestr(tmp, "mapbank\\");
						if (find && find != &tmp[0]) strcpy(&tmp[0], find);
						strcat(tmp, NewLevelName);

						t.returnstring_s = tmp;

						if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) != ".fpm")  t.returnstring_s = t.returnstring_s + ".fpm";
						g.projectfilename_s = t.returnstring_s;

						bool oksave = true;
						if (FileExist(g.projectfilename_s.Get())) {
							oksave = overWriteFileBox(g.projectfilename_s.Get());
						}
						if (oksave)
						{
							//Add newly saved fpm level to recent list.
							int firstempty = -1;
							int i = 0;
							for (; i < REMEMBERLASTFILES; i++) {
								if (firstempty == -1 && strlen(pref.last_open_files[i]) <= 0)
									firstempty = i;
								if (strlen(pref.last_open_files[i]) > 0 && pestrcasestr(g.projectfilename_s.Get(), pref.last_open_files[i])) { //already there
									break;
								}
							}
							if (i >= REMEMBERLASTFILES) {
								if (firstempty == -1) {
									//No empty slots , rotate.
									for (int ii = 0; ii < REMEMBERLASTFILES - 1; ii++) {
										strcpy(pref.last_open_files[ii], pref.last_open_files[ii + 1]);
									}
									strcpy(pref.last_open_files[REMEMBERLASTFILES - 1], g.projectfilename_s.Get());
								}
								else
									strcpy(pref.last_open_files[firstempty], g.projectfilename_s.Get());
							}

							iLaunchAfterSync = 503; //Do the actualy save here.
							iSkibFramesBeforeLaunch = 3;
							iLaunchAfterSyncAction = 11;
							strcpy(cTriggerMessage, "Saving Level ...");
							bTriggerMessage = true;

							strcpy(Storyboard.Nodes[iNewLevelNode].title, NewLevelName);
							strcpy(Storyboard.Nodes[iNewLevelNode].level_name, g.projectfilename_s.Get());

							if (bGotAThumb)
							{
								CreateBackBufferCacheName(Storyboard.Nodes[iNewLevelNode].level_name, 512, 288);
								SaveImage(BackBufferCacheName.Get(), STORYBOARD_THUMBS + 402);
								if (FileExist(BackBufferCacheName.Get()))
								{
									if (CopyToProjectFolder(BackBufferCacheName.Get()))
									{
										//PE: Use relative projectbank filename.
										if (FileExist(ProjectCacheName.Get()))
											BackBufferCacheName = ProjectCacheName;
									}

									//Load to correct id.
									SetMipmapNum(1); //PE: mipmaps not needed.
									image_setlegacyimageloading(true);
									LoadImageSize(BackBufferCacheName.Get(), Storyboard.Nodes[iNewLevelNode].thumb_id, 512, 288);
									image_setlegacyimageloading(false);
									SetMipmapNum(-1);
									strcpy(Storyboard.Nodes[iNewLevelNode].thumb, BackBufferCacheName.Get());
								}
							}

							bTriggerTerrainSaveAsWindow = false; //Close down window.
							iRet = 2;
						}
						else
						{
							//Cancel just ignore.
						}

						//strcpy(Storyboard.Nodes[node].level_name, "");
						//Overwrite ?
					}
					else
					{
						strcpy(NewLevelError, "Error: Please give your level a name before save.");
					}
				}
				ImGui::SameLine();
				if (ImGui::StyleButton("Cancel", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					//Cancel.
					bTriggerTerrainSaveAsWindow = false; //Close down window.
					iRet = 1;
				}

				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");

				bImGuiGotFocus = true;
				ImGui::Indent(-10);
				ImGui::EndPopup();

				if (bDigAHoleToHWND && bwindow)
					bwindow->DrawList->AddCallback((ImDrawCallback)11, NULL); //disable force render.
			}

		}
	}
	else
	{
		iTerrainSaveAsProcess = 0;
	}

	return(iRet);
}

int save_create_storyboard_project(void)
{
	int iRet = 0;
	static int iSetKeyboardFocusHere = 10;
	if (bTriggerSaveAs)
	{
		//Ask to save as.

		ImGui::OpenPopup("Save As#Storyboard");
		ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Once);
		static int popwinheight = 0;
		if (popwinheight > 800 || iSkibFramesBeforeLaunch > 0)
		{
			ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Always);
		}
		ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
		bool bSaveAsWindow = true;
		if (ImGui::BeginPopupModal("Save As#Storyboard", &bSaveAsWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
		{
			popwinheight = ImGui::GetWindowSize().y;

			if (bTriggerSaveAsAfterNewLevel)
			{
				ImVec2 vCurPos = ImGui::GetCursorPos();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(3.0f, 8.0f));
				ImGui::SetItemAllowOverlap();
				ImVec2 vIconSize = { (float)ImGui::GetFontSize()*3.5f, (float)ImGui::GetFontSize()*3.5f };
				if (ImGui::ImgBtn(TOOL_GOBACK, vIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
				{
					bTriggerSaveAs = false;
					bTriggerSaveAsAfterNewLevel = false;
					iRet = 2;

				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Close");
				ImGui::SetCursorPos(vCurPos);
			}

			ImGui::Indent(10);
			ImGui::Text("");

			ImGui::SetWindowFontScale(1.6);
			if (bTriggerSaveAsAfterNewLevel)
			{
				ImGui::TextCenter("Create a New Game Project");
				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");
			}
			else
			{
				ImGui::TextCenter("Save Game Project As");
			}
			ImGui::Separator();

			if (bTriggerSaveAsAfterNewLevel)
				ImGui::Dummy(ImVec2(580, 1));
			else
				ImGui::Dummy(ImVec2(510, 1));
			ImGui::SetWindowFontScale(1.2);
			ImGui::Text("");
			if (bTriggerSaveAsAfterNewLevel)
			{
				ImGui::TextCenter("All new games need a name. This is so they can be saved to the");
				ImGui::TextCenter("hard drive and identified when edited in the future.");
				ImGui::Text("");
				ImGui::TextCenter("If you have a name in mind that's great! Just enter it below.");
				ImGui::Text("");
				ImGui::TextCenter("If you're unsure then try to be creative and give it a temporary name");
				ImGui::TextCenter("for now. You can always rename it later on.");
			}
			else
			{
				ImGui::Text("To save your game project, please give your project a name and click 'save'");
				ImGui::Text("");
				ImGui::TextWrapped("NOTE: This name will also be used as your standalone game name.");
			}
			ImGui::Text("");


			if (strlen(SaveProjectAsError) > 0)
			{
				ImGui::Text(SaveProjectAsError);
				ImGui::Text("");
			}
			if (bTriggerSaveAsAfterNewLevel)
			{
				ImGui::SetWindowFontScale(1.4);
				ImGui::TextCenter("Enter Your Game Name Here");
				ImGui::SetWindowFontScale(1.2);
			}
			else
			{
				ImGui::Text("Game Project Name");
			}
			ImGui::PushItemWidth(-10);

			bool bClicked = false;
			bool bForceClicked = false;

			if (iSetKeyboardFocusHere > 0)
			{
				iSetKeyboardFocusHere--;
				ImGui::SetKeyboardFocusHere();
			}
			if (ImGui::InputText("##SaveAsNameStoryboard", SaveProjectAsName, 250, ImGuiInputTextFlags_None | ImGuiInputTextFlags_EnterReturnsTrue))//ImGuiInputTextFlags_None ImGuiInputTextFlags_ReadOnly
			{
				//Clean name.
				std::string sCleanName = SaveProjectAsName;
				replaceAll(sCleanName, """", "");
				replaceAll(sCleanName, "\\", "");
				replaceAll(sCleanName, "/", "");
				replaceAll(sCleanName, "^", "");
				replaceAll(sCleanName, "?", "");
				replaceAll(sCleanName, "@", "");
				replaceAll(sCleanName, "\t", "");
				replaceAll(sCleanName, ":", "");
				strcpy(SaveProjectAsName, sCleanName.c_str());
				if(bTriggerSaveAsAfterNewLevel) bForceClicked = true; // Enter now just create the game.
			}
			ImGui::PopItemWidth();

			ImGui::Text("");

			ImGui::SetWindowFontScale(1.4);

			if (bTriggerSaveAsAfterNewLevel)
			{
				//ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2( (ImGui::GetContentRegionAvailWidth()*0.25), 0)); //Center with new header.
				bClicked = ImGui::StyleButton("Create Game Project", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f));
			}
			else
				bClicked = ImGui::StyleButton("Save As", ImVec2(ImGui::GetContentRegionAvail().x*0.5 - 20.0f, 0.0f));

			if (bClicked || bForceClicked)
			{
				//PE: Trim
				std::string sCleanName = SaveProjectAsName;
				sCleanName.erase(sCleanName.find_last_not_of(" \t") + 1); //PE: No spaces tab at end.
				strcpy(SaveProjectAsName, sCleanName.c_str());

				if (strlen(SaveProjectAsName) > 0)
				{
					char destination[MAX_PATH];
					strcpy(destination, "projectbank\\");
					strcat(destination, SaveProjectAsName);
					GG_GetRealPath(destination, 1);
					int bOkSave = true;
					if (PathExist(destination) == 1)
					{
						int iAction = askBoxCancel("Project already exists, do you want to overwrite ?", "Confirmation"); //1==Yes 2=Cancel 0=No
						if (iAction == 1)
						{
							//backup old folder.
							int i_loop = 1;
							char backup[MAX_PATH];
							sprintf(backup, "%s_backup_%d", destination, i_loop++);
							while (MoveFileA(destination, backup) == 0)
								sprintf(backup, "%s_backup_%d", destination, i_loop++);
						}
						else
						{
							//Cancel.
							bOkSave = false;
						}
					}
					if (bOkSave)
					{
						//Continue.
						MakeDirectory(destination);
						strcat(destination, "\\project.dat");
						strcpy(Storyboard.gamename, SaveProjectAsName);
						Storyboard.project_readonly = 0;
						save_storyboard(Storyboard.gamename, false);
						bTriggerSaveAs = false;
						bTriggerSaveAsAfterNewLevel = false;
						iRet = 1;
					}
				}
				else
				{
					strcpy(SaveProjectAsError, "Error: Please give your game project a name before saving.");
				}
			}
			if (!bTriggerSaveAsAfterNewLevel)
			{
				ImGui::SameLine();
				if (ImGui::StyleButton("Cancel", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					//Cancel.
					bTriggerSaveAs = false;
					bTriggerSaveAsAfterNewLevel = false;
					iRet = 2;
				}
			}
			ImGui::SetWindowFontScale(1.0);
			ImGui::Text("");

			bImGuiGotFocus = true;
			ImGui::Indent(-10);
			ImGui::EndPopup();
		}
	}
	else
	{
		iSetKeyboardFocusHere = 10;
	}
	return iRet;
}


//FindFirstLevel(g_Storyboard_First_Level_Node, g_Storyboard_First_fpm);
//if( g_Storyboard_First_Level_Node == -1) // Not Found.

//g_Storyboard_Current_Level MUST be set by load_fpm , so "load game" will also work.
//g_Storyboard_Current_Level = g_Storyboard_First_Level_Node;
//strcpy(g_Storyboard_Current_fpm,g_Storyboard_First_fpm);


//Win
// int a = FindNextLevel(g_Storyboard_Current_Level, g_Storyboard_Current_fpm)
//if( a == 0 ) // No more levels found, go to won.lua
// if( a == 1 ) //Goto a new level.
// if( a == 2 ) //Goto a new lua screen.

//Lost
// int a = FindNextLevel(g_Storyboard_Current_Level, g_Storyboard_Current_lua , 1)
// jump to g_Storyboard_Current_lua.


int FindOutputScreenNode(int iNode, int index)
{
	//Storyboard.Nodes[iNextNode].lua_name
	if (iNode >= 0)
	{
		//Find connected to:
		int iLinkTo = Storyboard.Nodes[iNode].output_linkto[index];
			//Find input.
		for (int i = 0; i < STORYBOARD_MAXNODES; i++)
		{
			if (Storyboard.Nodes[i].used)
			{
				for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
				{
					if (iLinkTo > 0 && iLinkTo == Storyboard.Nodes[i].input_id[l])
					{
						return(i);
					}
				}
			}
		}
	}
	return(-1);
}

int FindNextLevel(int &iNextLevelNode, char *level_name, int action)
{
	int iNextNode = -1;
	int iNextWinScreenNode = -1;
	int iNextLostScreenNode = -1;

	if (iNextLevelNode >= 0)
	{
		//Find connected to:
		int iLinkToLost = Storyboard.Nodes[iNextLevelNode].output_linkto[1]; //2=Next Loast screen.
		int iLinkToWin = Storyboard.Nodes[iNextLevelNode].output_linkto[0]; //2=Next Won screen.
		int iLinkTo = Storyboard.Nodes[iNextLevelNode].output_linkto[2]; //2=Next level.
			//Find input.
		for (int i = 0; i < STORYBOARD_MAXNODES; i++)
		{
			if (Storyboard.Nodes[i].used)
			{
				for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
				{
					if (iLinkTo > 0 && iLinkTo == Storyboard.Nodes[i].input_id[l])
					{
						iNextNode = i;
					}
					if (iLinkToWin > 0 && iLinkToWin == Storyboard.Nodes[i].input_id[l])
					{
						iNextWinScreenNode = i;
					}
					if (iLinkToLost > 0 && iLinkToLost == Storyboard.Nodes[i].input_id[l])
					{
						iNextLostScreenNode = i;
					}
				}
			}
		}
	}
	if (action == 1)
	{
		//Get lost screen.
		if (iNextLostScreenNode > 0)
		{
			//Found it.
			iNextLevelNode = iNextLostScreenNode;
			strcpy(level_name, Storyboard.Nodes[iNextLostScreenNode].lua_name);
			return(2); //Goto next lua script.
		}
		//Not connected for lose.lua
		strcpy(level_name, "lose.lua");
		return(2); //Goto next lua script.
	}

	if (iNextNode > 0)
	{
		//Found next level.
		if (strlen(Storyboard.Nodes[iNextNode].level_name) > 0)
		{
			iNextLevelNode = iNextNode;
			strcpy(level_name, Storyboard.Nodes[iNextNode].level_name);
			return(1); //Goto next level.
		}
	}
	//Not linking to a level, check if we have a linking won screen.
	if (iNextWinScreenNode > 0)
	{
		if (strlen(Storyboard.Nodes[iNextWinScreenNode].lua_name) > 0)
		{
			iNextLevelNode = iNextWinScreenNode;
			strcpy(level_name, Storyboard.Nodes[iNextWinScreenNode].lua_name);
			return(2); //Goto next won lua script.
		}

	}

	//Not linking to anything, force a win.lua
	strcpy(level_name, "win.lua");
	return(2); //Goto next lua script.
}

void FindFirstSplash(char *splash_name)
{
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		if (Storyboard.Nodes[i].used)
		{
			if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
			{
				if (strlen(Storyboard.Nodes[i].thumb) > 0)
				{
					strcpy(splash_name, Storyboard.Nodes[i].thumb);
				}
			}
		}
	}
}

int FindLuaScreenNode(char *name)
{
	if (strlen(Storyboard.gamename) <= 0) return(-1);
	std::string lua_name = name;
	replaceAll(lua_name, ".lua", "");
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		if (Storyboard.Nodes[i].used)
		{
			std::string check_lua_name = Storyboard.Nodes[i].lua_name;
			replaceAll(check_lua_name, ".lua", "");
			if (stricmp(check_lua_name.c_str(), lua_name.c_str()) == NULL)
			{
				return i;
			}
		}
	}
	return -1;
}

void FindFirstLevel(int &iFirstLevelNode, char *level_name, bool bFailIfNoLink)
{
	//Get loading screen connected to:
	iFirstLevelNode = -1;
	int iLoadingScreenNode = -1;
	int iLevelNode = -1;
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		if (Storyboard.Nodes[i].used)
		{
			if (stricmp(Storyboard.Nodes[i].lua_name, "loading.lua") == 0)
			{
				iLoadingScreenNode = i;
			}
		}
	}
	if (iLoadingScreenNode >= 0)
	{
		//Find connected to:
		int iLinkTo = Storyboard.Nodes[iLoadingScreenNode].output_linkto[0];
		if (iLinkTo > 0)
		{
			//Find input.
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used)
				{
					for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
					{
						if (iLinkTo == Storyboard.Nodes[i].input_id[l])
						{
							iLevelNode = i;
							break;
						}
					}
				}
				if (iLevelNode > 0) break;
			}
		}
	}
	if (iLevelNode > 0)
	{
		//Found first level.
		if (strlen(Storyboard.Nodes[iLevelNode].level_name) > 0)
		{
			iFirstLevelNode = iLevelNode;
			strcpy(level_name, Storyboard.Nodes[iFirstLevelNode].level_name);
			return;
		}
	}

	if (bFailIfNoLink)
	{
		return;
	}

	//No level connected to the loading.lua page.
	//Just use the level with the internal name "Level 1"

	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		if (Storyboard.Nodes[i].used)
		{
			if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL)
			{
				if (strcmp("Level 1", Storyboard.Nodes[i].levelnumber) == 0)
				{
					if (strlen(Storyboard.Nodes[i].level_name) > 0)
					{
						iFirstLevelNode = i;
						strcpy(level_name, Storyboard.Nodes[i].level_name);
						return;
					}
				}
			}
		}
	}
	return;
}

bool FindFreeLevelNode( int &iNextLevel,int &levelname ,int &iFirstNodeFree)
{
	//PE: Find next level from nodes.
	iNextLevel = 0;
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		if (Storyboard.Nodes[i].used)
		{
			if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL)
				iNextLevel++;
		}
	}
	//Free level name.
	levelname = -1;
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		char tmp[255];
		sprintf(tmp, "Level %d", i + 1);
		bool bFound = false;
		for (int a = 0; a < STORYBOARD_MAXNODES; a++)
		{
			if (Storyboard.Nodes[a].used)
			{
				if (strcmp(tmp, Storyboard.Nodes[a].levelnumber) == 0)
				{
					bFound = true;
				}
			}
		}
		if (!bFound)
		{
			levelname = i + 1;
			break;
		}
	}

	iFirstNodeFree = -1;
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		if (!Storyboard.Nodes[i].used)
		{
			iFirstNodeFree = i;
			break;
		}
	}

	return true;
}

void mapNodeStyle(void)
{
	//PE: We might need to tweek this for other styes.
	//PE: These grey with transparent to get some style colors looks better.

	ImVec4* colors = ImGui::GetStyle().Colors;
	ImVec4 fade = colors[ImGuiCol_Button] * ImVec4(0.8, 0.8, 0.8, 0.75);

	GImNodes->Style.Colors[ImNodesCol_NodeBackground] = IM_COL32(128, 128, 128, 130); //ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_WindowBg]);
	GImNodes->Style.Colors[ImNodesCol_NodeBackgroundHovered] = IM_COL32(128, 128, 128,200); //ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_Button]);
	GImNodes->Style.Colors[ImNodesCol_NodeBackgroundSelected] = IM_COL32(128, 128, 128, 200); //ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_Button]);
	GImNodes->Style.Colors[ImNodesCol_NodeOutline] = IM_COL32(128, 128, 128, 200); //ImGui::ColorConvertFloat4ToU32(fade);

	// title bar colors match ImGui's titlebg colors
	GImNodes->Style.Colors[ImNodesCol_TitleBar] = ImGui::ColorConvertFloat4ToU32(fade);
	GImNodes->Style.Colors[ImNodesCol_TitleBarHovered] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_Button]);
	GImNodes->Style.Colors[ImNodesCol_TitleBarSelected] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_Button]);
//	GImNodes->Style.Colors[ImNodesCol_TitleBar] = ImGui::ColorConvertFloat4ToU32(fade);
//	GImNodes->Style.Colors[ImNodesCol_TitleBarHovered] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_TitleBg]);
//	GImNodes->Style.Colors[ImNodesCol_TitleBarSelected] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_TitleBg]);


	GImNodes->Style.Colors[ImNodesCol_Link] = IM_COL32(180, 180, 180, 200);
	GImNodes->Style.Colors[ImNodesCol_LinkHovered] = IM_COL32(180, 180, 180, 255);
	GImNodes->Style.Colors[ImNodesCol_LinkSelected] = IM_COL32(180, 180, 180, 255);
	// pin colors match ImGui's button colors
	GImNodes->Style.Colors[ImNodesCol_Pin] = IM_COL32(180, 180, 180, 200);
	GImNodes->Style.Colors[ImNodesCol_PinHovered] = IM_COL32(180, 180, 180, 255);

	// link colors match ImGui's slider grab colors
	//GImNodes->Style.Colors[ImNodesCol_Link] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_Button]);
	//GImNodes->Style.Colors[ImNodesCol_LinkHovered] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_ButtonHovered]);
	//GImNodes->Style.Colors[ImNodesCol_LinkSelected] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_ButtonHovered]);
	// pin colors match ImGui's button colors
	//GImNodes->Style.Colors[ImNodesCol_Pin] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_Button]);
	//GImNodes->Style.Colors[ImNodesCol_PinHovered] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_ButtonHovered]);

	GImNodes->Style.Colors[ImNodesCol_BoxSelector] = IM_COL32(128, 128, 128, 30);
	GImNodes->Style.Colors[ImNodesCol_BoxSelectorOutline] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_PlotLines]);

	GImNodes->Style.Colors[ImNodesCol_GridBackground] = IM_COL32(0, 0, 0, 0);
	GImNodes->Style.Colors[ImNodesCol_GridLine] = IM_COL32(200, 200, 200, 25);

	// minimap colors
	GImNodes->Style.Colors[ImNodesCol_MiniMapBackground] = IM_COL32(25, 25, 25, 150);
	GImNodes->Style.Colors[ImNodesCol_MiniMapBackgroundHovered] = IM_COL32(25, 25, 25, 200);
	GImNodes->Style.Colors[ImNodesCol_MiniMapOutline] = IM_COL32(150, 150, 150, 100);
	GImNodes->Style.Colors[ImNodesCol_MiniMapOutlineHovered] = IM_COL32(150, 150, 150, 200);
	GImNodes->Style.Colors[ImNodesCol_MiniMapNodeBackground] = IM_COL32(200, 200, 200, 100);
	GImNodes->Style.Colors[ImNodesCol_MiniMapNodeBackgroundHovered] = IM_COL32(200, 200, 200, 255);
	GImNodes->Style.Colors[ImNodesCol_MiniMapNodeBackgroundSelected] = GImNodes->Style.Colors[ImNodesCol_MiniMapNodeBackgroundHovered];
	GImNodes->Style.Colors[ImNodesCol_MiniMapNodeOutline] = IM_COL32(200, 200, 200, 100);
	GImNodes->Style.Colors[ImNodesCol_MiniMapLink] = GImNodes->Style.Colors[ImNodesCol_Link];
	GImNodes->Style.Colors[ImNodesCol_MiniMapLinkSelected] = GImNodes->Style.Colors[ImNodesCol_LinkSelected];
	GImNodes->Style.Colors[ImNodesCol_MiniMapCanvas] = IM_COL32(200, 200, 200, 25);
	GImNodes->Style.Colors[ImNodesCol_MiniMapCanvasOutline] = IM_COL32(200, 200, 200, 200);
}

void storyboard_menubar(float area_width, float node_width, float node_height)
{
	static int iCloseDownCount = 100;
	static int iCloseDownCount2 = 100;
	static int iCloseDownCount3 = 100;

	if (ImGui::BeginMenuBar())
	{
		ImVec2 CursorMenuStart = ImGui::GetCursorPos();
		if (ImGui::BeginMenu("File##Storyboard"))
		{
			bool bIsMenuHovered = false;

			if (ImGui::MenuItem("New Game Project", ""))
			{
				CloseAllOpenTools();
				bool bAbort = false;
				if (Storyboard.iChanged)
				{
					if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
					{
						save_storyboard(Storyboard.gamename, false);
					}
					else
					{
						int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
						if (iAction == 1)
						{
							//Save.
							if (strlen(Storyboard.gamename) > 0)
								save_storyboard(Storyboard.gamename, false);
							else
							{
								bAbort = true;
								save_storyboard(Storyboard.gamename, true);
							}
						}
					}
				}
				if (!bAbort)
				{
					bStoryboardInitNodes = false; //Just init again.
					bStoryboardFirstRunSetInitPos = false;
					strcpy(pref.cLastUsedStoryboardProject, "");
					bTriggerSaveAsAfterNewLevel = true;
					bTriggerSaveAs = true;
					strcpy(SaveProjectAsName, "");
					strcpy(SaveProjectAsError, "");

					//
				}
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
			if (ImGui::MenuItem("Open Game Project", ""))
			{
				CloseAllOpenToolsThatNeedSave();
				bool bAbort = false;
				if (Storyboard.iChanged)
				{
					if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
					{
						save_storyboard(Storyboard.gamename, false);
					}
					else
					{
						int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
						if (iAction == 1)
						{
							//Save.
							if (strlen(Storyboard.gamename) > 0)
								save_storyboard(Storyboard.gamename, false);
							else
							{
								bAbort = true;
								save_storyboard(Storyboard.gamename, true);
							}
						}
					}
				}

				if (!bAbort)
				{
					//Open Game Project
					bTriggerOpenProject = true;
				}
				//
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			//PE: Only use save if we already have a Project Name.
			if (strlen(Storyboard.gamename) > 0)
			{
				if (Storyboard.project_readonly != 1)
				{
					if (ImGui::MenuItem("Save Game Project", ""))
					{
						CloseAllOpenToolsThatNeedSave();
						//
						save_storyboard(Storyboard.gamename, false);
					}
					if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
				}
			}

			if (ImGui::MenuItem("Save Game Project As...", ""))//CTRL+R" ) )//F12") )
			{
				CloseAllOpenToolsThatNeedSave();
				//
				save_storyboard(Storyboard.gamename, true);
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();


			ImGui::Separator();
			//for (int ii = 0; ii < REMEMBERLASTFILES; ii++) { //reverse
			for (int ii = REMEMBERLASTFILES - 1; ii >= 0; ii--) {
				if (strlen(pref.last_project_files[ii]) > 0) {

					//std::string s_tmp = std::to_string(1+ii); //Reverse
					std::string s_tmp = std::to_string(REMEMBERLASTFILES - ii);
					s_tmp += ": ";
					s_tmp += pref.last_project_files[ii];

					if (ImGui::MenuItem(s_tmp.c_str())) {
						if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
						if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
						if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
						if (bEntity_Properties_Window) bEntity_Properties_Window = false;
						if (t.ebe.on == 1) ebe_hide();
						bool bAbort = false;
						if (Storyboard.iChanged)
						{
							if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
							{
								save_storyboard(Storyboard.gamename, false);
							}
							else
							{
								int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
								if (iAction == 1)
								{
									//Save.
									if (strlen(Storyboard.gamename) > 0)
										save_storyboard(Storyboard.gamename, false);
									else
									{
										bAbort = true;
										save_storyboard(Storyboard.gamename, true);
									}
								}
							}
						}
						if (!bAbort)
						{
							load_storyboard(pref.last_project_files[ii]);
							iGamePausedNodeID = storyboard_add_missing_nodex(8, area_width, node_width, node_height + 20.0, false);
							iLoadGameNodeID = storyboard_add_missing_nodex(3, area_width, node_width, node_height + 20.0, false);
							iSaveGameNodeID = storyboard_add_missing_nodex(9, area_width, node_width, node_height + 20.0, false);
							iGraphicsNodeID = storyboard_add_missing_nodex(10, area_width, node_width, node_height + 20.0, false);
							iSoundsNodeID = storyboard_add_missing_nodex(11, area_width, node_width, node_height + 20.0, false);
							iControlNodeID = storyboard_add_missing_nodex(12, area_width, node_width, node_height + 20.0, false);
							iLoadingScreenNodeID = storyboard_add_missing_nodex(2, area_width, node_width, node_height + 20.0, false);
						
						}
					}
					if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
				}
			}

			ImGui::Separator();
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if (ImGui::MenuItem("Exit to Desktop"))
			{
				if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
				if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
				if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
				if (bEntity_Properties_Window) bEntity_Properties_Window = false;
				if (t.ebe.on == 1) ebe_hide();
				//
				bool bAbort = false;
				if (Storyboard.iChanged)
				{
					if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
					{
						save_storyboard(Storyboard.gamename, false);
					}
					else
					{
						int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
						if (iAction == 1)
						{
							//Save.
							if (strlen(Storyboard.gamename) > 0)
								save_storyboard(Storyboard.gamename, false);
							else
							{
								bAbort = true;
								save_storyboard(Storyboard.gamename, true);
							}
						}
					}
				}
				if (!bAbort)
				{
					bStoryboardWindow = false;
					g_bCascadeQuitFlag = true;
				}
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			ImGui::EndMenu();
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if (pref.bAutoOpenMenuItems)
			{
				if (!bIsMenuHovered)
				{
					if (iCloseDownCount-- <= 0)
					{
						ImGui::OpenPopup("##DummyClose##Storyboard");
						if (ImGui::BeginMenu("##DummyClose##Storyboard"))
						{
							ImGui::EndMenu();
						}
					}
				}
				else
				{
					iCloseDownCount = 100;
				}
			}
		}
		else
		{
			if (pref.bAutoOpenMenuItems)
				if (ImGui::IsItemHovered())
				{
					ImGui::OpenPopup("File##Storyboard");
					iCloseDownCount = 100;
				}
		}

		//###################
		//#### Edit menu ####
		//###################

		if (ImGui::BeginMenu("Edit##Storyboard"))
		{
			bool bIsMenuHovered = false;

			if (ImGui::MenuItem("Add New Level", "CTRL+N"))
			{
				iStoryboardExecuteKey = 'N';
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if (ImGui::MenuItem("Add Existing Level", "CTRL+L"))
			{
				iStoryboardExecuteKey = 'L';
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			ImGui::Separator();
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if (ImGui::MenuItem("Play Game", "CTRL+SPACE"))
			{
				iStoryboardExecuteKey = ' ';
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if( ImGui::MenuItem("Play Game With Invulnerability", "") )
			{
				iStoryboardExecuteKey = '!';
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			ImGui::Separator();
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if (ImGui::MenuItem("Export Standalone Game","CTRL+E"))
			{
				iStoryboardExecuteKey = 'E';
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			ImGui::Separator();
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if (ImGui::MenuItem("Settings", ""))
			{
				strcpy(cPreferencesMessage, "");
				bPreferences_Window = true;
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();


			ImGui::EndMenu();
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if (pref.bAutoOpenMenuItems)
			{
				if (!bIsMenuHovered)
				{
					if (iCloseDownCount2-- <= 0)
					{
						ImGui::OpenPopup("##DummyClose##Storyboard");
						if (ImGui::BeginMenu("##DummyClose##Storyboard"))
						{
							ImGui::EndMenu();
						}
					}
				}
				else
				{
					iCloseDownCount2 = 100;
				}
			}
		}
		else
		{
			if (pref.bAutoOpenMenuItems)
				if (ImGui::IsItemHovered())
				{
					ImGui::OpenPopup("Edit##Storyboard");
					iCloseDownCount2 = 100;
				}
		}


		//###################
		//#### Help menu ####
		//###################

		if (ImGui::BeginMenu("Help##Storyboard"))
		{
			bool bIsMenuHovered = false;
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if (ImGui::MenuItem("Read User Manual"))
			{
				ExecuteFile("https://gameguru-max.document360.io/docs", "", "", 0);
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			/* ZJ: Moved to the hub.
			if (ImGui::MenuItem("GameGuru MAX YouTube Channel"))
			{
				ExecuteFile("https://www.youtube.com/channel/UC1q1e3Q9IKMk4nDlAGb_5Jg", "", "", 0);
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if (ImGui::MenuItem("GameGuru MAX Forum"))
			{
				ExecuteFile("https://forum.game-guru.com/", "", "", 0);
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if (ImGui::MenuItem("GameGuru MAX Discord"))
			{
				ExecuteFile("https://discord.gg/xnTAbBR", "", "", 0);
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
			*/

			if (g_bUpdateAppAvailable == true)
			{
				if (ImGui::MenuItem("Check For Updates"))
				{
					int iRet = AskSaveBeforeNewAction();
					if (iRet != 2)
					{
						g.projectmodified = 0;
						g.projectmodifiedstatic = 0;
						ExecuteFile("..\\..\\GameGuru MAX Updater.exe", "", "", 0);
						g_bCascadeQuitFlag = true;
					}
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
			}

			if (ImGui::MenuItem("Report an Issue (GitHub)"))
			{
				ExecuteFile("https://github.com/TheGameCreators/GameGuruRepo/issues/new", "", "", 0);
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();


			#ifdef USEWELCOMESCREEN
			if (ImGui::MenuItem("GameGuru MAX Hub")) //"Welcome Screen"
			{
				bWelcomeScreen_Window = true;
				bStoryboardWindow = false;
				cLastProjectList = ""; //Trigger a reload of projects, if anything changed.
				bWelcomeNoBackButton = true;
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
			#endif

			image_setlegacyimageloading(true);
			/*
			if (ImGui::MenuItem("Level Shortcuts")) {
				strcpy(cHelpMenuImage, "languagebank\\english\\artwork\\testgamelayout.png");
				LoadImage(cHelpMenuImage, HELPMENU_IMAGE);
				bHelp_Menu_Image_Window = true;
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
			*/

			if (bAddWhatNewToMenu)
			{
				if (ImGui::MenuItem("What's New?")) //Change Log
				{
					//welcome_show(WELCOME_ANNOUNCEMENTS);
					bool welcome_get_change_log(void);
					if (gbWelcomeSystemActive == false)
					{
						welcome_init(1);
						welcome_init(2);
					}
					welcome_init(0);
					if (welcome_get_change_log() == true)
					{
						welcome_runloop(WELCOME_ANNOUNCEMENTS);
						iTriggerWelcomeSystemStuff = 99; //PE: Start welcome system.
					}
				}
			}

			if (ImGui::MenuItem("About")) {
				bAbout_Window = true;
				bAbout_Window_First_Run = true;
			}
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
			image_setlegacyimageloading(false);


			ImGui::EndMenu();
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if (pref.bAutoOpenMenuItems)
			{
				if (!bIsMenuHovered)
				{
					if (iCloseDownCount3-- <= 0)
					{
						ImGui::OpenPopup("##DummyClose##Storyboard");
						if (ImGui::BeginMenu("##DummyClose##Storyboard"))
						{
							ImGui::EndMenu();
						}
					}
				}
				else
				{
					iCloseDownCount3 = 100;
				}
			}
		}
		else
		{
			if (pref.bAutoOpenMenuItems)
				if (ImGui::IsItemHovered())
				{
					ImGui::OpenPopup("Help##Storyboard");
					iCloseDownCount3 = 100;
				}
		}

		ImVec2 CursorMenuEnd = ImGui::GetCursorPos();
		if (ImGui::IsMouseHoveringRect(ImGui::GetWindowPos()+CursorMenuStart+ImVec2(-4,0), ImGui::GetWindowPos() + CursorMenuEnd+ImVec2(0,24)))
		{
			iCloseDownCount = 100;
			iCloseDownCount2 = 100;
			iCloseDownCount3= 100;
		}
		ImGui::EndMenuBar();
	}
}


void save_storyboard(char *name,bool bSaveAs)
{
	cstr savename;
	if (!name) return;
	if (Storyboard.project_readonly == 1 && !bSaveAs) return;
	savename = name;
	if (bSaveAs)
	{
		//Select name.
		bTriggerSaveAs = true;
		return;
		//cStr tOldDir = GetDir();
		//char * cFileSelected;
		//cstr fulldir = "projectbank\\";
		//cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_DIR, "All\0*.*\0", fulldir.Get(), NULL);
		//SetDir(tOldDir.Get());

		//if (cFileSelected && strlen(cFileSelected) > 0) {
		//	cstr tmp = cFileSelected;
		//	//D:\dev\GameGuru MAX\Max\Files\projectbank\My New Game
		//	//PathExist()
		//	return;
		//}
	}
	if (savename.Len() <= 0)
	{
		//Use save as.
		strcpy(cTriggerMessage, "Missing NAME of Game Project.");
		bTriggerMessage = true;
		return;
	}

	cLastProjectList = ""; //PE: Update project files.

	char project[MAX_PATH];
	strcpy(project, "projectbank\\");
	strcat(project, savename.Get());
	strcat(project, "\\project.dat");
	FILE* projectfile = GG_fopen(project, "wb+");
	if (projectfile) {
		fwrite(&Storyboard, 1, sizeof(Storyboard), projectfile);
		fclose(projectfile);
		strcpy(pref.cLastUsedStoryboardProject, savename.Get());

		#ifdef RPG_GAMES
		bool save_rpg_system(char *name);
		save_rpg_system(savename.Get());
		#endif
	}
	else
	{
		//Failed ?
		return;
	}
	if (1)
	{
		//Add newly saved project to recent list.
		int firstempty = -1;
		int i = 0;
		for (; i < REMEMBERLASTFILES; i++) {
			if (firstempty == -1 && strlen(pref.last_project_files[i]) <= 0)
				firstempty = i;
			if (strlen(pref.last_project_files[i]) > 0 && stricmp(savename.Get(), pref.last_project_files[i]) == 0) { //already there
				break;
			}
		}
		if (i >= REMEMBERLASTFILES) {
			if (firstempty == -1) {
				//No empty slots , rotate.
				for (int ii = 0; ii < REMEMBERLASTFILES - 1; ii++) {
					strcpy(pref.last_project_files[ii], pref.last_project_files[ii + 1]);
				}
				strcpy(pref.last_project_files[REMEMBERLASTFILES - 1], savename.Get());
			}
			else
				strcpy(pref.last_project_files[firstempty], savename.Get());
		}
	}

	Storyboard.iChanged = false;
}

void load_storyboard(char *name)
{
	if (!name) return;
	if (strlen(name) <= 0) return;

	//PE: We have a problem. if project folder renamed it dont match Storyboard.gamename. update if reasdonly project.
	//Zombie Cellar Demo
	//Escape from the Zombie Cellar

	char project[MAX_PATH];
	strcpy(project, "projectbank\\");
	strcat(project, name);
	strcat(project, "\\project.dat");

	FILE* projectfile = GG_fopen(project, "rb");
	if (projectfile)
	{
		size_t size = fread(&checkproject, 1, sizeof(checkproject), projectfile);
		//Valid pref:
		
		char sig[12] = "Storyboard\0";
		if (checkproject.sig[0] == 'S' && checkproject.sig[8] == 'r')
		{
			//Valid Sig - Cleanup old project.
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used)
				{
					if (ImageExist(Storyboard.Nodes[i].thumb_id)) DeleteImage(Storyboard.Nodes[i].thumb_id);
				}
			}

			//PE: set defaults.
			iLoadGameNodeID = 3;
			iTitleScreenNodeID = 1;
			iGamePausedNodeID = 8;
			Storyboard = checkproject;
			bStoryboardFirstRunSetInitPos = false; //Load new thumbs, and reposition new nodes.
			Storyboard.iChanged = false;
			strcpy(pref.cLastUsedStoryboardProject, name);
			fclose(projectfile);

			//PE: Check if this is a readonly project.
			char fullPath[MAX_PATH];
			strcpy(fullPath, project);
			GG_GetRealPath(fullPath, 0);
			extern char szRootDir[MAX_PATH];
			int rootLen = strlen(szRootDir);
			if (strnicmp(fullPath, szRootDir, rootLen) == 0)
			{
				//PE: Read only folder.
				Storyboard.project_readonly = 1;
				//PE: If game has been renamed.
				if (strcmp(name, Storyboard.gamename) != 0)
				{
					strcpy(Storyboard.gamename, name);
				}
			}
			else
			{
				//Read from write folder.
				Storyboard.project_readonly = 0;
			}

			#ifdef RPG_GAMES
			init_rpg_system();
			load_rpg_system(name);
			#endif
		}
		else
		{
			strcpy(cTriggerMessage, "Could not load project, bad signature.");
			bTriggerMessage = true;
			fclose(projectfile);
		}
	}
	else
	{
		strcpy(cTriggerMessage, "Could not find project.");
		bTriggerMessage = true;
	}
}

bool load_checkproject_storyboard(char *name)
{
	if (!name) return false;
	if (strlen(name) <= 0) return false;

	char project[MAX_PATH];
	strcpy(project, "projectbank\\");
	strcat(project, name);
	strcat(project, "\\project.dat");

	FILE* projectfile = GG_fopen(project, "rb");
	if (projectfile)
	{
		size_t size = fread(&checkproject, 1, sizeof(checkproject), projectfile);
		//Valid pref:
		fclose(projectfile);
		char sig[12] = "Storyboard\0";
		if (checkproject.sig[0] == 'S' && checkproject.sig[8] == 'r')
		{
			return true;
		}
	}
	return false;
}


//SmallStoryboardStruct smallcheckproject; //PE: Switched to full as we have game settings now.

void GetProjectList(char *path, bool bGetThumbs)
{
	if (!path) return;
	int uniqueId = 16000;

	if (cLastProjectList != path)
	{
		projectbank_list.clear();
		//projectbank_list_exist.clear();
		projectbank_imageid.clear();
		projectbank_image.clear();

		cLastProjectList = path;
		LPSTR pOldDir = GetDir();

		char destination[MAX_PATH];
		strcpy(destination, path);
		GG_GetRealPath(destination, 1); //We need to path to the write folder.

		SetDir(destination);
		ChecklistForFiles();
		SetDir(pOldDir);
		for (int c = 1; c <= ChecklistQuantity(); c++)
		{
			if (ChecklistValueA(c) != 0)
			{
				// only folders
				cstr folder = ChecklistString(c);
				if (folder != "." && folder != "..")
				{
					bool bIgnore = true;
					char project[MAX_PATH];
					strcpy(project, destination);
					strcat(project, folder.Get());
					strcat(project, "\\project.dat");

					//PE: Must have a project.
					if ( GG_FileExists(project) )
					{
						bIgnore = false;
					}
					if (!bIgnore)
					{
						projectbank_list.push_back(folder.Get());

						// quick check to see if the folder exists
						//bool bProjectExist = false;
						//char pProjFolderFile[MAX_PATH];
						//strcpy(pProjFolderFile, "projectbank\\");
						//strcat(pProjFolderFile, folder.Get());
						//strcat(pProjFolderFile, "\\project.dat");
						//GG_GetRealPath(pProjFolderFile, false);
						//if (FileExist(pProjFolderFile) == 1)
						//	bProjectExist = true;
						//else
						//	bProjectExist = false;
						//projectbank_list_exist.push_back(bProjectExist);

						if (!bGetThumbs)
						{
							projectbank_image.push_back(""); //Just use CLICK HERE.
						}
						projectbank_imageid.push_back(0);
					}
				}
			}
		}
		SetDir(pOldDir);

		//Find project thumbs.
		if (bGetThumbs)
		{
			for (int i = 0; i < projectbank_list.size(); i++)
			{
				if (!pestrcasestr((char *)projectbank_list[i].c_str(), "_backup_"))
				{
					char project[MAX_PATH];
					strcpy(project, "projectbank\\");
					strcat(project, projectbank_list[i].c_str());
					strcat(project, "\\project.dat");

					FILE* projectfile = GG_fopen(project, "rb");
					if (projectfile)
					{
						//size_t size = fread(&smallcheckproject, 1, sizeof(smallcheckproject), projectfile);
						//PE: Need full load now, as we can have Game Settings.
						size_t size = fread(&checkproject, 1, sizeof(checkproject), projectfile);

						char sig[12] = "Storyboard\0";
						if (checkproject.sig[0] == 'S' && checkproject.sig[8] == 'r')
						{
							cstr bestfound = "";
							//Valid Sig - Cleanup old project.
							if (strlen(checkproject.game_thumb) > 0 && FileExist(checkproject.game_thumb) )
							{
								bestfound = checkproject.game_thumb;
							}
							else
							{
								for (int i = 0; i < STORYBOARD_MAXNODES; i++) //SMALL_STORYBOARD_MAXNODES
								{
									if (checkproject.Nodes[i].used)
									{
										if (checkproject.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
										{
											//Splash if no level found.
											if (bestfound == "")
											{
												if (!pestrcasestr(checkproject.Nodes[i].thumb, "editors\\uiv3\\"))
												{
													//custom use.
													bestfound = checkproject.Nodes[i].thumb;
												}
											}
										}
										if (checkproject.Nodes[i].type == STORYBOARD_TYPE_SCREEN)
										{
											if (pestrcasestr(checkproject.Nodes[i].title, "title screen"))
											{
												//Splash if no level found.
												if (!pestrcasestr(checkproject.Nodes[i].thumb, "editors\\templates\\"))
												{
													//custom use.
													bestfound = checkproject.Nodes[i].thumb;
												}
											}
										}
										//PE: Try finding level that loading.lua is pointing to ?
										if (checkproject.Nodes[i].type == STORYBOARD_TYPE_LEVEL)
										{
											if (strlen(checkproject.Nodes[i].level_name) > 0)
											{
												CreateBackBufferCacheName(checkproject.Nodes[i].level_name, 512, 288);
												if (CreateProjectCacheName(checkproject.gamename, BackBufferCacheName.Get()) &&
													FileExist(ProjectCacheName.Get()))
												{
													bestfound = ProjectCacheName.Get();
													break;
												}
												else if (FileExist(BackBufferCacheName.Get()))
												{
													bestfound = BackBufferCacheName.Get();
													break;
												}
											}
										}

									}
								}
							}
							projectbank_image.push_back(bestfound.Get());
						}
						else
						{
							projectbank_image.push_back(""); //Just use CLICK HERE.
						}
						fclose(projectfile);
					}
					else
					{
						//PE: Was missing if not found. https://github.com/TheGameCreators/GameGuruRepo/issues/1722
						projectbank_image.push_back(""); //Just use CLICK HERE.
					}
				}
				else
				{
					projectbank_image.push_back(""); //Backup just use CLICK HERE.
				}
			}
		}
	}
}


bool bWidgetMouseDraggin = false;
void storyboard_control_widget(int nodeid, int index, ImVec2 pos, ImVec2 size, ImRect rMonitorArea, ImVec2 vMonitorStart, ImVec2 vScale)
{

	ImGuiWindow* window = ImGui::GetCurrentWindow();
	ImVec2 ocpos = ImGui::GetCursorPos();
	ImGui::SetCursorPos(vMonitorStart);
	ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
	ImVec2 padding = { 2.0, 2.0 };
	window->DrawList->AddRect(rMonitorArea.Min + pos - padding, rMonitorArea.Min + pos + size + padding, ImGui::GetColorU32(tool_selected_col));

	ImVec2 but_size = ImVec2(12.0, 12.0);
	ImVec2 fp = ImGui::GetStyle().FramePadding;
	float fpb = ImGui::GetStyle().FrameBorderSize;
	ImVec4 *style_colors = ImGui::GetStyle().Colors;
	ImVec4 oldbutA = style_colors[ImGuiCol_ButtonActive];
	ImVec4 oldbutH = style_colors[ImGuiCol_ButtonHovered];
	ImVec4 oldbutN = style_colors[ImGuiCol_Button];
	style_colors[ImGuiCol_Button] = tool_selected_col;
	style_colors[ImGuiCol_ButtonHovered] = tool_selected_col;
	style_colors[ImGuiCol_ButtonHovered].w *= 0.80f;
	style_colors[ImGuiCol_ButtonActive] = tool_selected_col;

	ImGui::GetStyle().FramePadding = ImVec2(0, 0);
	ImGui::GetStyle().FrameBorderSize = 0;

	ImGui::SetCursorPos(vMonitorStart + pos - (but_size*0.5) );
	ImGui::SetItemAllowOverlap();
	bool bSizeHover = false;
	bool bSizeHover2 = false;
	if (ImGui::ButtonEx("##TopLeftCorner", but_size , 0))
	{
		//Resize, todo if time.
	}
	if (ImGui::IsItemHovered()) bSizeHover2 = true;
	ImGui::SetCursorPos(vMonitorStart + pos + ImVec2(size.x,0) - (but_size*0.5));
	ImGui::SetItemAllowOverlap();
	if (ImGui::ButtonEx("##TopRightCorner", but_size, 0))
	{
		//Resize, todo if time.
	}
	if (ImGui::IsItemHovered()) bSizeHover = true;
	ImGui::SetCursorPos(vMonitorStart + pos + ImVec2(0, size.y) - (but_size*0.5));
	ImGui::SetItemAllowOverlap();
	if (ImGui::ButtonEx("##BotLeftCorner", but_size, 0))
	{
		//Resize, todo if time.
	}
	if (ImGui::IsItemHovered()) bSizeHover2 = true;
	ImGui::SetCursorPos(vMonitorStart + pos + size - (but_size*0.5));
	ImGui::SetItemAllowOverlap();
	if (ImGui::ButtonEx("##BotRightCorner", but_size, 0))
	{
		//Resize, todo if time.
	}
	if (ImGui::IsItemHovered()) bSizeHover = true;

	ImGui::GetStyle().FramePadding = fp;
	ImGui::GetStyle().FrameBorderSize = fpb;
	style_colors[ImGuiCol_Button] = oldbutN;
	style_colors[ImGuiCol_ButtonHovered] = oldbutH;
	style_colors[ImGuiCol_ButtonActive] = oldbutA;

	static ImVec2 vMovePos;
	static int iMoveType = 0;

	static bool bWaitForRelease = false;
	if (bWaitForRelease)
	{
		if (!ImGui::IsMouseDown(0))
		{
			bWaitForRelease = false;
		}
	}
	else if (ImGui::IsMouseDown(0))
	{
		iMoveType = 0;
		if (bSizeHover)
			iMoveType = 1;
		if (bSizeHover2)
			iMoveType = 2;
		bWaitForRelease = true;
	}
	
	if (!bExternal_Entities_Window && !bVideoPlayerMaximized && !bPreferences_Window && !bLastSmallVideoPlayerMaximized)
	{
		static int bShowCenterLines = 0;
		static bool bNoSnapping = false;
		float fAdjustX = 0.0, fAdjustY = 0.0;
		ImVec2 fMouseToPercent = ImVec2(100.0 / (1920.0*vScale.x), 100.0 / (1080.0*vScale.y));
		int grid = Storyboard.Nodes[nodeid].screen_grid_size;
		if (ImGui::IsKeyPressed(39,true))
		{
			if (grid > 0)
				fAdjustX = grid;
			else
				fAdjustX = 1.0 * fMouseToPercent.x;
		}
		if (ImGui::IsKeyPressed(37,true))
		{
			if (grid > 0)
				fAdjustX = -grid;
			else
				fAdjustX = -1.0 * fMouseToPercent.x;
		}
		if (ImGui::IsKeyPressed(38, true))
		{
			if (grid > 0)
				fAdjustY = -grid;
			else
				fAdjustY = -1.0 * fMouseToPercent.y;
		}
		if (ImGui::IsKeyPressed(40, true))
		{
			if (grid > 0)
				fAdjustY = grid;
			else
				fAdjustY = 1.0 * fMouseToPercent.y;
		}

		if (fAdjustX != 0.0 || fAdjustY != 0.0)
		{
			if (fAdjustX != 0.0) Storyboard.Nodes[nodeid].widget_pos[index].x += fAdjustX;
			if (fAdjustY != 0.0) Storyboard.Nodes[nodeid].widget_pos[index].y += fAdjustY;
			if (grid > 0)
			{
				if (fAdjustX != 0.0) Storyboard.Nodes[nodeid].widget_pos[index].x -= fmod(Storyboard.Nodes[nodeid].widget_pos[index].x, grid);
				if (fAdjustY != 0.0) Storyboard.Nodes[nodeid].widget_pos[index].y -= fmod(Storyboard.Nodes[nodeid].widget_pos[index].y, grid);
			}
			bShowCenterLines = 30; //PE: This adds snapping so we cant move after this.
			bNoSnapping = true;
		}

		ImVec2 vLargerGrabArea = ImVec2(10.0, 10.0);
		if (ImGui::IsMouseHoveringRect(rMonitorArea.Min + pos - vLargerGrabArea, rMonitorArea.Min + pos + size + vLargerGrabArea) || bWidgetMouseDraggin)
		{
			//Drag if mouse down.
			if (ImGui::IsMouseDown(0) && ImGui::IsMouseDragging(0))
			{
				if (!bWidgetMouseDraggin)
				{
					vMovePos = Storyboard.Nodes[nodeid].widget_pos[index];
				}
				if (iMoveType == 1)
				{
					float fAdjust = ImGui::GetIO().MouseDelta.x / 350.0;
					fAdjust += ImGui::GetIO().MouseDelta.y / 350.0;
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_BUTTON || Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_PROGRESS || Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_SLIDER)
					{
						Storyboard.Nodes[nodeid].widget_size[index].x += fAdjust;
						if (Storyboard.Nodes[nodeid].widget_size[index].x > 4.0) Storyboard.Nodes[nodeid].widget_size[index].x = 4.0;
						Storyboard.Nodes[nodeid].widget_size[index].y = Storyboard.Nodes[nodeid].widget_size[index].x;
					}
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXT || Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXTAREA)
					{
						Storyboard.Nodes[nodeid].widget_font_size[index] += fAdjust;
						if (Storyboard.Nodes[nodeid].widget_font_size[index] > 3.0) Storyboard.Nodes[nodeid].widget_font_size[index] = 3.0;
						if (Storyboard.Nodes[nodeid].widget_font_size[index] < 0.05) Storyboard.Nodes[nodeid].widget_font_size[index] = 0.05;
					}
				}
				else if (iMoveType == 2)
				{
					float fAdjust = ImGui::GetIO().MouseDelta.x / 350.0;
					fAdjust += ImGui::GetIO().MouseDelta.y / 350.0;
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_BUTTON || Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_PROGRESS || Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_SLIDER)
					{
						Storyboard.Nodes[nodeid].widget_size[index].x -= fAdjust;
						if (Storyboard.Nodes[nodeid].widget_size[index].x > 4.0) Storyboard.Nodes[nodeid].widget_size[index].x = 4.0;
						Storyboard.Nodes[nodeid].widget_size[index].y = Storyboard.Nodes[nodeid].widget_size[index].x;
					}
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXT || Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXTAREA)
					{
						Storyboard.Nodes[nodeid].widget_font_size[index] -= fAdjust;
						if (Storyboard.Nodes[nodeid].widget_font_size[index] > 3.0) Storyboard.Nodes[nodeid].widget_font_size[index] = 3.0;
						if (Storyboard.Nodes[nodeid].widget_font_size[index] < 0.05) Storyboard.Nodes[nodeid].widget_font_size[index] = 0.05;
					}
				}
				else
				{
					vMovePos.x += ImGui::GetIO().MouseDelta.x * fMouseToPercent.x;
					vMovePos.y += ImGui::GetIO().MouseDelta.y * fMouseToPercent.y;

					if (Storyboard.Nodes[nodeid].screen_grid_size > 0)
					{
						int grid = Storyboard.Nodes[nodeid].screen_grid_size;
						float adjustx = fmod(vMovePos.x, grid);
						float adjusty = fmod(vMovePos.y, grid);
						Storyboard.Nodes[nodeid].widget_pos[index].x = vMovePos.x - adjustx;
						Storyboard.Nodes[nodeid].widget_pos[index].y = vMovePos.y - adjusty;
					}
					else
					{
						Storyboard.Nodes[nodeid].widget_pos[index] = vMovePos;
					}
					bShowCenterLines = 1;
					bNoSnapping = false;
				}
				bWidgetMouseDraggin = true;

			}
			if (!ImGui::IsMouseDown(0))
			{
				bWidgetMouseDraggin = false;
			}
		}

		if (bShowCenterLines > 0)
		{
			bShowCenterLines--;
			float minsnapping = 49.8;
			float maxsnapping = 50.2;
			if (bNoSnapping)
			{
				//PE: One pixel.
				minsnapping = 50.0 - ((1.0 * fMouseToPercent.x) * 0.5);
				maxsnapping = 50.0 + ((1.0 * fMouseToPercent.x) * 0.5);
			}
			//Show center lines.
			if (Storyboard.Nodes[nodeid].widget_pos[index].x >= minsnapping && Storyboard.Nodes[nodeid].widget_pos[index].x <= maxsnapping)
			{
				//if(!bNoSnapping) 
				Storyboard.Nodes[nodeid].widget_pos[index].x = 50.0; //Align to center
				//Draw center line.
				float centerx = (rMonitorArea.Max.x - rMonitorArea.Min.x) * 0.5;
				centerx += rMonitorArea.Min.x;
				window->DrawList->AddLine(ImVec2(centerx, rMonitorArea.Min.y), ImVec2(centerx, rMonitorArea.Max.y), ImGui::GetColorU32(tool_selected_col));
			}

			if (bNoSnapping)
			{
				//PE: One pixel.
				minsnapping = 50.0 - ((1.0 * fMouseToPercent.y) * 0.5);
				maxsnapping = 50.0 + ((1.0 * fMouseToPercent.y) * 0.5);
			}

			float fPercent = (rMonitorArea.Max.y - rMonitorArea.Min.y) / 100.0;
			float fSizePivotCenterY = (size.y*0.5) / fPercent;
			//Show center Y line
			if (Storyboard.Nodes[nodeid].widget_pos[index].y + fSizePivotCenterY >= minsnapping && Storyboard.Nodes[nodeid].widget_pos[index].y + fSizePivotCenterY <= maxsnapping)
			{
				Storyboard.Nodes[nodeid].widget_pos[index].y = 50.0 - fSizePivotCenterY; //Align to center Y
				//Draw center line.
				float centery = (rMonitorArea.Max.y - rMonitorArea.Min.y) * 0.5;
				centery += rMonitorArea.Min.y;
				window->DrawList->AddLine(ImVec2(rMonitorArea.Min.x, centery), ImVec2(rMonitorArea.Max.x, centery), ImGui::GetColorU32(tool_selected_col));
			}
		}

	}

	ImGui::SetCursorPos(ocpos);
}

extern ImFont* customfont;
extern ImFont* customfontlarge;
float WidgetSelectUsedFont(int nodeid, int index)
{
	
	for (int i = 0; i < StoryboardFonts.size(); i++)
	{
		
		bool bIsSelected = false;
		//if (strcmp(StoryboardFonts[i].second.c_str(), Storyboard.Nodes[nodeid].widget_font[index]) == NULL)
		// ZJ: In standalone, the filenames are stored lowercase, so only compare lowercase strings to ensure the check works in all cases.
		if (strcmp(cstr((char*)StoryboardFonts[i].second.c_str()).Lower().Get(), cstr(Storyboard.Nodes[nodeid].widget_font[index]).Lower().Get()) == NULL)
		{
			ImGui::PushFont(StoryboardFonts[i].first);  //storyboard special fonts.
			return 2.0; //2.0=60,2.5=48
		}
	}
	//ImGui::PushFont(customfont);  //defaultfont
	//return 4.0;
	ImGui::PushFont(customfontlarge);  //defaultfont
	return 2.0;
}

std::vector<int> Storyboard_ActiveWidgets;

float LuaMousePosPercentX, LuaMousePosX, LuaMousePosPercentY, LuaMousePosY;
int LuaMouseClick = 0;
static char LoadGameTitle[9][256];
char cCopyToAllScreens[MAX_PATH];


int screen_editor(int nodeid, bool standalone, char *screen)
{
	static int iLastNode = -1;
	static int iUpdateBackDropNode = -1;
	static int iUpdateWidgetThumbNode = -1;
	static int iUpdateWidgetThumbButton = -1;
	static int iCurrentSelectedWidget = -1;
	static bool bPreviewScreen = false;
	static bool bLastStandalone = false;
	static bool bDisplayGrid = false;
	extern bool g_bNoGGUntilGameGuruMainCalled;
	extern int iSpecialLuaReturn;
	iSpecialLuaReturn = -1;
	if (!g_bNoGGUntilGameGuruMainCalled)
		return -1;
	{
		ImGuiContext& gi = *GImGui;
		if (!gi.Font->IsLoaded())
			return -1;
	}


	int iRet = -1;

	ImGuiWindow* window = NULL; //ImGui::GetCurrentWindow();
	if (standalone)
	{
		bJustRederedScreenEditor = true;
		// new frame if about to use imgui to render this sprite draw list
		if ((bImGuiInTestGame) && !bRenderTabTab && !bImGuiFrameState)
		{
			//We need a new frame.
			ImGui_NewFrame();
			ImGui_ImplWin32_NewFrame();
			ImGui::NewFrame();
			bRenderTabTab = true;
			bBlockImGuiUntilNewFrame = false;
			extern bool bSpriteWinVisible;
			bSpriteWinVisible = false;
			bImGuiRenderWithNoCustomTextures = false;
		}
		if (bImGuiInTestGame)
		{
			//From lua, we need to update imgui mousepos ...
			int mclick = 0;
			ImGuiIO& io = ImGui::GetIO();
			io.MouseDown[0] = 0; //PE: Mouse (release) is also lost inside blocking dialogs. Reset!
			io.MouseDown[1] = 0;
			io.MouseDown[2] = 0;
			io.MouseDown[3] = 0;
			if (g.luaactivatemouse > 0)
			{
				//PE: Use fFinalPercX,Y so VR is also supported.
				float mouseposx = LuaMousePosPercentX * ( (float) GetDisplayWidth() / 100.0f );
				float mouseposy = LuaMousePosPercentY * ( (float) GetDisplayHeight() / 100.0f);

				mclick = LuaMouseClick;
				io.MousePos.x = mouseposx; //LuaMousePosX; //MouseX();
				io.MousePos.y = mouseposy; //LuaMousePosY; //MouseY();
			}
			else
			{
				mclick = MouseClick();
			}
			if (mclick == 1) io.MouseDown[0] = 1;
			if (mclick == 2) io.MouseDown[1] = 1;
			if (mclick == 4) io.MouseDown[2] = 1;
		}
		//ImGuiContext& g = *GImGui;
		//if (g.FrameCount <= 0)
		//{
		//	return -1;
		//}
		//ImGuiViewport* viewport = ImGui::GetMainViewport();
		//ImGui::SetNextWindowPos(ImVec2(-100.0, 1) + ImGui::GetMainViewport()->Pos, ImGuiCond_Always);
		//ImGui::SetNextWindowSize(ImVec2(0.1, 0.1), ImGuiCond_Always);
		//ImGui::SetNextWindowBgAlpha(0.0f);
		//ImGui::SetNextWindowViewport(viewport->ID);
		//ImGui::Begin("GGClassicSprite", NULL, ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav);
		//window = ImGui::GetCurrentWindow();
		//ImVec2 renderTargetSize = ImGui::GetContentRegionAvail();
		//ImVec2 renderTargetPos = ImGui::GetWindowPos();
		//ImGui::End();

	}

	if (standalone && screen != NULL)
	{
		//Find node to display in standalone.
		nodeid = FindLuaScreenNode(screen);
	}
	
	if (standalone) bPreviewScreen = true;

	if (nodeid >= 0 && ( iLastNode != nodeid || bLastStandalone != standalone ) )
	{
		//Load in lua ...
		//editors\\templates\\lua\\loading.lua
		//PE: Get loadgame data.
		//savegames\\gameslot1.dat
		bool bLoadSlots = false;
		if (stricmp(Storyboard.Nodes[nodeid].lua_name, "loadgame.lua") == 0 || stricmp(Storyboard.Nodes[nodeid].lua_name, "savegame.lua") == 0)
		{
			bLoadSlots = true;
		}

		for (int i = 1; i <= 8;i++)
		{
			char slotname[256];
			sprintf(LoadGameTitle[i], "%d: EMPTY PROGRESS SLOT", i);
			if (standalone)
				strcpy(LoadGameTitle[i], "EMPTY PROGRESS SLOT");

			sprintf(slotname, "savegames\\gameslot%d.dat", i);
			FILE* fFile = GG_fopen(slotname, "r");
			if (fFile)
			{
				char ctmp[256];
				bool bStart = false;
				fgets(ctmp, 256 - 1, fFile);
				fgets(ctmp, 256 - 1, fFile);
				fgets(ctmp, 256 - 1, fFile);
				if (strlen(ctmp) > 0 && ctmp[strlen(ctmp) - 1] == '\n')
					ctmp[strlen(ctmp) - 1] = 0;
				if (strlen(ctmp) > 0)
				{
					strcpy(LoadGameTitle[i], ctmp);
				}
				fclose(fFile);
			}
		}

		if (standalone)
		{
			int iFreeSoundID = g.temppreviewsoundoffset + 2;
			bool bKeepPlaying = false;
			if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
			{
				if (iLastNode >= 0 && strlen(Storyboard.Nodes[iLastNode].screen_music) <= 0)
				{
					//Last node did not have any music, if still playing keep playing.
					bKeepPlaying = true;
				}
			}
			if (!bKeepPlaying)
			{
				if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0)
				{
					// play music
					if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
					if (FileExist(Storyboard.Nodes[nodeid].screen_music) == 1)
					{
						LoadSound(Storyboard.Nodes[nodeid].screen_music, iFreeSoundID, 0, 1);
						if (SoundExist(iFreeSoundID) == 1)
							PlaySound(iFreeSoundID);
					}
				}
			}
		}
		else
		{
			bPreviewScreen = false;
		}
		Storyboard_ActiveWidgets.clear();

		for (int i = 0; i < STORYBOARD_MAXWIDGETS; i++)
		{
			if (Storyboard.Nodes[nodeid].widget_used[i] == 1)
			{
				//Load in any images.
				image_setlegacyimageloading(true);
				if (strlen(Storyboard.Nodes[nodeid].widget_normal_thumb[i]) > 0)
				{
					LoadImage(Storyboard.Nodes[nodeid].widget_normal_thumb[i], Storyboard.Nodes[nodeid].widget_normal_thumb_id[i]);
				}
				if (strlen(Storyboard.Nodes[nodeid].widget_highlight_thumb[i]) > 0)
				{
					LoadImage(Storyboard.Nodes[nodeid].widget_highlight_thumb[i], Storyboard.Nodes[nodeid].widget_highlight_thumb_id[i]);
				}
				if (strlen(Storyboard.Nodes[nodeid].widget_selected_thumb[i]) > 0)
				{
					LoadImage(Storyboard.Nodes[nodeid].widget_selected_thumb[i], Storyboard.Nodes[nodeid].widget_selected_thumb_id[i]);
				}
				image_setlegacyimageloading(false);

				Storyboard_ActiveWidgets.push_back(i);
			}
		}

		iUpdateBackDropNode = nodeid;

		iCurrentSelectedWidget = -1;

		/*
		strcpy(Storyboard.Nodes[nodeid].widget_label[button], "QUIT GAME");
		Storyboard.Nodes[nodeid].widget_used[button] = 1;
		Storyboard.Nodes[nodeid].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
		Storyboard.Nodes[nodeid].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
		Storyboard.Nodes[nodeid].widget_pos[button] = ImVec2(50.0, 20.0 + 30.0); //Pos in percent. using pivot center on X only.
		Storyboard.Nodes[nodeid].widget_action[button] = STORYBOARD_ACTIONS_EXITGAME;
		Storyboard.Nodes[nodeid].widget_layer[button] = 0;
		Storyboard.Nodes[nodeid].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
		strcpy(Storyboard.Nodes[nodeid].widget_font[button], "Default Font"); // ?
		strcpy(Storyboard.Nodes[nodeid].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
		strcpy(Storyboard.Nodes[nodeid].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
		strcpy(Storyboard.Nodes[nodeid].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
		*/

		iLastNode = nodeid;
		bLastStandalone = standalone;
	}
	if (iUpdateWidgetThumbNode >= 0)
	{
		image_setlegacyimageloading(true);
		if (iUpdateWidgetThumbButton >= 0)
		{
			if (strlen(Storyboard.Nodes[nodeid].widget_normal_thumb[iUpdateWidgetThumbButton]) > 0)
			{
				LoadImage(Storyboard.Nodes[nodeid].widget_normal_thumb[iUpdateWidgetThumbButton], Storyboard.Nodes[nodeid].widget_normal_thumb_id[iUpdateWidgetThumbButton]);
			}
			if (strlen(Storyboard.Nodes[nodeid].widget_highlight_thumb[iUpdateWidgetThumbButton]) > 0)
			{
				LoadImage(Storyboard.Nodes[nodeid].widget_highlight_thumb[iUpdateWidgetThumbButton], Storyboard.Nodes[nodeid].widget_highlight_thumb_id[iUpdateWidgetThumbButton]);
			}
			if (strlen(Storyboard.Nodes[nodeid].widget_selected_thumb[iUpdateWidgetThumbButton]) > 0)
			{
				LoadImage(Storyboard.Nodes[nodeid].widget_selected_thumb[iUpdateWidgetThumbButton], Storyboard.Nodes[nodeid].widget_selected_thumb_id[iUpdateWidgetThumbButton]);
			}
		}
		image_setlegacyimageloading(false);
		iUpdateWidgetThumbNode = -1;
	}
	if (iUpdateBackDropNode >= 0)
	{
		if (iUpdateBackDropNode == 99999) //All
		{
			for (int i = 0; i < STORYBOARD_MAXWIDGETS; i++)
			{
				iUpdateBackDropNode = i;
				if (Storyboard.Nodes[iUpdateBackDropNode].type == STORYBOARD_TYPE_SCREEN)
				{
					//PE: Not transparent screens.
					if (!Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop_transparent)
					{
						if (ImageExist(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop_id)) DeleteImage(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop_id);

						//PE: Also need a thumb ?
						strcpy(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop, cCopyToAllScreens);
						
						if (strlen(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop) > 0)
						{
							//Backdrop.
							image_setlegacyimageloading(true);
							LoadImage(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop, Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop_id);
							image_setlegacyimageloading(false);
						}
					}
				}
			}
		}
		else
		{
			if (ImageExist(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop_id)) DeleteImage(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop_id);
			if (strlen(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop) > 0)
			{
				//Backdrop.
				image_setlegacyimageloading(true);
				LoadImage(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop, Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop_id);
				image_setlegacyimageloading(false);
			}
		}
		iUpdateBackDropNode = -1;
	}

	static int iQuitWindowLoop = 0;
	if ( ( bScreen_Editor_Window || standalone ) && nodeid >= 0)
	{

		if (standalone)
		{
			ImGuiViewport* viewport = ImGui::GetMainViewport();

			ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
			ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;
			ImGui::SetNextWindowPos(viewPortPos, ImGuiCond_Always);
			ImGui::SetNextWindowSize(viewPortSize, ImGuiCond_Always);
			ImGui::SetNextWindowViewport(viewport->ID);

			ImVec4 style_winback = ImGui::GetStyle().Colors[ImGuiCol_WindowBg];
			style_winback.w = 1.0f;
			ImGui::PushStyleColor(ImGuiCol_WindowBg, style_winback);

			
			ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));
			ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.0f, 0.0f));
			ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
			ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);


			int flags = ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove;
			bool bopen = ImGui::Begin("##StoryboardStandaloneWindow", &bStoryboardWindow, flags); // ImGuiWindowFlags_NoScrollbar

		}

		int preview_size_x = ImGui::GetMainViewport()->Size.x - 300.0;
		int preview_size_y = ImGui::GetMainViewport()->Size.y - 30.0;
		if (bPreviewScreen)
		{
			preview_size_x = ImGui::GetMainViewport()->Size.x;
			preview_size_y = ImGui::GetMainViewport()->Size.y;
		}
		float fStartWinPosY = ImGui::GetCursorPosY();

		/* No menubar we need all available Y space, for larger monitor area.
		if (ImGui::BeginMenuBar())
		{
			if (ImGui::BeginMenu("File##Storyboard"))
			{
				if (ImGui::MenuItem("Exit to Storyboard"))
				{
					bScreen_Editor_Window = false;
				}
				ImGui::EndMenu();
			}
			ImGui::EndMenuBar();
		}
		*/

		
		if (!bPreviewScreen)
		{
			ImGui::Columns(2, "StoryboardEditorWindowColumns", false);  //false no border
			ImGui::SetColumnOffset(0, 0.0f);
			ImGui::SetColumnOffset(1, preview_size_x);
		}

		//if (!standalone) window = ImGui::GetCurrentWindow();
		window = ImGui::GetCurrentWindow();

		ImVec2 vCurPos = ImGui::GetCursorPos();
		ImVec2 vIconSize = { (float)ImGui::GetFontSize()*3.5f, (float)ImGui::GetFontSize()*3.5f };
		if (!standalone)
		{

			ImGui::SetCursorPos(ImVec2(3.0f, fStartWinPosY + 1.0f));
			ImGui::SetItemAllowOverlap();
			if (ImGui::ImgBtn(TOOL_GOBACK, vIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
			{
				//Everything already saved.
				if (bPreviewScreen)
				{
					//Stop music ...
					int iFreeSoundID = g.temppreviewsoundoffset + 2;
					if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
					{
						// stop currently playing preview
						StopSound(iFreeSoundID);
					}
					bPreviewScreen = false;
				}
				else
				{
					int iFreeSoundID = g.temppreviewsoundoffset + 2;
					if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
					{
						// stop currently playing preview
						StopSound(iFreeSoundID);
					}

					iQuitWindowLoop = 4;
				}
			}
			if (!bPreviewScreen)
			{
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Exit to Storyboard");
			}
			else
			{
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Exit Preview");
			}
		}
		

		//Toolbar right aligned.
		cstr UniqueBackdropSelect = "##StoryboardSelectBackdrop";
		cstr UniqueMusicSelect = "##StoryboardSelectMusic";
		if (iSelectedLibraryStingReturnID == window->GetID(UniqueBackdropSelect.Get()))
		{
			strcpy(Storyboard.Nodes[nodeid].screen_backdrop, sSelectedLibrarySting.Get());
			iUpdateBackDropNode = nodeid; //Update thumb.
			sSelectedLibrarySting = "";
			iSelectedLibraryStingReturnID = -1; //disable.
		}
		if (iSelectedLibraryStingReturnID == window->GetID(UniqueMusicSelect.Get()))
		{
			strcpy(Storyboard.Nodes[nodeid].screen_music, sSelectedLibrarySting.Get());
			sSelectedLibrarySting = "";
			iSelectedLibraryStingReturnID = -1; //disable.
		}

		if (!bPreviewScreen)
		{
			if (0) //PE: Toolbar removed in design.
			{
				//STORYBOARD_PREVIEW
				ImGui::SetCursorPos(ImVec2(preview_size_x - ((vIconSize.x + 15.0) * 1.0) - 3.0f, fStartWinPosY + 1.0f));
				ImGui::SetItemAllowOverlap();
				if (ImGui::ImgBtn(STORYBOARD_PREVIEW, vIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
				{
					bPreviewScreen = true;
					int iFreeSoundID = g.temppreviewsoundoffset + 2;
					if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0)
					{
						// play music
						if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
						if (FileExist(Storyboard.Nodes[nodeid].screen_music) == 1)
						{
							LoadSound(Storyboard.Nodes[nodeid].screen_music, iFreeSoundID, 0, 1);
							if (SoundExist(iFreeSoundID) == 1)
								PlaySound(iFreeSoundID);
						}
					}

				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Preview");


				ImGui::SetCursorPos(ImVec2(preview_size_x - ((vIconSize.x + 15.0) * 2.0) - 3.0f, fStartWinPosY + 1.0f));
				ImGui::SetItemAllowOverlap();
				if (ImGui::ImgBtn(STORYBOARD_BACKDROP, vIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
				{
					//Choose backdrop
					bExternal_Entities_Window = true;
					iDisplayLibraryType = 2; //Image
					iLibraryStingReturnToID = window->GetID(UniqueBackdropSelect.Get());
					if (strlen(Storyboard.Nodes[nodeid].screen_backdrop) > 0)
					{
						sMakeDefaultSelecting = Storyboard.Nodes[nodeid].screen_backdrop;
						bSelectLibraryViewAll = true;
					}

				}

				/* removed from design
				static bool bContextActiveB = false;
				if (ImGui::IsItemHovered() || bContextActiveB)
				{
					if(!bContextActiveB) ImGui::SetTooltip("%s", "Choose Backdrop");
					if (ImGui::BeginPopupContextWindow())
					{
						bContextActiveB = true;
						if (ImGui::MenuItem("Remove Backdrop"))
						{
							strcpy(Storyboard.Nodes[nodeid].screen_backdrop, "");
							iUpdateBackDropNode = nodeid; //Update thumb.
						}
						ImGui::EndPopup();
					}
					else
					{
						bContextActiveB = false;
					}
				}
				*/

				ImGui::SetCursorPos(ImVec2(preview_size_x - ((vIconSize.x + 15.0) * 3.0) - 3.0f, fStartWinPosY + 1.0f));
				ImGui::SetItemAllowOverlap();
				if (ImGui::ImgBtn(STORYBOARD_MUSIC, vIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
				{
					//Choose music
					//Choose backdrop
					bExternal_Entities_Window = true;
					iDisplayLibraryType = 1; //Music
					iLibraryStingReturnToID = window->GetID(UniqueMusicSelect.Get());

					if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0)
					{
						sMakeDefaultSelecting = Storyboard.Nodes[nodeid].screen_music;
						bSelectLibraryViewAll = true;
					}
				}

				/* Removed from design
				static bool bContextActiveM = false;
				if (ImGui::IsItemHovered() || bContextActiveM)
				{
					if(!bContextActiveM) ImGui::SetTooltip("%s", "Choose Music");
					if (ImGui::BeginPopupContextWindow())
					{
						bContextActiveM = true;
						if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0)
						{
							if (ImGui::MenuItem("Play Music"))
							{
								int iFreeSoundID = g.temppreviewsoundoffset + 2;
								// play music
								if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
								if (FileExist(Storyboard.Nodes[nodeid].screen_music) == 1)
								{
									LoadSound(Storyboard.Nodes[nodeid].screen_music, iFreeSoundID, 0, 1);
									if (SoundExist(iFreeSoundID) == 1)
										PlaySound(iFreeSoundID);
								}
							}
							if (ImGui::MenuItem("Stop Music"))
							{
								int iFreeSoundID = g.temppreviewsoundoffset + 2;
								if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
								{
									// stop currently playing preview
									StopSound(iFreeSoundID);
								}
							}

						}
						if (ImGui::MenuItem("Remove Music"))
						{
							strcpy(Storyboard.Nodes[nodeid].screen_music, "");
						}
						ImGui::EndPopup();
					}
					else
					{
						bContextActiveM = false;
					}
				}
				*/
			}
			//Display title in center
			ImGui::SetCursorPos(vCurPos);
			ImGui::Text("");
			ImGui::SetWindowFontScale(1.4);
			cstr luatitle = cstr("Editing: ") + cstr(Storyboard.Nodes[nodeid].title);
			ImGui::TextCenter(luatitle.Get()); // lua_name
			ImGui::SetWindowFontScale(1.0);
			ImGui::Text("");
		}

		if ( bPreviewScreen ) ImGui::SetCursorPos(vCurPos+ImVec2(0,13));
		if ( standalone ) ImGui::SetCursorPos(vCurPos);

		ImVec2 vHeaderEnd = ImGui::GetCursorPos();


		//ImGui::Separator(); //Ruin Columns ?
		ImVec2 vMonitorPos = ImVec2(0, -8.0);
		ImVec2 vMonitorBorder = ImVec2(20, 20);
		float fRatio = 1.777777; // Default ratio 1920x1080
		float fRatioInv = 0.5625;
		float fMaxMonitorY = preview_size_y - vHeaderEnd.y; // -ImGui::GetFontSize();
		if (bPreviewScreen) fMaxMonitorY -= 10.0f;
		ImVec2 vMonitorSize;
		float vMonitorCenterX;
		if (standalone)
		{
			vMonitorPos = ImVec2(0, 0);
			fMaxMonitorY = preview_size_y;
			vMonitorSize = ImVec2(preview_size_x , preview_size_y);
			vMonitorSize.y = vMonitorSize.x * fRatioInv;
			if (vMonitorSize.y > fMaxMonitorY )
			{
				vMonitorSize.y = fMaxMonitorY;
				vMonitorSize.x = vMonitorSize.y * fRatio;
			}
			vMonitorCenterX = preview_size_x - vMonitorSize.x;
		}
		else
		{
			vMonitorSize = ImVec2(preview_size_x - 10.0 - vMonitorPos.x - (vMonitorBorder.x*2.0), fMaxMonitorY - vMonitorPos.y - (vMonitorBorder.y*2.0));
			vMonitorSize.y = vMonitorSize.x * fRatioInv;
			if (vMonitorSize.y > fMaxMonitorY - vMonitorPos.x - (vMonitorBorder.y*2.0))
			{
				vMonitorSize.y = fMaxMonitorY - vMonitorPos.y - (vMonitorBorder.y*2.0);
				vMonitorSize.x = (vMonitorSize.y * fRatio);
			}
			vMonitorCenterX = preview_size_x - 10.0 - (vMonitorSize.x + vMonitorPos.x + (vMonitorBorder.x*2.0));
		}
		vMonitorCenterX *= 0.5;
		if (vMonitorCenterX < 0.0) vMonitorCenterX = 0.0f;

		ImVec4 tool_selected_col = ImVec4(0.5, 0.5, 0.5, 0.5); //ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
		ImVec4 monitor_col = ImVec4(0, 0, 0, 1.0); //Black for now.
		ImVec4 monitor_border = ImVec4(0.30, 0.30, 0.30, 0.75); //gray
		ImVec2 padding = { 1.0, 1.0 };
		
		ImVec2 DCCursorPos = window->DC.CursorPos;
		if (!standalone)
		{
			vMonitorPos += vMonitorBorder;
		}
		else
		{
			//DCCursorPos = ImVec2(0, 0);
		}

		const ImRect image_bb((DCCursorPos + ImVec2(vMonitorCenterX,0) + vMonitorPos - padding), DCCursorPos + ImVec2(vMonitorCenterX, 0) + vMonitorPos + padding + vMonitorSize);

		ImRect rMonitorArea;
		rMonitorArea.Min = image_bb.Min + padding;
		rMonitorArea.Max = image_bb.Max - padding;
		if (standalone)
		{
			if (ImageExist(Storyboard.Nodes[nodeid].screen_backdrop_id) && !Storyboard.Nodes[nodeid].screen_backdrop_transparent ) //PE: Support transparent if no backdrop.
			{
				//Standalone Always fill hole screen.
				window->DrawList->AddRectFilled(DCCursorPos + ImVec2(-1, -1), DCCursorPos + ImVec2(preview_size_x, preview_size_y) + ImVec2(1, 1), ImGui::GetColorU32(monitor_col));
				window->DrawList->AddRectFilled(image_bb.Min + padding, image_bb.Max - padding, ImGui::GetColorU32(monitor_col));
			}
		}
		else
		{
			window->DrawList->AddRectFilled(image_bb.Min - vMonitorBorder, image_bb.Max + vMonitorBorder, ImGui::GetColorU32(monitor_border), 12.0, 15);
			window->DrawList->AddRectFilled(image_bb.Min + padding, image_bb.Max - padding, ImGui::GetColorU32(monitor_col));
			window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);

			if ( Storyboard.Nodes[nodeid].screen_backdrop_transparent && !bPreviewScreen) //PE: Support transparent if no backdrop.
			{
				void* lpTexture = GetImagePointer(STORYBOARD_TRANSPARET);
				if (lpTexture)
				{
					//Display transparent backdrop. stretch.
					window->DrawList->AddImage((ImTextureID)lpTexture, image_bb.Min + padding, image_bb.Max - padding, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 0.25)));
				}
			}

		}
		if (ImageExist(Storyboard.Nodes[nodeid].screen_backdrop_id))
		{
			//Draw backdrop.
			void* lpTexture = GetImagePointer(Storyboard.Nodes[nodeid].screen_backdrop_id);
			if (lpTexture)
			{
				//Support center,stretch,zoom
				//Storyboard.Nodes[nodeid].screen_backdrop_placement
				if (Storyboard.Nodes[nodeid].screen_backdrop_placement == 0)
				{
					//Center;

					float img_w = ImageWidth(Storyboard.Nodes[nodeid].screen_backdrop_id);
					float img_h = ImageHeight(Storyboard.Nodes[nodeid].screen_backdrop_id);

					ImVec2 vSize = ImVec2(preview_size_x, preview_size_y);
					if (!standalone) vSize = vMonitorSize;

					if (img_w > vSize.x || img_h > vSize.y) {
						float fRatio = 1.0f / (img_w / img_h);
						img_w = vSize.x;
						img_h = vSize.x * fRatio;
						if (img_h > vSize.y) {
							float fRatio = 1.0f / (img_h / img_w);
							img_h = vSize.y;
							img_w = vSize.y * fRatio;
						}
					}

					ImVec2 img_pos = rMonitorArea.Min;
					if (standalone) img_pos = DCCursorPos;

					img_pos.x += (vSize.x - img_w) * 0.5;
					img_pos.y += (vSize.y - img_h) * 0.5;
					window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + ImVec2(img_w, img_h), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
				}
				else if (Storyboard.Nodes[nodeid].screen_backdrop_placement == 2)
				{
					//Zoom
					float img_w = ImageWidth(Storyboard.Nodes[nodeid].screen_backdrop_id);
					float img_h = ImageHeight(Storyboard.Nodes[nodeid].screen_backdrop_id);

					ImVec2 vSize = ImVec2(preview_size_x, preview_size_y);
					if (!standalone) vSize = vMonitorSize;
					float fRatio = 1.0f / (img_h / img_w);
					img_h = vSize.y;
					img_w = vSize.y * fRatio;
					if (img_w < vSize.x)
					{
						float adjustx = vSize.x - img_w;
						img_w += adjustx;
						//img_h += adjustx * (1.0f / (img_h / img_w));
						img_h += adjustx * (1.0f / (img_w / img_h)); //PE: Ups the other way around.
					}

					ImVec2 img_pos = rMonitorArea.Min;
					if (standalone) img_pos = DCCursorPos;

					img_pos.x += (vSize.x - img_w) * 0.5;
					img_pos.y += (vSize.y - img_h) * 0.5;

					if (!standalone) window->DrawList->PushClipRect(rMonitorArea.Min, rMonitorArea.Max, true);
					window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + ImVec2(img_w, img_h), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
					if (!standalone) window->DrawList->PopClipRect();

				}
				else //if (Storyboard.Nodes[nodeid].screen_backdrop_placement == 1)
				{
					//Stretch
					if (standalone)
					{
						const ImRect image_bb((DCCursorPos + vMonitorPos - padding), DCCursorPos + vMonitorPos + padding + vMonitorSize);
						window->DrawList->AddImage((ImTextureID)lpTexture, DCCursorPos, DCCursorPos + ImVec2(preview_size_x, preview_size_y), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
					}
					else
					{
						window->DrawList->AddImage((ImTextureID)lpTexture, image_bb.Min + padding, image_bb.Max - padding, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
					}
				}
			}
		}
		if (!standalone)
		{
			//Moved grid to after backdrop.
			if (bDisplayGrid && !bPreviewScreen && iQuitWindowLoop <= 0)
			{
				if (Storyboard.Nodes[nodeid].screen_grid_size > 0)
				{
					ImVec2 vScale = vMonitorSize / ImVec2(1980.0, 1080);
					ImVec4 tool_selected_col = ImVec4(0.75, 0.75, 0.75, 0.25); //ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
					float grid_size = Storyboard.Nodes[nodeid].screen_grid_size;
					//ImVec2 fOnePercent = ImVec2(1920.0 / 100.0, 1080.0 / 100.0); //PE: This can be changed in the future to support different screen ratio settings.
					ImVec2 fOnePercent = ImVec2(vMonitorSize.x / 100.0, vMonitorSize.y / 100.0); //PE: This can be changed in the future to support different screen ratio settings.
					float grid_step = (grid_size * fOnePercent.x); // *vScale.x;
					for (float fx = (image_bb.Min.x + padding.x); fx < (image_bb.Max.x - padding.x); fx += grid_step)
					{
						ImVec2 linefrom = ImVec2(fx, image_bb.Min.y + padding.y);
						ImVec2 lineto = ImVec2(fx, image_bb.Max.y - padding.y);
						window->DrawList->AddLine(linefrom, lineto, ImGui::GetColorU32(tool_selected_col));
					}
					grid_step = (grid_size * fOnePercent.y); // *vScale.y;
					for (float fy = (image_bb.Min.y + padding.y); fy < (image_bb.Max.y - padding.y); fy += grid_step)
					{
						ImVec2 linefrom = ImVec2(image_bb.Min.x + padding.x, fy);
						ImVec2 lineto = ImVec2(image_bb.Max.x - padding.x, fy);
						window->DrawList->AddLine(linefrom, lineto, ImGui::GetColorU32(tool_selected_col));
					}
				}
			}

		}
		ImVec2 vScale = vMonitorSize / ImVec2(1980.0, 1080);
		ImVec2 vMonitorStart = ImVec2(vMonitorCenterX, 0) + vHeaderEnd + vMonitorPos;
		ImVec2 vMonitorEnd = ImVec2(vMonitorCenterX, 0) + vHeaderEnd + vMonitorPos + vMonitorSize;

		ImGui::SetWindowFontScale(vScale.y);

		ImGui::SetCursorPos(vMonitorStart);
		//ImGui::Text("START Area");
		//ImGui::SetWindowFontScale(4.0*vScale.y);
		//ImGui::Text("Mouse: %f,%f", ImGui::GetMousePos().x, ImGui::GetMousePos().y);
		//ImGui::Text("Mouse: %d,%d", g_pGlob->iWindowsMouseX, g_pGlob->iWindowsMouseY);

		ImGui::SetWindowFontScale(vScale.y);
		ImGui::SetCursorPos(vMonitorEnd);
		//ImGui::Text("END Area");

		if (iCurrentSelectedWidget < 0) iCurrentSelectedWidget = 0;

		int iSkipWidgetSelectionForFrames = 0;
		//Draw all widgets.
		for (int i = 0; i < Storyboard_ActiveWidgets.size(); i++)
		{
			int index = Storyboard_ActiveWidgets[i];
			bool bReadOnly = Storyboard.Nodes[nodeid].widget_read_only[index];
			bool bSpecialLuaReturnValue = false;
			if (bReadOnly)
			{
				if (index >= 1 && index <= 8 && (stricmp(Storyboard.Nodes[nodeid].lua_name, "loadgame.lua") == 0 || stricmp(Storyboard.Nodes[nodeid].lua_name, "savegame.lua") == 0 ) )
				{
					strcpy(Storyboard.Nodes[nodeid].widget_label[index], LoadGameTitle[index]);
					bReadOnly = false;
				}
			}

			//ImVec2 fOnePercent = ImVec2(1920.0 / 100.0, 1080.0 / 100.0); //PE: This can be changed in the future to support different screen ratio settings.
			ImVec2 fOnePercent = ImVec2(vMonitorSize.x / 100.0, vMonitorSize.y / 100.0);
			bool bUsePivotXCenter = true;
			int iTextAdjustment = 1; // 0=left, 1=center , 2=right

			ImVec2 widget_pos = Storyboard.Nodes[nodeid].widget_pos[index] * fOnePercent; //Real screen pos.
			//widget_pos = widget_pos * vScale; //Scale to visible screen size.
			ImVec2 widget_size = ImVec2(500, 74); //Default widget size.
			widget_size = widget_size * vScale;

			//One widget can only use one font, so select it now and use for all functions.
			float font_scale = WidgetSelectUsedFont(nodeid, index);
			ImGui::SetWindowFontScale(font_scale*vScale.x * Storyboard.Nodes[nodeid].widget_font_size[index]);

			bool bProgressbar = false;
			if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_PROGRESS || Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_SLIDER)
			{
				bProgressbar = true;
			}
			//Widget Button
			if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_BUTTON || bProgressbar || Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_RADIOTYPE)
			{
				if (ImageExist(Storyboard.Nodes[nodeid].widget_normal_thumb_id[index]))
				{
					widget_size.x = ImageWidth(Storyboard.Nodes[nodeid].widget_normal_thumb_id[index]);
					widget_size.y = ImageHeight(Storyboard.Nodes[nodeid].widget_normal_thumb_id[index]);
					widget_size = widget_size * vScale; //Scale to visible screen size.

					widget_size = widget_size * Storyboard.Nodes[nodeid].widget_size[index];
				}

				if (bUsePivotXCenter)
					widget_pos = (widget_pos - ImVec2((widget_size.x*0.5), 0.0)); //Scale to visible screen size.

				ImGui::SetCursorPos(vMonitorStart + widget_pos);
				ImGui::Dummy(widget_size);
				bool bHovered = false;
				if (ImGui::IsItemHovered())
				{
					//if (ImGui::IsMouseReleased(0) )
					if (!bWidgetMouseDraggin && ImGui::IsMouseDown(0))
					{
						if( iSkipWidgetSelectionForFrames == 0)
							iCurrentSelectedWidget = index;
					}
					//ImGui::SetTooltip("%s", "Select Button");
					bHovered = true;
				}
				//Button Image
				void* lpTexture = GetImagePointer(Storyboard.Nodes[nodeid].widget_normal_thumb_id[index]);
				if(!bProgressbar && bHovered) lpTexture = GetImagePointer(Storyboard.Nodes[nodeid].widget_highlight_thumb_id[index]);
				if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_RADIOTYPE)
				{
					//PE: Just use first as default selected.
					if (Storyboard.NodeRadioButtonSelected[nodeid] < 0.0) Storyboard.NodeRadioButtonSelected[nodeid] = index;
					if (Storyboard.NodeRadioButtonSelected[nodeid] == index)
					{
						lpTexture = GetImagePointer(Storyboard.Nodes[nodeid].widget_selected_thumb_id[index]);
						if(!lpTexture) lpTexture = GetImagePointer(Storyboard.Nodes[nodeid].widget_highlight_thumb_id[index]);
					}
				}
				if (lpTexture)
				{
					ImGui::SetCursorPos(vMonitorStart + widget_pos);
					ImVec2 img_pos = ImGui::GetWindowPos() + vMonitorStart + widget_pos;
					img_pos.y -= ImGui::GetScrollY();
					window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + widget_size, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
				}
				if (bProgressbar)
				{
					lpTexture = GetImagePointer(Storyboard.Nodes[nodeid].widget_highlight_thumb_id[index]);
					if (lpTexture)
					{
						static float fProgress = 0.0;
						if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_SLIDER)
						{
							//Must be changeable.
							fProgress = Storyboard.NodeSliderValues[nodeid][index];
						}
						else
						{
							if (standalone)
							{
								if (bStartLoadingGame && iFakeLoadGameTest > 0)
									fProgress = 100 - iFakeLoadGameTest;
								else
									fProgress = t.game.levelloadprogress;
							}
							else
							{
								fProgress += 0.25;
							}
							if (fProgress >= 100.0) fProgress = 0.0;
						}
						ImVec2 vSize = widget_size;
						vSize.x = (widget_size.x / 100.0) * fProgress;
						ImGui::SetCursorPos(vMonitorStart + widget_pos);
						ImVec2 img_pos = ImGui::GetWindowPos() + vMonitorStart + widget_pos;
						img_pos.y -= ImGui::GetScrollY();
						window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + vSize, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
					}
				}
				if (!bProgressbar)
				{
					//Text Label
					ImVec2 fTextAdjust = ImVec2(0.0, 0.0);
					ImVec2 fTextSize = ImGui::CalcTextSize(Storyboard.Nodes[nodeid].widget_label[index]); //Already scaled.
					if (iTextAdjustment == 0)
						fTextAdjust.y = (widget_size.y * 0.5) - (fTextSize.y * 0.5); //y always center
					else if (iTextAdjustment == 1)
						fTextAdjust = (widget_size * 0.5) - (fTextSize * 0.5);
					else if (iTextAdjustment == 2)
					{
						fTextAdjust.x = widget_size.x - fTextSize.x - 4.0; //4.0 = padding.
						fTextAdjust.y = widget_size.y * 0.5 - fTextSize.y * 0.5; //y always center
					}
					ImGui::SetCursorPos(vMonitorStart + widget_pos + fTextAdjust);
					ImGui::TextColored(Storyboard.Nodes[nodeid].widget_font_color[index], Storyboard.Nodes[nodeid].widget_label[index]);
				}
			}
			
			if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXT || Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXTAREA)
			{
				cstr text = Storyboard.Nodes[nodeid].widget_label[index];
				if (!bPreviewScreen && text.Len() <= 0) text = "Empty Text"; //PE: Cant have empty text, we cant see it, where to select it.

				widget_size = ImGui::CalcTextSize(text.Get());
				if (bUsePivotXCenter)
					widget_pos = (widget_pos - ImVec2((widget_size.x*0.5), 0.0));

				ImGui::SetCursorPos(vMonitorStart + widget_pos);
				ImGui::Dummy(widget_size);
				bool bHovered = false;
				if (ImGui::IsItemHovered())
				{
					//if (ImGui::IsMouseReleased(0))
					if (!bWidgetMouseDraggin && ImGui::IsMouseDown(0)) //Direct fast select.
					{
						if(iSkipWidgetSelectionForFrames == 0)
							iCurrentSelectedWidget = index;
					}
					//ImGui::SetTooltip("%s", "Select Text");
					bHovered = true;
				}

				ImGui::SetCursorPos(vMonitorStart + widget_pos);
				if(Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXTAREA)
					ImGui::PushTextWrapPos(0.0f);

				//Storyboard.Nodes[node].widget_label[button], ""
				ImGui::TextColored(Storyboard.Nodes[nodeid].widget_font_color[index] , text.Get());
				if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXTAREA)
					ImGui::PopTextWrapPos();
			}

			bool bLuaPageClosing = false;

			//PE: TODO - Need to add sound on button click somewhere here!.
			cstr cTriggerButtonClickSound = "";
			if (standalone)
			{
				if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_BUTTON)
				{
					ImVec2 vLargerGrabArea = ImVec2(10.0, 10.0);
					if (ImGui::IsMouseHoveringRect(rMonitorArea.Min + widget_pos - vLargerGrabArea, rMonitorArea.Min + widget_pos + widget_size + vLargerGrabArea))
					{
						//if mouse release.
						if (ImGui::IsMouseReleased(0))
						{
							if (strlen(Storyboard.Nodes[nodeid].widget_click_sound[index]) > 0)
							{
								cTriggerButtonClickSound = Storyboard.Nodes[nodeid].widget_click_sound[index];
							}

							if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_RETURNVALUETOLUA)
							{
								iSpecialLuaReturn = index;
								iRet = STORYBOARD_ACTIONS_RETURNVALUETOLUA;
								if (stricmp(Storyboard.Nodes[nodeid].lua_name, "savegame.lua") == 0)
								{
									if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0) //PE: Only stop music if we have our own.
										bLuaPageClosing = true;
								}
								if (stricmp(Storyboard.Nodes[nodeid].lua_name, "loadgame.lua") == 0)
								{
									if (index >= 1 && index <= 8)
									{
										if (!pestrcasestr(LoadGameTitle[index], "EMPTY PROGRESS SLOT"))
										{
											if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0) //PE: Only stop music if we have our own.
												bLuaPageClosing = true;
										}
									}
								}
							}
							//Find new node to execute. SwitchPage("")
							if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_BACK)
							{
								lua_switchpageback();
								if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0) //PE: Only stop music if we have our own.
									bLuaPageClosing = true;
								iRet = STORYBOARD_ACTIONS_BACK;
							}
							if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_CONTINUE)
							{
								t.s_s = "";
								lua_switchpage();
								if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0) //PE: Only stop music if we have our own.
									bLuaPageClosing = true;
								iRet = STORYBOARD_ACTIONS_CONTINUE;
							}
							if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_GOTOLEVEL)
							{
								//Support go to level directly ?
								iRet = STORYBOARD_ACTIONS_GOTOLEVEL;
							}
							if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_STARTGAME)
							{
								t.s_s = "";
								lua_switchpage();
								bLuaPageClosing = true;
								iRet = STORYBOARD_ACTIONS_STARTGAME;

								//PE: Always use first level.
								FindFirstLevel(g_Storyboard_First_Level_Node, g_Storyboard_First_fpm);
								g_Storyboard_Current_Level = g_Storyboard_First_Level_Node;
								strcpy(g_Storyboard_Current_fpm, g_Storyboard_First_fpm);
								//Clean name.
								std::string sLevelTitle = g_Storyboard_First_fpm;
								replaceAll(sLevelTitle, ".fpm", "");
								replaceAll(sLevelTitle, "mapbank\\", "");
								t.game.jumplevel_s = sLevelTitle.c_str();

							}
							if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_LEAVEGAME)
							{
								lua_leavegame();
								bLuaPageClosing = true;
								iRet = STORYBOARD_ACTIONS_LEAVEGAME;
								bLastStandalone = false;
							}
							if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_RESUMEGAME)
							{
								lua_resumegame();
								bLuaPageClosing = true;
								iRet = STORYBOARD_ACTIONS_RESUMEGAME;
							}

							if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_EXITGAME)
							{
								lua_quitgame();
								bLuaPageClosing = true;
								iRet = STORYBOARD_ACTIONS_EXITGAME;
								bLastStandalone = false;
								extern bool bSpecialStandalone;
								if (bSpecialStandalone)
								{
									extern bool g_bCascadeQuitFlag;
									g_bCascadeQuitFlag = true;
									PostQuitMessage(0);
									//PE: Launch editor again.
									//editorfromstandalone=
									SetCurrentDirectoryA("..\\");
									char par[MAX_PATH];
									extern bool bReturnToWelcome;
									if(bReturnToWelcome)
										sprintf(par, "editorfromstandalone2=%s", Storyboard.gamename);
									else
										sprintf(par, "editorfromstandalone=%s", Storyboard.gamename);
									ExecuteFile("GameGuruMAX.exe", par, "", 0);
									Sleep(500);
									ExitProcess(0);
								}

							}
							if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_GOTOSCREEN)
							{
								if ( _stricmp(Storyboard.Nodes[nodeid].lua_name,"gamemenu.lua") == 0 && strlen(Storyboard.Nodes[nodeid].output_action[index]) > 0
									&& Storyboard.Nodes[nodeid].output_can_link_to_type[index] == STORYBOARD_TYPE_SCREEN)
								{
									//PE: Special mode where we need to follow output_action.
									//PE: This is a mess, and need to be changed when we change the system to ALL buttons have outlinks.
									std::string lua_name = Storyboard.Nodes[nodeid].output_action[index];
									if (index == 2) lua_name = "loadgame";
									if (index == 3) lua_name = "savegame";
									if (index == 7) lua_name = "controls";
									replaceAll(lua_name, ".lua", "");
									t.s_s = lua_name.c_str();
									lua_switchpage();
									bLuaPageClosing = true; //always stop music.
									iRet = STORYBOARD_ACTIONS_GOTOSCREEN;
								}
								else
								{
									int iNewNode = FindOutputScreenNode(nodeid, index);
									if (iNewNode >= 0)
									{
										//Connected.
										if (Storyboard.Nodes[iNewNode].type == STORYBOARD_TYPE_SCREEN)
										{
											if (strlen(Storyboard.Nodes[iNewNode].lua_name) > 0)
											{
												std::string lua_name = Storyboard.Nodes[iNewNode].lua_name;
												replaceAll(lua_name, ".lua", "");
												t.s_s = lua_name.c_str();
												lua_switchpage();
												if (strlen(Storyboard.Nodes[iNewNode].screen_music) > 0) //PE: Only stop music if new swcreen have its own.
													bLuaPageClosing = true;
												iRet = STORYBOARD_ACTIONS_GOTOSCREEN;

											}
										}
									}
									else
									{
										//PE: Not linked, check if we have a direct link to screen without a pin connection.
										if (index < STORYBOARD_MAXOUTPUTS)
										{
											if (strlen(Storyboard.Nodes[nodeid].output_title[index]) <= 0) //Empty no output pin.
											{
												if (Storyboard.Nodes[nodeid].output_can_link_to_type[index] == STORYBOARD_TYPE_SCREEN)
												{
													if (strlen(Storyboard.Nodes[nodeid].output_action[index]) > 0)
													{
														if (Storyboard.Nodes[nodeid].output_linkto[index] == 0)
														{
															std::string lua_name = Storyboard.Nodes[nodeid].output_action[index];
															replaceAll(lua_name, ".lua", "");
															t.s_s = lua_name.c_str();
															lua_switchpage();
															bLuaPageClosing = true; //always stop music.
															iRet = STORYBOARD_ACTIONS_GOTOSCREEN;

														}
													}
												}
											}
										}

									}
								}
							}
						}
					}
				}
			}
			else
			{
				if (bPreviewScreen)
				{
					//Trigger any sound from buttons.
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_BUTTON)
					{
						ImVec2 vLargerGrabArea = ImVec2(10.0, 10.0);
						if (ImGui::IsMouseHoveringRect(rMonitorArea.Min + widget_pos - vLargerGrabArea, rMonitorArea.Min + widget_pos + widget_size + vLargerGrabArea))
						{
							//if mouse release.
							if (ImGui::IsMouseReleased(0))
							{
								if (strlen(Storyboard.Nodes[nodeid].widget_click_sound[index]) > 0)
								{
									cTriggerButtonClickSound = Storyboard.Nodes[nodeid].widget_click_sound[index];
								}
							}
						}
					}
				}
			}
			if (cTriggerButtonClickSound != "")
			{
				//Play sound.
				int iFreeSoundID = g.temppreviewsoundoffset + 4; //Button Sound.
				// play music
				if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
				if (FileExist(cTriggerButtonClickSound.Get()) == 1)
				{
					LoadSound(cTriggerButtonClickSound.Get(), iFreeSoundID, 0, 1);
					if (SoundExist(iFreeSoundID) == 1)
						PlaySound(iFreeSoundID);
				}
				cTriggerButtonClickSound = "";
			}
			if (bLuaPageClosing)
			{
				//Stop music ...
				int iFreeSoundID = g.temppreviewsoundoffset + 2;
				if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
				{
					// stop currently playing preview
					StopSound(iFreeSoundID);
				}
			}

			//Set Slider Values.
			//Storyboard.NodeSliderValues[nodeid][index];
			if (!bReadOnly && iQuitWindowLoop <= 0 && (bPreviewScreen || standalone) )
			{
				if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_SLIDER)
				{
					ImVec2 vLargerGrabArea = ImVec2(10.0, 10.0);
					if (ImGui::IsMouseHoveringRect(rMonitorArea.Min + widget_pos - vLargerGrabArea, rMonitorArea.Min + widget_pos + widget_size + vLargerGrabArea))
					{
						if (ImGui::IsMouseDown(0))
						{
							//Percent.
							ImVec2 mousecords = ImGui::GetMousePos();
							ImVec2 xy = mousecords - (rMonitorArea.Min + widget_pos);
							float percent = xy.x / (widget_size.x / 100.0);

							if (mousecords.x > (rMonitorArea.Min.x + widget_pos.x + widget_size.x))
								percent = 100.0;
							else if (percent < 0.0)
								percent = 0.0;
							else if (percent > 100.0)
								percent = 100.0;

							Storyboard.NodeSliderValues[nodeid][index] = percent;

							iSpecialLuaReturn = index;
						}
					}
				}
				if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_RADIOTYPE)
				{
					if (ImGui::IsMouseHoveringRect(rMonitorArea.Min + widget_pos , rMonitorArea.Min + widget_pos + widget_size ))
					{
						if (ImGui::IsMouseDown(0))
						{
							Storyboard.NodeRadioButtonSelected[nodeid] = index;
							iSpecialLuaReturn = index;
						}
					}
				}
			}
			//Control Widget.
			if (iCurrentSelectedWidget == index && !standalone)
			{
				if (!bReadOnly && iQuitWindowLoop <= 0 && !bPreviewScreen)
				{
					storyboard_control_widget(nodeid, index, widget_pos, widget_size, rMonitorArea, vMonitorStart, vScale);
				}
			}

			if (iSkipWidgetSelectionForFrames > 0) //PE: Make sure we dont select anything after a window on top.
				iSkipWidgetSelectionForFrames--;

			ImGui::SetWindowFontScale(1.0*vScale.y);
			//ImGui::PushFont(customfont);  //select defaultfont
			ImGui::PopFont();
		}


		ImGui::SetWindowFontScale(1.0);
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + vMonitorCenterX + vMonitorPos.x, vHeaderEnd.y + vMonitorSize.y + vMonitorPos.y + 3.0));
		//ImGui::Text("Below monitor");

		ImGui::SetCursorPos( ImVec2(ImGui::GetCursorPosX(), vHeaderEnd.y + fMaxMonitorY + 6.0));
		//ImGui::Text("Way down : Status");

		if (!bPreviewScreen)
			ImGui::NextColumn();

		if (!bPreviewScreen && iCurrentSelectedWidget >= 0)
		{
			float w = ImGui::GetContentRegionAvailWidth();
			bool bReadOnly = Storyboard.Nodes[nodeid].widget_read_only[iCurrentSelectedWidget];
			bool bSpecialNoText = false;
			if (bReadOnly)
			{
				bSpecialNoText = true;
				if (iCurrentSelectedWidget >= 1 && iCurrentSelectedWidget <= 8 && ( stricmp(Storyboard.Nodes[nodeid].lua_name, "loadgame.lua") == 0 || stricmp(Storyboard.Nodes[nodeid].lua_name, "savegame.lua") == 0 ) )
				{
					strcpy(Storyboard.Nodes[nodeid].widget_label[iCurrentSelectedWidget], LoadGameTitle[iCurrentSelectedWidget]);
					bReadOnly = false;
				}
			}

			if (bReadOnly)
			{
				//PE: Disable ALL gadgets and moving/rotation/scaling.
				ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
				ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
			}

			float buttonwide = 200.0f;
			if (ImGui::StyleCollapsingHeader("Screen Media", ImGuiTreeNodeFlags_DefaultOpen))
			{
				ImGui::Indent(10);

				//ImGui::TextCenter("Backdrop Image");

				cstr cBackDrop = Storyboard.Nodes[nodeid].screen_backdrop;
				if (pestrcasestr(Storyboard.Nodes[nodeid].screen_backdrop, "editors\\"))
				{
					cBackDrop = "default";
				}
				cstr cNewBackDrop = imgui_setpropertyfile2_v2(0, cBackDrop.Get(), "Backdrop Image", "Select Backdrop", "imagebank\\", false,"backdrop");
				if (cNewBackDrop != cBackDrop)
				{
					strcpy(Storyboard.Nodes[nodeid].screen_backdrop, cNewBackDrop.Get());
					iUpdateBackDropNode = nodeid; //Update thumb.
				}

				if (strlen(Storyboard.Nodes[nodeid].screen_backdrop) > 0)
				{
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvail().x-14.f)*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Remove Backdrop", ImVec2(buttonwide, 0.0f)))
					{
						strcpy(Storyboard.Nodes[nodeid].screen_backdrop, "");
						iUpdateBackDropNode = nodeid; //Update thumb.
					}
					if (!Storyboard.Nodes[nodeid].screen_backdrop_transparent)
					{
						//PE: thump problem ?
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvail().x - 14.f)*0.5) - (buttonwide*0.5), 0.0f));
						if (ImGui::StyleButton("Copy Backdrop to All Screens##1", ImVec2(buttonwide, 0.0f)))
						{
							int iAction = askBoxCancel("This will copy your backdrop to all screens, are you sure ?\nNOTE: You need to edit your screens after this change, to update the thumbnails.", "Confirmation"); //1==Yes 2=Cancel 0=No
							if (iAction == 1)
							{
								strcpy(cCopyToAllScreens, Storyboard.Nodes[nodeid].screen_backdrop);
								iUpdateBackDropNode = 99999; //Update ALL thumbs. ???
							}
						}

					}
				}

				if (pref.iStoryboardAdvanced)
				{
					ImGui::TextCenter("Backdrop Position");

					const char* backdrop_placement[] = { "Backdrop Center" , "Backdrop Stretch", "Backdrop Zoom" };
					ImGui::PushItemWidth(-10);
					if (ImGui::Combo("##screen_backdrop_placement", &Storyboard.Nodes[nodeid].screen_backdrop_placement, backdrop_placement, IM_ARRAYSIZE(backdrop_placement)))
					{
						//
					}
					ImGui::PopItemWidth();


					bool bTmp = Storyboard.Nodes[nodeid].screen_backdrop_transparent;
					ImGui::Checkbox("Transparent Backdrop", &bTmp);
					Storyboard.Nodes[nodeid].screen_backdrop_transparent = bTmp;
				}

				//ImGui::TextCenter("Music Track");
				cstr cMusicTrack = Storyboard.Nodes[nodeid].screen_music;
				cstr cNewMusicTrack = imgui_setpropertyfile2_v2(0, cMusicTrack.Get(), "Music Track", "Select Music Track", "audiobank\\", false);
				if (cNewMusicTrack != cMusicTrack)
				{
					strcpy(Storyboard.Nodes[nodeid].screen_music, cNewMusicTrack.Get());
				}

				if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0)
				{
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvail().x-14.0f)*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Remove Music", ImVec2(buttonwide, 0.0f)))
					{
						strcpy(Storyboard.Nodes[nodeid].screen_music, "");
					}
					
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvail().x - 14.f)*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Copy Music to All Screens", ImVec2(buttonwide, 0.0f)))
					{
						int iAction = askBoxCancel("This will copy your music to all screens, are you sure?", "Confirmation"); //1==Yes 2=Cancel 0=No
						if (iAction == 1)
						{
							for (int i = 0; i < STORYBOARD_MAXWIDGETS; i++)
							{
								if (Storyboard.Nodes[i].used && Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN)
								{
									//PE: Only title,about,won,lost,loading
									bool bValid = false;
									if (i == iTitleScreenNodeID) bValid = true;
									if (i == iLoadingScreenNodeID) bValid = true;
									if (i == iAboutScreenNodeID) bValid = true;
									if (i == iGameWonScreenNodeID) bValid = true;
									if (i == iGameLostScreenNodeID) bValid = true;
									if (bValid && i != nodeid)
									{
										//PE: Copy music to scene.
										strcpy(Storyboard.Nodes[i].screen_music, Storyboard.Nodes[nodeid].screen_music);
									}
								}
							}
						}
					}
					
				}

				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvail().x-14.0)*0.5) - (buttonwide*0.5), 0.0f));
				if (ImGui::StyleButton("Preview Screen", ImVec2(buttonwide, 0.0f)))
				{
					bPreviewScreen = true;
					int iFreeSoundID = g.temppreviewsoundoffset + 2;
					if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0)
					{
						// play music
						if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
						if (FileExist(Storyboard.Nodes[nodeid].screen_music) == 1)
						{
							LoadSound(Storyboard.Nodes[nodeid].screen_music, iFreeSoundID, 0, 1);
							if (SoundExist(iFreeSoundID) == 1)
								PlaySound(iFreeSoundID);
						}
					}

				}

				ImGui::Indent(-10);

			}
			//ImGui::Text("");
			if (ImGui::StyleCollapsingHeader("Grid Settings", ImGuiTreeNodeFlags_DefaultOpen))
			{
				ImGui::Indent(10);

				ImGui::TextCenter("Grid Size");
				ImGui::MaxSliderInputInt("##StoryboardGridSize", &Storyboard.Nodes[nodeid].screen_grid_size, 0, 10, "Set Grid Size");

				if (Storyboard.Nodes[nodeid].screen_grid_size > 0)
				{
					ImGui::Checkbox("Show Grid", &bDisplayGrid);
				}
				else
				{
					bool bTmp = false;
					ImGui::Checkbox("Show Grid", &bTmp);
				}

				ImGui::Indent(-10);
			}
			//ImGui::Text("");

			cstr sLabel = "Button Settings";
			cstr sPositionText = "Current Position";
			cstr sTextText = "Text";
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_TEXT) { sLabel = "Text Settings"; sPositionText = "Current Text Position"; }
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_IMAGE)  sLabel = "Image Settings";
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_VIDEO)  sLabel = "Video Settings";
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_PROGRESS)  sLabel = "Progress Bar Settings";
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_SLIDER)  sLabel = "Slider Settings";
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_TEXTAREA) { sLabel = "Text Area Settings"; sPositionText = "Current Text Position"; }
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_BUTTON) { sPositionText = "Current Button Position"; sTextText = "Button Text"; }
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_RADIOTYPE) { sLabel = "Radio Button Settings"; sTextText = "Radio Button Text"; }
		

			if (ImGui::StyleCollapsingHeader(sLabel.Get(), ImGuiTreeNodeFlags_DefaultOpen))
			{
				ImGui::Indent(10);

				ImGui::TextCenter(sPositionText.Get());

				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, 3.0f));
				ImGui::Text("X"); //PE: No room for XYZ labels in default width ?
				ImGui::SameLine();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, -3.0f));
				ImGui::PushItemWidth(w * 0.5 - (ImGui::GetFontSize() * 2.0));
				if (ImGui::InputFloat("##StoryboarTextPositionX", &Storyboard.Nodes[nodeid].widget_pos[iCurrentSelectedWidget].x, 0.0f, 0.0f, "%.0f")) //"%.2f"
				{
					//
				}
				if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Widget Position X");
				ImGui::PopItemWidth();
				ImGui::SameLine();
				ImGui::Text("Y");
				ImGui::SameLine();
				ImGui::PushItemWidth(w * 0.5 - (ImGui::GetFontSize() * 2.0));
				if (ImGui::InputFloat("##StoryboarTextPositionY", &Storyboard.Nodes[nodeid].widget_pos[iCurrentSelectedWidget].y, 0.0f, 0.0f, "%.0f")) //"%.2f"
				{
					//
				}
				if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Widget Position Y");
				ImGui::PopItemWidth();


				if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] != STORYBOARD_WIDGET_PROGRESS)
				{

					if (!bSpecialNoText)
					{
						ImGui::TextCenter(sTextText.Get());
						cstr UniqueTextFiledName = cstr("##WidgetTextStoryboardInput") + cstr(iCurrentSelectedWidget);

						ImGui::PushItemWidth(-10);
						if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_TEXTAREA)
						{
							ImGui::InputTextMultiline(UniqueTextFiledName.Get(), Storyboard.Nodes[nodeid].widget_label[iCurrentSelectedWidget], 250, ImVec2(0, 6.0*ImGui::GetFontSize()), ImGuiInputTextFlags_None); //ImGuiInputTextFlags_ReadOnly
						}
						else
						{
							ImGui::InputText(UniqueTextFiledName.Get(), Storyboard.Nodes[nodeid].widget_label[iCurrentSelectedWidget], 250, ImGuiInputTextFlags_None); //ImGuiInputTextFlags_ReadOnly
						}
						if (ImGui::MaxIsItemFocused())
						{
							bImGuiGotFocus = true;
						}
						ImGui::PopItemWidth();
					}

					ImGui::TextCenter("Text Font");
					//	extern std::vector< std::pair<ImFont*, std::string>> StoryboardFonts;
					char FontSelected[MAX_PATH];
					strcpy(FontSelected, Storyboard.Nodes[nodeid].widget_font[iCurrentSelectedWidget]);

					ImGui::PushItemWidth(-10);
					WidgetSelectUsedFont(nodeid, iCurrentSelectedWidget);
					ImGui::SetWindowFontScale(0.75);

					if (ImGui::BeginCombo("##TextFontStoryboard", FontSelected)) // The second parameter is the label previewed before opening the combo.
					{
						bool bIsSelected = false;
						if (strcmp(FontSelected, "Default Font") == NULL) bIsSelected = true;
						ImGui::PushFont(customfontlarge);  //defaultfont
						if (ImGui::Selectable("Default Font", bIsSelected))
						{
							strcpy(Storyboard.Nodes[nodeid].widget_font[iCurrentSelectedWidget], "Default Font");
						}
						ImGui::PopFont();
						for (int i = 0; i < StoryboardFonts.size(); i++)
						{
							bool bIsSelected = false;
							if (strcmp(StoryboardFonts[i].second.c_str(), FontSelected) == NULL) bIsSelected = true;

							ImGui::PushFont(StoryboardFonts[i].first);  //defaultfont
							if (ImGui::Selectable(StoryboardFonts[i].second.c_str(), bIsSelected))
							{
								strcpy(Storyboard.Nodes[nodeid].widget_font[iCurrentSelectedWidget], StoryboardFonts[i].second.c_str());
							}
							//ImGui::PushFont(customfont);  //defaultfont
							ImGui::PopFont();
						}
						ImGui::EndCombo();
						//ImGui::PopFont();
					}
					ImGui::PopItemWidth();

					ImGui::SetWindowFontScale(1.0);
					//ImGui::PushFont(customfont);  //select defaultfont
					ImGui::PopFont();

					ImGui::TextCenter("Text Color");
					bool open_popup = ImGui::ColorButton("##StoryboardWidgetTextColor", Storyboard.Nodes[nodeid].widget_font_color[iCurrentSelectedWidget], 0, ImVec2(w - 20.0, 0));
					if (open_popup)
						ImGui::OpenPopup("##StoryboardWidgetTextColor");
					if (ImGui::BeginPopup("##StoryboardWidgetTextColor", ImGuiWindowFlags_NoMove))
					{
						if (ImGui::ColorPicker4("##StoryboardPickerTextColor", (float*)&Storyboard.Nodes[nodeid].widget_font_color[iCurrentSelectedWidget], ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoSmallPreview))
						{
							//
						}
						ImGui::EndPopup();
					}
					//Add pencil
					void* lpTexture = GetImagePointer(TOOL_PENCIL);
					if (lpTexture)
					{
						ImVec2 vDrawPos = { ImGui::GetCursorScreenPos().x + (ImGui::GetContentRegionAvail().x - 30.0f) ,ImGui::GetCursorScreenPos().y - (ImGui::GetFontSize()*1.5f) - 3.0f };
						window->DrawList->AddImage((ImTextureID)lpTexture, vDrawPos, vDrawPos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1, 1, 1, 1)));
					}

					ImGui::TextCenter("Text Size");
					if (Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] > 3.5) Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] = 3.5;
					ImGui::MaxSliderInputFloat("##WidgetTextSize", &Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget], 0.00f, 3.50f, "Set Text Font Size", 1.0, 100);
					if (Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] > 3.5) Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] = 3.5;
					if (Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] <= 0) Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] = 0.0001;

				}

				if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_BUTTON || Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_PROGRESS || Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_SLIDER || Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_RADIOTYPE)
				{

					ImGui::TextCenter("Button Size");
					float fTmp = Storyboard.Nodes[nodeid].widget_size[iCurrentSelectedWidget].x;
					if (fTmp > 4.0) fTmp = 4.0;
					ImGui::MaxSliderInputFloat("##WidgetButtonSize", &fTmp, 0.00f, 4.00f, "Set Image Size", 1.0, 100);
					if (fTmp <= 0.10) fTmp = 0.1000;
					Storyboard.Nodes[nodeid].widget_size[iCurrentSelectedWidget].x = fTmp;
					Storyboard.Nodes[nodeid].widget_size[iCurrentSelectedWidget].y = fTmp;

					int iButtons = 3;
					if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_PROGRESS || Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_SLIDER) iButtons = 2;

					//Button Image Regular
					for (int i = 0; i < iButtons; i++) //PE: Selected not really used yet, to enable it just set < 3 :)
					{
						if (i == 0) ImGui::TextCenter("Button Image Regular");
						if (i == 1) ImGui::TextCenter("Button Image Highlighted");
						if (i == 2) ImGui::TextCenter("Button Image Selected");

						cstr UniqueRegularButtonSelect = "##StoryboardUniqueRegularButtonSelect";
						if (i == 1) UniqueRegularButtonSelect = "##StoryboardUniqueHighligtedButtonSelect";
						if (i == 2) UniqueRegularButtonSelect = "##StoryboardUniqueSelectedButtonSelect";

						if (iSelectedLibraryStingReturnID == window->GetID(UniqueRegularButtonSelect.Get()))
						{
							if (i == 0) strcpy(Storyboard.Nodes[nodeid].widget_normal_thumb[iCurrentSelectedWidget], sSelectedLibrarySting.Get());
							if (i == 1) strcpy(Storyboard.Nodes[nodeid].widget_highlight_thumb[iCurrentSelectedWidget], sSelectedLibrarySting.Get());
							if (i == 2) strcpy(Storyboard.Nodes[nodeid].widget_selected_thumb[iCurrentSelectedWidget], sSelectedLibrarySting.Get());
							iUpdateWidgetThumbNode = nodeid;
							iUpdateWidgetThumbButton = iCurrentSelectedWidget;
							sSelectedLibrarySting = "";
							iSelectedLibraryStingReturnID = -1; //disable.
							iSkipWidgetSelectionForFrames = 10; //No widget selection for 10 frames.
						}
						int iTextureID = Storyboard.Nodes[nodeid].widget_normal_thumb_id[iCurrentSelectedWidget];
						if (i == 1) iTextureID = Storyboard.Nodes[nodeid].widget_highlight_thumb_id[iCurrentSelectedWidget];
						if (i == 2) iTextureID = Storyboard.Nodes[nodeid].widget_selected_thumb_id[iCurrentSelectedWidget];

						ImVec2 ImageSize = ImVec2(w - 20.0, ImGui::GetFontSize());
						void* lpTexture = GetImagePointer(iTextureID);
						if (lpTexture)
						{
							float img_w = ImageWidth(iTextureID);
							float img_h = ImageHeight(iTextureID);
							ImageSize.y = img_h * (ImageSize.x / img_w);
						}
						ImVec2 vImagePos = ImGui::GetCursorPos();

						ImGui::Dummy(ImageSize);
						ImVec4 color = ImVec4(1.0, 1.0, 1.0, 1.0);
						ImVec4 back_color = ImVec4(0.2, 0.2, 0.2, 0.75);
						if (ImGui::IsItemHovered())
						{
							color.w = 0.75;
							if (!bWidgetMouseDraggin && ImGui::IsMouseReleased(0))
							{
								//Choose Button image
								sStartLibrarySearchString = "Buttons";
								bExternal_Entities_Window = true;
								iDisplayLibraryType = 2; //Image
								iLibraryStingReturnToID = window->GetID(UniqueRegularButtonSelect.Get());
							}
						}
						ImVec2 img_pos = ImGui::GetWindowPos() + vImagePos;
						img_pos.y -= ImGui::GetScrollY();

						window->DrawList->AddRectFilled(img_pos, img_pos + ImageSize, ImGui::GetColorU32(back_color));
						if (lpTexture)
						{
							window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + ImageSize, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(color));
						}
						else
						{
							window->DrawList->AddRectFilled(img_pos, img_pos + ImageSize, ImGui::GetColorU32(color));
						}
						lpTexture = GetImagePointer(TOOL_PENCIL); //Add pencil
						if (lpTexture)
						{
							ImVec2 vDrawPos = { ImGui::GetCursorScreenPos().x + (ImGui::GetContentRegionAvail().x - 30.0f) ,ImGui::GetCursorScreenPos().y - ImageSize.y - 3.0f };
							window->DrawList->AddImage((ImTextureID)lpTexture, vDrawPos, vDrawPos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1, 1, 1, 1)));
						}
					}

					if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] != STORYBOARD_WIDGET_PROGRESS && Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] != STORYBOARD_WIDGET_SLIDER)
					{
						//ImGui::TextCenter("Button Sound");
						cstr cursound = Storyboard.Nodes[nodeid].widget_click_sound[iCurrentSelectedWidget];
						cstr butsound = imgui_setpropertyfile2_v2(0, cursound.Get(), "Button Sound", "Select Button Sound", "audiobank\\", false);
						if (butsound != cursound)
						{
							strcpy(Storyboard.Nodes[nodeid].widget_click_sound[iCurrentSelectedWidget], butsound.Get());
						}

						ImGui::TextCenter("Actions");
						char ActionSelected[255];

						int iCurAction = Storyboard.Nodes[nodeid].widget_action[iCurrentSelectedWidget];
						if (iCurAction == STORYBOARD_ACTIONS_NONE) strcpy(ActionSelected, "None");
						if (iCurAction == STORYBOARD_ACTIONS_STARTGAME) strcpy(ActionSelected, "Start Game");
						if (iCurAction == STORYBOARD_ACTIONS_EXITGAME) strcpy(ActionSelected, "Exit Game");
						if (iCurAction == STORYBOARD_ACTIONS_CONTINUE) strcpy(ActionSelected, "Continue Game Or Back");
						if (iCurAction == STORYBOARD_ACTIONS_BACK) strcpy(ActionSelected, "Close Screen");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREEN) strcpy(ActionSelected, "Go To Another Screen");
						if (iCurAction == STORYBOARD_ACTIONS_LEAVEGAME) strcpy(ActionSelected, "Leave Game");
						if (iCurAction == STORYBOARD_ACTIONS_RESUMEGAME) strcpy(ActionSelected, "Resume Game");
						if (iCurAction == STORYBOARD_ACTIONS_RETURNVALUETOLUA) strcpy(ActionSelected, "Return Button ID to Lua");

						
						const char* actions_names[] = { "None", "Start Game", "Exit Game", "Continue Game Or Back", "Close Screen" ,"Go To Another Screen","Leave Game","Resume Game","Return Button ID to Lua" };
						//if (ImGui::Combo("##BehavioursSimpleInput", &item_current_type_selection, items_align, IM_ARRAYSIZE(items_align))) {
						ImGui::PushItemWidth(-10);
						if (ImGui::BeginCombo("##StoryboardAction", ActionSelected)) // The second parameter is the label previewed before opening the combo.
						{
							for (int i = 0; i < IM_ARRAYSIZE(actions_names); i++)
							{
								bool bIsSelected = false;
								if (strcmp(actions_names[i], ActionSelected) == NULL) bIsSelected = true;
								//PE: Currently everything is fixed, so cant change actions.
								int flag = ImGuiSelectableFlags_Disabled;
								if (bIsSelected) flag = 0;
								if (ImGui::Selectable(actions_names[i], bIsSelected, flag))
								{
									//Cant change anything.
								}
							}
							ImGui::EndCombo();
						}
						ImGui::PopItemWidth();
					}

				}

				ImGui::Indent(-10);
			}
			if (bReadOnly)
			{
				ImGui::PopItemFlag();
				ImGui::PopStyleVar();
			}

			if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
				//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				ImGui::Text("");
				ImGui::Text("");
			}


		}

		if (!bPreviewScreen)
			ImGui::Columns(1);

		if (iQuitWindowLoop > 0)
		{
			if (iQuitWindowLoop == 1)
			{
				BackBufferSaveCacheName = "";
				BackBufferObjectID = 0;
				BackBufferImageID = 0;
				bLoopBackBuffer = false;
				BackBufferSnapShotMode = false;
				bSnapShotModeUse2D = false;
				bFullScreenBackbuffer = false;
				//Use Grab to get center of screen.
				if (BitmapExist(99))
				{

					ImRect rGrabMonitorArea = rMonitorArea;

					//PE: Widescreen - now use full backbuffer so everything fits.
					//ImRect rGrabMonitorArea = { 29.0,108.0,1597.0,990.0 };
					//float screen_ration_x = 1920.0 / ImGui::GetMainViewport()->Size.x;
					//float screen_ration_y = 1017.0 / ImGui::GetMainViewport()->Size.y;

					SetGrabImageMode(1);
					assert( 0 && "DX11 not in use" );
					/*
					LPGGSURFACE	pTmpSurface = g_pGlob->pCurrentBitmapSurface;
					ID3D11Texture2D *pBackBuffer = NULL;
					pBackBuffer = (ID3D11Texture2D *)GetBitmapTexture2D(99);
					g_pGlob->pCurrentBitmapSurface = pBackBuffer;
					GGSURFACE_DESC ddsd;
					pBackBuffer->GetDesc(&ddsd);

					float grabx = rGrabMonitorArea.Max.x - rGrabMonitorArea.Min.x;
					float graby = rGrabMonitorArea.Max.y - rGrabMonitorArea.Min.y;
					//graby -= 10.0;

					//PE: Change to using vMonitorStart its already in pixels.
					float imgcx = vMonitorStart.x + 1.0; //Skip our padding line.
					float imgcy = vMonitorStart.y + 1.0; //Skip our padding line.

					if (graby > ddsd.Height)
						graby = ddsd.Height;
					if (grabx > ddsd.Width)
						grabx = ddsd.Width;

					if (imgcx + grabx > ddsd.Width) imgcx = ddsd.Width - grabx - 1.0; // check is >= so need -1.
					if (imgcy < 0) imgcy = 0;
					if (imgcx < 0) imgcx = 0;

					bool bValid = true;
					if (imgcx >= imgcx + grabx || imgcy >= imgcy + graby)
					{
						//PE: pBackBuffer->GetDesc failed ?
						if (ddsd.Width >= 1900 && ddsd.Height >= 1000)
						{
							imgcx = 30.0;
							imgcy = 98.0;
							grabx = 1567.0;
							graby = 872.0;
						}
						else
							bValid = false;
					}

					if (bValid)
					{
						//GrabImage(STORYBOARD_THUMBS + 400, 0, 0, ddsd.Width, ddsd.Height, 3);
						//SaveImage("d:\\MAX-DocWrite\\400.png", STORYBOARD_THUMBS + 400);
						//PE: We need a unique id for this STORYBOARD_THUMBS+400
						GrabImage(STORYBOARD_THUMBS + 400, imgcx, imgcy, imgcx + grabx, imgcy + graby, 3);
						SetGrabImageMode(0);
					}
					g_pGlob->pCurrentBitmapSurface = pTmpSurface;

					if (FileExist("thumbbank\\lastnewlevel.jpg")) DeleteAFile("thumbbank\\lastnewlevel.jpg");

					if (bValid)
					{
						if (ImageExist(STORYBOARD_THUMBS + 400))
						{
							char destination[MAX_PATH];
							strcpy(destination, "thumbbank\\lastnewlevel.jpg");
							GG_GetRealPath(destination, 1);
							//Need a no alpha save.
							extern bool g_bDontUseImageAlpha;
							g_bDontUseImageAlpha = true;
							SaveImage(destination, STORYBOARD_THUMBS + 400);
							g_bDontUseImageAlpha = false;
							DeleteImage(STORYBOARD_THUMBS + 400);
						}
					}
					*/
				}

				//Quit and get new thumb to correct node id.
				iWaitFor2DEditor = 5;
				iWaitFor2DEditorNode = nodeid;
				bScreen_Editor_Window = false;
				if (BitmapExist(99))
				{
					DeleteBitmapEx(99);
				}
			}
			else
			{
				//Grab a thumb. need some frames.
				BackBufferIsGroup = false;
				BackBufferEntityID = 0;
				BackBufferObjectID = 0;
				BackBufferImageID = g.importermenuimageoffset + 50;
				//iLargePreviewImageID = BackBufferImageID;
				BackBufferSizeX = ImGui::GetMainViewport()->Size.x;
				BackBufferSizeY = ImGui::GetMainViewport()->Size.y;
				BackBufferZoom = 1.0f;
				BackBufferCamLeft = 0.0f;
				BackBufferCamUp = 0.0f;
				bRotateBackBuffer = false;
				bBackBufferAnimated = false;
				BackBufferSaveCacheName = ""; //No saving on tooltip images
				fLastRubberBandX1 = fLastRubberBandX2 = fLastRubberBandY1 = fLastRubberBandY2 = 0.0f;//Dont fit snapshot to rubber band.
				//Control camera snap shot.
				bLoopBackBuffer = true;
				bSnapShotModeUseCamera = true;
				BackBufferSnapShotMode = true;
				bSnapShotModeUse2D = true;
				bFullScreenBackbuffer = true;
			}

			if (iQuitWindowLoop == 4)
			{
				if (BitmapExist(99))
				{
					DeleteBitmapEx(99);
				}
			}

			iQuitWindowLoop--;
		}

		if (standalone)
		{
			ImGui::PopStyleColor();
			ImGui::PopStyleVar();   // pop window padding
			ImGui::PopStyleVar();   // pop frame padding
			ImGui::PopStyleVar();   // pop item padding
			ImGui::PopStyleVar();   // windows border
			ImGui::End();
		}

	}
	else
	{
		//Something wrong, close down window.
		bScreen_Editor_Window = false;
	}

	return iRet;
}

int autosave_storyboard_project(void)
{
	int iAction = 0;
	if (!Storyboard.iChanged) return iAction;
	if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
	{
		save_storyboard(Storyboard.gamename, false);
	}
	else
	{
		if (strlen(Storyboard.gamename) > 0)
		{
			iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
			if (iAction == 1)
			{
				save_storyboard(Storyboard.gamename, false);
			}
		}
	}
	return iAction;
}

bool bTempDisableRain = false;
bool bTempDisableSnow = false;

void update_per_frame_effects(void)
{
	#ifdef POSTPROCESSRAIN
	if (t.visuals.bRainEnabled)
	{
		if (bImGuiInTestGame)
		{
			if (!master_renderer->getRainEnabled())
			{
				master_renderer->setRainEnabled(t.visuals.bRainEnabled);
			}
		}
		else
		{
			if (!bEnableWeather)
			{
				if (master_renderer->getRainEnabled())
					master_renderer->setRainEnabled(false);
			}
			else
			{
				master_renderer->setRainEnabled(t.visuals.bRainEnabled);
			}
		}
		static float fRainOffsetX = 1.0;
		static float fRainOffsetY = 1.0;
		static float fRainStep = 0.002;
		fRainOffsetX += (fRainStep*t.visuals.fRainSpeedX*g.timeelapsed_f);
		fRainOffsetY += (fRainStep*t.visuals.fRainSpeedY*g.timeelapsed_f);
		master_renderer->setRainOffsetX(fRainOffsetX);
		master_renderer->setRainOffsetY(fRainOffsetY);

		if (master_renderer->getRainEnabled())
		{
			static int iDelayedRayCast = 0;
			if (iDelayedRayCast++ % 10 == 0)
			{
				bTempDisableRain = false;
				float xPos = CameraPositionX();
				float yPos = CameraPositionY();
				float zPos = CameraPositionZ();

				//Try a ray and check if we need to disable.(indoor)
				if (g.lightmappedobjectoffset >= g.lightmappedobjectoffsetfinish)
					int ttt = IntersectAll(85000, 85000 + g.merged_new_objects - 1, 0, 0, 0, 0, 0, 0, -123);
				else
					int ttt = IntersectAll(g.lightmappedobjectoffset, g.lightmappedobjectoffsetfinish, 0, 0, 0, 0, 0, 0, -123);
				int iHitObj = IntersectAllEx(g.entityviewstartobj, g.entityviewendobj, xPos, yPos, zPos, xPos, yPos + 2000.0f, zPos, 0, 0, 0, 0);
				if (iHitObj > 0) {
					//Disable temp.
					bTempDisableRain = true;
				}
			}
			if (bTempDisableRain)
			{
				master_renderer->setRainEnabled(false);
			}
		}

	}
	else
	{
		if (master_renderer->getRainEnabled())
			master_renderer->setRainEnabled(false);
	}
	#endif

	#ifdef POSTPROCESSSNOW
	if (t.visuals.bSnowEnabled)
	{
		if (bImGuiInTestGame)
		{
			if (!master_renderer->getSnowEnabled())
			{
				master_renderer->setSnowEnabled(t.visuals.bSnowEnabled);
			}
		}
		else
		{
			if (!bEnableWeather)
			{
				if (master_renderer->getSnowEnabled())
					master_renderer->setSnowEnabled(false);
			}
			else
			{
				master_renderer->setSnowEnabled(t.visuals.bSnowEnabled);
			}
		}
		static float fSnowOffset = 100.0;
		static float fSnowStep = 0.2;
		float diff = (fSnowStep*t.visuals.fSnowSpeed*g.timeelapsed_f);
		fSnowOffset += diff;
		master_renderer->setSnowOffset(fSnowOffset);
		if (diff < 0 && fSnowOffset > -10.0 && fSnowOffset < 10.0) diff -= 100.0f;
		if (diff > 0 && fSnowOffset > -10.0 && fSnowOffset < 10.0) diff += 100.0f;
		if (master_renderer->getSnowEnabled());
		{
			static int iDelayedRayCast = 0;
			if (iDelayedRayCast++ % 10 == 0)
			{
				bTempDisableSnow = false;
				float xPos = CameraPositionX();
				float yPos = CameraPositionY();
				float zPos = CameraPositionZ();

				//Try a ray and check if we need to disable.(indoor)
				if (g.lightmappedobjectoffset >= g.lightmappedobjectoffsetfinish)
					int ttt = IntersectAll(85000, 85000 + g.merged_new_objects - 1, 0, 0, 0, 0, 0, 0, -123);
				else
					int ttt = IntersectAll(g.lightmappedobjectoffset, g.lightmappedobjectoffsetfinish, 0, 0, 0, 0, 0, 0, -123);
				int iHitObj = IntersectAllEx(g.entityviewstartobj, g.entityviewendobj, xPos, yPos, zPos, xPos, yPos + 2000.0f, zPos, 0, 0, 0, 0);
				if (iHitObj > 0) {
					//Disable temp.
					bTempDisableSnow = true;
				}
			}
			if (bTempDisableSnow)
			{
				master_renderer->setSnowEnabled(false);
			}
		}
	}
	else
	{
		if (master_renderer->getSnowEnabled())
			master_renderer->setSnowEnabled(false);
	}
	#endif
}


#ifdef WICKEDENGINE
void early_access_strandalone_welcome( void )
{
	void StartForceRender(void);
	bool quit = false;
	bool bBrowserStarted = false;
	image_setlegacyimageloading(true);
	LoadImage("editors\\uiv3\\standalone_ea-ea.png", SKYBOX_ICONS+99);
	image_setlegacyimageloading(false);

	while (!quit)
	{
		if (!bRenderTabTab && !bImGuiFrameState)
		{
			//We need a new frame.
			ImGui_NewFrame();
			ImGui_ImplWin32_NewFrame();
			ImGui::NewFrame();
			bRenderTabTab = true;
			bBlockImGuiUntilNewFrame = false;
			extern bool bSpriteWinVisible;
			bSpriteWinVisible = false;
			bImGuiRenderWithNoCustomTextures = false;
		}
		//From lua, we need to update imgui mousepos ...
		int mclick = 0;
		ImGuiIO& io = ImGui::GetIO();
		io.MouseDown[0] = 0;
		io.MouseDown[1] = 0;
		io.MouseDown[2] = 0;
		io.MouseDown[3] = 0;

		mclick = MouseClick();

		if (mclick == 1) io.MouseDown[0] = 1;
		if (mclick == 2) io.MouseDown[1] = 1;
		if (mclick == 4) io.MouseDown[2] = 1;

		ImGuiViewport* viewport = ImGui::GetMainViewport();
		ImGui::SetNextWindowViewport(viewport->ID);
		ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
		ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;
		ImGui::SetNextWindowPos(viewPortPos, ImGuiCond_Always);
		ImGui::SetNextWindowSize(viewPortSize, ImGuiCond_Always);

		ImGui::Begin("##Early Access Version", &quit, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize);

		ImVec2 cpos = ImGui::GetCursorPos();
		float img_w = 1260;
		float img_h = 900;
		ImVec2 img_pos = ImVec2(0.0, 0.0);

		void* lpTexture = GetImagePointer(SKYBOX_ICONS + 99);
		if (lpTexture)
		{
			//Support center,stretch,zoom
			//Storyboard.Nodes[nodeid].screen_backdrop_placement
			//Center;

			img_w = ImageWidth(SKYBOX_ICONS + 99);
			img_h = ImageHeight(SKYBOX_ICONS + 99);

			ImVec2 vSize = ImGui::GetMainViewport()->Size;

			if (img_w > vSize.x || img_h > vSize.y) {
				float fRatio = 1.0f / (img_w / img_h);
				img_w = vSize.x;
				img_h = vSize.x * fRatio;
				if (img_h > vSize.y) {
					float fRatio = 1.0f / (img_h / img_w);
					img_h = vSize.y;
					img_w = vSize.y * fRatio;
				}
			}
			img_pos = ImVec2(0.0, 0.0);
			img_pos.x += (vSize.x - img_w) * 0.5;
			img_pos.y += (vSize.y - img_h) * 0.5;
			ImGuiWindow* window = ImGui::GetCurrentWindow();
			window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + ImVec2(img_w, img_h), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
			cpos = img_pos + ImVec2(0, img_h-260.0);
		}
		else
		{
			ImGui::Dummy(ImVec2(1250, 900));
		}
		ImGui::SetCursorPos(cpos);

		ImGui::SetNextWindowPos(img_pos + ImVec2(0, img_h - 280.0), ImGuiCond_Always);
		ImGui::BeginChild("##DummyEAwelcomechild", ImVec2(img_w-20,280.0), false, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoBackground);
		ImGui::Indent(20);
		ImGui::Text("");
		ImGui::SetWindowFontScale(1.3);
		//ImGui::TextWrapped("PLEASE NOTE\nThis game project has been exported from the Early Access version of GameGuru MAX and is for test purposes only. You should not have been charged to play this game and the quality of the game and performance does not reflect the final quality of GameGuru MAX games.");
		ImGui::TextWrapped("IMPORTANT - PLEASE NOTE!\nDuring the Early Access development phase of GameGuru MAX, all games saved as standalone are considered test games and must not be sold. The games will include a startup message informing users that the game has been made with an Early Access version. This restriction will be lifted once we leave Early Access.\n\nIf you develop a full game and would like to apply for it to be published before the full release of GameGuru MAX then please follow this LINK and fill out the short form. \n\nPlease ensure that anyone you share your standalone game with has a PC system that meets the minimum requirements of GameGuru MAX.");
		ImVec2 prevCursor = ImGui::GetCursorPos();
		ImGui::SetCursorPos(prevCursor + ImVec2(1006, -96));
		if (ImGui::HyberlinkButton("", ImVec2(ImGui::GetFontSize() * 2.2f, ImGui::GetFontSize() * 1.5f)))
		{
			ExecuteFile("https://www.game-guru.com/publish-request", 0, 0);
		}
		ImGui::SetCursorPos(prevCursor);
		ImGui::Text("");
		ImGui::SetWindowFontScale(1.6);
		float buttonwide = ImGui::GetContentRegionAvail().x*0.5 - 10.0f;
		if (ImGui::StyleButton("VISIT GAMEGURU MAX WEBSITE", ImVec2(buttonwide, 0)))
		{
			/*ExecuteFile("https://www.game-guru.com/max", "", "", 0);*/
			ExecuteFile("https://bit.ly/MAXWebsite", "", "", 0);
		
			Sleep(1000); //Give it time to startup.
			bBrowserStarted = true;
		}
		ImGui::SameLine();
		ImGui::SetCursorPos(ImGui::GetCursorPos() +ImVec2(10.0,0.0));
		if (ImGui::StyleButton("CONTINUE", ImVec2(buttonwide, 0)))
		{
			quit = true;
		}

		ImGui::SetWindowFontScale(1.0);
		ImGui::RenderMouseCursor(ImVec2(io.MousePos.x, io.MousePos.y), 1.0);
		ImGui::Indent(-20);
		ImGui::EndChild();
		ImGui::End();

		StartForceRender();
		if (bBrowserStarted) Sleep(15); //Hand over time to browser.
	}
	if (ImageExist(SKYBOX_ICONS + 99))
	{
		StartForceRender();
		DeleteImage(SKYBOX_ICONS + 99);
	}
	bBlockImGuiUntilNewFrame = true;

}
#endif

#endif


#endif

#ifdef WICKEDENGINE
void HandleObjectDeletion()
{
	//  delete selected entity via delete key
	bool bNoDelete = false;
	static bool bWaitOnDelRelease = false;
#ifdef WICKEDENGINE
	if (bWaitOnDelRelease && t.inputsys.kscancode == 211)
		bNoDelete = true;
	else
		bWaitOnDelRelease = false;
#endif

	if (!bNoDelete && t.onetimeentitypickup == 0)
	{
		if (t.gridentity != 0)
		{
			if (t.inputsys.kscancode == 211 || iExecuteCTRLkey == ImGuiKey_Delete)
			{
				t.inputsys.mclickreleasestate = 1;
				t.gridentitydelete = 1;
				t.selstage = 1;
				t.inputsys.kscancode = 0;
				t.widget.pickedObject = 0; //dont remove widget object.
				bWaitOnDelRelease = true;
			}
		}
		else
		{
			if (t.inputsys.kscancode == 211 || (t.widget.deletebuttonselected == 1 && t.inputsys.mclick == 0) || iExecuteCTRLkey == ImGuiKey_Delete)
			{
				t.widget.deletebuttonselected = 0;
				bool bContinueWithDelete = true;
				if (t.widget.pickedEntityIndex > 0)
				{
					// specifically avoid deleting child entities if highlighting a parent
					if (g.entityrubberbandlist.size() > 0)
					{
						bool bDisableRubberBandMoving = false;
						#ifdef WICKEDENGINE
						if (current_selected_group >= 0 && group_editing_on)
						{
							bDisableRubberBandMoving = true;
						}
						#endif
						if (!bDisableRubberBandMoving)
						{
							//LB: to ensure cannot delete objects that are part of a group, 
							// check if the group is a parent group (user can delete child groups okay)
							#ifdef WICKEDENGINE
							// before make final decision, see if a parent group can hand over control to one of its child groups
							if (current_selected_group >= 0 && vEntityGroupList[current_selected_group][0].iGroupID != -1)
							{
								// this group is a parent, so see if there are any child groups
								int iLookForThisID = vEntityGroupList[current_selected_group][0].iGroupID;
								for (int gi = 0; gi < MAXGROUPSLISTS; gi++)
								{
									if (gi != current_selected_group && vEntityGroupList[gi].size() > 0)
									{
										if (vEntityGroupList[gi][0].iParentGroupID == iLookForThisID)
										{
											// found a child of this parent, switch roles (so parent can be deleted below)
											for (int n = 0; n < vEntityGroupList[gi].size(); n++)
											{
												// child becomes the parent
												vEntityGroupList[gi][n].iGroupID = iLookForThisID;
												vEntityGroupList[gi][n].iParentGroupID = -1;
											}
											for (int n = 0; n < vEntityGroupList[current_selected_group].size(); n++)
											{
												// parent becomes the child (temporarily so they can be deleted)
												vEntityGroupList[current_selected_group][n].iGroupID = -1;
												vEntityGroupList[current_selected_group][n].iParentGroupID = iLookForThisID;
											}
											// also, ensure the original parent group image survives, so copy just before deletions
											iEntityGroupListImage[gi] = iEntityGroupListImage[current_selected_group];
											// only need one child to become parent
											break;
										}
									}
								}
							}
							// prevent deleting them, and instead instruct user to ungroup the objects first
							if (current_selected_group >= 0 && vEntityGroupList[current_selected_group][0].iGroupID != -1)
							{
								// do not delete 'key' objects that are part of group
								strcpy(cTriggerMessage, "Cannot delete a parent group. First ungroup objects, then you can delete them all.");
								bTriggerMessage = true;
								bContinueWithDelete = false;
							}
							else
							#endif
							{
								#ifdef WICKEDENGINE
								// before delete, ensure child groups are ungrouped before the delete
								if (current_selected_group >= 0 && vEntityGroupList[current_selected_group][0].iParentGroupID != -1)
								{
									// pass flag to ensure rubber band list not cleared, so we can delete below
									UnGroupSelected(true);
								}
								#endif
								// delete all entities in rubber band highlight list
								gridedit_deleteentityrubberbandfrommap();
								gridedit_clearentityrubberbandlist();
								t.widget.pickedEntityIndex = 0;
							}
						}
					}
				}
				if (bContinueWithDelete == true)
				{
					if (t.widget.pickedObject > 0)
					{
						// delete a single entity selected by widget
						if (t.widget.pickedEntityIndex > 0)
						{
							t.tentitytoselect = t.widget.pickedEntityIndex;
#ifdef WICKEDENGINE
							DeleteEntityFromLists(t.tentitytoselect);
#endif
							gridedit_deleteentityfrommap();
						}
						t.widget.pickedObject = 0;
						widget_updatewidgetobject();
					}
					bWaitOnDelRelease = true;
					t.tentitytoselect = 0;
				}
			}
			if (t.inputsys.keyspace == 0) t.inputsys.spacekeynotreleased = 0;
			if (t.inputsys.keyspace == 1 && t.inputsys.rubberbandmode == 0 && t.inputsys.spacekeynotreleased == 0)
			{
				// end selection when press SPACE
				gridedit_clearentityrubberbandlist();
				t.widget.pickedEntityIndex = 0;
				if (t.widget.pickedObject > 0)
				{
					t.widget.pickedObject = 0;
					widget_updatewidgetobject();
				}
				t.tentitytoselect = 0;
			}
		}
	}
	else
	{
		if (t.inputsys.mclick == 0)  t.onetimeentitypickup = 0;
	}
}

void ToggleDPIAwareness(bool bDPIAware)
{
	// determine if on or off
	char pDPINotAware[256];
	if (bDPIAware == false)
		strcpy(pDPINotAware, "1");
	else
		strcpy(pDPINotAware, "0");

	// write into registry
	HKEY hKeyNames = 0;
	LPCSTR pSubKeyName = "Software\\GameGuruMAX";
	DWORD dwDisposition;
	DWORD Status = RegCreateKeyExA(HKEY_CURRENT_USER, pSubKeyName, 0L, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS | KEY_WRITE, NULL, &hKeyNames, &dwDisposition);
	if (Status == ERROR_SUCCESS)
	{
		if (dwDisposition == REG_OPENED_EXISTING_KEY)
		{
			RegCloseKey(hKeyNames);
			Status = RegOpenKeyExA(HKEY_CURRENT_USER, pSubKeyName, 0L, KEY_WRITE, &hKeyNames);
		}
	}
	if (hKeyNames != 0)
	{
		if (Status == ERROR_SUCCESS)
		{
			Status = RegSetValueExA(hKeyNames, "DPINotAware", 0, REG_SZ, (LPBYTE)pDPINotAware, (strlen(pDPINotAware) + 1) * sizeof(char));
		}
		RegCloseKey(hKeyNames);
	}
}

void ControlAdvancedSetting(int& setting, const char* tooltip, bool* bLargePreview)
{
	ImGui::Spacing();
	ImGui::Indent(-10);

	bool bState = setting;
	ImVec2 label_size = ImGui::CalcTextSize("View Advanced Settings...", NULL, true);

	// ZJ: The tooltip doesn't work without PushID?
	ImGui::PushID(10000);
	
	ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvailWidth()*0.5) - (label_size.x*0.5) - (ImGui::GetFrameHeight()*0.5), 0.0f));
	if (ImGui::Checkbox("", &bState))
	{
		setting = bState;
	}
	
	char* action = "Show ";
	if (setting)
		action = "Hide ";
	char fullText[MAX_PATH];
	strcpy(fullText, action);
	strcpy(fullText + strlen(action), tooltip);

	if (ImGui::IsItemHovered()) ImGui::SetTooltip(fullText);
	ImGui::PopID();
	ImGui::SameLine();

	if (ImGui::HyberlinkButton("View Advanced Settings##2", ImVec2(label_size.x, 0)))
	{
		extern int iSetSettingsFocusTab;
		extern bool bPreferences_Window;
		iSetSettingsFocusTab = 2;
		bPreferences_Window = true;

		//This is a modal window, so we need to close it to see the settings window.
		if (bLargePreview)
		{
			*bLargePreview = false;
		}
	}

	ImGui::Spacing();
	ImGui::Indent(10);
}

void TestLevel_ToggleBoundary(bool _2d, bool _3d)
{
	if (t.game.gameisexe == 1)
	{
		_2d = false;
		_3d = false;
	}

	if (_2d) 
		ggterrain_global_render_params2.flags2 |= GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE;
	else 
		ggterrain_global_render_params2.flags2 &= ~GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE;

	if(_3d)
		ggterrain_global_render_params2.flags2 |= GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE_3D;
	else 
		ggterrain_global_render_params2.flags2 &= ~GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE_3D;

}

void TestLevel_ToggleTreeVegWater(bool tree, bool veg, bool water)
{
	if (t.game.gameisexe == 0)
	{
		ggtrees_global_params.draw_enabled = tree;
		gggrass_global_params.draw_enabled = veg;
		t.gamevisuals.bWaterEnable = water;
		t.gamevisuals.bEndableTreeDrawing = tree;
		t.gamevisuals.bEndableGrassDrawing = veg;
	}
}

void LockSelectedObject(bool bLock, int iObjectLockedIndex)
{
	if (bLock)
	{
		int e = t.widget.pickedEntityIndex;
		t.entityelement[e].editorlock = 1 - t.entityelement[e].editorlock;
		sObject* pObject;
		if (t.entityelement[e].obj > 0) {
			pObject = g_ObjectList[t.entityelement[e].obj];
			if (pObject) {
				if (t.entityelement[e].editorlock)
				{
					sRubberBandType vEntityLockedItem;
					vEntityLockedItem.e = e;
					vEntityLockedList.push_back(vEntityLockedItem);
				}
				else {
					//Delete from list.
					for (int i = 0; i < vEntityLockedList.size(); i++)
					{
						if (vEntityLockedList[i].e == e) {
							vEntityLockedList.erase(vEntityLockedList.begin() + i);
							break;
						}
					}
					WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
				}
			}
		}
	}
	else
	{
		int e = t.widget.pickedEntityIndex;
		if (iObjectLockedIndex >= 0) {
			t.entityelement[e].editorlock = 0;
			sObject* pObject;
			if (t.entityelement[e].obj > 0) {
				pObject = g_ObjectList[t.entityelement[e].obj];
				if (pObject) {
					WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
				}
			}
			vEntityLockedList.erase(vEntityLockedList.begin() + iObjectLockedIndex);
		}
	}
}
#endif

void InjectIconToExe(char *icon, char *exe,int intresourcenumber)
{
	if (!icon || !exe) return;

	HANDLE hIcon = CreateFileA(icon,
		GENERIC_READ,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if (!hIcon)
	{
		return;
	}

	LPBYTE lpBuf;
	DWORD dwFileSize, dwBytesRead;

	dwFileSize = GetFileSize(hIcon, NULL);
	lpBuf = (LPBYTE)malloc(dwFileSize);
	if (!lpBuf)
	{
		CloseHandle(hIcon);
		return;
	}

	ReadFile(hIcon, lpBuf, dwFileSize, &dwBytesRead, NULL);
	if (dwBytesRead != dwFileSize)
	{
		free(lpBuf);
		CloseHandle(hIcon);
		return;
	}

	CloseHandle(hIcon);


	HANDLE hUpdateRes;
	hUpdateRes = BeginUpdateResourceA(exe, FALSE);
	if (hUpdateRes == NULL)
	{
		free(lpBuf);
		return;
	}

	//Max english
	#define IDI_GAMEGURUMAX                 102
	if (!UpdateResource(hUpdateRes,
		RT_ICON,
		MAKEINTRESOURCE(intresourcenumber), //MAKEINTRESOURCE(IDI_GAMEGURUMAX),
		MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
		lpBuf+22, dwBytesRead-22)) //PE: Test offset header 22
	{
		free(lpBuf);
		return;
	}

	#pragma pack(push, 1)
	struct myheader
	{
		WORD Reserved;
		WORD ResourceType;
		WORD ImageCount;

		BYTE Width;
		BYTE Height;
		BYTE Colors;
		BYTE Reserved2;
		WORD Planes;
		WORD BitsPerPixel;
		DWORD ImageSize;
		WORD ImageOffset;
	} myheader;
	#pragma pack(pop)
	myheader.Reserved = 0;
	myheader.ResourceType = 1;
	myheader.ImageCount = 1;
	myheader.Width = 0; //256
	myheader.Height = 0; //256
	myheader.Colors = 0;
	myheader.Reserved2 = 0;
	myheader.Planes = 1;
	myheader.BitsPerPixel = 32; //
	myheader.ImageSize = dwBytesRead - 22; //
	myheader.ImageOffset = 1; //

	BOOL b = UpdateResource(hUpdateRes, MAKEINTRESOURCE(RT_GROUP_ICON), MAKEINTRESOURCE(102), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), &myheader, sizeof(myheader));

	if (!EndUpdateResource(hUpdateRes, FALSE))
	{
		free(lpBuf);
		return;
	}

	free(lpBuf);
}
