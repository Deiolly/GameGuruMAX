//----------------------------------------------------
//--- GAMEGURU - M-GridEdit
//----------------------------------------------------

// moved all the defines into the WICKED DEFINE area ()

// Includes 
#include "stdafx.h"
#include "gameguru.h"
#include "M-WelcomeSystem.h"
#include "M-Widget.h"
#include "GGVR.h"
#include "M-GridEditB.h"

#ifdef RPG_GAMES
void ProcessRPGSetupWindow(void);
bool IsRPGActive(void);
bool save_rpg_system(char *name);
bool load_rpg_system(char *name);
void init_rpg_system(void);
bool bRPGSetup_Window = false;
#endif

#ifdef STORYBOARD
//#include "..\..\GameGuru\Imgui\imnodes.cpp" now added to project to compile the CPP
#include "..\..\GameGuru\Imgui\imnodes.h"
#include "..\..\GameGuru\Imgui\imgui_impl_win32.h"
#include "..\..\GameGuru\Imgui\imgui_gg_extras.h"
int grideleprof_uniqui_id = 35000;
#define MAXTEXTINPUT 1024
float g_Storyboard_header_height = 150.0f;
char cTmpInput[MAXTEXTINPUT + 1];
int g_Storyboard_First_Level_Node = -1;
int g_Storyboard_Current_Level = -1;
char g_Storyboard_First_fpm[256];
char g_Storyboard_Current_fpm[256];
char g_Storyboard_Current_lua[256];
std::vector<std::string> projectbank_list;
//std::vector<bool> projectbank_list_exist;
std::vector<std::string> projectbank_image;
std::vector<int> projectbank_imageid;
StoryboardStruct Storyboard;
StoryboardStruct checkproject;
std::vector< std::pair<ImFont*, std::string>> StoryboardFonts;
bool bScreen_Editor_Window = false;
int iScreen_Editor_Node = -1;
int iStoryboardExecuteKey = 0;
bool bTriggerSaveAs = false;
bool bTriggerOpenProject = false;
int iDelayTriggerOpenProject = 0;
bool bTriggerSaveAsAfterNewLevel = false;
char SaveProjectAsName[256] = "\0";
char SaveProjectAsError[256] = "\0";
bool bTriggerWhatsNewInStoryboard = false;
bool bAddWhatNewToMenu = false;
bool bOpenProjectsFromWelcome = false;
#endif
cstr TriggerLoadGameProject = "";
bool bStoryboardFirstRunSetInitPos = false;
bool bStoryboardInitNodes = false;
bool bJustRederedScreenEditor = false;

#define FREETRIALONDISCOUNT
bool g_bUpdateAppAvailable = false;
bool g_bFreeTrialVersion = false;
int g_iFreeTrialDaysLeft = 0;
bool g_bFreeTrialNowExitsApp = false;

bool g_bAdjustPlaneXZUsingSurfaceXZ = false;
bool g_bResetPlaneAfterXZAdjust = false;
bool g_bHoldGridEntityPosWhenManaged = true;
float g_fHoldGridEntityPosX = 0;
float g_fHoldGridEntityPosY = 0;
float g_fHoldGridEntityPosZ = 0;
float g_fLocalTurnRotationForSmartMode = 0.0f;
int g_iStackToSurfaceMode = 0;
int g_iOrientToSurfaceMode = 0;
bool g_bParticleEditorPresent = false;
DWORD g_dwParticleEditorProcessHandle = NULL;

//#include "M-CharacterCreatorPlusTTS.h" now done in new header
#include <algorithm>
#include <string>
#include <time.h>

#include <wininet.h>
#include <mmsystem.h>
#include "ShlObj.h"
#include "sha1.h"
#include "sha2.h"

#include "miniz.h"

#ifndef PRODUCTCLASSIC
int iGenralWindowsFlags = ImGuiWindowFlags_None | ImGuiWindowFlags_NoMove;
bool bBoostIconColors = false;
int iDisplayCircleFrames = 0;
#endif

#ifdef WICKEDENGINE
#include "shellapi.h"
#include ".\\..\..\\Guru-WickedMAX\\GPUParticles.h"
using namespace GPUParticles;
#include "GGTerrain/GGTerrain.h"
using namespace GGTerrain;
#include "GGTerrain/GGTrees.h"
using namespace GGTrees;
#include "GGTerrain/GGGrass.h"
using namespace GGGrass;
#endif

#ifdef WICKEDENGINE
#include ".\..\..\Guru-WickedMAX\wickedcalls.h"
#include "..\..\Guru-WickedMAX\master.h"
#define USE_ENTITY_TOOL_WINDOW
#ifdef DISPLAYBOUNDINGBOXIN_PROPERTIES
#define XMSTATICCOLOR XMFLOAT4(1.0f, 0.1f, 0.0f, 0.4f)
#define XMDYNAMICCOLOR XMFLOAT4(0.25f, 1.0f, 0.25f, 0.4f)
#else
#define XMSTATICCOLOR XMFLOAT4(1.0f, 0.25f, 0.0f, 0.0f)
#define XMDYNAMICCOLOR XMFLOAT4(0.25f, 1.0f, 0.25f, 0.0f)
#endif

extern sObject* g_selected_editor_object;
extern XMFLOAT4 g_selected_editor_color;
bool bEditorGridFitObjectSize = false;
int iEditorGridSizeX = 100;
int iEditorGridSizeZ = 100;
bool bRenderTabTab = false;
bool bRenderNextFrame = false;
bool bNeedImGuiInput = false;
bool bProfilerEnable = false;
int iExtractMode = 0; //0 = find floor, 1 = extracted y value. , 3 = fixed y value.
float fExtractYValue = 0, fExtractFixedYValue = GGORIGIN_Y;
bool bExtractFixPivot = true;
bool g_bStandaloneSinglePlayer = true;
bool g_bStandaloneMultiPlayer = false;
bool g_bStandaloneVRMode = false;
bool g_bPreviewLighting = false;
int iLastOpenHeader = 1;
int iExecuteCTRLkey = 0;
int iExecuteALTkey = 0;
int iIncludeLeftIconSet = 0;
extern uint64_t g_hovered_dot_entity;
extern sObject* g_hovered_dot_pobject;
sObject* g_destination_dot_pobject = NULL;
sObject* g_source_dot_pobject = NULL;
sObject* g_selected_middle_dot_pobject = NULL;
bool bDotMiddleWindow = false;
ImVec2 vDotMiddleWindowPos;
#define MAXDOTMIDDLE 1000
#define DOTOBJECTIDADD 40000
#define DOTCURSOROBJECTID (70001+40000+20000)
#define DOTMIDDLEOBJECTID (70001+40000+20001)
#define MAXDOTARCSOBJECTS 20000
#define DOTARCSOBJECTID (70001+40000+20001+MAXDOTMIDDLE+1000000)
#define RELATIONOBJECTID (70001+40000+20001+MAXDOTMIDDLE)
#define RELATIONOBJECTMAX 1000
int iLargestDotObjectID = 70001;
int iLargestDotCount = 999999;
bool bDotObjectDragging = false;
int iDotMiddleInfoSource[MAXDOTMIDDLE];
int iDotMiddleInfoDestination[MAXDOTMIDDLE];
int iDotMiddleColor[MAXDOTMIDDLE];
int iDotArceColor[MAXDOTARCSOBJECTS];

int iDotMiddleInfoSourceType[MAXDOTMIDDLE];
int iDotMiddleInfoDestinationType[MAXDOTMIDDLE];
extern float fLastHitPosition[4];
int iCursorDotObject = 0;
bool bFactionWindow[16];
float fDrawDotCircleTimer = 0;
bool bDrawDotCircle = false;
float fDrawDotCircleRadius = 0.0;
int fDrawDotCircleFrom = 0;
bool g_bDotsAreVisible = false;

#define BACKBUFFERIMAGE (g.perentitypromptimageoffset+9000)
int BackBufferObjectID = 0;
bool BackBufferSnapShotMode = false;
bool BackBufferParticlesMode = false;
int iBackBufferParticlesTrigger = 0;
int BackBufferParticleEmitter = -1;
bool bFullScreenBackbuffer = false;
bool bSnapShotModeUseCamera = false;
bool bSnapShotModeUse2D = false;
float fSnapShotModeCameraX = 0.0f, fSnapShotModeCameraY = 0.0f, fSnapShotModeCameraZ = 0.0f;
float fSnapShotModeCameraAngX = 0.0f, fSnapShotModeCameraAngY = 0.0f, fSnapShotModeCameraAngZ = 0.0f;
cstr g_LastGroupSaved_s;
bool g_bBehaviorEditorActive = false;
int bStopBackbufferGrab = 0;

bool library_createbehavior = false;
char library_newbehaviorname[256];

bool BackBufferIsGroup = false;
int BackBufferEntityID = 0;
int BackBufferImageID = 0;
int BackBufferSizeX = 0;
int BackBufferSizeY = 0;
float BackBufferRotateY = 0.0f, RestoreBackBufferRotateY = -1.0f;
float BackBufferRotateX = 0.0f, RestoreBackBufferRotateX = -1.0f;
float BackBufferRotateZ = 0.0f, RestoreBackBufferRotateZ = -1.0f;
float BackBufferZoom = 0.0f, RestoreBackBufferZoom = -1.0f;
float BackBufferCamMove = 0.0f;
float BackBufferCamLeft = 0.0f, RestoreBackBufferCamLeft = -1.0f;
float BackBufferCamUp = 0.0f, RestoreBackBufferCamUp = -1.0f;
bool bBackBufferAnimated = false;
bool bBackBufferRestoreCamera = false;
bool bEditorInFreeFlightMode = false;

bool bLoopBackBuffer = false;
bool bLoopFullFPS = false;
bool bRotateBackBuffer = false;
cstr BackBufferCacheName = "";
cstr ProjectCacheName = "";
cstr BackBufferSaveCacheName = "";
extern std::vector<sImageList> g_imageList;
static std::vector<sImageList> g_TempimageList;
int iRestoreEntidMaster = -1;
int fpe_current_loaded_script = -1;
int fpe_current_loaded_script_image = 0;
int fpe_current_loaded_script_image_count = 0;

bool bReadyToDropEntity = false;
bool bWaitOnMouseRelease = false;
bool bDraggingActive = false;
bool bDraggingActiveInitial = false;
int iDragDropActive = 0;
#define HITPOINTYSTARTPOS GGORIGIN_Y
float fHitPointX = 0.0f, fHitPointY = 0.0f, fHitPointZ = 0.0f;
float fHitOffsetX = 0.0f, fHitOffsetY = 0.0f, fHitOffsetZ = 0.0f;
float fHitRayFrom = 0.0f ,fLastHitY = 0.0f;

extern sObject* g_hovered_pobject;
bool bTriggerVisibleWidget = false;
bool bMouseInputSystemUsed = false;
int iLastHitObjectID = 0;
int iStartMouseX, iStartMouseY;
int iObjectMoveMode = 2; // default to move and find floor mode (smartest = Lees Sneaky Solution)
int iObjectMoveModeDropSystem = 0;
int iObjectMoveModeDropSystemUsing = 0;
bool bObjectAllowOverlapping = 1;

float fDebug = 0.0f, fDebug1 = 0.0f, fDebug2 = 0.0f, fDebug3 = 0.0f;

int i_switch_group_tab = 0;
int current_selected_group = -1;
int thumb_selected_group = -1;
bool group_editing_on = false;
bool bCreateNewGroupOnNextDrop = false;
int iLastEntityOnCursor = 0;
float fLastRubberBandX1 = 0.0f;
float fLastRubberBandX2 = 0.0f;
float fLastRubberBandY1 = 0.0f;
float fLastRubberBandY2 = 0.0f;
bool bDetectTerrainOnly = false;
bool bRubberBandCreated = false;
bool bDragCameraActive = false;
bool g_bThumbBankCopyMode = true;
bool g_bRefreshRotationValuesFromObjectOnce = false;
bool g_bRefreshScaleValuesFromObjectOnce = false;
bool g_bLightProbeScaleChanged = false;
int iReusePickObjectID = -1;
int iReusePickEntityID = -1;
float fReusePickHitX = 0, fReusePickHitY = 0, fReusePickHitZ = 0;
sObject* pReusePickObject = 0;
std::vector<sLibraryList> g_LibraryFileList;
cStr cLastProjectList = "";


cstr cCurrentBackDropImageFile = "None";
bool bUseBackDropImage = true;
cstr cUseBackbufferCubemap = "";
bool bBackbufferCubemapActive = false;
int iLastSelectedEntityGroup = -1;
int iLastSelectedEntity = 0;
int iSetSettingsFocusTab = 0;
bool bStoryboardWindow = false;
bool bStoryboardWindowOpenLoad = false;
bool bMarketplace_Window = false;
bool bTriggerCloseEntityWindow = false;
bool bMarketplace_Init = false;
bool bFreeTrial_Window = false;
bool bFreeTrial_Init = false;
cstr sDefaultImportPath = "";
bool bResetObjectLibrarySize = false;
bool bWelcomeScreen_Window = false;
bool bWelcomeNoBackButton = false;
bool bWelcomeScreen_Init = false;
std::map<std::string, int> selected_library_fpe;
bool bProceduralLevel = false;
bool bProceduralLevelFromStoryboard = false;
int iBlackoutForFrames = 0;
int iQuitProceduralLevel = false;
bool bProceduralLevelStartup = false;
int g_iUniqueGroupID = 1000;
cstr sGotoPreviewWithFile = "";
int iGotoPreviewType = 0;
int init_Left_Categories_Column_Width = 3;
int g_iDevToolsOpen = 0;
bool bInvulnerableMode = false;
bool bStartInvulnerableMode = false;
bool bNoSecondAsk = false;
int iWelcomeHeaderType = 0;
int iAboutLogoType = 0;
int active_tools_obj = 0;
int active_tools_entity_index = 0;

#endif //WICKEDENGINE

bool bTrashcanIconActive = false, bTrashcanIconActive2 = false;
int current_sort_order = 0;
int iWidgetSelection = 0;
bool bRotScaleAlreadyUpdated = false;
float fEditorGridOffsetX = 50.0f;
float fEditorGridOffsetY = 0.0f;
float fEditorGridOffsetZ = 50.0f;
float fEditorGridSizeX = 100.0f;
float fEditorGridSizeY = 100.0f;
float fEditorGridSizeZ = 100.0f;
int old_iMSAASampleCount = -1;
int old_iMSAO = -1;
float old_fMSAOPower = -1.0;
int old_iShadowSpotCascadeResolution = -1;
int old_iShadowSpotResolution = -1;
int old_iShadowPointResolution = -1;
bool bForceRefreshLightCount = false;
int iUpdateOcean = 0;
bool bEditorLight = false;
cStr sNextLevelToLoad;

#ifdef WICKEDENGINE
float fMouseWheelZoomFactor = 3.0;
bool g_bResetCameraToFreeFlightOnNewLevel = false;
float fLocalMax = 1000.0f;
#else
float fMouseWheelZoomFactor = 1.0;
#endif

// Defines
#define ENABLETUTORIALVIDEOS

// 
//  GAMEGURU MAP EDITOR EXECUTABLE CODE
// 

//Check if we are in f9 mode
extern bool g_occluderf9Mode;
//Skip terrain rendering when going into importer mode
extern bool g_bSkipTerrainRender;
// extern to global that toggles when load map removed from entities
extern bool g_bBlackListRemovedSomeEntities;
extern bool gbWelcomeSystemActive;
extern int g_iWelcomeLoopPage;
extern int g_trialStampDaysLeft;
int g_tstoreprojectmodifiedstatic = 0;

#ifdef VRTECH
extern bool g_bCharacterCreatorPlusActivated;
// can prevent app from quitting out while in test game
extern bool g_bDisableQuitFlag;
extern bool bEnableWeather;
char cImGuiDebug[2048] = "\0";
bool bForceKey = false;
int iForceScancode = -1;
cstr csForceKey = "";
bool bForceKey2 = false;
cstr csForceKey2 = "";
bool bForceUndo = false;
bool bForceRedo = false;
int iLaunchAfterSync = 0;
bool bTriggerFovUpdate = false;
int iLaunchAfterSyncAction = 0;
bool bLaunchTestGameAfterLoad = false;
bool bLaunchSaveStandalonefterLoad = false;
bool bCloseStoryboardAfterLoad = false;
int iLevelEditorFromStoryboardID = -1;
char pLaunchAfterSyncPreSelectModel[MAX_PATH] = "\0";
char pLaunchAfterSyncLastImportedModel[MAX_PATH] = "\0";
int iOldLaunchAfterSync = 0;
int iSkibFramesBeforeLaunch = 0;
DWORD gWindowSizeXOld = 0;
DWORD gWindowSizeYOld = 0;
DWORD gWindowSizeAddY = 0;
DWORD gWindowSizeAddX = 0;
DWORD gWindowVisibleOld = 0;
DWORD gWindowPosXOld = 0;
DWORD gWindowPosYOld = 0;
DWORD gWindowMaximized = 0;
int xmouseold = 0, ymouseold = 0;

#ifdef ENABLEIMGUI
extern bool bImGuiInTestGame;
extern bool bBlockImGuiUntilNewFrame;
extern bool bImGuiRenderWithNoCustomTextures;
extern bool bImGuiFrameState;
extern bool bImGuiReadyToRender;
extern bool bImGuiInitDone;
extern ImVec2 OldrenderTargetSize;
extern ImVec2 OldrenderTargetPos;
extern ImVec2 renderTargetAreaPos;
extern ImVec2 renderTargetAreaSize;
extern bool bImGuiRenderTargetFocus;
extern bool bImGuiGotFocus;
extern bool g_bCascadeQuitFlag;
extern int ImGuiStatusBar_Size;
extern char defaultWriteFolder[260];
bool bEntityGotFocus = false;
char cDirectOpen[260];
bool imgui_is_running = false;
int refresh_gui_docking = 0;
ImGuiID dock_main_tabs, dock_tools_windows;
cstr RedockNextWindow;
ImGuiViewport* viewport;
int toolbar_size;
bool g_bInTutorialMode = false;
int g_iCountdownToAlphaBetaMessage = 0;
ImVec4 drawCol_toogle;
int g_EntityClipboardAnchorEntityIndex = -1;
std::vector<int> g_EntityClipboard;

extern preferences pref;
extern cFolderItem MainEntityList;

bool bExport_Standalone_Window = false;
bool bExport_SaveToGameCloud_Window = false;
bool bExternal_Entities_Window = false;
int iDisplayLibraryType = 0;
int iDisplayLibrarySubType = 0;
int iLastDisplayLibraryType = -1;
cstr sStartLibrarySearchString = "";
cstr sTriggerCategorySelect = "";
int iLibraryStingReturnToID = 0;
int iSelectedLibraryStingReturnID = -1;
cstr sMakeDefaultSelecting = "";
cstr sSelectedLibrarySting = "";
bool bSelectLibraryViewAll = false;
bool bExternal_Entities_Init = false;
bool bEntity_Properties_Window = false;
bool bProperties_Window_Block_Mouse = false;
bool bCheckForClosing = false;
bool bCheckForClosingForce = false;
bool bBuilder_Properties_Window = false;
bool bBuilder_Left_Window = false;
bool bTerrain_Tools_Window = false;
bool bWaypoint_Window = false;
bool bDownloadStore_Window = false;
bool bImporter_Window = false;
bool bHelpVideo_Window = false;
bool bHelp_Window = false;
extern char cForceTutorialName[1024];
bool bHelp_Menu_Image_Window = false;
bool bAbout_Window = false;
bool bCredits_Window = false;
bool bBug_Reporting_Window = false;
bool bBug_RefreshBugList = false;
bool bAbout_Window_First_Run = false;
bool bCredits_Window_First_Run = true;
bool bAbout_Init = false;
bool Entity_Tools_Window = true;
bool bInfo_Window = false;
bool bInfo_Reload = false;
bool bInfo_Window_First_Run = true;
cstr cInfoMessage = "";
cstr cInfoImage = "", cInfoImageLast = "";
int iInfoUniqueId = 0;
extern int g_iActiveMonitors;

#ifdef WICKEDENGINE
bool Visuals_Tools_Window = false;
bool Weather_Tools_Window = false;
int iRestoreLastWindow = 0;
std::vector<sRubberBandType> vEntityLockedList;
#define MAXGROUPSLISTS 100
cstr sEntityGroupListName[MAXGROUPSLISTS];
std::vector<sRubberBandType> vEntityGroupList[MAXGROUPSLISTS];
int iEntityGroupListImage[MAXGROUPSLISTS];
bool bPreferences_Window = false;
char cPreferencesMessage[MAX_PATH] = { "\x0" };
bool Shooter_Tools_Window = false; // Shooter_Tools_Window not really a window now, just a filter mode for Object Tools
bool Puzzle_Tools_Window = false; //Not yet active. only for toggle state.
bool RPG_Tools_Window = false; //Not yet active. only for toggle state.
char cNextWindowFocus[256];
bool bEditGameSettings = false;
#endif
int media_icon_size_leftpanel = 64;
int iColumnsWidth_leftpanel = 110;
int iColumns_leftpanel = 0;
bool bDisplayText_leftpanel = true;
float fFontSize_leftpanel = 1.0;

//entityeleproftype backup_grideleprof;  //PE: We dont use a cancel system anymore.
cFolderItem::sFolderFiles *pDragDropFile = NULL;
int iOldgridentity = -1;
float fPropertiesColoumWidth = 100.0f;
bool bTriggerMessage = false;
bool bTriggerSmallMessage = false;
int iTriggerMessageDelay = 0;
int iTriggerMessageFrames = 0;
int iTriggerMessageY = 0;
char cTriggerMessage[MAX_PATH] = "\0";
char cSmallTriggerMessage[MAX_PATH] = "\0";
int iMessageTimer = 0;
ImVec4 drawCol_back;
ImVec4 drawCol_normal;
ImVec4 drawCol_hover;
ImVec4 drawCol_Down;
ImVec4 drawCol_black = { 0,0,0,0 };

extern ISpObjectToken * CCP_SelectedToken;
extern LPSTR pCCPVoiceSet;
extern char CCP_SpeakText[1024];
extern wchar_t CCP_SpeakText_w[1024];
extern int CCP_Speak_Rate;

std::vector<cstr> tutorial_list; //unsorted.
std::map<std::string, std::string> tutorial_files;
std::map<std::string, std::string> tutorial_videos;
std::map<std::string, std::string> tutorial_description;
std::vector<cstr> about_text; //unsorted.

bool bTutorial_Init = false;
int current_tutorial = -1;
int selected_tutorial = 0;
bool bVideoPlayerMaximized = false;
bool bSmallVideoPlayerMaximized = false;
bool bLastSmallVideoPlayerMaximized = false;

bool bVideoResumePossible = false;
bool bVideoPerccentStart = false;
int iVideoFindFirstFrame = 0;
int iVideoDelayExecute = 0;
bool bTutorialCheckAction = false;
int bDelayedTutorialCheckAction = -1;
int iDelayedCameraRestore = 0;
char cForceTutorialName[1024] = "\0";
char cTutorialName[TUTORIALMAXTEXT] = "\0";
cstr cVideoDescription = "";
ActiveTutorial tut;
bool bTutorialRendered = false;
bool bSmallVideoFrameStart = true;
bool bSetTutorialSectionLeft = false;

//Tooltip object code.
int iLastTooltipSelection = -1;
int iTooltipTimer = 0;
int iTooltipHoveredTimer = 0;
int iTooltipLastObjectId = 0;
bool iTooltipAlreadyLoaded = true;
bool iTooltipObjectReady = false;
float lastKeyTime = 0;
char cHelpMenuImage[MAX_PATH];
bool bLostFocus = false;
bool bRenderTargetModalMode = false;
int iStartupTime = 0;
cstr CurrentWinTitle = "";
int speech_ids[5];

extern bool bWaypointDrawmode;
extern float custom_back_color[4];
extern bool bUpdateVeg;
extern int iLastUpdateVeg;

#endif
#endif

// moved here so Classic would compile
bool Shooter_Tools_Window_Active = false;
void DeleteWaypointsAddedToCurrentCursor(void);
void Add_Grid_Snap_To_Position(void);
float ImGuiGetMouseX(void);
float ImGuiGetMouseY(void);
void RotateAndMoveRubberBand(int iActiveObj, float fMovedActiveObjectX, float fMovedActiveObjectY, float fMovedActiveObjectZ, GGQUATERNION quatRotationEvent); //float fMovedActiveObjectRX, float fMovedActiveObjectRY, float fMovedActiveObjectRZ);
void SetStartPositionsForRubberBand(int iActiveObj);

#ifdef WICKEDENGINE
	void HandleObjectDeletion();
	void ControlAdvancedSetting(int&, const char*, bool* = nullptr);
	void TestLevel_ToggleBoundary(bool _2d, bool _3d);
	void TestLevel_ToggleTreeVegWater(bool tree, bool veg, bool water);
#endif

void set_inputsys_mclick(int value)
{
	t.inputsys.mclick = value;

	//char pDebugMouseClick[32];
	//sprintf(pDebugMouseClick, "inputsys.mclick = %d", t.inputsys.mclick);
	//timestampactivity(0, pDebugMouseClick);
}

#ifdef VRTECH
// GLOBAL to know when in welcome area
int iTriggerWelcomeSystemStuff = 0;
#endif
int iCountDownToShowQuickStartDialog = 0;

void gridedit_triggermessagehandler (bool bForceMessageNoFade)
{
	if (!bTriggerMessage && bTriggerSmallMessage && iTriggerMessageFrames > 0)
	{
		ImGuiViewport* mainviewport = ImGui::GetMainViewport();
		if (mainviewport)
		{
			ImDrawList* dl = ImGui::GetForegroundDrawList(mainviewport);
			if (dl)
			{
				ImGuiContext& g = *GImGui;
				float fontscale = 1.25;
				ImVec2 textsize = ImGui::CalcTextSize(cSmallTriggerMessage)  * fontscale;
				float vCenterTextX = (OldrenderTargetSize.x * 0.5) - (textsize.x * 0.5);
				ImVec4 background = ImGui::GetStyle().Colors[ImGuiCol_WindowBg];
				background.w = 0.7;

				dl->AddRectFilled(ImVec2(OldrenderTargetPos.x + vCenterTextX - 2.0, OldrenderTargetPos.y + 50.0 - 2.0), ImVec2(OldrenderTargetPos.x + vCenterTextX + textsize.x + 2.0, OldrenderTargetPos.y + 50.0 + textsize.y + 2.0), ImGui::GetColorU32(background), 2.0, ImDrawCornerFlags_All);
				dl->AddText(g.Font, g.FontSize * fontscale, ImVec2(OldrenderTargetPos.x + vCenterTextX, OldrenderTargetPos.y + 50.0 ), ImGui::GetColorU32(ImGuiCol_Text), cSmallTriggerMessage);
			}
		}
		iTriggerMessageFrames--;
		if (iTriggerMessageFrames == 0)
		{
			cSmallTriggerMessage[0] = 0;
			bTriggerSmallMessage = false;
		}
	}
	if (bTriggerMessage)
	{
		if (iTriggerMessageDelay > 0)
		{
			iTriggerMessageDelay--;
			return;
		}

		if (iTriggerMessageY == 1)
		{
			if (iMessageTimer == 0 || Timer() - iMessageTimer > 8100)
				iMessageTimer = Timer();
		}
		else
		{
			if (iMessageTimer == 0 || Timer() - iMessageTimer > 4100)
				iMessageTimer = Timer();
		}
		ImGuiViewport* viewport = ImGui::GetMainViewport();
		ImGui::SetNextWindowViewport(viewport->ID);
		if (iTriggerMessageY > 0)
		{
			ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
			ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;
			ImGui::SetNextWindowPos(viewPortPos + ImVec2(50, 24+iTriggerMessageY), ImGuiCond_Always);
			ImGui::SetNextWindowSize(ImVec2(viewPortSize.x - 100, 0), ImGuiCond_Always);
		}
		else
		{
			//ImGui::SetNextWindowPos(OldrenderTargetPos + ImVec2(50, 50), ImGuiCond_Always);
			//ImGui::SetNextWindowSize(ImVec2(OldrenderTargetSize.x - 100, 0), ImGuiCond_Always);

			//PE: Now always center on viewport instead of rendertarget. as we now are inside storyboard.
			ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
			ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;
			ImGui::SetNextWindowPos(viewPortPos + ImVec2(200, 130), ImGuiCond_Always);
			ImGui::SetNextWindowSize(ImVec2(viewPortSize.x - 400, 0), ImGuiCond_Always);
		}
		bool winopen = true;

		ImVec4* style_colors = ImGui::GetStyle().Colors;
		ImVec4 oldBgColor = style_colors[ImGuiCol_WindowBg];
		ImVec4 oldTextColor = style_colors[ImGuiCol_Text];

		float fader = 1.0f;
		if (bForceMessageNoFade == false)
		{
			if (iTriggerMessageY == 1)
				fader = ((float)Timer() - (float)iMessageTimer) / 1500.0f;
			else
				fader = ((float)Timer() - (float)iMessageTimer) / 1000.0f;

			fader -= 1.0;
			if (fader < 0) {
				fader = 0.0001;
			}
			fader /= 3.0;
			fader = 1.0 - fader;
			if (fader < 0.1)
			{
				bTriggerMessage = false;
				bTriggerSmallMessage = false;
				iTriggerMessageY = 0;
				iMessageTimer = 0;
			}
		}

		style_colors[ImGuiCol_WindowBg].x = 0.0;
		style_colors[ImGuiCol_WindowBg].y = 0.0;
		style_colors[ImGuiCol_WindowBg].z = 0.0;
		if (iTriggerMessageY == 1)
			style_colors[ImGuiCol_WindowBg].w *= (fader*0.85);
		else
			style_colors[ImGuiCol_WindowBg].w *= (fader*0.5);

		style_colors[ImGuiCol_Text].x = 1.0;
		style_colors[ImGuiCol_Text].y = 1.0;
		style_colors[ImGuiCol_Text].z = 1.0;
		style_colors[ImGuiCol_Text].w *= fader;

		ImGui::Begin("##Messageinfo", &winopen, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoInputs);
		ImGui::SetWindowFontScale(2.0);
		ImGui::Text(" ");
		float fTextSize = ImGui::CalcTextSize(cTriggerMessage).x;
		ImGui::SetCursorPos(ImVec2((ImGui::GetWindowSize().x*0.5) - (fTextSize*0.5), ImGui::GetCursorPos().y));

		ImGui::Text(cTriggerMessage);
		ImGui::Text(" ");
		ImGui::SetWindowFontScale(1.0);
		ImGui::End();
		style_colors[ImGuiCol_WindowBg] = oldBgColor;
		style_colors[ImGuiCol_Text] = oldTextColor;
	}
}

int gguishadereffectindex = 0;
// mapeditor inits and loop call
void mapeditorexecutable_init ( void )
{
	//  Means we are in the editor (1) or in standalone game (0)
	timestampactivity(0,"ide input mode");
	g.globals.ideinputmode = 1;

	// Wicked skips VR for now to speed up launch
	bool bSkipVRForNow = false;
	#ifdef WICKEDENGINE
	if(g.gvrmodefordevelopers==1)
		bSkipVRForNow = false; // for users who wish to play with half-baked VR 
	else
		bSkipVRForNow = true; // saves 1750ms from init below!!!
	#endif

	// No VR or RIFTMODE in Editor Mode
	g.globals.riftmode = 0;
	#ifdef VRTECH
	g.vrglobals.GGVREnabled = 0; 
	if (bSkipVRForNow == true)
	{
		timestampactivity(0, "VR System disabled to improve launch speed (temporary)");
		g.vrglobals.GGVRUsingVRSystem = 1;
	}
	else
	{
		g.vrglobals.GGVRUsingVRSystem = 1;
		if (g.gvrmode == 2) g.vrglobals.GGVREnabled = 1; // OpenVR (Steam)
		if (g.gvrmode == 3) g.vrglobals.GGVREnabled = 2; // Windows Mixed Reality (Microsoft)
		char pVRSystemString[1024];
		sprintf(pVRSystemString, "choose VR system with mode %d", g.vrglobals.GGVREnabled);
		timestampactivity(0, pVRSystemString);
		int iErrorCode = GGVR_ChooseVRSystem(g.vrglobals.GGVREnabled, g.gproducelogfiles, "");// cstr(g.fpscrootdir_s + "\\GGWMR.dll").Get() );
		if (iErrorCode > 0)
		{
			// if VR headset is not present, switch VR off to speed up non-VR rendering (especially for debug)
			char pErrorStr[1024];
			sprintf(pErrorStr, "Error Choosing VR System : Code %d", iErrorCode);
			timestampactivity(0, pErrorStr);
			timestampactivity(0, "switching VR off, headset not detected");
			g.vrglobals.GGVREnabled = 0;
		}
		else
		{
			//PE: Only if we use vr.
			if (g.gvrmode > 0)
			{
				// Give portal enough time to start its launch, then get rid of GameWindow until we need it!
				//Sleep(1900); seems daft pausing every launch just in case WMR Portal is not already active, reduce
				Sleep(10);
				CloseWindow(g_pGlob->hOriginalhWnd);
				Sleep(10);
				g_pGlob->hOriginalhWnd = NULL;
				SetWindowPos(g_pGlob->hWnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
			}
		}
	}
	#endif
	
	//  Set device to get multisampling AA active in editor
	t.multisamplingfactor=0;
	t.multimonitormode=0;

	//  Init app
	timestampactivity(0,"sync states");
	SyncOn (   ); SyncRate (  0 );
	t.strwork = "" ; t.strwork = t.strwork + t.strarr_s[475]+" - [Editor]";
	timestampactivity(0,"window states");
	ShowWindow ( ); WindowToFront (  t.strwork.Get() );
	AlwaysActiveOff ( );

	/* LB: We manually convert all X files to DBO as they are added to build, so this not needed!
	// No longer want X files in the core files (replace them as we find them)
	#ifdef WICKEDENGINE
	// Character Creator Parts Folders
	bool bFoundAndConvertedCharacterCreatorPartsModel = false;
	LPSTR pOldDir = GetDir();
	for (int iFolder = 0; iFolder < 3; iFolder++)
	{
		if ( iFolder == 0 ) SetDir("charactercreatorplus\\parts\\adult male\\");
		if ( iFolder == 1 ) SetDir("charactercreatorplus\\parts\\adult female\\");
		if ( iFolder == 2 ) SetDir("charactercreatorplus\\parts\\zombie male\\");
		ChecklistForFiles();
		for (int c = 0; c < ChecklistQuantity(); c++)
		{
			LPSTR pFile = ChecklistString(1 + c);
			if (pFile && strlen(pFile) > 2 && strnicmp(pFile + strlen(pFile) - 2, ".x", 2) == NULL)
			{
				//PE: default animations.X fails.

				// found X file, convert to DBO now
				if (ObjectExist(g.entityworkobjectoffset) == 1) DeleteObject(g.entityworkobjectoffset);
				LoadObject(pFile, g.entityworkobjectoffset);
				char pDBOFile[MAX_PATH];
				strcpy(pDBOFile, pFile);
				pDBOFile[strlen(pDBOFile) - 2] = 0;
				strcat(pDBOFile, ".dbo");
				if (FileExist(pDBOFile)) DeleteFileA(pDBOFile);
				SaveObject(pDBOFile, g.entityworkobjectoffset);
				bFoundAndConvertedCharacterCreatorPartsModel = true;

				// and remove the old X file for easier cleanup (keep backups in dropbox)
				if (FileExist(pDBOFile)) DeleteFileA(pFile);
			}
		}
		SetDir(pOldDir);
	}
	if (ObjectExist(g.entityworkobjectoffset) == 1) DeleteObject(g.entityworkobjectoffset);
	if (bFoundAndConvertedCharacterCreatorPartsModel == true)
	{
		MessageBoxA(NULL, "Found and converted a Character Creator Parts Model", "CCP", MB_OK);
	}
	#endif
	*/

	#ifdef VRTECH
	// start thread loader for for generic (startup) files (multi-threaded loading)
	generic_preloadfiles();
	#endif

	// moved auth check to void Master::Update(float dt) - as early as possible!

	// So entirely replace fixed function rendering, use this shader effect
	g.guishadereffectindex = loadinternaleffect("effectbank\\reloaded\\gui_basic.fx");
	gguishadereffectindex = g.guishadereffectindex;
	g.guidiffuseshadereffectindex = loadinternaleffect("effectbank\\reloaded\\gui_diffuse.fx");
	g.guiwireframeshadereffectindex = loadinternaleffect("effectbank\\reloaded\\gui_wireframe.fx");
	g.guidepthshadereffectindex = loadinternaleffect("effectbank\\reloaded\\gui_showdepth.fx");

	//  Camera aspect ratio adjustment for desktop resolution
	timestampactivity(0,"camera states");
	t.aspect_f=GetDesktopWidth() ; t.aspect_f=t.aspect_f/GetDesktopHeight();
	SetCameraAspect ( t.aspect_f );

	//  Set editor to use a true 1;1 pixel mapping for Text ( , Steam GUI and other overlay images )
	// moved higher up
	//timestampactivity(0,"pixel states");
	//SetChildWindowTruePixel ( 1 );
	//common_refreshDisplaySize ( );

	// 111115 - base start memory for GameGuru (overwritten if g.grestoreeditorsettings==0)
	timestampactivity(0,"memory states");
	g.gamememactuallyusedstart=SMEMAvailable(1);

	#ifdef VRTECH
	// Reset texture/profile in EBE folder
	ebe_restoreebedefaulttextures();
	#endif

	//  Early editor only inits
	timestampactivity(0,"pre widget init state");
	t.tsplashstatusprogress_s="WIDGET INIT";
	timestampactivity(0,t.tsplashstatusprogress_s.Get());
	timestampactivity(0,"widget status update");
	version_splashtext_statusupdate ( );
	widget_init ( );

	t.tsplashstatusprogress_s="SLIDERS INIT";
	timestampactivity(0,t.tsplashstatusprogress_s.Get());
	version_splashtext_statusupdate ( );
	sliders_init ( );

	//  Generic asset loading common to editor and game
	t.tresetforstartofeditor=1;
	t.tsplashstatusprogress_s="LOAD COMMON ASSETS";
	timestampactivity(0,t.tsplashstatusprogress_s.Get());
	version_splashtext_statusupdate ( );
	common_loadcommonassets ( 0 );

	//  Initialise meshes and editor resources
	t.tsplashstatusprogress_s="INIT EDITOR RESOURCES";
	timestampactivity(0,t.tsplashstatusprogress_s.Get());
	version_splashtext_statusupdate ( );
	t.lastgrideditselect=-1;
	g.gmapeditmode = 1;
	editor_init ( );

	//  Load resource file which has test game memory usage data contained
	t.tsplashstatusprogress_s="LOAD MAIN RESOURCES";
	timestampactivity(0,t.tsplashstatusprogress_s.Get());
	version_splashtext_statusupdate ( );
	loadresource();

	//  Call visuals loop once to set shader constants
	t.tsplashstatusprogress_s="UPDATE VISUAL SETTINGS";
	timestampactivity(0,t.tsplashstatusprogress_s.Get());
	version_splashtext_statusupdate ( );
	t.visuals=t.editorvisuals;
	t.visuals.refreshshaders=1;
	visuals_loop ( );
	visuals_shaderlevels_update ( );

	#ifdef WICKEDENGINE
	//PE: FOV has changed here if on widescreen that adjust fov depending on aspect ratio.
	//PE: We must refesh the windows to account for the new fov.
	float gpw = master.masterrenderer.GetWidth3D();
	float gph = master.masterrenderer.GetHeight3D();
	if (((float)gpw / (float)gph) > 2.1 && gpw > 1920)
	{
		bTriggerFovUpdate = true; //PE: Set FOV.
	}
	#endif

	// Load map editior settings
	t.bTriggerNewMapAtStart = true;
	t.bIgnoreFirstCallToNewLevel = false;
	if ( g.grestoreeditorsettings == 1 ) 
	{
		t.tsplashstatusprogress_s="RESTORE LAST PROJECT";
		timestampactivity(0,t.tsplashstatusprogress_s.Get());
		version_splashtext_statusupdate ( );
		//popup_text_close();
		t.tfile_s = g.mysystem.editorsGridedit_s+"cfg.cfg";//"editors\\gridedit\\cfg.cfg";
		if ( FileExist(t.tfile_s.Get()) == 1 ) 
		{
			//  Load last Editor CFG Settings
			t.skipfpmloading=1;
			editor_loadcfg ( );

			//  load project specified in CFG (worklevel.fpm?)
			mapfile_loadproject_fpm ( );

			//  Now wipe config (in case we fail to load in restart, we avoid an infinite loop)
			if (  FileExist(t.tfile_s.Get()) == 1  ) DeleteAFile ( t.tfile_s.Get() );

			//  load in current files in LEVELBANK\TESTMAP (not from FPM)
			gridedit_load_map ( );
			#ifdef WICKEDENGINE
			t.terrain.grassregionx1 = t.terrain.grassregionx2;
			grass_init();
			//bUpdateVeg = true;
			extern int g_iSuperTriggerFullGrassReveal; // hmm, shoved in to get the damn grass showing on initial load!
			g_iSuperTriggerFullGrassReveal = 10;
			#endif
			t.skipfpmloading=0;
		}
	}
	else
	{
		// Start Splash (only one which does not wait for Sync ( -as interface not avail. in debug) )
		t.tsplashstatusprogress_s="";
		timestampactivity(0,t.tsplashstatusprogress_s.Get());
		version_splashtext_statusupdate ( );
		//version_splashtext ( );
	}

	//  trigger zoom to aquire camera range for editor
	t.updatezoom=1;

	//  Start resource bar must accurately reflect ALL data loaded by editor
	if ( g.grestoreeditorsettings==0 )
	{
		t.gamememactuallyusedstarttriggercount = 5; // 111115 - one trigger to get STARTMEM at beginning of GameGuru session execution (honest value)
	}

	//  Var to control machine independent speed
	game_timeelapsed_init ( );
	t.tsl_f=Timer();

	// IDE announcement system (note VR Quest has this option)
	#ifdef VRTECH
	// (note VR Quest has this option)
	iTriggerWelcomeSystemStuff = 1;
	#endif
#ifdef STORYBOARD
	if (g.gshowannouncements == 1)
	{
		bTriggerWhatsNewInStoryboard = true;
	}
#else
	if ( g.gshowannouncements == 1 )
	{
		welcome_init(1);
		welcome_init(0);
		welcome_show(WELCOME_ANNOUNCEMENTS);
	}
#endif
	// only show front dialogs if not resuming from previous session
	int iCountDownToShowQuickStartDialog = 0;
	if ( g.grestoreeditorsettings == 0 ) 
	{
		// Welcome quick start page
		g.quickstartmenumode = 0;
		if ( g.iFreeVersionModeActive != 0 )
		{
			editor_showquickstart ( 0 );
			welcome_free();
		}
		else
		{
			if (g.gshowonstartup == 1 || g.iTriggerSoftwareToQuit != 0) 
			{
				editor_showquickstart(0);
				welcome_free(); //PE: We must always close it for level auto load to work.
			}
			else
			{
				welcome_free();
			}
		}
	}
	else
	{
		// always need to close down loading splash
		welcome_free();
	}

	// After 5 minutes, trigger another trial reminder
	DWORD dwStartOfEditingSession = timeGetTime() + (1000*60*5);
	DWORD dwSecondReminder = 0;

	#ifdef ENABLEIMGUI
	//Load needed images.
	image_preload_files_reset(); //PE: At this point we have no more thread loaded images to use.
	SetMipmapNum(1); //PE: mipmaps not needed.
	image_setlegacyimageloading(true);

	LoadImage("editors\\uiv3\\shape.png", TOOL_SHAPE);
	LoadImage("editors\\uiv3\\level.png", TOOL_LEVELMODE);
	LoadImage("editors\\uiv3\\storedlevel.png", TOOL_STOREDLEVEL);
	LoadImage("editors\\uiv3\\blendmode.png", TOOL_BLENDMODE);
	LoadImage("editors\\uiv3\\rampmode.png", TOOL_RAMPMODE);
	LoadImage("editors\\uiv3\\painttexture.png", TOOL_PAINTTEXTURE);
	LoadImage("editors\\uiv3\\paintgrass.png", TOOL_PAINTGRASS);
	LoadImage("editors\\uiv3\\entity.png", TOOL_ENTITY);
	LoadImage("editors\\uiv3\\markers.png", TOOL_MARKERS);
	LoadImage("editors\\uiv3\\waypoints.png", TOOL_WAYPOINTS);
	LoadImage("editors\\uiv3\\newwaypoints.png", TOOL_NEWWAYPOINTS);
	LoadImage("editors\\uiv3\\testgame.png", TOOL_TESTGAME);
	LoadImage("editors\\uiv3\\vrmode.png", TOOL_VRMODE);
	#ifdef WICKEDENGINE
	LoadImage("editors\\uiv3\\savestandalone.png", TOOL_SOCIALVR);
	#else
	LoadImage("editors\\uiv3\\socialvr.png", TOOL_SOCIALVR);
	#endif
	LoadImage("editors\\uiv3\\newlevel.png", TOOL_NEWLEVEL);
	LoadImage("editors\\uiv3\\loadlevel.png", TOOL_LOADLEVEL);
	LoadImage("editors\\uiv3\\savelevel.png", TOOL_SAVELEVEL);
	LoadImage("editors\\uiv3\\rounding_overlay_style0-h.png", ROUNDING_OVERLAY);
	LoadImage("editors\\uiv3\\ebe-block.png", EBE_BLOCK);
	LoadImage("editors\\uiv3\\ebe-column.png", EBE_COLUMN);
	LoadImage("editors\\uiv3\\ebe-cube.png", EBE_CUBE);
	LoadImage("editors\\uiv3\\ebe-floor.png", EBE_FLOOR);
	LoadImage("editors\\uiv3\\ebe-new.png", EBE_NEW);
	LoadImage("editors\\uiv3\\ebe-row.png", EBE_ROW);
	LoadImage("editors\\uiv3\\ebe-stairs.png", EBE_STAIRS);
	LoadImage("editors\\uiv3\\ebe-wall.png", EBE_WALL);
	LoadImage("editors\\uiv3\\builder.png", TOOL_BUILDER);
	LoadImage("editors\\uiv3\\ccp.png", TOOL_CCP);
	LoadImage("editors\\uiv3\\import.png", TOOL_IMPORT);
	LoadImage("editors\\uiv3\\media-play.png", MEDIA_PLAY);
	LoadImage("editors\\uiv3\\media-pause.png", MEDIA_PAUSE);
	LoadImage("editors\\uiv3\\media-refresh.png", MEDIA_REFRESH);
	LoadImage("editors\\uiv3\\media-record.png", MEDIA_RECORD);
	LoadImage("editors\\uiv3\\media-recording.png", MEDIA_RECORDING);
	LoadImage("editors\\uiv3\\media-recordprocessing.png", MEDIA_RECORDPROCESSING);
	LoadImage("editors\\uiv3\\pointer2.png", TUTORIAL_POINTER);
	LoadImage("editors\\uiv3\\pointer3.png", TUTORIAL_POINTERUP);	
	#ifdef USETOOLBARHEADER
	LoadImage("editors\\uiv3\\theader.png", TOOL_HEADER);
	#endif
	#ifdef WICKEDENGINE
	if (FileExist("editors\\uiv3\\gameguru-max-logo-ea2.png"))
	{
		LoadImage("editors\\uiv3\\gameguru-max-logo-ea2.png", ABOUT_LOGO);
		iAboutLogoType = 2;
	}
	else
	{
		LoadImage("editors\\uiv3\\gameguru-max-logo-ea.png", ABOUT_LOGO);
		iAboutLogoType = 0;
	}
	#else
	LoadImage("editors\\uiv3\\ABOUT-Logo.png", ABOUT_LOGO);
	#endif
	LoadImage("editors\\uiv3\\ABOUT-TGC.png", ABOUT_TGC);
	LoadImage("editors\\uiv3\\ABOUT-Country.png", ABOUT_HB);
	LoadImage("editors\\uiv3\\ebe-control1.png", EBE_CONTROL1);
	LoadImage("editors\\uiv3\\ebe-control2.png", EBE_CONTROL2);
	LoadImage("editors\\uiv3\\shape-up.png", TOOL_SHAPE_UP);
	LoadImage("editors\\uiv3\\shape-down.png", TOOL_SHAPE_DOWN);
	LoadImage("editors\\uiv3\\drawwaypoints.png", TOOL_DRAWWAYPOINTS);
	LoadImage("editors\\uiv3\\dotcircle.png", TOOL_DOTCIRCLE);
	LoadImage("editors\\uiv3\\dotcircles.png", TOOL_DOTCIRCLE_S);
	LoadImage("editors\\uiv3\\dotcirclem.png", TOOL_DOTCIRCLE_M);
	#ifdef WICKEDENGINE
	LoadImage("editors\\uiv3\\ent-properties.png", TOOL_ENT_EDIT);
	LoadImage("editors\\uiv3\\ent-extract.png", TOOL_ENT_EXTRACT);
	LoadImage("editors\\uiv3\\ent-duplicate.png", TOOL_ENT_DUPLICATE);
	LoadImage("editors\\uiv3\\ent-lock.png", TOOL_ENT_LOCK);
	LoadImage("editors\\uiv3\\ent-findfloor.png", TOOL_ENT_FINDFLOOR);
	LoadImage("editors\\uiv3\\ent-delete.png", TOOL_ENT_DELETE);
	LoadImage("editors\\uiv3\\ent-search.png", TOOL_ENT_SEARCH);
#endif	
	#ifdef PRODUCTV3
	#else
	LoadImage("editors\\uiv3\\circle.png", TOOL_CIRCLE);
	LoadImage("editors\\uiv3\\circles.png", TOOL_CIRCLE_S);
	LoadImage("editors\\uiv3\\circlem.png", TOOL_CIRCLE_M);
	#endif

	#ifdef WICKEDENGINE
	LoadImage("editors\\uiv3\\environment.png", TOOL_VISUALS);
	LoadImage("editors\\uiv3\\camera.png", TOOL_CAMERA);
	LoadImage("editors\\uiv3\\light.png", TOOL_CAMERALIGHT);
	LoadImage("editors\\uiv3\\goback.png", TOOL_GOBACK);
	LoadImage("editors\\uiv3\\media-maximize.png", MEDIA_MAXIMIZE);
	LoadImage("editors\\uiv3\\media-minimize.png", MEDIA_MINIMIZE);


	LoadImage("editors\\uiv3\\weather-sun.png", ENV_SUN);
	LoadImage("editors\\uiv3\\weather-rain.png", ENV_RAIN);
	LoadImage("editors\\uiv3\\weather-snow.png", ENV_SNOW);
	LoadImage("editors\\uiv3\\weather.png", ENV_WEATHER);

	LoadImage("editors\\uiv3\\rpg-game.png", TOOL_RPG);
	LoadImage("editors\\uiv3\\puzzle.png", TOOL_PUZZLE);
	LoadImage("editors\\uiv3\\shooter.png", TOOL_SHOOTER);
	
	LoadImage("entitybank\\_markers\\Trigger Zone.bmp", TOOL_TRIGGERZONE);
	LoadImage("entitybank\\_markers\\flag.bmp", TOOL_FLAG);

	LoadImage("editors\\uiv3\\pencil-small.png", TOOL_PENCIL);

	//LoadImage("editors\\uiv3\\dotchrome.dds", UI3D_DOTOBJECTS);// dotobject.png", UI3D_DOTOBJECTS);
	//LoadImage("editors\\uiv3\\brain_marker.dds", UI3D_DOTMIDDLEOBJECTS);//dotmiddleobject.png", UI3D_DOTMIDDLEOBJECTS);
	//LoadImage("editors\\uiv3\\brain_mark_three.png", UI3D_DOTMIDDLEOBJECTS);//dotmiddleobject.png", UI3D_DOTMIDDLEOBJECTS);
	LoadImage("editors\\uiv3\\logichighlight.png", UI3D_DOTOBJECTS);	
	LoadImage("editors\\uiv3\\brain_logic_marker.dds", UI3D_DOTMIDDLEOBJECTS);

	LoadImage("editors\\uiv3\\shape-circle.png", SHAPE_CIRCLE);
	LoadImage("editors\\uiv3\\shape-square.png", SHAPE_SQUARE);


	LoadImage("editors\\uiv3\\key-alt.png", KEY_ALT);
	LoadImage("editors\\uiv3\\key-backspace.png", KEY_BACKSPACE);
	LoadImage("editors\\uiv3\\keyboard.png", KEY_KEYBOARD);
	LoadImage("editors\\uiv3\\key-control.png", KEY_CONTROL);
	LoadImage("editors\\uiv3\\key-minus.png", KEY_MINUS);
	LoadImage("editors\\uiv3\\key-plus.png", KEY_PLUS);
	LoadImage("editors\\uiv3\\key-shift.png", KEY_SHIFT);
	LoadImage("editors\\uiv3\\key-tab.png", KEY_TAB);
	LoadImage("editors\\uiv3\\left-mouse-button.png", MOUSE_LMB);
	LoadImage("editors\\uiv3\\right-mouse-button.png", MOUSE_RMB);

	LoadImage("editors\\uiv3\\key-r.png", KEY_R);
	LoadImage("editors\\uiv3\\key-delete.png", KEY_DELETE);
	LoadImage("editors\\uiv3\\key-y.png", KEY_Y);
	LoadImage("editors\\uiv3\\key-return.png", KEY_RETURN);
	LoadImage("editors\\uiv3\\key-pgup.png", KEY_PGUP);
	LoadImage("editors\\uiv3\\key-pgdn.png", KEY_PGDN);
	LoadImage("editors\\uiv3\\key-f.png", KEY_F);
	LoadImage("editors\\uiv3\\key-g.png", KEY_G);
	LoadImage("editors\\uiv3\\key-z.png", KEY_Z);
	LoadImage("editors\\uiv3\\key-i.png", KEY_I);

	LoadImage("editors\\uiv3\\key-n.png", KEY_N);
	LoadImage("editors\\uiv3\\key-l.png", KEY_L);
	LoadImage("editors\\uiv3\\key-e.png", KEY_E);
	LoadImage("editors\\uiv3\\key-space.png", KEY_SPACE);
	LoadImage("editors\\uiv3\\key-t.png", KEY_T);
	LoadImage("editors\\uiv3\\key-o.png", KEY_O);
	LoadImage("editors\\uiv3\\key-q.png", KEY_Q);


	LoadImage("editors\\uiv3\\key-separator.png", KEY_SEPARATOR);
	LoadImage("editors\\uiv3\\key-separator-small.png", KEY_SEPARATOR_SMALL);

	LoadImage("editors\\uiv3\\favoritesmall.png", MEDIA_FAVORITE);

	LoadImage("editors\\uiv3\\group-edit.png", TOOL_GROUPEDIT);
	LoadImage("editors\\uiv3\\ungroup.png", TOOL_UNGROUP);
	LoadImage("editors\\uiv3\\group.png", TOOL_GROUP);
	LoadImage("editors\\uiv3\\group-save.png", TOOL_GROUPSAVE);

	LoadImage("editors\\uiv3\\trashcan.png", TOOL_TRASHCAN);
	LoadImage("editors\\uiv3\\unlock-tools.png", TOOL_UNLOCK);
	LoadImage("editors\\uiv3\\lock-tools.png", TOOL_LOCK);
	LoadImage("editors\\uiv3\\smart-object.png", TOOL_SMARTOBJECT);
	
	LoadImage("editors\\uiv3\\favoritesmall-dis.png", MEDIA_FAVORITE_DIS);
	LoadImage("editors\\uiv3\\key-maximize.png", KEY_MAXIMIZE);

	LoadImage("editors\\uiv3\\middle-mouse-button.png", MOUSE_MMB);

	LoadImage("editors\\uiv3\\object-horizontal.png", OBJECT_MOVE_XZ);
	LoadImage("editors\\uiv3\\object-vert.png", OBJECT_MOVE_Y);
	LoadImage("editors\\uiv3\\object-surface.png", OBJECT_MOVE_SURFACESCAN);
	LoadImage("editors\\uiv3\\object-findfloor.png", OBJECT_MOVE_FINDFLOOR);
	LoadImage("editors\\uiv3\\object-orientation.png", OBJECT_MOVE_ORIENTATION);
	LoadImage("editors\\uiv3\\object-lock.png", OBJECT_MOVE_LOCK);
	LoadImage("editors\\uiv3\\object-unlock.png", OBJECT_MOVE_UNLOCK);

	LoadImage("editors\\uiv3\\key-control-shift.png", KEY_CONTROL_SHIFT);

	LoadImage("editors\\uiv3\\i-info.png", ICON_INFO);
	LoadImage("editors\\uiv3\\temp_infinity.png", IMPORTER_ALL_MESH);

	LoadImage("editors\\uiv3\\ent-filter.png", TOOL_ENT_FILTER);

	LoadImage("editors\\marketplace\\ggmax.png", MARKETPLACE_GGMAX);
	LoadImage("editors\\marketplace\\gc-store.png", MARKETPLACE_GCSTORE);
	LoadImage("editors\\marketplace\\sketchfab.png", MARKETPLACE_SKETCHFAB);
	LoadImage("editors\\marketplace\\filler.png", MARKETPLACE_FILLER);
	LoadImage("editors\\marketplace\\marketplace.png", MARKETPLACE_HEADER);
	LoadImage("editors\\marketplace\\shockwave-sound.png", MARKETPLACE_SHOCKWAVESOUND);
	LoadImage("editors\\marketplace\\community.png", MARKETPLACE_COMMUNITY);
	
	#ifdef FREETRIALONDISCOUNT
	LoadImage("editors\\freetrial\\header-sale.png", FREETRIAL_HEADER);
	LoadImage("editors\\freetrial\\body-sale.png", FREETRIAL_BODY);
	#else
	LoadImage("editors\\freetrial\\header.png", FREETRIAL_HEADER);
	LoadImage("editors\\freetrial\\body.png", FREETRIAL_BODY);
	#endif
	LoadImage("editors\\freetrial\\notavailable.png", FREETRIAL_NOTAVAILABLE);
	LoadImage("editors\\freetrial\\oldschooldigit-base-50px.png", FREETRIAL_COUNTER_BASE);
	LoadImage("editors\\freetrial\\header-sale-oneday.png", FREETRIAL_COUNTER_ONEDAY);			
	LoadImage("editors\\uiv3\\filler-rounded.png", WELCOME_FILLERROUNDED);

	LPSTR pWelcomeHeaderHUB = "editors\\uiv3\\welcome-header-ea3.png";
	if (g_bFreeTrialVersion == true)
	{
		pWelcomeHeaderHUB = "editors\\freetrial\\welcome-header-ea3.png";
	}
	if (FileExist(pWelcomeHeaderHUB))
	{
		LoadImage(pWelcomeHeaderHUB, WELCOME_HEADER);
		iWelcomeHeaderType = 3;
	}
	else if (FileExist("editors\\uiv3\\welcome-header-ea2.png"))
	{
		LoadImage("editors\\uiv3\\welcome-header-ea2.png", WELCOME_HEADER);
		iWelcomeHeaderType = 2;
	}
	else if (FileExist("editors\\uiv3\\welcome-header-ea.png"))
	{
		LoadImage("editors\\uiv3\\welcome-header-ea.png", WELCOME_HEADER);
		iWelcomeHeaderType = 1;
	}
	else
	{
		LoadImage("editors\\uiv3\\welcome-header.png", WELCOME_HEADER);
		iWelcomeHeaderType = 0;
	}

	LoadImage("editors\\uiv3\\filetype-ogg.png", FILETYPE_OGG);
	LoadImage("editors\\uiv3\\filetype-wav.png", FILETYPE_WAV);
	LoadImage("editors\\uiv3\\filetype-mp3.png", FILETYPE_MP3);


	LoadImage("editors\\uiv3\\filetype-video.png", FILETYPE_VIDEO);

	LoadImage("editors\\uiv3\\player-start.png", PLAYER_START);
	LoadImage("editors\\uiv3\\player-start2.png", PLAYER_START2);
	LoadImage("editors\\uiv3\\filetype-particle.png", FILETYPE_PARTICLE);

	SetIconSet(true);
	SetMipmapNum(1); //PE: mipmaps not needed.
	image_setlegacyimageloading(true);


	LoadImage("editors\\uiv3\\light-point.png", LIGHT_POINT);
	LoadImage("editors\\uiv3\\light-spot.png", LIGHT_SPOT);

	LoadImage("editors\\uiv3\\checkbox-character-off.png", FILTER_CHAR_OFF);
	LoadImage("editors\\uiv3\\checkbox-character-on.png", FILTER_CHAR_ON);
	LoadImage("editors\\uiv3\\checkbox-scenary-off.png", FILTER_SCENARY_OFF);
	LoadImage("editors\\uiv3\\checkbox-scenary-on.png", FILTER_SCENARY_ON);
	LoadImage("editors\\uiv3\\checkbox-favorite-off.png", FILTER_FAVORITE_OFF);
	LoadImage("editors\\uiv3\\checkbox-favorite-on.png", FILTER_FAVORITE_ON);
	LoadImage("editors\\uiv3\\checkbox-hud-off.png", FILTER_HUD_OFF);
	LoadImage("editors\\uiv3\\checkbox-hud-on.png", FILTER_HUD_ON);
	LoadImage("editors\\uiv3\\checkbox-elements-off.png", FILTER_ELEMENTS_OFF);
	LoadImage("editors\\uiv3\\checkbox-elements-on.png", FILTER_ELEMENTS_ON);
	LoadImage("editors\\uiv3\\checkbox-user-off.png", FILTER_USER_OFF);
	LoadImage("editors\\uiv3\\checkbox-user-on.png", FILTER_USER_ON);
	LoadImage("editors\\uiv3\\checkbox-dlua-off.png", FILTER_DLUA_OFF);
	LoadImage("editors\\uiv3\\checkbox-dlua-on.png", FILTER_DLUA_ON);

	LoadImage("editors\\uiv3\\pin.png", MEDIA_PIN);
	LoadImage("editors\\uiv3\\unpin.png", MEDIA_UNPIN);
	LoadImage("editors\\uiv3\\tool-mountain.png", TOOL_TERRAIN_TOOLBAR);

	LoadImage("editors\\uiv3\\ccp-none.png", CCP_NONE);
	LoadImage("editors\\uiv3\\ccp-empty.png", CCP_EMPTY);

	LoadImage("editors\\uiv3\\terrain-random.png", TERRAIN_RANDOM);
	LoadImage("editors\\uiv3\\terrain-pick.png", TERRAIN_PICK);
	LoadImage("editors\\uiv3\\terrain-write.png", TERRAIN_WRITE);
	LoadImage("editors\\uiv3\\terrain-restore.png", TERRAIN_RESTORE);

	//
	if (FileExist("editors\\uiv3\\storyboard-header5-ea.png"))
	{
		LoadImage("editors\\uiv3\\storyboard-header5-ea.png", STORYBOARD_HEADER);
		g_Storyboard_header_height = 114.0f; //PE: Way better on ultra wide monitors.
	}
	else if (FileExist("editors\\uiv3\\storyboard-header4-ea.png"))
	{
		LoadImage("editors\\uiv3\\storyboard-header4-ea.png", STORYBOARD_HEADER);
		g_Storyboard_header_height = 130.0f; //PE: Way better on ultra wide monitors.
	}
	else if (FileExist("editors\\uiv3\\storyboard-header3-ea.png"))
	{
		LoadImage("editors\\uiv3\\storyboard-header3-ea.png", STORYBOARD_HEADER);
		g_Storyboard_header_height = 130.0f; //PE: Way better on ultra wide monitors.
	}
	else
	{
		LoadImage("editors\\uiv3\\storyboard-header2-ea.png", STORYBOARD_HEADER);
		g_Storyboard_header_height = 150.0f;
	}
	LoadImage("editors\\uiv3\\entity_image2.png", STORYBOARD_BACKDROP);
	LoadImage("editors\\uiv3\\entity_music2.png", STORYBOARD_MUSIC);
	LoadImage("editors\\uiv3\\entity_checkpoint2.png", STORYBOARD_PREVIEW);
	LoadImage("editors\\templates\\backdrops\\transparent-backdrop.png", STORYBOARD_TRANSPARET);

	LoadImage("tutorialbank\\welcome-video.jpg", WELCOME_VIDEO);

	LoadImage("editors\\uiv3\\tree_tool.png", TOOL_PAINTTREE); //PE: Need another one for this, no +
	LoadImage("editors\\uiv3\\tree_add.png", TOOL_TREE_ADD);
	LoadImage("editors\\uiv3\\tree_delete.png", TOOL_TREE_DELETE);
	LoadImage("editors\\uiv3\\tree_move.png", TOOL_TREE_MOVE);
	LoadImage("editors\\uiv3\\trees_add.png", TOOL_TREES_ADD);
	LoadImage("editors\\uiv3\\trees_delete_2.png", TOOL_TREES_DELETE);

	LoadImage("editors\\uiv3\\click-here-box.png", BOX_CLICK_HERE);

	LoadImage("editors\\uiv3\\brain-icon.png", BRAIN_ICON);
	LoadImage("editors\\uiv3\\icon-question.png", QUESTION_ICON);

	LoadImage("editors\\uiv3\\terrain mover.dds", UI3D_TERRAINMOVER);//dotmiddleobject.png", UI3D_DOTMIDDLEOBJECTS);


	LoadImage("editors\\uiv3\\icon_bush.png", TOOL_PAINTBUSH); //PE: Need another one for this, no +
	LoadImage("editors\\uiv3\\add_bush.png", TOOL_BUSH_ADD);
	LoadImage("editors\\uiv3\\delete_bush.png", TOOL_BUSH_DELETE);
	LoadImage("editors\\uiv3\\move_bush.png", TOOL_BUSH_MOVE);
	LoadImage("editors\\uiv3\\paint_bushes.png", TOOL_BUSHES_ADD);
	LoadImage("editors\\uiv3\\delete_bushes.png", TOOL_BUSHES_DELETE);
	LoadImage("editors\\uiv3\\scale_bush.png", TOOL_BUSH_SCALE);
	LoadImage("editors\\uiv3\\scale_tree.png", TOOL_TREE_SCALE);

	LoadImage("editors\\uiv3\\hub-livebroadcasts.png", HUB_LIVEBROADCAST);
	LoadImage("editors\\uiv3\\hub-discord.png", HUB_DISCORD);
	LoadImage("editors\\uiv3\\hub-facebook.png", HUB_FACEBOOK);
	LoadImage("editors\\uiv3\\hub-forum.png", HUB_FORUM);
	LoadImage("editors\\uiv3\\hub-instagram.png", HUB_INSTAGRAM);
	LoadImage("editors\\uiv3\\hub-tiktok.png", HUB_TIKTOK);
	LoadImage("editors\\uiv3\\hub-twitter.png", HUB_TWITTER);

	LoadImage("editors\\uiv3\\hub-userguide.png", HUB_USERGUIDE);
	LoadImage("editors\\uiv3\\hub-website.png", HUB_WEBSITE);

	#endif

	#ifdef STORYBOARD
	ImNodes::CreateContext();
	#endif

	#ifdef WICKEDENGINE
	gridedit_makelighthybrid();
	#endif

	image_setlegacyimageloading(false);
	SetMipmapNum(-1);

#ifdef STORYBOARD
	//ImFont* ScreenFonts[]

#endif

	ChangeGGFont("editors\\uiv3\\Roboto-Medium.ttf",15);

	// launchLoadOnStartup is never changed anywhere

	#ifdef USERENDERTARGET
	//PE: redirect all to image.
	SetCameraToImage(0, g.postprocessimageoffset, GetDisplayWidth(), GetDisplayHeight(), 2);
	imgui_is_running = true;
	#endif

	//Allow drag drop from outside.
	//DragAcceptFiles(g_pGlob->hWnd, TRUE); - cannot find this with 64 bit compile!

	//Make sure we have envmap.
	visuals_justshaderupdate();
	t.visuals.refreshskysettingsfromlua = true;
	cubemap_generateglobalenvmap();
	t.visuals.refreshskysettingsfromlua = false;

	t.visuals.VegQuantity_f = t.gamevisuals.VegQuantity_f;
	t.visuals.VegWidth_f = t.gamevisuals.VegWidth_f;
	t.visuals.VegHeight_f = t.gamevisuals.VegHeight_f;
	grass_setgrassgridandfade();

	if (!(ObjectExist(t.tGrassObj) == 1 && GetMeshExist(t.tGrassObj) == 1))
		grass_init();

	t.terrain.grassupdateafterterrain = 1;
	grass_loop();
	t.terrain.grassupdateafterterrain = 0;
	ShowVegetationGrid();
	visuals_justshaderupdate();

	// Moved last so we can load levels before main loop.
	// start thread loader for Character Creator texture files (multi-threaded loading) (saves 2s if started CCP)

	timestampactivity(0, "preload CCP textures early");
	charactercreatorplus_preloadinitialcharacter();

	//  Main loop
	iStartupTime = Timer();
	timestampactivity(0, "Guru Map Editor Loop Starts");

	#ifdef WICKEDENGINE
	//Default to OBJECT TOOL panel (so can view tutorials right away)
	bForceKey = true;
	csForceKey = "o";
	#else
	//Default to TERRAIN TOOL panel
	bForceKey = true;
	csForceKey = "t";
	bForceKey2 = true;
	csForceKey2 = "6";
	t.inputsys.domodeterrain = 1; t.inputsys.dowaypointview = 0;
	t.terrain.terrainpaintermode = 1;// 6; start off in sculpt mode
	bTerrain_Tools_Window = true;
	#endif
	t.gridentitymarkersmodeonly = 0; 
	t.grideditselect = 0;
	#else
	timestampactivity(0,"Guru Map Editor Loop Starts");
	#endif
	
	// trigger an alha/beta prompt
	#ifdef WICKEDENGINE
	g_iCountdownToAlphaBetaMessage = 20;
	#endif

	#ifdef WICKEDENGINE
	bWelcomeScreen_Window = false;
	#ifdef USEWELCOMESCREEN
	//Trigger welcome screen.
	extern bool bSpecialEditorFromStandalone;
	extern bool bEnsureIntroVideoIsNotRun;
	extern bool bReturnToWelcome;
	if (pref.iDisplayWelcomeScreen == 1)
	{
		if (bSpecialEditorFromStandalone && bReturnToWelcome)
		{
			bWelcomeNoBackButton = true;
			bWelcomeScreen_Window = true;
		}
		else if (!bSpecialEditorFromStandalone)
		{
			bWelcomeNoBackButton = true;
			bWelcomeScreen_Window = true;
		}
	}
	//LB: ensure special return from standalone flag reset if final destination was welcome HUB (to prevent storyboard being forced to switch)
	if (bReturnToWelcome == true)
	{
		bSpecialEditorFromStandalone = false;
		bEnsureIntroVideoIsNotRun = true;
		bReturnToWelcome = false;
	}
	#endif
	#endif
}

#ifdef ENABLEIMGUI
void mapeditorexecutable_loop_leavetestgame(void)
{
	bBlockImGuiUntilNewFrame = true;
	#ifdef WICKEDENGINE
	bRenderNextFrame = false;
	#endif
	SetCameraToImage(0, g.postprocessimageoffset, GetDisplayWidth(), GetDisplayHeight(), 2); //switch back to render target.
	iLaunchAfterSync = 0;
	bImGuiInTestGame = false;
	sky_show(); //Restore skybox.
	iLastUpdateVeg = 0; //Veg: update any changes from F9
	bUpdateVeg = true;

	// set vsync back on when we return to the editor so we don't 100% the GPU
	wiEvent::SetVSync( true );
}
#endif

#ifdef WICKEDENGINE
ImVec2 back_renderTargetAreaPos;
ImVec2 back_renderTargetAreaSize;
int backup_pickedObject = -1;
int backup_gridentity = -1;
int backup_gridentityobj = -1;
#endif
int back_iLastResolutionWidth = 0;
int back_iLastResolutionHeight = 0;
bool bFakeStandaloneTest = false;
int iTriggerGrassTreeUpdate = 0;

bool commonexecutable_loop_for_game(void)
{
#ifndef PRODUCTCLASSIC

	#ifdef WICKEDENGINE
	//PE: Support delayed terrain update in standalone.
	extern int iTriggerInvalidateAfterFrames;

	//float height;
	//if (!GGTerrain_GetHeight(CameraPositionX(), CameraPositionZ(), &height, 0, 0))
	//{
	//	//Height not available in this are ? , trigger a update.
	//	iTriggerGrassTreeUpdate = 10;
	//}

	if (iTriggerGrassTreeUpdate > 0)
	{
		if (iTriggerGrassTreeUpdate == 5)
		{
			float height = 0;
			if (!GGTerrain_GetHeight(CameraPositionX(), CameraPositionZ(), &height, 0, 0))
			{
				//Height not available in this are ?.
				iTriggerGrassTreeUpdate++;
			}
		}
		if (iTriggerGrassTreeUpdate == 1)
		{
			//PE: Still not fully working if you move from one area to another and terrain at camera is getting updated, and tree/veg dont update ?
			//if (GGGrass::GGGrass_UpdateInstances() == 0)
			//{
			//	//PE: Failed try again.
			//	iTriggerGrassTreeUpdate++;
			//}

			{
				ggterrain_extra_params.iUpdateGrass = 1;
				ggterrain_extra_params.iUpdateTrees = 1;
			}
		}
		iTriggerGrassTreeUpdate--;
	}
	if (iTriggerInvalidateAfterFrames > 0)
	{
		if (iTriggerInvalidateAfterFrames == 1)
		{
			//PE: Height should be availble now.
			//PE: Also update grass and tree, i have some levels where grass is floating in air.
			iTriggerGrassTreeUpdate = 20;
		}
		if (iTriggerInvalidateAfterFrames == 10)
		{
			//PE: Need to do this delayed so terrain update have been updated with new data.
			//PE: Invalidate everything so custom sculpt data is updated with textures ...
			//PE: @Paul not sure if there is a better way to do this, but this works :)
			GGTerrain::GGTerrain_InvalidateRegion(-1000000.0, -1000000.0, 1000000.0, 1000000.0, GGTERRAIN_INVALIDATE_ALL);
		}
		iTriggerInvalidateAfterFrames--;
	}
	#endif

	// called from both mapeditor(test game) and standalone game
	if (bTriggerFovUpdate)
	{
		float fUsedFOV = t.visuals.CameraFOV_f;
		if (bImGuiInTestGame==false) fUsedFOV = 45;
		bTriggerFovUpdate = false;
		float fCameraFov = XM_PI / ((fUsedFOV) / 15.0f); //Fit GG settings.
		if (bImGuiInTestGame == true)
		{
			fCameraFov = GGToRadian(fUsedFOV); // Oops - backwards logic, lower FOV needs lower angle passed in
		}
		wiScene::GetCamera().CreatePerspective((float)master.masterrenderer.GetLogicalWidth(), (float)master.masterrenderer.GetLogicalHeight(), t.visuals.CameraNEAR_f, t.visuals.CameraFAR_f, fCameraFov);
		wiScene::GetCamera().SetDirty(true);
	}

	if (iLaunchAfterSync == 201)
	{
		//As we set 201 launch testgame after we have a imgui frame, we need to set Scissors here.
		bImGuiInTestGame = true;
		g_bDisableQuitFlag = true;

		//PE: Use the actual screen resolution, not the windows size.
		extern ImVec2 fImGuiScissorTopLeft;
		extern ImVec2 fImGuiScissorBottomRight;
		fImGuiScissorTopLeft = { 0, 0 };
		fImGuiScissorBottomRight = { (float)GetSystemMetrics(SM_CXSCREEN),  (float)GetSystemMetrics(SM_CYSCREEN) };

		//PE: Used by LUA.
		extern DWORD g_dwScreenWidth;
		extern DWORD g_dwScreenHeight;
		g_dwScreenWidth = fImGuiScissorBottomRight.x;
		g_dwScreenHeight = fImGuiScissorBottomRight.y;
		g_pGlob->iScreenWidth = fImGuiScissorBottomRight.x;
		g_pGlob->iScreenHeight = fImGuiScissorBottomRight.y;

		#ifdef WICKEDENGINE
		//PE: Change resolution in wicked.
		if (wiRenderer::GetDevice() != nullptr)
		{
			int width = fImGuiScissorBottomRight.x;
			int height = fImGuiScissorBottomRight.y;
			float fNearDistance = DEFAULT_NEAR_PLANE;
			float fFarDistance = DEFAULT_FAR_PLANE;
		}
		#endif

		g_bDisableQuitFlag = false;
		t.postprocessings.fadeinvalue_f = 0.0f; //PE: Make sure we trigger default settings like music / volume ...

		#ifdef WICKEDENGINE
		WickedCall_DisplayCubes(false); //PE: Hide terrain tool cubes.
		wiProfiler::SetEnabled(false); //PE: Clear stat for a fresh testgame or standalone.
		#endif

		#ifdef WICKEDENGINE
		//LB: need to hide shooter genre debug here as UI still shows them even AFTER the preview_init has been called!
		// hide visual logic dots and arcs
		extern bool g_bDotsAreVisible;
		if (g_bDotsAreVisible)
		{
			//DrawCharacterDots(false);
			DrawLogicNodes(false);
			g_bDotsAreVisible = false;
		}

		if (bStartInvulnerableMode)
		{
			bStartInvulnerableMode = false;
			bInvulnerableMode = true;
		}

		#endif

		iLaunchAfterSync = 202;
		return true;
	}
	if (iLaunchAfterSync == 202)
	{
		bImGuiInTestGame = true;
		g_bDisableQuitFlag = true;
		#ifdef WICKEDENGINE
		//PE: Support  g_bDrawSpritesFirst
		extern bool	g_bDrawSpritesFirst;
		extern bool bMainLoopRunning;
		if (g_bDrawSpritesFirst)
		{
			UpdateSprites();
		}
		bMainLoopRunning = false;
		#endif
		if (editor_previewmap_loopcode(0) == true)
		{
			// when loop ends, run code after loop
			bImGuiInTestGame = false;
			bBlockImGuiUntilNewFrame = true;
			bFakeStandaloneTest = false;
			#ifdef WICKEDENGINE
			bRenderNextFrame = false;

			wiProfiler::SetEnabled(false); //PE: Clear stat.
			if (bProfilerEnable)
			{
				wiProfiler::SetEnabled(true);
			}
			#endif
			editor_previewmap_afterloopcode(0);
			mapeditorexecutable_loop_leavetestgame();

			// mapeditor or standalone game
			if (t.game.gameisexe == 1)
			{
				// trigger exit from game
				iLaunchAfterSync = 0;
				PostQuitMessage(0);
			}
			else
			{
				// map editor restore
				#ifdef WICKEDENGINE
				//Restore resolution and scissor
				float fNearDistance = DEFAULT_NEAR_PLANE;
				float fFarDistance = DEFAULT_FAR_PLANE; //PE: Default editor camera range.
				extern ImVec2 fImGuiScissorTopLeft;
				extern ImVec2 fImGuiScissorBottomRight;
				fImGuiScissorTopLeft = back_renderTargetAreaPos;
				fImGuiScissorBottomRight = back_renderTargetAreaPos + back_renderTargetAreaSize;
				g_pGlob->iScreenWidth = back_iLastResolutionWidth;
				g_pGlob->iScreenHeight = back_iLastResolutionHeight;
				if(backup_pickedObject != -1)
					t.widget.pickedObject = backup_pickedObject;
				if(backup_gridentity != -1)
					backup_gridentity = t.gridentity;
				if (backup_gridentityobj != -1)
					backup_gridentityobj = t.gridentityobj;
				#endif

				#ifdef NEWGAMEELEMENTGRID
				if(!t.showeditorelements) editor_toggle_element_vis((bool)t.showeditorelements);
				#endif

				// continue
				iSkibFramesBeforeLaunch = 2;
				iLaunchAfterSync = 203;
			}

			//PE: Reset if we have any hanging keys from test game.
			ImGuiIO& io = ImGui::GetIO();
			io.KeySuper = false;
			io.KeyCtrl = false;
			io.KeyAlt = false;
			io.KeyShift = false;
			for (int iTemp = 0; iTemp < 256; iTemp++)
			{
				io.KeysDown[iTemp] = 0;
			}
			io.MouseDown[0] = 0; //PE: Mouse (release) is also loast inside blocking dialogs. Reset!
			io.MouseDown[1] = 0;
			io.MouseDown[2] = 0;
			io.MouseDown[3] = 0;

		}
		g_bDisableQuitFlag = false;
		return true;
	}
#endif

	// allow continue on to editor if appropriate
	return false;
}

void gridedit_setsmartobjectvisibilityinrubberband(bool bVisible)
{
	if (g.entityrubberbandlist.size() > 0)
	{
		for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
		{
			int e = g.entityrubberbandlist[i].e;
			if (t.entityprofile[t.entityelement[e].bankindex].ischildofgroup != 0)
			{
				if (t.entityprofile[t.entityelement[e].bankindex].ismarker != 0)
				{
					if (bVisible)
						ShowObject(t.entityelement[e].obj);
					else
						HideObject(t.entityelement[e].obj);
				}
			}
		}
	}
}

void SetGlobalGraphicsSettings( int level ) // 0=lowest, 1=medium, 2=high, 3=ultra, default to 2 (high)
{
	GGTerrain::GGTerrain_SetPerformanceMode( level );
	GGTrees::GGTrees_SetPerformanceMode( level );
	GGGrass::GGGrass_SetPerformanceMode( level );

	switch( level )
	{
		case 0: // low
		{
			t.visuals.bSSREnabled = false;
			t.visuals.bFXAAEnabled = false;
			t.visuals.bLightShafts = false;
			t.visuals.bLensFlare = false;
			t.visuals.bReflectionsEnabled = false;
			t.visuals.iShadowSpotCascadeResolution = 512;
			t.visuals.iShadowPointMax = 2;
			t.visuals.iShadowPointResolution = 256;
			t.visuals.iShadowSpotMax = 1;
			t.visuals.iShadowSpotResolution = 256;
		} break;

		case 1: // medium
		{
			t.visuals.bSSREnabled = false;
			t.visuals.bFXAAEnabled = true;
			t.visuals.bLightShafts = true;
			t.visuals.bLensFlare = true;
			t.visuals.bReflectionsEnabled = true;
			t.visuals.iShadowSpotCascadeResolution = 1024;
			t.visuals.iShadowPointMax = 4;
			t.visuals.iShadowPointResolution = 512;
			t.visuals.iShadowSpotMax = 4;
			t.visuals.iShadowSpotResolution = 512;
		} break;

		case 2: // high
		{
			t.visuals.bSSREnabled = false;
			t.visuals.bFXAAEnabled = true;
			t.visuals.bLightShafts = true;
			t.visuals.bLensFlare = true;
			t.visuals.bReflectionsEnabled = true;
			t.visuals.iShadowSpotCascadeResolution = 2048;
			t.visuals.iShadowPointMax = 12;
			t.visuals.iShadowPointResolution = 512;
			t.visuals.iShadowSpotMax = 8;
			t.visuals.iShadowSpotResolution = 512;
		} break;

		case 3: // ultra
		{
			t.visuals.bSSREnabled = false;
			t.visuals.bFXAAEnabled = true;
			t.visuals.bLightShafts = true;
			t.visuals.bLensFlare = true;
			t.visuals.bReflectionsEnabled = true;
			t.visuals.iShadowSpotCascadeResolution = 2048;
			t.visuals.iShadowPointMax = 16;
			t.visuals.iShadowPointResolution = 512;
			t.visuals.iShadowSpotMax = 8;
			t.visuals.iShadowSpotResolution = 512;
		} break;
	}
	/* PE: We cant do this, this will overwrite users settings.
	t.gamevisuals.bSSREnabled = t.visuals.bSSREnabled;
	t.gamevisuals.bFXAAEnabled = t.visuals.bFXAAEnabled;
	t.gamevisuals.bLightShafts = t.visuals.bLightShafts;
	t.gamevisuals.bLensFlare = t.visuals.bLensFlare;
	t.gamevisuals.bReflectionsEnabled = t.visuals.bReflectionsEnabled;
	t.gamevisuals.iShadowSpotCascadeResolution = t.visuals.iShadowSpotCascadeResolution;
	t.gamevisuals.iShadowPointMax = t.visuals.iShadowPointMax; 
	t.gamevisuals.iShadowPointResolution = t.visuals.iShadowPointResolution;
	t.gamevisuals.iShadowSpotMax = t.visuals.iShadowSpotMax;
	t.gamevisuals.iShadowSpotResolution = t.visuals.iShadowSpotResolution;
	*/

	Wicked_Update_Visuals( &t.visuals );
}

void mapeditorexecutable_full_folder_refresh(void)
{
	static char cFullWritePath[MAX_PATH];
	if (!bExternal_Entities_Init)
	{
		//First get those in document folder.
		strcpy(cFullWritePath, "entitybank");
		GG_GetRealPath(cFullWritePath, 1);
		LPSTR pOld = GetDir();
		cStr CurrentPath = cStr(pOld) + cStr("\\entitybank");
		bool bSkipDocWriteFolder = false;
		if (strnicmp(CurrentPath.Get(), cFullWritePath, CurrentPath.Len()) == 0)
		{
			//Same Dirs.
			bSkipDocWriteFolder = true;
		}
		if (!bSkipDocWriteFolder)
		{
			GetMainEntityList(cFullWritePath, "", NULL, "w:", true, 0);
			SetDir(pOld);
			cFolderItem *pLastFolder = &MainEntityList;
			while (pLastFolder->m_pNext)
			{
				pLastFolder = pLastFolder->m_pNext;
			}
			GetMainEntityList("entitybank", "", pLastFolder, "", false, 0);
		}
		else
		{
			GetMainEntityList("entitybank", "", NULL, "", true, 0);
		}
		SetDir(pOld);

		//PE: Append other files types.
		#ifdef WICKEDENGINE
		#ifdef USENEWMEDIASELECTWINDOWS
		strcpy(cFullWritePath, "audiobank");
		GG_GetRealPath(cFullWritePath, 1);
		pOld = GetDir();
		CurrentPath = cStr(pOld) + cStr("\\audiobank");
		bSkipDocWriteFolder = false;
		if (strnicmp(CurrentPath.Get(), cFullWritePath, CurrentPath.Len()) == 0)
		{
			//Same Dirs.
			bSkipDocWriteFolder = true;
		}
		if (!bSkipDocWriteFolder)
		{
			GetMainEntityList(cFullWritePath, "", NULL, "w:", true, 1);
			SetDir(pOld);
			cFolderItem *pLastFolder = &MainEntityList;
			while (pLastFolder->m_pNext)
			{
				pLastFolder = pLastFolder->m_pNext;
			}
			GetMainEntityList("audiobank", "", pLastFolder, "", false, 1);
		}
		else
		{
			GetMainEntityList("audiobank", "", NULL, "", true, 1);
		}

		//Images
		strcpy(cFullWritePath, "imagebank");
		GG_GetRealPath(cFullWritePath, 1);
		pOld = GetDir();
		CurrentPath = cStr(pOld) + cStr("\\imagebank");
		bSkipDocWriteFolder = false;
		if (strnicmp(CurrentPath.Get(), cFullWritePath, CurrentPath.Len()) == 0)
		{
			//Same Dirs.
			bSkipDocWriteFolder = true;
		}
		if (!bSkipDocWriteFolder)
		{
			GetMainEntityList(cFullWritePath, "", NULL, "w:", true, 2);
			SetDir(pOld);
			cFolderItem *pLastFolder = &MainEntityList;
			while (pLastFolder->m_pNext)
			{
				pLastFolder = pLastFolder->m_pNext;
			}
			GetMainEntityList("imagebank", "", pLastFolder, "", false, 2);
		}
		else
		{
			GetMainEntityList("imagebank", "", NULL, "", true, 2);
		}

		//Videos
		strcpy(cFullWritePath, "videobank");
		GG_GetRealPath(cFullWritePath, 1);
		pOld = GetDir();
		CurrentPath = cStr(pOld) + cStr("\\videobank");
		bSkipDocWriteFolder = false;
		if (strnicmp(CurrentPath.Get(), cFullWritePath, CurrentPath.Len()) == 0)
		{
			//Same Dirs.
			bSkipDocWriteFolder = true;
		}
		if (!bSkipDocWriteFolder)
		{
			GetMainEntityList(cFullWritePath, "", NULL, "w:", true, 3);
			SetDir(pOld);
			cFolderItem *pLastFolder = &MainEntityList;
			while (pLastFolder->m_pNext)
			{
				pLastFolder = pLastFolder->m_pNext;
			}
			GetMainEntityList("videobank", "", pLastFolder, "", false, 3);
		}
		else
		{
			GetMainEntityList("videobank", "", NULL, "", true, 3);
		}

		//Script
		strcpy(cFullWritePath, "scriptbank");
		GG_GetRealPath(cFullWritePath, 1);
		pOld = GetDir();
		CurrentPath = cStr(pOld) + cStr("\\scriptbank");
		bSkipDocWriteFolder = false;
		if (strnicmp(CurrentPath.Get(), cFullWritePath, CurrentPath.Len()) == 0)
		{
			//Same Dirs.
			bSkipDocWriteFolder = true;
		}
		if (!bSkipDocWriteFolder)
		{
			GetMainEntityList(cFullWritePath, "", NULL, "w:", true, 4);
			SetDir(pOld);
			cFolderItem *pLastFolder = &MainEntityList;
			while (pLastFolder->m_pNext)
			{
				pLastFolder = pLastFolder->m_pNext;
			}
			GetMainEntityList("scriptbank", "", pLastFolder, "", false, 4);
		}
		else
		{
			GetMainEntityList("scriptbank", "", NULL, "", true, 4);
		}

		//Particles
		strcpy(cFullWritePath, "particlesbank");
		GG_GetRealPath(cFullWritePath, 1);
		pOld = GetDir();
		CurrentPath = cStr(pOld) + cStr("\\particlesbank");
		bSkipDocWriteFolder = false;
		if (strnicmp(CurrentPath.Get(), cFullWritePath, CurrentPath.Len()) == 0)
		{
			//Same Dirs.
			bSkipDocWriteFolder = true;
		}
		if (!bSkipDocWriteFolder)
		{
			GetMainEntityList(cFullWritePath, "", NULL, "w:", true, 5);
			SetDir(pOld);
			cFolderItem *pLastFolder = &MainEntityList;
			while (pLastFolder->m_pNext)
			{
				pLastFolder = pLastFolder->m_pNext;
			}
			GetMainEntityList("particlesbank", "", pLastFolder, "", false, 5);
		}
		else
		{
			GetMainEntityList("particlesbank", "", NULL, "", true, 5);
		}

		//Animations
		strcpy(cFullWritePath, "charactercreatorplus\\animations");
		GG_GetRealPath(cFullWritePath, 1);
		pOld = GetDir();
		CurrentPath = cStr(pOld) + cStr("\\charactercreatorplus\\animations");
		bSkipDocWriteFolder = false;
		if (strnicmp(CurrentPath.Get(), cFullWritePath, CurrentPath.Len()) == 0)
		{
			//Same Dirs.
			bSkipDocWriteFolder = true;
		}
		if (!bSkipDocWriteFolder)
		{
			GetMainEntityList(cFullWritePath, "", NULL, "w:", true, 6);
			SetDir(pOld);
			cFolderItem *pLastFolder = &MainEntityList;
			while (pLastFolder->m_pNext)
			{
				pLastFolder = pLastFolder->m_pNext;
			}
			GetMainEntityList("charactercreatorplus\\animations", "", pLastFolder, "", false, 6);
		}
		else
		{
			GetMainEntityList("charactercreatorplus\\animations", "", NULL, "", true, 6);
		}
		#endif
		#endif

		SetDir(pOld);
		bExternal_Entities_Init = true;

		//Sort folder entrys.
		cFolderItem *pNewFolder = (cFolderItem *)&MainEntityList;
		cFolderItem *m_pfirstFolder = NULL;
		int mc = 0;
		while (pNewFolder->m_pNext)
		{
			if (!m_pfirstFolder) m_pfirstFolder = pNewFolder->m_pNext;
			pNewFolder = pNewFolder->m_pNext;
			mc++;
		}
		if (mc > 1)
		{
			//#### SORT ####
			char ** cptr = new char *[mc + 1];
			cFolderItem *m_pSortFolder = m_pfirstFolder->m_pNext;
			int mc2 = 0;
			for (int a = 0; a < mc; a++)
			{
				if (m_pSortFolder)
				{
					cptr[a] = (char *)m_pSortFolder;
					m_pSortFolder = m_pSortFolder->m_pNext;
					mc2++;
				}
			}
			qsort(cptr, mc2, sizeof(cptr[0]), cstring_cmp_folder);
			m_pSortFolder = m_pfirstFolder->m_pNext;
			m_pfirstFolder->m_pNext = (cFolderItem *)cptr[0];
			for (int a = 0; a < mc2; a++)
			{
				m_pSortFolder = (cFolderItem *)cptr[a];
				if (m_pSortFolder)
				{
					if (a + 1 < mc2) m_pSortFolder->m_pNext = (cFolderItem *)cptr[a + 1];
				}
			}
			delete[] cptr;
			if (m_pSortFolder) m_pSortFolder->m_pNext = NULL;
		}
	}

	#ifdef WICKEDENGINE
	static bool bScan_Files_List = true;
	static int bScan_Files_Start = 50; //Wait some frames before we start , so terrain ... can get a head start.

	extern int g_iScannedFiles;
	extern std::vector<cFolderItem::sFolderFiles *> g_ScanFpeFiles;
	extern bool g_bFpeScanning;

	if (bExternal_Entities_Init && bScan_Files_List && bScan_Files_Start-- <= 0)
	{
		cFolderItem *pSearchFolder = &MainEntityList;
		pSearchFolder = pSearchFolder->m_pNext;
		while (pSearchFolder) {
			if (pSearchFolder->m_pFirstFile) {
				cFolderItem::sFolderFiles * searchfiles = pSearchFolder->m_pFirstFile->m_pNext;
				while (searchfiles) {
					//PE: For now only scan fpe, we might need additional info about other file types but ...
					if (searchfiles->iType == 0)
					{
						g_ScanFpeFiles.push_back(searchfiles);
					}
					searchfiles = searchfiles->m_pNext;
				}
			}
			pSearchFolder = pSearchFolder->m_pNext;
		}
		fpe_thread_start();
		bScan_Files_List = false;
	}
}

void launchOrShowParticleEditor(void)
{
	char pOldDir[MAX_PATH];
	strcpy(pOldDir, GetDir());
	SetDir("..");
	SetDir("DLC\\Particle Editor\\");
	LPSTR pParticleEditorWindowTitle = "Particle Editor 0.7b";
	if (WindowExist(pParticleEditorWindowTitle) == 0)
	{
		pParticleEditorWindowTitle = "Particle Editor";
		if (WindowExist(pParticleEditorWindowTitle) == 0)
		{
			// not here, launch it!
			ExecuteFile("particle_editor.exe", "", "");
		}
		else
		{
			// found you!
			WindowToFront(pParticleEditorWindowTitle);
		}
	}
	else
	{
		// found you!
		WindowToFront(pParticleEditorWindowTitle);
	}
	SetDir(pOldDir);
}

void mapeditorexecutable_loop(void)
{
	#ifdef WICKEDENGINE
	if (g_iCountdownToAlphaBetaMessage > 0)
	{
		g_iCountdownToAlphaBetaMessage--;
		if (g_iCountdownToAlphaBetaMessage == 0)
		{
			// great time to check for any new updates!
			common_autoupdatecheck();
		}
	}
	#endif

	#ifdef ENABLEIMGUI
	#ifdef WICKEDENGINE
	if (iUpdateOcean > 0)
	{
		iUpdateOcean--;
		if ( iUpdateOcean == 0 )
		{
			extern wiECS::Entity g_weatherEntityID;
			wiScene::WeatherComponent* weather = wiScene::GetScene().weathers.GetComponent(g_weatherEntityID);
			wiScene::GetScene().OceanRegenerate();
		}
	}
	#endif

#ifdef WICKEDENGINE

	static int iCheckForMinimized = 0;
	static bool bInMinimizeMode = false;
	//WS_MINIMIZE
	if (bInMinimizeMode)
	{
		Sleep(250); //Set Speed to 4 fps, so we have some reactions in other windows outside the main window.
		LONG lWinStyle = GetWindowLong(g_pGlob->hWnd, GWL_STYLE);
		if (!(lWinStyle & WS_MINIMIZE))
			bInMinimizeMode = false;
	}
	if (iCheckForMinimized++ >= 180) //PE: Evry 3 sec.
	{
		LONG lWinStyle = GetWindowLong(g_pGlob->hWnd,GWL_STYLE);
		if (lWinStyle & WS_MINIMIZE)
			bInMinimizeMode = true;
		iCheckForMinimized = 0;
	}

	/* DUP
	extern int iTriggerInvalidateAfterFrames;
	if (iTriggerInvalidateAfterFrames > 0)
	{
		if (iTriggerInvalidateAfterFrames == 1)
		{
			//PE: Need to do this delayed so terrain update have been updated with new data.
			//PE: Invalidate everything so custom sculpt data is updated with textures ...
			//PE: @Paul not sure if there is a better way to do this, but this works :)
			GGTerrain::GGTerrain_InvalidateRegion(-1000000.0, -1000000.0, 1000000.0, 1000000.0, GGTERRAIN_INVALIDATE_ALL);
		}
		iTriggerInvalidateAfterFrames--;
	}
	*/

	//PE: Change icon set here where we have no imgui images on screen.
	SetIconSetCheck(false);
#endif

	bSmallVideoFrameStart = true;
	// special modes used when in test game or standalone game
	if (commonexecutable_loop_for_game() == true) return;

	//PE: Some function require we have a empty imgui , so launch here.
	extern bool g_bNoSwapchainPresent;

	#ifdef WICKEDENGINE

	bLastSmallVideoPlayerMaximized = bSmallVideoPlayerMaximized; //We need to status one frame behind.
	bSmallVideoPlayerMaximized = false;

	//PE: Moved load here. so no imgui objects on screen.
	//PE: Some imgui used ShaderResourceViews seams to change while loading a new level in wicked.
	if (iSkibFramesBeforeLaunch == 0) 
	{
		switch (iLaunchAfterSync)
		{
		case 203: //PE: trigger a WM_SIZE so resolution,scissor,targetarea all match.
		{
			iLaunchAfterSync = 0;
			if (gWindowMaximized == 1) {
				ShowWindow(g_pGlob->hWnd, SW_MAXIMIZE);
			}
			else {
				SetWindowPos(g_pGlob->hWnd, HWND_TOP, gWindowPosXOld, gWindowPosYOld, gWindowSizeXOld + gWindowSizeAddX, gWindowSizeYOld + gWindowSizeAddY, SWP_SHOWWINDOW);
				ShowWindow(g_pGlob->hWnd, SW_SHOWNORMAL);
			}
			bUpdateVeg = true;
			bTriggerFovUpdate = true;
			break;
		}
		case 502: //Do the actual level load.
		{
			g.projectfilename_s = sNextLevelToLoad;
			
			extern bool g_bAllowBackwardCompatibleConversion;
			g_bAllowBackwardCompatibleConversion = true;
			#ifdef WICKEDENGINE
			GGTerrain_RemoveAllFlatAreas();
			#endif
			gridedit_load_map();
			g_bAllowBackwardCompatibleConversion = false;

			#ifdef WICKEDENGINE

			if(!bCloseStoryboardAfterLoad)
				iLevelEditorFromStoryboardID = -1; //If loaded from here, we cant update storyboard.

			t.terrain.grassregionx1 = t.terrain.grassregionx2;
			grass_init();
			bUpdateVeg = true;
			#endif

			iLaunchAfterSync = 80; //Update env
			iSkibFramesBeforeLaunch = 5;

			int firstempty = -1;
			int i = 0;
			for (; i < REMEMBERLASTFILES; i++) {
				if (firstempty == -1 && strlen(pref.last_open_files[i]) <= 0)
					firstempty = i;

				if (strlen(pref.last_open_files[i]) > 0 && pestrcasestr(g.projectfilename_s.Get(), pref.last_open_files[i])) { //already there
					break;
				}
			}
			if (i >= REMEMBERLASTFILES) {
				if (firstempty == -1) {
					//No empty slots , rotate.
					for (int ii = 0; ii < REMEMBERLASTFILES - 1; ii++) {
						strcpy(pref.last_open_files[ii], pref.last_open_files[ii + 1]);
					}
					strcpy(pref.last_open_files[REMEMBERLASTFILES - 1], g.projectfilename_s.Get());
				}
				else
					strcpy(pref.last_open_files[firstempty], g.projectfilename_s.Get());
			}

			//Locate player start marker.
			for (t.e = 1; t.e <= g.entityelementlist; t.e++)
			{
				if (t.entityelement[t.e].bankindex > 0)
				{
					if (t.entityprofile[t.entityelement[t.e].bankindex].ismarker == 1 && t.entityprofile[t.entityelement[t.e].bankindex].lives != -1)
					{
						//Point camera.
						t.obj = t.entityelement[t.e].obj;
						if (t.obj > 0) {
							float offsetx = ((float)GetDesktopWidth() - renderTargetAreaSize.x) * 0.25f;
							t.cx_f = ObjectPositionX(t.obj) + offsetx; //t.editorfreeflight.c.x_f;
							t.cy_f = ObjectPositionZ(t.obj); //t.editorfreeflight.c.z_f;
						}
						break;
					}
				}
			}

			#ifdef WICKEDENGINE
			//PE: Just let the old fade out.
			//strcpy(cTriggerMessage, "Level loaded");
			//bTriggerMessage = true;
			#endif
			iLastUpdateVeg = 0;
			bUpdateVeg = true;
			//extern bool bFullVegUpdate;
			//bFullVegUpdate = true; // seems to be a lot of bUpdateVeg=true calls, but no good at showing grass initially, needed bFullVegUpdate ?!? 
			extern int g_iSuperTriggerFullGrassReveal; // hmm, shoved in to get the damn grass showing on initial load!
			g_iSuperTriggerFullGrassReveal = 10;

			//PE: Always start in object mode.
			bForceKey = true;
			csForceKey = "o";
			bTerrain_Tools_Window = false;
			Entity_Tools_Window = true;
			break;
		}
		case 2: //Open
			#ifdef WICKEDENGINE
			GGTerrain_CancelRamp();
			#endif
			iLaunchAfterSync = 0;
			int iRet;
			iRet = AskSaveBeforeNewAction();
			if (iRet != 2)
			{
				//t.returnstring_s must have full path to .fpm.

				//PE: filedialogs change dir so.
				cStr tOldDir = GetDir();
				char * cFileSelected;
				cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "fpm\0*.fpm\0", g.mysystem.mapbankAbs_s.Get(), NULL, true);
				SetDir(tOldDir.Get());
				if (cFileSelected && strlen(cFileSelected) > 0)
				{
					t.returnstring_s = cFileSelected;
					if (t.returnstring_s != "")
					{
						if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) == ".fpm")
						{
							t.gridentity = 0;
							t.inputsys.constructselection = 0;
							//In wicked keep current window open, terrain , entity...
							#ifndef WICKEDENGINE
							t.inputsys.domodeentity = 1;
							t.grideditselect = 5;
							#endif
							editor_refresheditmarkers();

							g.projectfilename_s = t.returnstring_s;
							
							sNextLevelToLoad = t.returnstring_s;
							iLaunchAfterSync = 502; //Load actual level.
							iSkibFramesBeforeLaunch = 3;
							strcpy(cTriggerMessage, "Loading Level ...");
							bTriggerMessage = true;
							//gridedit_load_map();

						}
					}
				}
			}
			iLastUpdateVeg = 0;
			//bUpdateVeg = true;
			extern int g_iSuperTriggerFullGrassReveal; // hmm, shoved in to get the damn grass showing on initial load!
			g_iSuperTriggerFullGrassReveal = 10;
			break;

		case 7: // Direct Open
		{
			#ifdef WICKEDENGINE
			GGTerrain_CancelRamp();
			#endif
			iLaunchAfterSync = 0;
			int iRet;
			iRet = AskSaveBeforeNewAction();
			if (iRet != 2)
			{
				if (strlen(cDirectOpen) > 0) {

					t.returnstring_s = cDirectOpen;
					if (t.returnstring_s != "")
					{
						if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) == ".fpm")
						{
							t.gridentity = 0;
							t.inputsys.constructselection = 0;
							//In wicked keep current window open, terrain , entity...
							#ifndef WICKEDENGINE
							t.inputsys.domodeentity = 1;
							t.grideditselect = 5;
							#endif
							editor_refresheditmarkers();

							g.projectfilename_s = t.returnstring_s;

							sNextLevelToLoad = t.returnstring_s;
							iLaunchAfterSync = 502; //Load actual level.
							iSkibFramesBeforeLaunch = 3;
							strcpy(cTriggerMessage, "Loading Level ...");
							bTriggerMessage = true;
						}
					}
				}
			}
			iLastUpdateVeg = 0;
			//bUpdateVeg = true;
			extern int g_iSuperTriggerFullGrassReveal; // hmm, shoved in to get the damn grass showing on initial load!
			g_iSuperTriggerFullGrassReveal = 10;
			break;
		}
		}
	}
	#endif

	switch(iLaunchAfterSync)
	{
		case 1:  // Test Game
		case 20: // VR Test Game

			#ifdef WICKEDENGINE

			if (t.game.gameisexe == 0)
			{
				//PE: Backup so we can restore last selected object after testgame.
				backup_pickedObject = t.widget.pickedObject;
				backup_gridentity = t.gridentity;
				backup_gridentityobj = t.gridentityobj;
			}
			else
			{
				backup_pickedObject = -1;
				backup_gridentity = -1;
				backup_gridentityobj = -1;
			}

			GGTerrain_CancelRamp();
			bInvulnerableMode = false;
			if (bStartInvulnerableMode)
			{
				bStartInvulnerableMode = false;
				bInvulnerableMode = true;
			}
			
			//PE: Cant set it here, need to be after we have made a backup of user settings.
			//SetGlobalGraphicsSettings( pref.iTestGameGraphicsQuality );

			#endif

			if (iLaunchAfterSync == 20 && g.gvrmode == 0)
			{
				HWND hThisWnd = GetForegroundWindow();
				MessageBoxA(hThisWnd, "You are not in VR mode. You need to exit the software. When you restart, select VR MODE ON to enable VR.", "Not in VR Mode", MB_OK);
			}
			else
			{
				bImGuiInTestGame = true;
				bool bTestInVRMode = false;
				if (iLaunchAfterSync == 20) bTestInVRMode = true;
				#ifdef WICKEDENGINE
				extern int iLastResolutionWidth;
				extern int iLastResolutionHeight;
				back_iLastResolutionWidth = iLastResolutionWidth;
				back_iLastResolutionHeight = iLastResolutionHeight;
				back_renderTargetAreaPos = renderTargetAreaPos;
				back_renderTargetAreaSize = renderTargetAreaSize;
				#endif
				//RunCode(0); //switch to backbuffer 
				// g.projectmodified = 1; if just testing, do not assume a modification!
				// ensure threads loading resources are silent before test game
				image_preload_files_wait();
				object_preload_files_wait();
				image_preload_files_reset();
				object_preload_files_reset();
				if ( bTestInVRMode == false )
				{
					#ifdef WICKEDENGINE
					editor_previewmap_initcode(0);
					iLaunchAfterSync = 201;
					#else
					editor_previewmap(0);
					mapeditorexecutable_loop_leavetestgame();
					#endif
				}
				else
				{
					#ifdef WICKEDENGINE
					editor_previewmap_initcode(1);
					iLaunchAfterSync = 201;
					#else
					RunCode(0); //switch to backbuffer
					editor_previewmap(1);
					mapeditorexecutable_loop_leavetestgame();
					SetCameraToImage(0, g.postprocessimageoffset, GetDisplayWidth(), GetDisplayHeight(), 2); //switch back to render target.
					bImGuiInTestGame = false;
					#endif
				}
				#ifdef WICKEDENGINE
				// wicked engine needs to stay in constant loop - no internal loops!!
				#else
				iLaunchAfterSync = 0;
				sky_show(); //Restore skybox.
				iLastUpdateVeg = 0; //Veg: update any changes from F9
				bUpdateVeg = true;
				#endif
				break;
			}
			break;

		case 30: //Create thumbnail.
		{
			if (iTooltipLastObjectId > 0) {
				int drawobj = g.entitybankoffset + iTooltipLastObjectId;
				g_bNoSwapchainPresent = true; //dont present backbuffer to HWND.
				#ifdef WICKEDENGINE
				// restore this later on!
				#else
				RenderToPreview(drawobj);
				#endif
			}
			iLaunchAfterSync = 31;
			break;
		}
		case 31: //Switch back to presenting the swapchain.
		{
			g_bNoSwapchainPresent = false;
			iLaunchAfterSync = 0;
			break;
		}

		case 21: //Social VR.
		{
			bImGuiInTestGame = true;
			RunCode(0); //switch to backbuffer
			editor_multiplayermode();
			bBlockImGuiUntilNewFrame = true;
			#ifdef WICKEDENGINE
			bRenderNextFrame = false;
			#endif
			SetCameraToImage(0, g.postprocessimageoffset, GetDisplayWidth(), GetDisplayHeight(), 2); //switch back to render target.
			bImGuiInTestGame = false;
			iLaunchAfterSync = 0;
			sky_show(); //Restore skybox.
			iLastUpdateVeg = 0; //Veg: update any changes from F9
			bUpdateVeg = true;
			break;
		}

		default:
			break;
	}

	//Display Weather.
	extern bool bEnableWeather;
	if (bEnableWeather) 
	{
		update_env_particles();
		ravey_particles_update();
	}

	//PE: Imgui variables.
	ImGuiIO& io = ImGui::GetIO(); (void)io;

	//PE: To solve problem with ALT-TAB away and key "release" are sent to another app.
	HWND tmpHwnd = GetFocus();
	if (bLostFocus == false && tmpHwnd != g_pGlob->hWnd) 
	{
		bLostFocus = true;
		io.KeySuper = false;
		io.KeyCtrl = false;
		io.KeyAlt = false;
		io.KeyShift = false;

		t.inputsys.keyreturn = 0;
		t.inputsys.keyshift = 0;
		t.inputsys.keytab = 0;
		t.inputsys.keyleft = 0;
		t.inputsys.keyright = 0;
		t.inputsys.keyup = 0;
		t.inputsys.keydown = 0;
		t.inputsys.keycontrol = 0;
		t.inputsys.keyspace = 0;
		t.inputsys.kscancode = 0;

		for (int iTemp = 0; iTemp < 273; iTemp++)
			io.KeysDown[iTemp] = 0;
	}
	if (tmpHwnd == g_pGlob->hWnd) 
	{
		if (bLostFocus) {
			//We got focus again.
			//Looks like its fine to reset keys on lost only.
			//If there is a problem, they can also be reset here.
		}
		bLostFocus = false;
	}

	// set when showonstartup.ini does not exist and is created (first run sorts out UI panels)
	// and it seems, fixes the issue of 'bImGuiGotFocus' being true on some laptops on first run!?
	if (g.gfirsttimerun == 1)
	{
		g.gfirsttimerun = 0;
		refresh_gui_docking = 0;
		pref.vStartResolution = { 1280,800 };
		pref.iMaximized = 1;
		#ifndef WICKEDENGINE
		//PE: Dont touch window in wicked.
		SetWindowSize(pref.vStartResolution.x, pref.vStartResolution.y);
		float centerx = (GetDesktopWidth()*0.5) - (pref.vStartResolution.x*0.5);
		float centery = ((float)(GetDesktopHeight()*0.5) - (float)(pref.vStartResolution.y*0.5)) * 0.5f;
		if (centerx < 0) centerx = 0;
		if (centery < 0) centery = 0;
		SetWindowPosition(centerx, centery);
		MaximiseWindow();
		#endif
	}

	#ifdef WICKEDENGINE
	//PE: ImGuiWindowFlags_NoNav added to prevent cursor keys to navigate imgui.
	if(pref.iAllowUndocking)
		iGenralWindowsFlags = ImGuiWindowFlags_None | ImGuiWindowFlags_NoNav;
	else
		iGenralWindowsFlags = ImGuiWindowFlags_None | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoNav;
	#endif

	ImVec4 style_back = ImGui::GetStyle().Colors[ImGuiCol_Text];
	ImVec4 style_winback = ImGui::GetStyle().Colors[ImGuiCol_WindowBg];
	style_back = ImVec4(1.0, 1.0, 1.0, 1.0);

	bBoostIconColors = false;

	if (pref.current_style == 3) 
	{
		drawCol_back = ImColor(255, 255, 255, 128)*style_back;
		drawCol_normal = ImColor(255, 255, 255, 255);
		drawCol_hover = ImColor(180, 180, 180, 230);
	}
	else if (pref.current_style == 25) {
		drawCol_back = ImColor(255, 255, 255, 128)*style_back;
		drawCol_normal = ImColor(255, 255, 255, 255);
		//drawCol_normal = ImColor(220,220,220, 255);
		drawCol_hover = ImColor(180, 180, 180, 230);
		bBoostIconColors = true;
	}
	else 
	{
		drawCol_back = ImColor(255, 255, 255, 128)*style_back;
		drawCol_normal = ImColor(220, 220, 220, 230)*style_back;
		drawCol_hover = ImColor(255, 255, 255, 255)*style_back;
	}
	drawCol_Down = ImColor(255, 255, 255, 255)*style_back;
	ImVec4 drawCol_active = ImColor(120, 220, 120, 220)*style_back;
	ImVec4 drawCol_tmp = ImColor(220, 220, 220, 220)*style_back;
	ImVec4 drawCol_header = ImColor(255, 255, 255, 255)*style_back;

	bool toolbar_gradiant = false;
	#ifdef USETOOLBARGRADIENT
	toolbar_gradiant = true;
	#endif

	#ifdef USETOOLBARCOLORS
	ImVec4 drawCol_back_gg = ImVec4(147/255.0, 196 / 255.0, 125 / 255.0, 1.0);
	ImVec4 drawCol_back_terrain = ImVec4(244 / 255.0, 163 / 255.0, 29 / 255.0, 1.0);
	ImVec4 drawCol_back_terrain_tools = ImVec4(244 / 255.0, 163 / 255.0, 29 / 255.0, 1.0);
	ImVec4 drawCol_back_entities = ImVec4(138 / 255.0, 142 / 255.0, 200 / 255.0, 1.0);
	ImVec4 drawCol_back_waypoint = ImVec4(164 / 255.0, 84 / 255.0, 40 / 255.0, 1.0);
	ImVec4 drawCol_back_test = ImVec4(245 / 255.0, 228 / 255.0, 64 / 255.0, 1.0);
	ImVec4 drawCol_back_tools = ImVec4(244 / 255.0, 163 / 255.0, 29 / 255.0, 1.0);
	#else
	#ifdef USETOOLBARHEADER
	ImVec4 drawCol_back_gg = style_winback * ImVec4(1.0, 1.0, 1.0, 0.75);
	ImVec4 drawCol_back_terrain = style_winback * ImVec4(1.0, 1.0, 1.0, 0.85);
	ImVec4 drawCol_back_terrain_tools = style_winback * ImVec4(1.0, 1.0, 1.0, 0.75);
	ImVec4 drawCol_back_entities = style_winback * ImVec4(1.0, 1.0, 1.0, 0.85);
	ImVec4 drawCol_back_waypoint = style_winback * ImVec4(1.0, 1.0, 1.0, 0.75);
	ImVec4 drawCol_back_tools = style_winback * ImVec4(1.0, 1.0, 1.0, 0.85);
	ImVec4 drawCol_back_test = style_winback * ImVec4(1.0, 1.0, 1.0, 0.75);
	#else
	int adder = 6;
	ImVec4 drawCol_back_test = ImColor(255, 255, 255, adder)*style_back; adder += 6;
	ImVec4 drawCol_back_tools = ImColor(255, 255, 255, adder)*style_back; adder += 6;
	ImVec4 drawCol_back_waypoint = ImColor(255, 255, 255, adder)*style_back; adder += 6;
	ImVec4 drawCol_back_entities = ImColor(255, 255, 255, adder)*style_back; adder += 6;
	ImVec4 drawCol_back_terrain_tools = ImColor(255, 255, 255, adder)*style_back; adder += 6;
	ImVec4 drawCol_back_terrain = ImColor(255, 255, 255, adder)*style_back; adder += 6;
	ImVec4 drawCol_back_gg = ImColor(255, 255, 255, adder)*style_back;
	drawCol_toogle = drawCol_back_gg;
	if (pref.current_style == 25) {
		drawCol_back_test = ImColor(255, 255, 255,0);
		drawCol_back_tools = ImColor(255, 255, 255, 0);
		drawCol_back_waypoint = ImColor(255, 255, 255, 0);
		drawCol_back_entities = ImColor(255, 255, 255, 0);
		drawCol_back_terrain_tools = ImColor(255, 255, 255, 0);
		drawCol_back_terrain = ImColor(255, 255, 255, 0);
		drawCol_back_gg = ImColor(255, 255, 255, 0);
		drawCol_toogle = ImColor(255, 255, 255, 50);
	}
	#endif
	#endif

	ImVec4 drawCol_back_active = ImColor(255, 255, 255, 160); //*style_back;
	if (pref.current_style == 25) {
		drawCol_back_active = ImColor(128, 128, 128, 128); //*style_back;
	}


	static bool bLastImGuiGotFocus;
	bLastImGuiGotFocus = bImGuiGotFocus;

	bImGuiGotFocus = false; //PE: Set this if any of the imgui windows got focus.
	bImGuiReadyToRender = false;

	// Start the Dear ImGui frame
	#ifdef WICKEDENGINE
	if (!bImGuiFrameState && !bRenderTabTab) // lee added !bRenderTabTab to prevent double newframe
	#else
	if (!bImGuiFrameState)
	#endif
	{
		ImGui_NewFrame();
		ImGui_ImplWin32_NewFrame();
		ImGui::NewFrame();
		extern bool bSpriteWinVisible;
		bSpriteWinVisible = false;
		bImGuiFrameState = true;
		bTutorialRendered = false;
		bBlockImGuiUntilNewFrame = false;
		bImGuiRenderWithNoCustomTextures = false;
	}

	float fontSize = 0.0f;
	ImVec2 mCharAdvance = ImVec2(0, 0);
	int iOldRounding = 0;
	if (bImGuiFrameState) {
		fontSize = ImGui::CalcTextSize("#").x;
		mCharAdvance = ImVec2(fontSize, ImGui::GetTextLineHeightWithSpacing());
	}

	//PE: Additional resets, not done in direct input.
	t.inputsys.doartresize = 0;
	t.inputsys.dosave = 0; t.inputsys.doopen = 0; t.inputsys.donew = 0; t.inputsys.donewflat = 0; t.inputsys.dosaveas = 0;
	if (bImGuiFrameState) {

		// LEELEE disable interaction with main editor if Welcome system is active!
		if (iTriggerWelcomeSystemStuff != 0)
		{
			// LEELEE disable input to IMGUI menu/toolbar/panels while Welcome System is active
			//PE: Displaying it as Modal will disable everything but the welcome system.
			bRenderTargetModalMode = true;
		}
		else
		{
			bRenderTargetModalMode = false;
		}

		int icon_size = 60;
		ImVec2 iToolbarIconSize = { (float)icon_size, (float)icon_size };
		static bool dockingopen = true;
		float fsy = ImGui::CalcTextSize("#").y;
		toolbar_size = icon_size + (fsy*2.0) + 2;
		ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
		ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;
		ImGuiStatusBar_Size = fsy*2.0;

		//PE: Render toolbar.

		iOldRounding = ImGui::GetStyle().WindowRounding;
		ImGui::GetStyle().WindowRounding = 0.0f;

		
		if (bStopBackbufferGrab > 0)
		{
			bStopBackbufferGrab--;
			if (bStopBackbufferGrab == 0)
			{
				if (BitmapExist(99))
				{
					DeleteBitmapEx(99);
				}
				bFullScreenBackbuffer = false;
			}
		}


		//#################
		//#### Toolbar ####
		//#################

		static float toolbar_offset_center = 0;
		int current_mode = 0;

		if (t.grideditselect == 6) 
		{
			extern bool bWaypointDrawmode;
			if(bWaypointDrawmode)
				current_mode = TOOL_DRAWWAYPOINTS;
			else
				current_mode = TOOL_WAYPOINTS;
		}
		else if (t.grideditselect == 5) 
		{
			#ifdef WICKEDENGINE
			//LB: Shooter now a filter mode
			//if (Shooter_Tools_Window)
			//{
			//	current_mode = TOOL_SHOOTER;
			//}
			//else
			#endif
			{
				if (t.gridentitymarkersmodeonly == 0)
					current_mode = TOOL_ENTITY;
				else
					current_mode = TOOL_MARKERS;
			}
		}
		else 
		{
			if (t.terrain.terrainpaintermode >= 1 && t.terrain.terrainpaintermode <= 5)
			{
				if (t.terrain.terrainpaintermode == 1)  current_mode = TOOL_SHAPE;
				if (t.terrain.terrainpaintermode == 2)  current_mode = TOOL_LEVELMODE;
				if (t.terrain.terrainpaintermode == 3)  current_mode = TOOL_STOREDLEVEL;
				if (t.terrain.terrainpaintermode == 4)  current_mode = TOOL_BLENDMODE;
				if (t.terrain.terrainpaintermode == 5)  current_mode = TOOL_RAMPMODE;
			}
			else
			{
				if (t.terrain.terrainpaintermode == 6)  current_mode = TOOL_PAINTTEXTURE;
				if (t.terrain.terrainpaintermode == 7)  current_mode = TOOL_PAINTTEXTURE;
				if (t.terrain.terrainpaintermode == 8)  current_mode = TOOL_PAINTTEXTURE;
				if (t.terrain.terrainpaintermode == 9)  current_mode = TOOL_PAINTTEXTURE;
				if (t.terrain.terrainpaintermode == 10) current_mode = TOOL_PAINTGRASS;
			}
		}

		if(g_bCharacterCreatorPlusActivated)
			current_mode = TOOL_CCP;
		if(bBuilder_Properties_Window || t.ebe.on == 1)
			current_mode = TOOL_BUILDER;
		if (bImporter_Window && t.importer.importerActive == 1)
			current_mode = TOOL_IMPORT;

		if ( t.gridentity > 0 && t.entityprofile[t.gridentity].isebe != 0) {
			current_mode = TOOL_BUILDER;
		}
		//PE: Now toggle.
		//if(Visuals_Tools_Window)
		//	current_mode = TOOL_VISUALS;
		#ifdef WICKEDENGINE
		bool bOldWelcomeScreen_Window = bWelcomeScreen_Window;
		#endif

		//PE: Make sure we dont place the toolbar in its own viewport.
		ImGui::SetNextWindowPos(ImVec2(0, 0) + viewPortPos, ImGuiCond_Always);
		ImGui::SetNextWindowSize(ImVec2(ImGui::GetMainViewport()->Size.x, toolbar_size));
		//ImGuiWindowFlags_NoBackground

		if (pref.current_style == 25)
		{
			ImGui::PushStyleColor(ImGuiCol_WindowBg, ImVec4(0.12f, 0.26f, 0.35f, 1.00f));
			ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.11f, 0.16f, 0.22f, 1.00f)); //org ImVec4(0.58f, 0.58f, 0.58f, 1.00f); // ImGui::PopStyleColor();
		}

		int toolbar_flags = ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
		#ifdef WICKEDENGINE
		if (bOldWelcomeScreen_Window)
		{
			toolbar_flags |= ImGuiWindowFlags_NoChangeZOrder;
		}
		#endif
		ImGui::Begin("Toolbar", NULL , toolbar_flags);

		#ifdef WICKEDENGINE
		if (bOldWelcomeScreen_Window)
		{
			//Disable
			ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
		}
		#endif

		ImVec4 drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
		float fDiv = 1.0f / 255.0f;
		//ImVec4 drawCol_Divider_Selected = ImVec4(0.4f, 0.8f, 1.0f, 1.0f);
		//ImVec4 drawCol_Divider_Selected = ImVec4(fDiv * 142.0f, fDiv * 184.0f, fDiv * 212.0f, 1.0f);
		ImVec4 drawCol_Divider_Selected = ImVec4(fDiv * 177.0f, fDiv * 206.0f, fDiv * 225.0f, 1.0f);
		if (pref.current_style == 25) {
			drawCol_hover = ImVec4(fDiv * 142.0f, fDiv * 184.0f, fDiv * 212.0f, 1.0f);
		}

		ImGui::GetStyle().WindowRounding = iOldRounding;

		#ifdef USETOOLBARHEADER
		void* lpTexture = GetImagePointer(TOOL_HEADER);
		if (lpTexture) {
			ImGuiWindow* window = ImGui::GetCurrentWindow();
			window->DrawList->AddImage((ImTextureID)lpTexture, viewPortPos, viewPortPos + ImVec2(1920, 200), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(drawCol_header));
		}
		#endif

		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.0f, 0.0f));
		ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
		#ifdef CENTERETOOLBAR		
		if(toolbar_offset_center > 0 && toolbar_offset_center < ImGui::GetWindowSize().x)
			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x + ( (ImGui::GetWindowSize().x * 0.5) - (toolbar_offset_center*0.5) ) , ImGui::GetCursorPos().y));
		#endif

		float cursorpos = ImGui::GetCursorPos().x;

		#ifdef ADDGGTOOLBAR

		#ifdef WICKEDENGINE
		//PE: New "Back to Game Project" ? 
		if (ImGui::ImgBtn(TOOL_GOBACK, iToolbarIconSize, drawCol_back_gg, drawCol_normal/**drawCol_Selection*/, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant,false,false,false, bBoostIconColors)) 
		{
			CloseAllOpenToolsThatNeedSave();
			//No function yet.
			#ifdef STORYBOARD
			//Storyboard can change levels ... so make sure we ask to save first.
			#ifdef ENABLEAUTOLEVELSAVE
			if (!pref.iDisableLevelAutoSave && g.projectfilename_s != "")
			{
				//Auto save.
				iLaunchAfterSync = 504; //Do the actualy save here.
				iSkibFramesBeforeLaunch = 3;
				strcpy(cTriggerMessage, "Auto Saving Level ...");
				bTriggerMessage = true;
				iLaunchAfterSyncAction = 1; //Go to storyboard.
			}
			else
			#endif
			{
				#ifdef WICKEDENGINE
				if (g.projectmodified == 1 && g.projectfilename_s != "")
				{
					int iRet = askBoxCancel("Do you wish to save first?", "Confirmation"); //1==Yes 2=Cancel 0=No

					if (iRet == 1)
					{
						//Yes
						iLaunchAfterSync = 504; //Do the actualy save here.
						iSkibFramesBeforeLaunch = 3;
						strcpy(cTriggerMessage, "Saving Level ...");
						bTriggerMessage = true;
						iLaunchAfterSyncAction = 1; //Go to storyboard.
					}
					if (iRet == 0)
					{
						//PE: NO = Restore original fpm. on next load in storyboard.
						g.projectfilename_s = "";
						/* A little slow here, so wait until next storyboard level edit.
						extern bool g_bAllowBackwardCompatibleConversion;
						g_bAllowBackwardCompatibleConversion = true;
						GGTerrain_RemoveAllFlatAreas();
						gridedit_load_map();
						g_bAllowBackwardCompatibleConversion = false;
						*/
						g.projectmodified = 0; gridedit_changemodifiedflag();
						g.projectmodifiedstatic = 0;
						GGTerrain_CancelRamp();
						bStoryboardWindow = true;
					}
				}
				else
				#endif
				{
					int iRet = AskSaveBeforeNewAction();
					if (iRet != 2)
					{
						GGTerrain_CancelRamp();
						bStoryboardWindow = true;
					}
				}

				// Object library does not disappear if open when going to storyboard.
				if (bExternal_Entities_Window)
					bTriggerCloseEntityWindow = true;
			}
			#endif
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Back to Game Project Storyboard");
		#endif

		//PE: Load icon removed for now.
		#ifndef WICKEDENGINE
		if (ImGui::ImgBtn(TOOL_LOADLEVEL, iToolbarIconSize, drawCol_back_gg, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant)) {
			CloseAllOpenToolsThatNeedSave();

			iLaunchAfterSync = 2; //Load
			iSkibFramesBeforeLaunch = 2;
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Open Level");
		#endif

		ImGui::SameLine();
		#ifdef WICKEDENGINE
		if (ImGui::ImgBtn(TOOL_SAVELEVEL, iToolbarIconSize, drawCol_back_gg, drawCol_normal/**drawCol_Selection*/, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant, false, false, false, bBoostIconColors)) {
		#else
		if (ImGui::ImgBtn(TOOL_SAVELEVEL, iToolbarIconSize, drawCol_back_gg, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant, false, false, false, bBoostIconColors)) {
		#endif
			CloseAllOpenToolsThatNeedSave();
			if (bTutorialCheckAction) TutorialNextAction();

			iLaunchAfterSync = 3; //Save
			iSkibFramesBeforeLaunch = 2;
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Save Level");
		ImGui::SameLine();

		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x + 2.0f, ImGui::GetCursorPos().y));
		#endif

		ImGuiWindow* window = ImGui::GetCurrentWindow();
		ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
		if(pref.current_style == 3 )
			tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_Button];

		ImVec2 tool_selected_padding = { 1.0, 1.0 };

		CheckTutorialAction("TOOL_SHAPE", -10.0f); //Tutorial: check if we are waiting for this action
		#ifdef WICKEDENGINE
		//if (t.grideditselect == 0 && t.terrain.terrainpaintermode >= 1 && t.terrain.terrainpaintermode <= 5 ) 
		if (t.grideditselect == 0 && t.terrain.terrainpaintermode >= 1 && t.terrain.terrainpaintermode <= 12)
		{
			//PE: Keep selection in all sculpt modes.
			drawCol_tmp = drawCol_back_terrain * drawCol_back_active;
			if (pref.current_style == 25) drawCol_Selection = drawCol_Divider_Selected;
			window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		}
		else 
		{
			drawCol_tmp = drawCol_back_terrain;
		}
		//if (ImGui::ImgBtn(TOOL_SHAPE, iToolbarIconSize, drawCol_tmp, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant, false, false, false, bBoostIconColors))
		if (ImGui::ImgBtn(TOOL_TERRAIN_TOOLBAR, iToolbarIconSize, drawCol_tmp, drawCol_normal/**drawCol_Selection*/, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant, false, false, false, bBoostIconColors))
		#else
		if (current_mode == TOOL_SHAPE) drawCol_tmp = drawCol_back_terrain*drawCol_back_active; else drawCol_tmp = drawCol_back_terrain;
		if (current_mode == TOOL_SHAPE && pref.current_style >= 0) window->DrawList->AddRect( (window->DC.CursorPos - tool_selected_padding) , window->DC.CursorPos + tool_selected_padding + iToolbarIconSize , ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_SHAPE, iToolbarIconSize, drawCol_tmp, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant, false, false, false, bBoostIconColors))
		#endif
		{
			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();
			#ifdef WICKEDENGINE
			if (!pref.iEnableSingleRightPanelAdvanced)
			{
				Weather_Tools_Window = false;
				Visuals_Tools_Window = false;
				//LB: Shooter now a filter mode Shooter_Tools_Window = false;
				iRestoreLastWindow = 0;
			}
			#endif

			bForceKey = true;
			csForceKey = "t";
			bForceKey2 = true;
			csForceKey2 = "1";
		}
#ifdef WICKEDENGINE
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Terrain, Painting, Trees and Vegetation (T)"); //"Terrain Tools"
#else
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Shape Mode");
#endif
		ImGui::SameLine();

#ifndef WICKEDENGINE
		drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
		CheckTutorialAction("TOOL_LEVELMODE", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_mode == TOOL_LEVELMODE) drawCol_tmp = drawCol_back_terrain*drawCol_back_active; else drawCol_tmp = drawCol_back_terrain;
		if (current_mode == TOOL_LEVELMODE && pref.current_style >= 0) window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_LEVELMODE, iToolbarIconSize, drawCol_tmp, drawCol_normal, drawCol_hover, drawCol_Down,0, 0, 0, 0, false, toolbar_gradiant)) {

			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();

			bForceKey = true;
			csForceKey = "t";
			bForceKey2 = true;
			csForceKey2 = "2";
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Level Mode");
		ImGui::SameLine();

		CheckTutorialAction("TOOL_STOREDLEVEL", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_mode == TOOL_STOREDLEVEL) drawCol_tmp = drawCol_back_terrain * drawCol_back_active; else drawCol_tmp = drawCol_back_terrain;
		if (current_mode == TOOL_STOREDLEVEL && pref.current_style >= 0) window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_STOREDLEVEL, iToolbarIconSize, drawCol_tmp, drawCol_normal, drawCol_hover, drawCol_Down,0, 0, 0, 0, false, toolbar_gradiant)) {

			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();

			bForceKey = true;
			csForceKey = "t";
			bForceKey2 = true;
			csForceKey2 = "3";
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Stored Level Mode");
		ImGui::SameLine();

		CheckTutorialAction("TOOL_BLENDMODE", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_mode == TOOL_BLENDMODE) drawCol_tmp = drawCol_back_terrain * drawCol_back_active; else drawCol_tmp = drawCol_back_terrain;
		if (current_mode == TOOL_BLENDMODE && pref.current_style >= 0) window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_BLENDMODE, iToolbarIconSize, drawCol_tmp, drawCol_normal, drawCol_hover, drawCol_Down,0, 0, 0, 0, false, toolbar_gradiant)) {

			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();

			bForceKey = true;
			csForceKey = "t";
			bForceKey2 = true;
			csForceKey2 = "4";
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Blend Mode");
		ImGui::SameLine();

		CheckTutorialAction("TOOL_RAMPMODE", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_mode == TOOL_RAMPMODE) drawCol_tmp = drawCol_back_terrain * drawCol_back_active; else drawCol_tmp = drawCol_back_terrain;
		if (current_mode == TOOL_RAMPMODE && pref.current_style >= 0) window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_RAMPMODE, iToolbarIconSize, drawCol_tmp, drawCol_normal, drawCol_hover, drawCol_Down,0, 0, 0, 0, false, toolbar_gradiant)) {

			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();

			bForceKey = true;
			csForceKey = "t";
			bForceKey2 = true;
			csForceKey2 = "5";
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Ramp Mode");
		ImGui::SameLine();
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x + 2.0f, ImGui::GetCursorPos().y));
#endif

#ifndef WICKEDENGINE //These are moved to Terrain Tools in Wicked. NEEDED for VRQUEST.
		//PE: This was somehow removed in this branch ? , needed for VRQuest.
		drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
		CheckTutorialAction("TOOL_PAINTTEXTURE", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_mode == TOOL_PAINTTEXTURE) drawCol_tmp = drawCol_back_terrain_tools * drawCol_back_active; else drawCol_tmp = drawCol_back_terrain_tools;
		if (current_mode == TOOL_PAINTTEXTURE && pref.current_style == 25) drawCol_Selection = drawCol_Divider_Selected;
		if (current_mode == TOOL_PAINTTEXTURE && pref.current_style >= 0) window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_PAINTTEXTURE, iToolbarIconSize, drawCol_tmp, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant, false, false, false, bBoostIconColors)) {
			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();
			#ifdef WICKEDENGINE
			if (!pref.iEnableSingleRightPanelAdvanced)
			{
				Weather_Tools_Window = false;
				Visuals_Tools_Window = false;
				Shooter_Tools_Window = false;
				iRestoreLastWindow = 0;
			}
			#endif
			bForceKey = true;
			csForceKey = "t";
			bForceKey2 = true;
			csForceKey2 = "6";
			bTerrain_Tools_Window = true;
		}
		#ifdef WICKEDENGINE
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Paint Terrain  (this feature is still being improved)");
		#else
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Paint Texture");
		#endif

		ImGui::SameLine();
		drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
		CheckTutorialAction("TOOL_PAINTGRASS", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_mode == TOOL_PAINTGRASS) drawCol_tmp = drawCol_back_terrain_tools * drawCol_back_active; else drawCol_tmp = drawCol_back_terrain_tools;
		if (current_mode == TOOL_PAINTGRASS && pref.current_style == 25) drawCol_Selection = drawCol_Divider_Selected;
		if (current_mode == TOOL_PAINTGRASS && pref.current_style >= 0) window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_PAINTGRASS, iToolbarIconSize, drawCol_tmp, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down,0, 0, 0, 0, false, toolbar_gradiant,false,false,false, bBoostIconColors))
		{
			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();
			#ifdef WICKEDENGINE
			if (!pref.iEnableSingleRightPanelAdvanced)
			{
				Weather_Tools_Window = false;
				Visuals_Tools_Window = false;
				Shooter_Tools_Window = false;
				iRestoreLastWindow = 0;
			}
			#endif

			bForceKey = true;
			csForceKey = "t";
			bForceKey2 = true;
			csForceKey2 = "0";
			bTerrain_Tools_Window = true;
		}
		#ifdef WICKEDENGINE
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Add Vegetation (this feature is still being improved)");
		#else
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Paint Grass");
		#endif
#endif

		ImGui::SameLine();
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x + 2.0f, ImGui::GetCursorPos().y));
		drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
		CheckTutorialAction("TOOL_ENTITY", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_mode == TOOL_ENTITY || current_mode == TOOL_SHOOTER) drawCol_tmp = drawCol_back_entities * drawCol_back_active; else drawCol_tmp = drawCol_back_entities;
		if ((current_mode == TOOL_ENTITY || current_mode == TOOL_SHOOTER ) && pref.current_style == 25) drawCol_Selection = drawCol_Divider_Selected;
		if ((current_mode == TOOL_ENTITY || current_mode == TOOL_SHOOTER ) && pref.current_style >= 0) window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_ENTITY, iToolbarIconSize, drawCol_tmp, drawCol_normal/**drawCol_Selection*/, drawCol_hover, drawCol_Down,0, 0, 0, 0, false, toolbar_gradiant,false,false,false, bBoostIconColors)) {

			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();
			#ifdef WICKEDENGINE
			if (!pref.iEnableSingleRightPanelAdvanced)
			{
				Weather_Tools_Window = false;
				Visuals_Tools_Window = false;
				//LB: Shooter now a filter mode Shooter_Tools_Window = false;
				iRestoreLastWindow = 0;
			}
			#endif

			bForceKey = true;
			#ifdef WICKEDENGINE
			csForceKey = "o";
			#else
			csForceKey = "e";
			#endif
			 Entity_Tools_Window = true;
		}
#ifdef WICKEDENGINE
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Object Tools (O)"); //Entity Mode
#else
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Object Tools (E)"); //Entity Mode
#endif

		ImGui::SameLine();
		drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);

		#ifndef WICKEDENGINE
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x + 2.0f, ImGui::GetCursorPos().y ));
		CheckTutorialAction("TOOL_MARKERS", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_mode == TOOL_MARKERS) drawCol_tmp = drawCol_back_entities * drawCol_back_active; else drawCol_tmp = drawCol_back_entities;
		if (current_mode == TOOL_MARKERS && pref.current_style >= 0) window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_MARKERS, iToolbarIconSize, drawCol_tmp, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down,0, 0, 0, 0, false, toolbar_gradiant)) {

			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();

			bForceKey = true;
			csForceKey = "m";
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Markers Mode (M)");
		ImGui::SameLine();
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x + 2.0f, ImGui::GetCursorPos().y));
		#endif

		#ifndef WICKEDENGINE
		CheckTutorialAction("TOOL_WAYPOINTS", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_mode == TOOL_WAYPOINTS) drawCol_tmp = drawCol_back_waypoint * drawCol_back_active; else drawCol_tmp = drawCol_back_waypoint;
		if (current_mode == TOOL_WAYPOINTS && pref.current_style >= 0) window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_WAYPOINTS, iToolbarIconSize, drawCol_tmp, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down,0, 0, 0, 0, false, toolbar_gradiant)) {

			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();

			bWaypoint_Window = true;
			bForceKey = true;
			csForceKey = "p";
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Waypoint Editing Mode (P)");
		ImGui::SameLine();
		#endif

		#ifndef WICKEDENGINE
		CheckTutorialAction("TOOL_DRAWWAYPOINTS", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_mode == TOOL_DRAWWAYPOINTS) drawCol_tmp = drawCol_back_waypoint * drawCol_back_active; else drawCol_tmp = drawCol_back_waypoint;
		if (current_mode == TOOL_DRAWWAYPOINTS && pref.current_style >= 0) window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_DRAWWAYPOINTS, iToolbarIconSize, drawCol_back_waypoint, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant)) {

			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();

			bWaypoint_Window = true;
			bForceKey = true;
			csForceKey = "p";

			extern int iDrawPoints;
			extern int iWaypointDeleteMode;

			bWaypointDrawmode = true;
			iWaypointDeleteMode = 1;
			iDrawPoints = 0;
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Draw Waypoint Path");
		ImGui::SameLine();
		#endif

		/*
		CheckTutorialAction("TOOL_NEWWAYPOINTS", -10.0f); //Tutorial: check if we are waiting for this action
		if (ImGui::ImgBtn(TOOL_NEWWAYPOINTS, iToolbarIconSize, drawCol_back_waypoint, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down,0, 0, 0, 0, false, toolbar_gradiant)) {

			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();

			bWaypoint_Window = true;
			bForceKey = true;
			csForceKey = "p";
			t.inputsys.domodewaypointcreate = 1;
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Create New Waypoint");
		ImGui::SameLine();
		*/

		#ifndef WICKEDENGINE
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x + 2.0f, ImGui::GetCursorPos().y));
		CheckTutorialAction("TOOL_CCP", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_mode == TOOL_CCP) drawCol_tmp = drawCol_back_tools * drawCol_back_active; else drawCol_tmp = drawCol_back_tools;
		if (current_mode == TOOL_CCP && pref.current_style >= 0) window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_CCP, iToolbarIconSize, drawCol_tmp, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant))
		{
			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();

			//Make sure any selection are removed
			t.gridentity = 0;
			t.inputsys.constructselection = 0;
			t.inputsys.domodeentity = 1;
			t.grideditselect = 5;
			editor_refresheditmarkers();
			RedockNextWindow = "Character Creator##PropertiesWindow";
			g_bCharacterCreatorPlusActivated = true;
			ImGui::SetWindowFocus(TABENTITYNAME);
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Character Creator");
		ImGui::SameLine();
		#endif

		#ifndef WICKEDENGINE
		CheckTutorialAction("TOOL_BUILDER", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_mode == TOOL_BUILDER) drawCol_tmp = drawCol_back_tools * drawCol_back_active; else drawCol_tmp = drawCol_back_tools;
		if (current_mode == TOOL_BUILDER && pref.current_style >= 0) window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_BUILDER, iToolbarIconSize, drawCol_tmp, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant)) {

			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();

			DeleteWaypointsAddedToCurrentCursor();
			//CheckTooltipObjectDelete();
			CloseDownEditorProperties();
			t.inputsys.constructselection = 0;
			#ifdef WICKEDENGINE
			iLastEntityOnCursor = 0;
			#endif
			if (t.ebebank_s[1].Len() > 0) 
			{
				t.addentityfile_s = t.ebebank_s[1].Get();
				if (t.addentityfile_s != "")
				{
					entity_adduniqueentity(false);
					t.tasset = t.entid;
					if (t.talreadyloaded == 0)
					{
						editor_filllibrary();
					}
				}
				#ifdef WICKEDENGINE
				iExtractMode = 0; //PE: Always start in find floor mode.
				#endif
				t.inputsys.constructselection = t.tasset;
				t.gridentity = t.entid;
				t.inputsys.constructselection = t.entid;
				t.inputsys.domodeentity = 1;
				t.grideditselect = 5;
				#ifdef WICKEDENGINE
				//Make sure we use a fresh t.grideleprof
				entity_fillgrideleproffromprofile();
				#endif
				editor_refresheditmarkers();

				//NewSite, make sure we are in entity mode.
				bForceKey = true;
				csForceKey = "e";
				bBuilder_Left_Window = true;
				#ifdef USELEFTPANELSTRUCTUREEDITOR
				ImGui::SetWindowFocus("Structure Editor##LeftPanel");
				#endif
			}
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Structure Editor");
		ImGui::SameLine();
		#endif

		#ifndef WICKEDENGINE
		#ifndef PRODUCTV3
		CheckTutorialAction("TOOL_IMPORT", -10.0f); //Tutorial: check if we are waiting for this action
		drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
		if (current_mode == TOOL_IMPORT) drawCol_tmp = drawCol_back_tools * drawCol_back_active; else drawCol_tmp = drawCol_back_tools;
		if (current_mode == TOOL_IMPORT && pref.current_style == 25) drawCol_Selection = drawCol_Divider_Selected;
		if (current_mode == TOOL_IMPORT && pref.current_style >= 0) window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_IMPORT, iToolbarIconSize, drawCol_tmp, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant))
		{
			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();

			//Make sure any selection are removed
			t.gridentity = 0;
			t.inputsys.constructselection = 0;
			t.inputsys.domodeentity = 1;
			t.grideditselect = 5;
			editor_refresheditmarkers();

			iLaunchAfterSync = 8; //Import model
			iSkibFramesBeforeLaunch = 5;
			ImGui::SetWindowFocus(TABENTITYNAME);
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Importer");
		ImGui::SameLine();
		#endif
		#endif

		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x + 2.0f, ImGui::GetCursorPos().y));
		float precise_icon_width = ImGui::GetCursorPos().x;

		CheckTutorialAction("TOOL_TESTGAME", -10.0f); //Tutorial: check if we are waiting for this action
		//if (ImGui::ImgBtn(TOOL_TESTGAME, iToolbarIconSize, drawCol_back_test, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down,0, 0, 0, 0, false, toolbar_gradiant)) {
		if (ImGui::ImgBtn(TOOL_TESTGAME, iToolbarIconSize, drawCol_tmp, drawCol_normal/**drawCol_Selection*/, drawCol_hover, drawCol_Down,0, 0, 0, 0, false, toolbar_gradiant,false,false,false, bBoostIconColors))
		{
			CloseAllOpenTools(false);
			if (bTutorialCheckAction) TutorialNextAction();

			//#ifdef WICKEDENGINE
			//MessageBoxA(NULL, "Test Game will return when model loading working", "Not In Alpha", MB_OK);
			//#else
			iLaunchAfterSync = 1;
			//#endif
		}

		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Test Level");

		ImGui::SameLine();

		precise_icon_width = ImGui::GetCursorPos().x - precise_icon_width;
		
		#ifdef WICKEDENGINE
		// No VR for now
		#else
		CheckTutorialAction("TOOL_VRMODE", -10.0f); //Tutorial: check if we are waiting for this action
		if (ImGui::ImgBtn(TOOL_VRMODE, iToolbarIconSize, drawCol_tmp, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down,0, 0, 0, 0, false, toolbar_gradiant,false,false,false, bBoostIconColors))
		{
			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();

			iLaunchAfterSync = 20; //Test game VR.
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0)
		{
			#ifdef WICKEDENGINE
			if (g.gvrmodefordevelopers==1 )
				ImGui::SetTooltip("%s", "Test Level in VR (This feature is experimental)");
			else
				ImGui::SetTooltip("%s", "Test Level in VR (This feature is not yet available)");
			#else
			ImGui::SetTooltip("%s", "Test Level in VR");
			#endif
		}
		ImGui::SameLine();
		#endif

		#ifndef WICKEDENGINE //PE: Save standalone toolbar icon removed in latest design.
		if (ImGui::ImgBtn(TOOL_SOCIALVR, iToolbarIconSize, drawCol_back_test, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down,0, 0, 0, 0, false, toolbar_gradiant))
		{
			#ifdef WICKEDENGINE
			// Now use this button for Save Standalone which contains the option for multiplayer export
			// Save Standalone (straight copy from FILE code, need common function holding this to avoid repeat code!!)
			CloseAllOpenTools();
			int iRet;
			iRet = AskSaveBeforeNewAction();
			if (iRet != 2)
			{
				bExport_Standalone_Window = true;
			}
			#else
			if (bWaypointDrawmode) { bWaypointDrawmode = false; }
			if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
			if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
			if (bEntity_Properties_Window) bEntity_Properties_Window = false;
			if (t.ebe.on == 1) ebe_hide();
			iLaunchAfterSync = 21; //Social VR
			#endif
		}
		#ifdef PRODUCTV3
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Social VR Mode");
		#else
		#ifdef WICKEDENGINE
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Save Standalone");
		#else
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Multiplayer Mode");
		#endif
		#endif
		ImGui::SameLine();
		#endif

		toolbar_offset_center = ImGui::GetCursorPos().x - cursorpos;

#ifdef WICKEDENGINE

//		float rightx = ImGui::GetContentRegionAvailWidth();
		float rightx = ImGui::GetContentRegionMax().x;
		float right_border = 2.0f;

		/*
		CheckTutorialAction("TOOL_VISUALS", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_mode == TOOL_VISUALS) drawCol_tmp = drawCol_back_terrain_tools * drawCol_back_active; else drawCol_tmp = drawCol_back_terrain_tools;
		if (current_mode == TOOL_VISUALS && pref.current_style >= 0) window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		if (ImGui::ImgBtn(TOOL_VISUALS, iToolbarIconSize, drawCol_tmp, drawCol_normal*drawCol_Selection, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant))
		{
			CloseAllOpenTools();
			if (bTutorialCheckAction) TutorialNextAction();

			Visuals_Tools_Window = true;
			//PE: Switch to entity mode, to remove terrain circle.
			bForceKey = true;
			csForceKey = "e";

		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Environment Effects");

		*/

		//########################
		//#### Toggle Buttons ####
		//########################

		ImVec4 toggle_color;

		//RPG Start
		bool bRPGToggle = false; // = RPG_Tools_Window (when ready to be used).
		ImGui::SetCursorPos(ImVec2(rightx - right_border - (precise_icon_width * 8), ImGui::GetCursorPos().y));
		toggle_color = drawCol_toogle;
		if (pref.current_style == 25) drawCol_Selection = drawCol_Divider_Selected;
		if (!bRPGToggle) {
			drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
			toggle_color = drawCol_back_test;
		}

		if (ImGui::ImgBtn(TOOL_RPG, iToolbarIconSize, toggle_color, drawCol_normal/**drawCol_Selection*/, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant, false, false, false, bBoostIconColors)) {
			bInfo_Window = true;
			cInfoMessage = "Future Feature: New Game Elements and Behavior logic will be added during the Early Access development phase that will allow you to create RPG style games.";
			if (0) //PE: Set to 1 when window ready.
			{
				if (iRestoreLastWindow == 0 && !pref.iEnableSingleRightPanelAdvanced)
				{
					if (bTerrain_Tools_Window)
						iRestoreLastWindow = 1;
					else
						iRestoreLastWindow = 2;
				}
				if (!pref.iEnableSingleRightPanelAdvanced)
					CloseAllOpenTools();

				if (Puzzle_Tools_Window) {

					Puzzle_Tools_Window = false;
					if (iRestoreLastWindow >= 0 && !pref.iEnableSingleRightPanelAdvanced)
					{
						if (iRestoreLastWindow == 1)
						{
							bTerrain_Tools_Window = true;
							t.grideditselect = 0;
						}
						else
						{
							bForceKey = true;
							csForceKey = "o";
							Entity_Tools_Window = true;
						}
						iRestoreLastWindow = 0;
					}
				}
				else {
					Puzzle_Tools_Window = true;
					if (!pref.iEnableSingleRightPanelAdvanced)
					{
						if (Weather_Tools_Window)
							Weather_Tools_Window = false;
						if (Visuals_Tools_Window)
							Visuals_Tools_Window = false;
						Entity_Tools_Window = false;
					}
					t.inputsys.dowaypointview = 0;
					t.gridentitymarkersmodeonly = 0;
					t.grideditselect = 5;

				}
			}
		}

		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "RPG Games (This feature not yet available)");
		ImGui::SameLine();

		//RPG End

		//Puzzle Start
		bool bPuzzleToggle = false; // = Puzzle_Tools_Window (when ready to be used).
		ImGui::SetCursorPos(ImVec2(rightx - right_border - (precise_icon_width * 7), ImGui::GetCursorPos().y));
		toggle_color = drawCol_toogle;
		if (pref.current_style == 25) drawCol_Selection = drawCol_Divider_Selected;
		if (!bPuzzleToggle) {
			drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
			toggle_color = drawCol_back_test;
		}

		if (ImGui::ImgBtn(TOOL_PUZZLE, iToolbarIconSize, toggle_color, drawCol_normal/**drawCol_Selection*/, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant, false, false, false, bBoostIconColors)) {
			bInfo_Window = true;
			cInfoMessage = "Future Feature: New Game Elements and Behavior logic will be added during the Early Access development phase that will allow you to create Puzzle style games.";
			if (0) //PE: Set to 1 when window ready.
			{
				if (iRestoreLastWindow == 0 && !pref.iEnableSingleRightPanelAdvanced)
				{
					if (bTerrain_Tools_Window)
						iRestoreLastWindow = 1;
					else
						iRestoreLastWindow = 2;
				}
				if (!pref.iEnableSingleRightPanelAdvanced)
					CloseAllOpenTools();

				if (Puzzle_Tools_Window) {

					Puzzle_Tools_Window = false;
					if (iRestoreLastWindow >= 0 && !pref.iEnableSingleRightPanelAdvanced)
					{
						if (iRestoreLastWindow == 1)
						{
							bTerrain_Tools_Window = true;
							t.grideditselect = 0;
						}
						else
						{
							bForceKey = true;
							csForceKey = "o";
							Entity_Tools_Window = true;
						}
						iRestoreLastWindow = 0;
					}
				}
				else {
					Puzzle_Tools_Window = true;
					if (!pref.iEnableSingleRightPanelAdvanced)
					{
						if (Weather_Tools_Window)
							Weather_Tools_Window = false;
						if (Visuals_Tools_Window)
							Visuals_Tools_Window = false;
						Entity_Tools_Window = false;
					}
					t.inputsys.dowaypointview = 0;
					t.gridentitymarkersmodeonly = 0;
					t.grideditselect = 5;

				}
			}
		}

		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Puzzle Games (This feature not yet available)");
		ImGui::SameLine();
		//Puzzle End

		//Shooter Start
		ImGui::SetCursorPos(ImVec2(rightx - right_border - (precise_icon_width * 6), ImGui::GetCursorPos().y));
		toggle_color = drawCol_toogle;
		if (pref.current_style == 25) drawCol_Selection = drawCol_Divider_Selected;
		if (!Shooter_Tools_Window) 
		{
			drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
			toggle_color = drawCol_back_test;
		}
		else
		{
			window->DrawList->AddRect((window->DC.CursorPos - tool_selected_padding), window->DC.CursorPos + tool_selected_padding + iToolbarIconSize, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		}
		if (ImGui::ImgBtn(TOOL_SHOOTER, iToolbarIconSize, toggle_color, drawCol_normal/**drawCol_Selection*/, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant, false, false, false, bBoostIconColors)) 
		{
			//LB: Shooter now a filter mode toggle only
			if (Shooter_Tools_Window)
				Shooter_Tools_Window = false;
			else
				Shooter_Tools_Window = true;
			/*
			//Display shooter window.
			if (iRestoreLastWindow == 0 && !pref.iEnableSingleRightPanelAdvanced)
			{
				if (bTerrain_Tools_Window)
					iRestoreLastWindow = 1;
				else
					iRestoreLastWindow = 2;
			}
			if (!pref.iEnableSingleRightPanelAdvanced)
				CloseAllOpenTools();

			if (Shooter_Tools_Window) 
			{
				Shooter_Tools_Window = false;
				if (iRestoreLastWindow >= 0 && !pref.iEnableSingleRightPanelAdvanced)
				{
					if (iRestoreLastWindow == 1)
					{
						bTerrain_Tools_Window = true;
						t.grideditselect = 0;
					}
					else
					{
						bForceKey = true;
						csForceKey = "e";
						Entity_Tools_Window = true;
					}
					iRestoreLastWindow = 0;
				}
			}
			else 
			{
				Shooter_Tools_Window = true;
				if (!pref.iEnableSingleRightPanelAdvanced)
				{
					if (Weather_Tools_Window)
						Weather_Tools_Window = false;
					if (Visuals_Tools_Window)
						Visuals_Tools_Window = false;
					Entity_Tools_Window = false;
				}
				t.inputsys.dowaypointview = 0;
				t.gridentitymarkersmodeonly = 0;
				t.grideditselect = 5;
			}
			*/
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Shooter Games");
		ImGui::SameLine();
		//Shooter End

		ImGui::SetCursorPos(ImVec2(rightx - right_border - (precise_icon_width * 5), ImGui::GetCursorPos().y));
		toggle_color = drawCol_toogle;
		if (pref.current_style == 25) drawCol_Selection = drawCol_Divider_Selected;
		if (!Visuals_Tools_Window) {
			drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
			toggle_color = drawCol_back_test;
		}
		
		if (ImGui::ImgBtn(TOOL_VISUALS, iToolbarIconSize, toggle_color, drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant, false, false, false, bBoostIconColors)) {
			//Display weather window.
			if (iRestoreLastWindow == 0 && !pref.iEnableSingleRightPanelAdvanced)
			{
				if (bTerrain_Tools_Window)
					iRestoreLastWindow = 1;
				else
					iRestoreLastWindow = 2;
			}
			if (!pref.iEnableSingleRightPanelAdvanced)
				CloseAllOpenTools();

			if (Visuals_Tools_Window) {

				Visuals_Tools_Window = false;
				if (iRestoreLastWindow >= 0 && !pref.iEnableSingleRightPanelAdvanced)
				{
					if (iRestoreLastWindow == 1)
					{
						bTerrain_Tools_Window = true;
						t.grideditselect = 0;
					}
					else
					{
						bForceKey = true;
						csForceKey = "o";
						Entity_Tools_Window = true;
					}
					iRestoreLastWindow = 0;
				}
			}
			else {
				Visuals_Tools_Window = true;
				if (!pref.iEnableSingleRightPanelAdvanced)
				{
					if (Weather_Tools_Window)
						Weather_Tools_Window = false;
					//LB: Shooter now a filter mode if (Shooter_Tools_Window)
					//	Shooter_Tools_Window = false;
					Entity_Tools_Window = false;
				}
			}
		}

		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Environment Effects");
		ImGui::SameLine();

		ImGui::SetCursorPos(ImVec2(rightx - right_border -(precise_icon_width*4) , ImGui::GetCursorPos().y));
		toggle_color = drawCol_toogle;
		if (pref.current_style == 25) drawCol_Selection = drawCol_Divider_Selected;
		if (!Weather_Tools_Window)
		{
			drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
			toggle_color = drawCol_back_test;
		}

		if (ImGui::ImgBtn(ENV_WEATHER, iToolbarIconSize, toggle_color, drawCol_normal/**drawCol_Selection*/, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant,false,false,false, bBoostIconColors)) 
		{
			//Display weather window.
			if (iRestoreLastWindow == 0 && !pref.iEnableSingleRightPanelAdvanced)
			{
				if (bTerrain_Tools_Window)
					iRestoreLastWindow = 1;
				else
					iRestoreLastWindow = 2;
			}
			if (!pref.iEnableSingleRightPanelAdvanced)
				CloseAllOpenTools();
			if (Weather_Tools_Window) 
			{
				Weather_Tools_Window = false;
				if (iRestoreLastWindow >= 0 && !pref.iEnableSingleRightPanelAdvanced)
				{
					if (iRestoreLastWindow == 1)
					{
						bTerrain_Tools_Window = true;
						t.grideditselect = 0;
					}
					else
					{
						bForceKey = true;
						csForceKey = "o";
						Entity_Tools_Window = true;
					}
					iRestoreLastWindow = 0;
				}
			}
			else 
			{
				Weather_Tools_Window = true;
				if (!pref.iEnableSingleRightPanelAdvanced)
				{
					if (Visuals_Tools_Window)
						Visuals_Tools_Window = false;
					//LB: Shooter now a filter mode
					//if (Shooter_Tools_Window)
					//	Shooter_Tools_Window = false;
					Entity_Tools_Window = false;
				}
			}
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Weather Settings");
		ImGui::SameLine();


		ImGui::SetCursorPos(ImVec2(rightx - right_border - (precise_icon_width * 3), ImGui::GetCursorPos().y));
		toggle_color = drawCol_toogle;
		if (pref.current_style == 25) drawCol_Selection = drawCol_Divider_Selected;
		if (!bEditorLight)
		{
			drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
			toggle_color = drawCol_back_test;
		}

		if (ImGui::ImgBtn(TOOL_CAMERALIGHT, iToolbarIconSize, toggle_color, drawCol_normal/**drawCol_Selection*/, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant,false,false,false, bBoostIconColors)) 
		{
			//Toggle camera mode.
			if (bEditorLight) bEditorLight = false;
			else bEditorLight = true;
			WickedCall_EnableCameraLight(bEditorLight);
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Editor Light");
		ImGui::SameLine();
		ImGui::SetCursorPos(ImVec2(rightx - right_border - (precise_icon_width * 2), ImGui::GetCursorPos().y));

		bool bIsTopDownStatus = !(bool)t.editorfreeflight.mode;
		toggle_color = drawCol_toogle;
		if (pref.current_style == 25) drawCol_Selection = drawCol_Divider_Selected;
		//if (bIsTopDownStatus)
		//{
		//	drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
		//	toggle_color = drawCol_back_test;
		//}
		drawCol_Selection = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
		toggle_color = drawCol_back_test;

		if (ImGui::ImgBtn(TOOL_CAMERA, iToolbarIconSize, toggle_color, drawCol_normal/**drawCol_Selection*/, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant,false,false,false, bBoostIconColors))
		{
			//Toggle camera mode.
			bForceKey = true;
			if (bIsTopDownStatus)
				csForceKey = "f";
			else
			{
				#ifdef WICKEDENGINE
				csForceKey = "f";
				#else
				csForceKey = "g";
				#endif
			}
		}
		if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Camera View");
		ImGui::SameLine();
		ImGui::SetCursorPos(ImVec2(rightx - right_border - (precise_icon_width * 1), ImGui::GetCursorPos().y));
		
		if (ImGui::ImgBtn(QUESTION_ICON, iToolbarIconSize, toggle_color, drawCol_normal/**drawCol_Selection*/, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, toolbar_gradiant,
			false, false, false, bBoostIconColors))
		{
			ExecuteFile("https://gameguru-max.document360.io/docs/test-topic", "", "", 0);
		}
		if (ImGui::IsItemHovered())ImGui::SetTooltip("Open GameGuru MAX User Guide");

		#endif

		ImGui::PopStyleVar();
		ImGui::PopStyleVar();


		#ifdef WICKEDENGINE
		if (bOldWelcomeScreen_Window)
		{
			ImGui::PopItemFlag(); //PE: Enable this tab.
		}
		#endif

		if (pref.current_style == 25) {
			ImGui::PopStyleColor(2);
			ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.22f, 0.43f, 0.57f, 1.00f)); //org ImVec4(0.58f, 0.58f, 0.58f, 1.00f); // ImGui::PopStyleColor();
		}

		#ifdef WICKEDENGINE
		#define HIDE_MOVED_MENU_TO_STORYBOARD
		#endif

		#ifdef WICKEDENGINE
		if (bOldWelcomeScreen_Window)
		{
			//Disable
			ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
		}
		#endif

		if (ImGui::BeginMenuBar())
		{
			if (ImGui::BeginMenu("File") )
			{
				//PE: YES new/load/save as is back :)

				#ifdef WICKEDENGINE
				// recommend an actual dialog to control how terrain/sky/veg/trees/stuff are generated
				// to start the user off with something more interesting than bumpy terrain!
				if (pref.iEnableLevelEditorOpenAndNew)
				{
					if (ImGui::MenuItem("New Level", "CTRL+N"))
					#else
					if (ImGui::MenuItem("New Random Level"))
					{
						if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
						if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
						if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
						if (bEntity_Properties_Window) bEntity_Properties_Window = false;
						if (t.ebe.on == 1) ebe_hide();

						#ifdef ALPHAEXPIRESYSTEM
						MessageBoxA(NULL, "PERLIN Random Terrain disabled for this Build", "Build Message", MB_OK);
						#else
						iLaunchAfterSync = 6;
						iSkibFramesBeforeLaunch = 5;
						#endif
					}
					if (ImGui::MenuItem("New Flat Level"))
#endif
					{
						#ifndef ENABLEAUTOLEVELSAVE
						int iRet = AskSaveBeforeNewAction();
						if (iRet == 0) //No save
						{
							g.projectmodified = 0; gridedit_changemodifiedflag();
							g.projectmodifiedstatic = 0;
						}

						#else
						int iRet = 0;
						#endif
						if (iRet != 2)
						{
							#ifdef WICKEDENGINE
							bNoSecondAsk = true;
							#endif
							CloseAllOpenTools();
						}
						#ifdef WICKEDENGINE
						#ifdef ENABLEAUTOLEVELSAVE
						if (!pref.iDisableLevelAutoSave && g.projectfilename_s != "")
						{
							//Auto save.
							iLaunchAfterSync = 504; //Do the actualy save here.
							iSkibFramesBeforeLaunch = 3;
							strcpy(cTriggerMessage, "Auto Saving Level ...");
							bTriggerMessage = true;
							iLaunchAfterSyncAction = 3; //New Level.
						}
						else
						#endif
						{
							if (iRet != 2)
							{

								//PE: Default to terrain tools , like when we launch Max.
								bForceKey = true;
								csForceKey = "t";
								bForceKey2 = true;
								csForceKey2 = "6";
								t.inputsys.domodeterrain = 1; t.inputsys.dowaypointview = 0;
								t.gridentitymarkersmodeonly = 0; t.grideditselect = 0;
								t.terrain.terrainpaintermode = 6;
								bTerrain_Tools_Window = true;
								// must reset any manual editing
								GGTerrain_ResetSculpting();
								void reset_terrain_paint_date(void);
								reset_terrain_paint_date();
								bProceduralLevelFromStoryboard = false;
								iLaunchAfterSync = 5;
								iSkibFramesBeforeLaunch = 5;
							}
						}
						#else
						iLaunchAfterSync = 5;
						iSkibFramesBeforeLaunch = 5;
						#endif
					}

				#ifdef WICKEDENGINE
				}
				#endif


				#ifdef WICKEDENGINE
				if (pref.iEnableLevelEditorOpenAndNew)
				{
					if (ImGui::MenuItem("Open Level", "CTRL+O"))
					#else
					if (ImGui::MenuItem("Open", "CTRL+O"))
					#endif
					{
						CloseAllOpenToolsThatNeedSave();
						//#ifdef ALPHAEXPIRESYSTEM
						//MessageBoxA ( NULL, "Level loading has been disabled for this Build", "Build Message", MB_OK );
						//#else

						#ifdef WICKEDENGINE
						#ifdef ENABLEAUTOLEVELSAVE
						if (!pref.iDisableLevelAutoSave && g.projectfilename_s != "")
						{
							//Auto save.
							iLaunchAfterSync = 504; //Do the actualy save here.
							iSkibFramesBeforeLaunch = 3;
							strcpy(cTriggerMessage, "Auto Saving Level ...");
							bTriggerMessage = true;
							iLaunchAfterSyncAction = 2; //Load level.
						}
						else
						#endif
						{
						#endif
							iLaunchAfterSync = 2;
							iSkibFramesBeforeLaunch = 5;
						#ifdef WICKEDENGINE
						}
						#endif
					}
					#ifdef WICKEDENGINE
				}
				#endif


				#ifdef WICKEDENGINE
				if (ImGui::MenuItem("Save Level", "CTRL+B"))
				#else
				if (ImGui::MenuItem("Save", "CTRL+Q"))
				#endif
				{
					CloseAllOpenToolsThatNeedSave();
					//#ifdef ALPHAEXPIRESYSTEM
					//MessageBoxA ( NULL, "Level saving has been disabled for this Build", "Build Message", MB_OK );
					//#else
					iLaunchAfterSync = 3; //Save
					iSkibFramesBeforeLaunch = 5;
					//#endif
				}

				#ifdef WICKEDENGINE
				if (ImGui::MenuItem("Save Level As...", ""))//CTRL+R" ) )//F12") )
				#else
				if (ImGui::MenuItem("Save As...", ""))//CTRL+R" ) )//F12") )
				#endif
				{
					CloseAllOpenToolsThatNeedSave();
					//#ifdef ALPHAEXPIRESYSTEM
					//MessageBoxA ( NULL, "Level saving has been disabled for this Build", "Build Message", MB_OK );
					//#else
					iLaunchAfterSync = 4; //Save As
					iSkibFramesBeforeLaunch = 5;
					//#endif
				}

				#ifndef WICKEDENGINE
				ImGui::Separator();
				if (ImGui::MenuItem("Save Standalone")) 
				{
					// Save Standalone
					if (bWaypointDrawmode) { bWaypointDrawmode = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();
					int iRet;
					iRet = AskSaveBeforeNewAction();
					if (iRet != 2)
					{
						bExport_Standalone_Window = true;
					}
				}
				#ifdef WICKEDENGINE
				// Feature not viable (creating an entire player to mimic MAX) - we now have Oculus Quest Link via OpenXR - yay and phew!
				#else
				if (ImGui::MenuItem("Save to Level Cloud"))
				{
					#ifdef ALPHAEXPIRESYSTEM
					MessageBoxA ( NULL, "Save to Level Cloud has been disabled for this Build", "Build Message", MB_OK );
					#else
					if (bWaypointDrawmode) { bWaypointDrawmode = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();

					// Save Standalone
					int iRet;
					iRet = AskSaveBeforeNewAction();
					if (iRet != 2)
					{
						bExport_SaveToGameCloud_Window = true;
					}
					#endif
				}
				#endif
				#ifdef WICKEDENGINE
				if (g.includeassetstore == 1)
				{
					if (ImGui::MenuItem("Download Store Items"))
					{
						if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
						if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
						if (bEntity_Properties_Window) bEntity_Properties_Window = false;
						if (t.ebe.on == 1) ebe_hide();
						//Code Missing
						extern int iDownloadStoreProgress;
						extern bool bDownloadStoreError;
						extern char cDownloadStoreError[4096];

						iDownloadStoreProgress = 0;
						bDownloadStoreError = false;
						strcpy(cDownloadStoreError, "");
						bDownloadStore_Window = true;
					}
				}
				#endif
				if (ImGui::MenuItem("Character Creator")) 
				{
					if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();

					//#ifdef WICKEDENGINE
					//MessageBoxA(NULL, "CCP will return when model loading working", "Not In Alpha", MB_OK);
					//#else
					g_bCharacterCreatorPlusActivated = true;
					//#endif
				}
				if (ImGui::MenuItem("Structure Editor")) 
				{
					if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();

					//#ifdef WICKEDENGINE
					//MessageBoxA(NULL, "Structure Editor will return when model loading working", "Not In Alpha", MB_OK);
					//#else
					DeleteWaypointsAddedToCurrentCursor();
					//CheckTooltipObjectDelete();
					CloseDownEditorProperties();
					t.inputsys.constructselection = 0;
					#ifdef WICKEDENGINE
					iLastEntityOnCursor = 0;
					#endif
					if (t.ebebank_s[1].Len() > 0) 
					{
						t.addentityfile_s = t.ebebank_s[1].Get();
						if (t.addentityfile_s != "")
						{
							entity_adduniqueentity(false);
							t.tasset = t.entid;
							if (t.talreadyloaded == 0)
							{
								editor_filllibrary();
							}
						}
						#ifdef WICKEDENGINE
						iExtractMode = 0; //PE: Always start in find floor mode.
						#endif
						t.inputsys.constructselection = t.tasset;
						t.gridentity = t.entid;
						t.inputsys.constructselection = t.entid;
						t.inputsys.domodeentity = 1;
						t.grideditselect = 5;
						editor_refresheditmarkers();

						//NewSite, make sure we are in entity mode.
						bForceKey = true;
						csForceKey = "e";
						bBuilder_Left_Window = true;
						#ifdef USELEFTPANELSTRUCTUREEDITOR
						ImGui::SetWindowFocus("Structure Editor##LeftPanel");
						#endif
					}
					//#endif
				}
				#ifndef PRODUCTV3
				if (ImGui::MenuItem("Import Model")) 
				{
					if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();

					iLaunchAfterSync = 8; //Import model
					iSkibFramesBeforeLaunch = 5;
				}
				#endif
				#endif

				ImGui::Separator();

				#ifdef WICKEDENGINE
				if (pref.iEnableLevelEditorOpenAndNew)
				#endif
				{
					//for (int ii = 0; ii < REMEMBERLASTFILES; ii++) { //reverse
					for (int ii = REMEMBERLASTFILES - 1; ii >= 0; ii--) {
						if (strlen(pref.last_open_files[ii]) > 0) {
							char tmp[260];
							strcpy(tmp, pref.last_open_files[ii]);
							int pos = strlen(tmp);
							while (pos > 0 && tmp[pos] != '\\') pos--;

							//std::string s_tmp = std::to_string(1+ii); //Reverse
							std::string s_tmp = std::to_string(REMEMBERLASTFILES - ii);
							s_tmp += ": ";
							s_tmp += &tmp[pos + 1];

							if (ImGui::MenuItem(s_tmp.c_str())) {
								if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
								if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
								if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
								if (bEntity_Properties_Window) bEntity_Properties_Window = false;
								if (t.ebe.on == 1) ebe_hide();

								strcpy(cDirectOpen, pref.last_open_files[ii]);
								iLaunchAfterSync = 7; //Direct open.
								iSkibFramesBeforeLaunch = 5;
							}
						}
					}

					ImGui::Separator();
				}

				#ifdef HIDE_MOVED_MENU_TO_STORYBOARD

				if (ImGui::MenuItem("Back to Storyboard Editor"))
				{
					CloseAllOpenToolsThatNeedSave();
					//Storyboard can change levels ... so make sure we ask to save first.
					int iRet = AskSaveBeforeNewAction();
					if (iRet != 2)
					{
						bStoryboardWindow = true;
					}
					bStoryboardWindow = true;
					GGTerrain_CancelRamp();
				}

				#else
				if (ImGui::MenuItem("Exit")) 
				{
					if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();
					#ifdef WICKEDENGINE
					g_bCascadeQuitFlag = true;
					#else
					int iRet = AskSaveBeforeNewAction();
					if (iRet != 2)
					{
						g_bCascadeQuitFlag = true;
					}
					#endif
				}
				#endif
				ImGui::EndMenu();
			}
			else
			{
				if(pref.bAutoOpenMenuItems)
					if (ImGui::IsItemHovered()) 
						ImGui::OpenPopup("File");
			}

			if (ImGui::BeginMenu("Edit"))
			{
				if (ImGui::MenuItem("Undo","CTRL+Z")) 
				{
					//t.inputsys.doundo = 1;
					bForceUndo = true;
				}
				if (ImGui::MenuItem("Redo", "CTRL+Y")) 
				{
					t.inputsys.doredo = 1;
					bForceRedo = true;
				}
				#ifdef WICKEDENGINE
				ImGui::Separator();
				if (ImGui::MenuItem("Cut", "CTRL+X")) {
					iExecuteCTRLkey = 'X';
				}
				if (ImGui::MenuItem("Copy", "CTRL+C")) {
					iExecuteCTRLkey = ImGuiKey_C;
				}
				if (ImGui::MenuItem("Paste", "CTRL+V")) {
					iExecuteCTRLkey = ImGuiKey_V;
				}
				ImGui::Separator();
				if (ImGui::MenuItem("Delete", "DEL")) {
					iExecuteCTRLkey = ImGuiKey_Delete;
				}

				ImGui::Separator();
				if (ImGui::MenuItem("Character Creator")) 
				{
					CloseAllOpenTools();
					iLaunchAfterSync = 82; //Start Character Creator
					iSkibFramesBeforeLaunch = 2;
					strcpy(cTriggerMessage, "Loading Character Creator");
					bTriggerMessage = true;
				}

				if (g_bParticleEditorPresent == true)
				{
					ImGui::Separator();
					if (ImGui::MenuItem("Particle Editor"))
					{
						launchOrShowParticleEditor();
					}
				}
				/* no longer 'sell' functionality
				else
				{
					ImGui::Separator();
					ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.75f, 0.75f, 0.75f, 1.0f));
					if ( ImGui::MenuItem("Particle Editor"))
					{
						if (g_bUpdateAppAvailable == true)
							ExecuteFile("https://www.game-guru.com/order?_ga=2.121561419.292858542.1654524806-1982497974.1625668666#dlc", "", "", 0);
						else
							ExecuteFile("https://store.steampowered.com/dlc/1247290/GameGuru_MAX/", "", "", 0);
					}
					ImGui::PopStyleColor();
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Buy the Particle Editor to design and add your own particles to your games");
				}
				*/

				ImGui::Separator();
				if (ImGui::MenuItem("Marketplace")) 
				{
					CloseAllOpenTools();
					DeleteWaypointsAddedToCurrentCursor();
					CloseDownEditorProperties();
					bMarketplace_Window = true;
				}

				#endif
				#ifdef BUILDINGEDITOR
				ImGui::Separator();
				if (ImGui::MenuItem("Building Editor")) {
					CloseAllOpenTools();
					BuildingEditor::init();
				}
				#endif

				ImGui::Separator();

				#ifndef WICKEDENGINE //PE: Moved to settings in new design.

				if (ImGui::BeginMenu("Window Views")) 
				{
					#ifdef WICKEDENGINE
					if (Visuals_Tools_Window)
					{
						if (ImGui::MenuItem("Hide Visuals")) {
							Visuals_Tools_Window = false;
						}
					}
					else
					{
						if (ImGui::MenuItem("Show Visuals")) {
							Visuals_Tools_Window = true;
						}
					}
					#endif
//					#ifndef DISABLETUTORIALS
					if (bHelp_Window) 
					{
						if (ImGui::MenuItem("Hide Tutorial")) {
							bHelpVideo_Window = false;
							bHelp_Window = false;
						}
					}
					else 
					{
						if (ImGui::MenuItem("Show Tutorial")) {
							bHelpVideo_Window = true;
							bHelp_Window = true;
							bSetTutorialSectionLeft = false;

						}
					}
//					#endif
					#ifdef USELEFTPANELSTRUCTUREEDITOR
					if (bBuilder_Left_Window) {
						if (ImGui::MenuItem("Hide Structure Editor")) {
							bBuilder_Left_Window = false;
						}
					}
					else {
						if (ImGui::MenuItem("Show Structure Editor")) {
							bBuilder_Left_Window = true;
						}
					}
					#endif
					if (iTriggerWelcomeSystemStuff == 0) 
					{
						if (ImGui::MenuItem("Show Welcome Screen")) 
						{
							editor_showquickstart(1);
							iTriggerWelcomeSystemStuff = 99;
						}
					}
					else 
					{
						if (ImGui::MenuItem("Hide Welcome Screen")) 
						{
							welcome_free();
							iTriggerWelcomeSystemStuff = 7;
						}
					}

					ImGui::EndMenu();
				}
				#endif

				#ifndef WICKEDENGINE //PE: Moved to settings in new design.
				if (ImGui::BeginMenu("Change Color Scheme")) 
				{
					#ifdef PRODUCTV3
					if (ImGui::MenuItem("Light Style")) { // VRQ/Classic = Light Style
						myLightStyle(NULL);
						pref.current_style = 3;
					}
					#else
					if (ImGui::MenuItem("Dark Style")) {
						myStyle2(NULL);
						pref.current_style = 0;
					}
					#endif
					if (ImGui::MenuItem("Darker Style")) {
						myDarkStyle(NULL);
						pref.current_style = 1;
					}
					ImGui::EndMenu();
				}
				#endif

				#ifndef WICKEDENGINE //PE: Moved in Max to settings.
				if (ImGui::BeginMenu("Reset Layout")) 
				{
					//Full Desktop Size
					if (ImGui::MenuItem("Full Desktop Size")) 
					{
						refresh_gui_docking = 0;
#ifndef WICKEDENGINE
						pref.vStartResolution = { 1280,800 };
						pref.iMaximized = 1;
						SetWindowSize(pref.vStartResolution.x, pref.vStartResolution.y);
						float centerx = (GetDesktopWidth()*0.5) - (pref.vStartResolution.x*0.5);
						float centery = ((float)(GetDesktopHeight()*0.5) - (float)(pref.vStartResolution.y*0.5)) * 0.5f;
						if (centerx < 0) centerx = 0;
						if (centery < 0) centery = 0;
						SetWindowPosition(centerx, centery);
#endif
						MaximiseWindow();
					}

					if (ImGui::MenuItem("Current Window Size")) {
						refresh_gui_docking = 0;
					}
					//PE: SetWindowSize is ruin the winodw in wicked.
#ifndef WICKEDENGINE
					if (ImGui::MenuItem("Size 1024x768")) {
						refresh_gui_docking = 0;
						pref.vStartResolution = { 1024,768 };
						pref.iMaximized = 0;
						SetWindowSize(pref.vStartResolution.x, pref.vStartResolution.y);
						float centerx = (GetDesktopWidth()*0.5) - (pref.vStartResolution.x*0.5);
						float centery = ((float)(GetDesktopHeight()*0.5) - (float)(pref.vStartResolution.y*0.5)) * 0.5f;
						if (centerx < 0) centerx = 0;
						if (centery < 0) centery = 0;
						SetWindowPosition(centerx, centery);
						RestoreWindow();
					}
					if (ImGui::MenuItem("Size 1280x800")) {
						refresh_gui_docking = 0;
						pref.vStartResolution = { 1280,800 };
						pref.iMaximized = 0;
						SetWindowSize(pref.vStartResolution.x, pref.vStartResolution.y);
						float centerx = (GetDesktopWidth()*0.5) - (pref.vStartResolution.x*0.5);
						float centery = ((float)(GetDesktopHeight()*0.5) - (float)(pref.vStartResolution.y*0.5)) * 0.5f;
						if (centerx < 0) centerx = 0;
						if (centery < 0) centery = 0;
						SetWindowPosition(centerx, centery);
						RestoreWindow();
					}
#endif
					ImGui::EndMenu();
				}
				#endif

				#ifdef WICKEDENGINE
				if (ImGui::MenuItem("Settings", "")) 
				{
					strcpy(cPreferencesMessage,"");
					bPreferences_Window = true;
				}
				#endif

				ImGui::EndMenu();
			}
			else
			{
				if (pref.bAutoOpenMenuItems)
					if (ImGui::IsItemHovered())
						ImGui::OpenPopup("Edit");
			}

#ifndef WICKEDENGINE
			if (ImGui::BeginMenu("Terrain"))
			{
				if (ImGui::MenuItem("Shape Mode")) {
					if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();
					bForceKey = true;
					csForceKey = "t";
					bForceKey2 = true;
					csForceKey2 = "1";
				}
				if (ImGui::MenuItem("Level Mode")) {
					if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();
					bForceKey = true;
					csForceKey = "t";
					bForceKey2 = true;
					csForceKey2 = "2";
				}
				if (ImGui::MenuItem("Stored Level Mode")) {
					if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();
					bForceKey = true;
					csForceKey = "t";
					bForceKey2 = true;
					csForceKey2 = "3";
				}
				if (ImGui::MenuItem("Blend Mode")) {
					if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();
					bForceKey = true;
					csForceKey = "t";
					bForceKey2 = true;
					csForceKey2 = "4";
				}
				if (ImGui::MenuItem("Ramp Mode")) {
					if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();
					bForceKey = true;
					csForceKey = "t";
					bForceKey2 = true;
					csForceKey2 = "5";
				}
				if (ImGui::MenuItem("Paint Texture")) {
					if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();
					bForceKey = true;
					csForceKey = "t";
					bForceKey2 = true;
					csForceKey2 = "6";
				}
				if (ImGui::MenuItem("Paint Grass")) {
					if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();
					bForceKey = true;
					csForceKey = "t";
					bForceKey2 = true;
					csForceKey2 = "0";
				}
				ImGui::EndMenu();
			}
			else
			{
				if (ImGui::IsItemHovered()) ImGui::OpenPopup("Terrain");
			}

			if (ImGui::BeginMenu("Entities"))
			{
				if (ImGui::MenuItem("Entity Mode")) {
					if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();
					bForceKey = true;
					csForceKey = "e";
				}
				if (ImGui::MenuItem("Marker Mode")) {
					if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();
					bForceKey = true;
					csForceKey = "m";
				}
				//PE: if we change text "waypoint" it should be done everywhere, like lua/help ... until then:
				if (ImGui::MenuItem("Waypoint Mode")) { //Follow text used: was Path Mode
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();

					bWaypoint_Window = true;
					bForceKey = true;
					csForceKey = "p";
				}
				if (ImGui::MenuItem("Draw Waypoint Path")) { //Follow text used, was: Draw New Path
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();

					bWaypoint_Window = true;
					bForceKey = true;
					csForceKey = "p";

					extern int iDrawPoints;
					extern int iWaypointDeleteMode;

					bWaypointDrawmode = true;
					iWaypointDeleteMode = 1;
					iDrawPoints = 0;

				}
				//Old waypoint system.
//					if (ImGui::MenuItem("Create New Path")) {
//						if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
//						if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
//						if (bEntity_Properties_Window) bEntity_Properties_Window = false;
//						if (t.ebe.on == 1) ebe_hide();
//						bWaypoint_Window = true;
//						bForceKey = true;
//						csForceKey = "p";
//						t.inputsys.domodewaypointcreate = 1;
//					}

				ImGui::EndMenu();
			}
			else
			{
				if (ImGui::IsItemHovered()) ImGui::OpenPopup("Entities");
			}


			if (ImGui::BeginMenu("Test Level"))
			{
				if (ImGui::MenuItem("Test Level")) 
				{
					if (bWaypointDrawmode) { bWaypointDrawmode = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();

					//#ifdef WICKEDENGINE
					//MessageBoxA(NULL, "Test Game will return when model loading working", "Not In Alpha", MB_OK);
					//#else
					iLaunchAfterSync = 1;
					//#endif
				}
				if (ImGui::MenuItem("Test Game in VR")) 
				{
					if (bWaypointDrawmode) { bWaypointDrawmode = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();
					iLaunchAfterSync = 20; //Test game VR.
				}
				#ifdef WICKEDENGINE
				// no third item in test game menu
				#else
				#ifdef PRODUCTV3
				if (ImGui::MenuItem("Social VR")) {
				#else
				if (ImGui::MenuItem("Multiplayer Mode")) {
				#endif
				#ifdef ALPHAEXPIRESYSTEM
				MessageBoxA(NULL, "Multiplayer Mode not available in build", "Not In Build", MB_OK);
				#else
				if (bWaypointDrawmode) { bWaypointDrawmode = false; }
				if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
				if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
				if (bEntity_Properties_Window) bEntity_Properties_Window = false;
				if (t.ebe.on == 1) ebe_hide();
				iLaunchAfterSync = 21; //Social VR
				//Always switch back to entity mode after test game.
				//bForceKey = true;
				//csForceKey = "e";
				//Entity_Tools_Window = true;
				#endif
				}
				#endif
				ImGui::EndMenu();
			}
			else
			{
				if (ImGui::IsItemHovered()) ImGui::OpenPopup("Test Level");
			}

#endif

			if (ImGui::BeginMenu("Help"))
			{
				#ifndef HIDE_MOVED_MENU_TO_STORYBOARD
				#ifdef WICKEDENGINE
				#ifdef USEWELCOMESCREEN
				//Editor KeyboardShortcuts, Game Keyboard Shortcuts, Game VR Controls, Read User Manual, Getting Started Tutorial and About
				if (ImGui::MenuItem("Welcome Screen")) {
					bWelcomeScreen_Window = true;
				}
				#endif
				#endif
				#endif

				image_setlegacyimageloading(true);

				// ZJ: No longer needed.
				/*				
				#ifdef HIDE_MOVED_MENU_TO_STORYBOARD
				if (ImGui::MenuItem("Editor Shortcuts", "F1")) {
					strcpy(cHelpMenuImage, "languagebank\\english\\artwork\\quick-help.png");
					LoadImage(cHelpMenuImage, HELPMENU_IMAGE);
					bHelp_Menu_Image_Window = true;
				}
				#endif
				*/

				#ifndef WICKEDENGINE
				if (ImGui::MenuItem("Editor Shortcuts","F1")) {
					strcpy(cHelpMenuImage, "languagebank\\english\\artwork\\quick-help.png");
					LoadImage(cHelpMenuImage, HELPMENU_IMAGE);
					bHelp_Menu_Image_Window = true;
				}
				#endif

#ifdef WICKEDENGINE
				if (ImGui::MenuItem("Test Level Controls")) {

#else
				if (ImGui::MenuItem("Level Shortcuts")) {
#endif
					strcpy(cHelpMenuImage, "languagebank\\english\\artwork\\testgamelayout.png");
					LoadImage(cHelpMenuImage, HELPMENU_IMAGE);
					bHelp_Menu_Image_Window = true;
				}

				#ifdef WICKEDENGINE
				// no VR for now
				#else
				if (ImGui::MenuItem("VR Controls")) {
					strcpy(cHelpMenuImage, "languagebank\\english\\artwork\\testgamelayout-vr.png");
					LoadImage(cHelpMenuImage, HELPMENU_IMAGE);
					bHelp_Menu_Image_Window = true;
				}
				#endif
				if (ImGui::MenuItem("Read User Manual")) 
				{
					#ifdef WICKEDENGINE
					ExecuteFile("https://gameguru-max.document360.io/docs", "", "", 0);
					#else
					cstr pPDFPath = g.fpscrootdir_s + "\\Files\\languagebank\\english\\artwork\\Getting Started Guide.pdf";
					ExecuteFile (pPDFPath.Get(), "", "", 0);
					#endif
				}
				if (g_bParticleEditorPresent == true)
				{
					if (ImGui::MenuItem("Particle Editor User Guide"))
					{
						char pOldDir[MAX_PATH];
						strcpy(pOldDir, GetDir());
						SetDir("..");
						SetDir("DLC\\Particle Editor\\media\\docs\\");
						ExecuteFile("Particle Editor User Guide.pdf", "", "", 0);
						SetDir(pOldDir);
					}
				}
				#ifndef DISABLETUTORIALS
				if (ImGui::MenuItem("Getting Started Tutorial"))
				{
					bHelpVideo_Window = true;
					bHelp_Window = true;
					bSetTutorialSectionLeft = false;
					strcpy(cForceTutorialName, "01 - Getting started");
				}
				#endif
				#ifdef WICKEDENGINE
				/* ZJ: Now these are in the hub.
				if (ImGui::MenuItem("GameGuru MAX YouTube Channel"))
				{
					ExecuteFile("https://www.youtube.com/channel/UC1q1e3Q9IKMk4nDlAGb_5Jg", "", "", 0);
				}
				if (ImGui::MenuItem("GameGuru MAX Forum"))
				{
					ExecuteFile("https://forum.game-guru.com/", "", "", 0);
				}
				if (ImGui::MenuItem("GameGuru MAX Discord"))
				{
					ExecuteFile("https://discord.gg/xnTAbBR", "", "", 0);
				}
				*/
      			if ( g_bUpdateAppAvailable == true )
				{
					if (ImGui::MenuItem("Check For Updates"))
					{
						int iRet = AskSaveBeforeNewAction();
						if (iRet != 2)
						{
							g.projectmodified = 0;
							g.projectmodifiedstatic = 0;
							ExecuteFile("..\\..\\GameGuru MAX Updater.exe", "", "", 0);
							g_bCascadeQuitFlag = true;
						}
					}
				}
				#ifndef LBBUGTRACKING
				if (ImGui::MenuItem("Report an Issue (GitHub)"))
				{
					ExecuteFile("https://github.com/TheGameCreators/GameGuruRepo/issues/new", "", "", 0);

				}
				#endif
				#ifdef LBBUGTRACKING
				if (ImGui::MenuItem("Bug Reporting System")) 
				{
					//LB: When choose Bug Tracking System, need to bring it to the front (or hide othedr right side panels)
					//if (!pref.iEnableSingleRightPanelAdvanced)
					//{
					//	CloseAllOpenTools();
					//	Weather_Tools_Window = false;
					//	Visuals_Tools_Window = false;
					//	Entity_Tools_Window = false;
					//	bTerrain_Tools_Window = false;
					//	bWaypoint_Window = false;
					//	iRestoreLastWindow = 0;
					//}
					bBug_Reporting_Window = true;
					bBug_RefreshBugList = true;
				}
				#endif
				#endif

				#ifdef WICKEDENGINE
				if (ImGui::MenuItem("GameGuru MAX Hub"))
				{
					bWelcomeNoBackButton = false;
					bWelcomeScreen_Window = true;
				}
				if (g_bFreeTrialVersion == true)
				{
					if (ImGui::MenuItem("Buy GameGuru MAX"))
					{
						CloseAllOpenTools();
						DeleteWaypointsAddedToCurrentCursor();
						CloseDownEditorProperties();
						bFreeTrial_Window = true;
					}
				}
				#endif

				if (ImGui::MenuItem("About")) {
					bAbout_Window = true;
					bAbout_Window_First_Run = true;
				}
				image_setlegacyimageloading(false);

				ImGui::EndMenu();
			}
			else
			{
				if (pref.bAutoOpenMenuItems)
					if (ImGui::IsItemHovered()) 
						ImGui::OpenPopup("Help");
			}
			ImGui::EndMenuBar();
		}

		#ifdef WICKEDENGINE
		if (bOldWelcomeScreen_Window)
		{
			ImGui::PopItemFlag(); //PE: Enable this tab.
		}
		#endif

		if (pref.current_style == 25)
			ImGui::PopStyleColor(); 

		//Process systemwide shortcut keys.

		ImGuiIO& io = ImGui::GetIO();
		if (ImGui::GetTime() - lastKeyTime >= 0.125) 
		{ 
			//small delay between key input.
			auto ctrl = io.KeyCtrl;
			auto alt = io.ConfigMacOSXBehaviors ? io.KeyCtrl : io.KeyAlt;
			auto shift = io.KeyShift;

			#ifndef WICKEDENGINE
			int iExecuteCTRLkey = 0;
			#endif
			//PE: No repeat on these keys.
			static bool bWaitOnGRelease = false;
			if (bWaitOnGRelease && ImGui::IsKeyReleased(71))
				bWaitOnGRelease = false;

			//LB: ensure CTRL+Z can release Z and repress so all does not happen at once
			static bool bWaitOnZRelease = false;
			if (bWaitOnZRelease /*&& ImGui::IsKeyReleased(90)*/ && !ImGui::IsKeyDown(90))
			{
				t.inputsys.undokeypress = 0;
				bWaitOnZRelease = false;
			}

			if (ctrl && !shift && !alt && ImGui::IsKeyPressed(89) || iExecuteCTRLkey == 'Y' ) //Y
			{ 
				//CTRL Y - redo
				lastKeyTime = (float)ImGui::GetTime();
				iExecuteCTRLkey = 0;
				bForceRedo = true;
			}
			else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(78) || iExecuteCTRLkey == 'N') //N
			{
				lastKeyTime = (float)ImGui::GetTime();
				iExecuteCTRLkey = 0;
				#ifdef STORYBOARD
				if (bStoryboardWindow && iExecuteCTRLkey != 'N' && !bProceduralLevel) iStoryboardExecuteKey = 'N';
				if (!bStoryboardWindow)
				#endif
				{
					#ifdef WICKEDENGINE
					if (pref.iEnableLevelEditorOpenAndNew)
					#endif
					{
						CloseAllOpenTools();
						iLaunchAfterSync = 5;
						bProceduralLevelFromStoryboard = false;
						iSkibFramesBeforeLaunch = 5;
					}
				}
			}
			else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(76)) //CTRL+L, Add level in storyboard, lock/unlock selected object(s) in editor
			{
				lastKeyTime = (float)ImGui::GetTime();
				iExecuteCTRLkey = 0;
				#ifdef STORYBOARD
				if (bStoryboardWindow && !bProceduralLevel)
					iStoryboardExecuteKey = 'L';
				else
				{
					bool bLock = true;
					// Determine if the selected object should be locked/unlocked.
					int iObjectLockedIndex = -1;
					if (vEntityLockedList.size() > 0)
					{
						for (int i = 0; i < vEntityLockedList.size(); i++)
						{
							int e = vEntityLockedList[i].e;
							if (e == t.widget.pickedEntityIndex)
							{
								iObjectLockedIndex = i;
								bLock = false;
								break;
							}
						}
					}

					LockSelectedObject(bLock, iObjectLockedIndex);
				}
				#endif
			}
			else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(69)) //E
			{
				lastKeyTime = (float)ImGui::GetTime();
				iExecuteCTRLkey = 0;
				#ifdef STORYBOARD
				if (bStoryboardWindow && !bProceduralLevel) iStoryboardExecuteKey = 'E';
				#endif
			}
			else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(32)) //SPACE
			{
				lastKeyTime = (float)ImGui::GetTime();
				iExecuteCTRLkey = 0;
				#ifdef STORYBOARD
				if (bStoryboardWindow && !bProceduralLevel) iStoryboardExecuteKey = ' ';
				#endif
			}
			else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(73) || iExecuteCTRLkey == 'I') //I - Importer
			{
				lastKeyTime = (float)ImGui::GetTime();
				iExecuteCTRLkey = 0;
				DeleteWaypointsAddedToCurrentCursor();
				CloseDownEditorProperties();
				CloseAllOpenTools();
				iLaunchAfterSync = 8; //Import model
				iSkibFramesBeforeLaunch = 5;
				#ifdef WICKEDENGINE
				bMarketplace_Window = false;
				if (bExternal_Entities_Window)
				{
					bTriggerCloseEntityWindow = true;
					bCheckForClosingForce = true; //Force window to close.
				}
				bEnableWeather = false;
				#else
				if (bExternal_Entities_Window)
				{
					bCheckForClosingForce = true;
				}
				#endif
			}
			else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(79) || iExecuteCTRLkey == 'O' ) //O
			{
				#ifdef WICKEDENGINE
				if (pref.iEnableLevelEditorOpenAndNew)
				#endif
				{
					lastKeyTime = (float)ImGui::GetTime();
					iExecuteCTRLkey = 0;
					CloseAllOpenTools();
					iLaunchAfterSync = 2;
					iSkibFramesBeforeLaunch = 5;
				}
			}
			//else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(83) || iExecuteCTRLkey == 'S') //S
#ifdef WICKEDENGINE
			else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(66) || iExecuteCTRLkey == 'B') //B
#else
			else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(81) || iExecuteCTRLkey == 'Q') //Q
#endif
			{
				lastKeyTime = (float)ImGui::GetTime();
				iExecuteCTRLkey = 0;
				CloseAllOpenToolsThatNeedSave();
				iLaunchAfterSync = 3; //Save
				iSkibFramesBeforeLaunch = 5;
			}
			/*
			//else if (!ctrl && !shift && !alt && ImGui::IsKeyPressed(0x7B)) // 0x70 = F1 0x7B = F12
			else if (!ctrl && !shift && !alt && ImGui::IsKeyPressed(82) || iExecuteCTRLkey == 'R') //R
			{
				lastKeyTime = (float)ImGui::GetTime();
				iExecuteCTRLkey = 0;
				CloseAllOpenTools();
				iLaunchAfterSync = 4; //Save As
				iSkibFramesBeforeLaunch = 5;
			}
			*/
			else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(88) || iExecuteCTRLkey == 'X') //X , "CUT"
			{
				if (!bLastImGuiGotFocus || iExecuteCTRLkey == 'X')
				{
					lastKeyTime = (float)ImGui::GetTime();
					iExecuteCTRLkey = 0;

					#ifdef WICKEDENGINE
					//PE: Do a copy before delete. , so we can paste after cut.
					//PE: TODO - To suppot CUT objects, we need to also store the masterid in g_EntityClipboard.
					/*
					if (t.widget.pickedEntityIndex > 0)
					{
						g_EntityClipboard.clear();
						if (g.entityrubberbandlist.size() > 0)
						{
							for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
							{
								int e = g.entityrubberbandlist[i].e;
								g_EntityClipboard.push_back(e);
							}
						}
						else
						{
							g_EntityClipboard.push_back(t.widget.pickedEntityIndex);
						}
						g_EntityClipboardAnchorEntityIndex = t.widget.pickedEntityIndex;
					}
					*/

					#endif

					t.widget.deletebuttonselected = 1;
					widget_show_widget();
				}
			}
			/* is this a thing? - only CTRL+Z documented in the UI
			else if (!ctrl && !shift && alt && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Backspace)))
			{ 
				//ALT BACKSPACE - undo
				lastKeyTime = (float)ImGui::GetTime();
				iExecuteCTRLkey = 0;
				if (t.inputsys.undokeypress == 0)
				{
					bForceUndo = true;
					bWaitOnZRelease = true;
				}
			}
			*/
			else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(90) && bWaitOnZRelease==false) 
			{ 
				//CTRL Z - undo
				lastKeyTime = (float)ImGui::GetTime();
				iExecuteCTRLkey = 0;
				bForceUndo = true;
				bWaitOnZRelease = true;
				t.inputsys.undokeypress = 1;
			}
			#ifdef GROUPINGFEATURE
			else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(71)) //CTRL+G
			{
				//CTRL G - Group.
				if (!bWaitOnGRelease)
					CreateNewGroup(-1);
				bWaitOnGRelease = true;
			}
			else if (ctrl && shift && !alt && ImGui::IsKeyPressed(71)) //CTRL+SHIFT+G
			{
				//CTRL+SHIFT G - UnGroup.
				if(!bWaitOnGRelease)
					UnGroupSelected();
				bWaitOnGRelease = true;
			}
			#endif
#ifdef WICKEDENGINE
			else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_C)) || iExecuteCTRLkey == ImGuiKey_C)
			{
				//PE: Mouse need to be in Level Editor for copy paste objects to work.
				if (!bLastImGuiGotFocus || iExecuteCTRLkey == ImGuiKey_C)
				{
					lastKeyTime = (float)ImGui::GetTime();
					iExecuteCTRLkey = 0;

					//CTRL C - copy rubber band or single to clipboard
					if (t.widget.pickedEntityIndex > 0)
					{
						g_EntityClipboard.clear();
						if (g.entityrubberbandlist.size() > 0)
						{
							for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
							{
								int e = g.entityrubberbandlist[i].e;
								int entid = t.entityelement[e].bankindex;
								if (entid > 0 && t.entityprofile[entid].ismarker != 1)
								{
									g_EntityClipboard.push_back(e);
								}
							}
						}
						else
						{
							int entid = t.entityelement[t.widget.pickedEntityIndex].bankindex;
							if (entid > 0 && t.entityprofile[entid].ismarker != 1 )
							{
								g_EntityClipboard.push_back(t.widget.pickedEntityIndex);
							}
						}
						g_EntityClipboardAnchorEntityIndex = t.widget.pickedEntityIndex;
					}
				}
			}
			else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_V)) || iExecuteCTRLkey == ImGuiKey_V )
			{
				//PE: Mouse need to be in Level Editor for copy paste objects to work.
				if (!bLastImGuiGotFocus || iExecuteCTRLkey == ImGuiKey_V)
				{

					lastKeyTime = (float)ImGui::GetTime();
					iExecuteCTRLkey = 0;

					//CTRL V - duplicate from clipboard
					if (g_EntityClipboard.size() > 0)
					{
						// a small offset so user can see new pasted entity
						float fShiftOffsetForPasteX = 25.0f + rand() % 50;
						float fShiftOffsetForPasteZ = 25.0f + rand() % 50;
						if (rand() % 2 == 0) fShiftOffsetForPasteX = -fShiftOffsetForPasteX;
						if (rand() % 2 == 0) fShiftOffsetForPasteZ = -fShiftOffsetForPasteZ;

						// determine anchor entity from original entity group
						int iAnchorEntityIndex = -1;

						// we are also going to move rubber band selection to new pasted group
						g.entityrubberbandlist.clear();

						// for each entity, create a duplicate and offset slightly so we can see it
						for (int i = 0; i < (int)g_EntityClipboard.size(); i++)
						{
							// duplicate new entity as clone of relevant original clipboard entity
							int e = g_EntityClipboard[i];
							t.gridentity = t.entityelement[e].bankindex;
							#ifdef WICKEDENGINE
							//PE: all t.gridentity... need to be set for this to work correctly.
							t.entid = t.gridentity;
							entity_fillgrideleproffromprofile();  // t.entid
							t.gridentityposx_f = t.entityelement[e].x;
							t.gridentityposy_f = t.entityelement[e].y;
							t.gridentityposz_f = t.entityelement[e].z;
							t.gridentityrotatex_f = t.entityelement[e].rx;
							t.gridentityrotatey_f = t.entityelement[e].ry;
							t.gridentityrotatez_f = t.entityelement[e].rz;
							t.gridentityrotatequatmode = t.entityelement[e].quatmode;
							t.gridentityrotatequatx_f = t.entityelement[e].quatx;
							t.gridentityrotatequaty_f = t.entityelement[e].quaty;
							t.gridentityrotatequatz_f = t.entityelement[e].quatz;
							t.gridentityrotatequatw_f = t.entityelement[e].quatw;
							if (t.entityprofile[t.gridentity].ismarker == 10)
							{
								t.gridentityscalex_f = 100.0f + t.entityelement[e].scalex;
								t.gridentityscaley_f = 100.0f + t.entityelement[e].scaley;
								t.gridentityscalez_f = 100.0f + t.entityelement[e].scalez;
							}
							else
							{
								t.gridentityscalex_f = ObjectScaleX(t.entityelement[e].obj);
								t.gridentityscaley_f = ObjectScaleY(t.entityelement[e].obj);
								t.gridentityscalez_f = ObjectScaleZ(t.entityelement[e].obj);
							}
							t.grideleprof = t.entityelement[e].eleprof;
							entity_cleargrideleprofrelationshipdata();
							t.grideleprof.newparticle.emitterid = -1; //PE: Must always get a new emitter ID.
							#endif

							#ifdef WICKEDENGINE
							//PE: InstanceObject - Cursor,Object Tools - objects must always be real clones.
							extern bool bNextObjectMustBeClone;
							bNextObjectMustBeClone = true;
							#endif

							gridedit_addentitytomap();

							#ifdef WICKEDENGINE
							bNextObjectMustBeClone = false;
							#endif

							if (e == g_EntityClipboardAnchorEntityIndex) iAnchorEntityIndex = t.e;
							t.entityelement[t.e].x = t.entityelement[e].x + fShiftOffsetForPasteX;
							t.entityelement[t.e].y = t.entityelement[e].y;
							t.entityelement[t.e].z = t.entityelement[e].z + fShiftOffsetForPasteZ;
							t.entityelement[t.e].rx = t.entityelement[e].rx;
							t.entityelement[t.e].ry = t.entityelement[e].ry;
							t.entityelement[t.e].rz = t.entityelement[e].rz;		
							t.entityelement[t.e].quatmode = t.entityelement[e].quatmode;
							t.entityelement[t.e].quatx = t.entityelement[e].quatx;
							t.entityelement[t.e].quaty = t.entityelement[e].quaty;
							t.entityelement[t.e].quatz = t.entityelement[e].quatz;
							t.entityelement[t.e].quatw = t.entityelement[e].quatw;
							t.entityelement[t.e].editorfixed = t.entityelement[e].editorfixed;
							t.entityelement[t.e].staticflag = t.entityelement[e].staticflag;
							t.entityelement[t.e].scalex = t.entityelement[e].scalex;
							t.entityelement[t.e].scaley = t.entityelement[e].scaley;
							t.entityelement[t.e].scalez = t.entityelement[e].scalez;
							t.entityelement[t.e].soundset = t.entityelement[e].soundset;
							t.entityelement[t.e].soundset1 = t.entityelement[e].soundset1;
							t.entityelement[t.e].soundset2 = t.entityelement[e].soundset2;
							t.entityelement[t.e].soundset3 = t.entityelement[e].soundset3;
							t.entityelement[t.e].soundset4 = t.entityelement[e].soundset4;
							#ifdef WICKEDENGINE
							t.entityelement[t.e].soundset5 = t.entityelement[e].soundset5;
							t.entityelement[t.e].soundset6 = t.entityelement[e].soundset6;
							#endif
							//PE: We have a new particle id here, so cant just copy.
							newparticletype backup_newparticle = t.entityelement[t.e].eleprof.newparticle;
							t.entityelement[t.e].eleprof = t.entityelement[e].eleprof;
							t.entityelement[t.e].eleprof.newparticle = backup_newparticle;
							PositionObject(t.entityelement[t.e].obj, t.entityelement[t.e].x, t.entityelement[t.e].y, t.entityelement[t.e].z);
							RotateObject(t.entityelement[t.e].obj, t.entityelement[t.e].rx, t.entityelement[t.e].ry, t.entityelement[t.e].rz);

							// Can't copy object relations so ensure previous are cleared
							t.entityelement[t.e].eleprof.iObjectLinkID = 0;
							for (int j = 0; j < 10; j++)
							{
								t.entityelement[t.e].eleprof.iObjectRelationships[i] = 0;
								t.entityelement[t.e].eleprof.iObjectRelationshipsType[i] = 0;
								t.entityelement[t.e].eleprof.iObjectRelationshipsData[i] = 0;
							}

							// and add to new rubber band group
							sRubberBandType rubberbandItem;
							rubberbandItem.e = t.e;
							rubberbandItem.x = t.entityelement[t.e].x;
							rubberbandItem.y = t.entityelement[t.e].y;
							rubberbandItem.z = t.entityelement[t.e].z;
							#ifdef WICKEDENGINE
							rubberbandItem.px = t.entityelement[t.e].x;
							rubberbandItem.py = t.entityelement[t.e].y;
							rubberbandItem.pz = t.entityelement[t.e].z;
							rubberbandItem.rx = t.entityelement[t.e].rx;
							rubberbandItem.ry = t.entityelement[t.e].ry;
							rubberbandItem.rz = t.entityelement[t.e].rz;				
							rubberbandItem.quatmode = t.entityelement[t.e].quatmode;
							rubberbandItem.quatx = t.entityelement[t.e].quatx;
							rubberbandItem.quaty = t.entityelement[t.e].quaty;
							rubberbandItem.quatz = t.entityelement[t.e].quatz;
							rubberbandItem.quatw = t.entityelement[t.e].quatw;
							rubberbandItem.scalex = t.entityelement[t.e].scalex;
							rubberbandItem.scaley = t.entityelement[t.e].scaley;
							rubberbandItem.scalez = t.entityelement[t.e].scalez;
							#endif
							g.entityrubberbandlist.push_back(rubberbandItem);
						}

						// switch widget to newly pasted entity so can instantly widget it about
						if (iAnchorEntityIndex != -1)
						{
							t.widget.pickedEntityIndex = iAnchorEntityIndex;
							t.widget.pickedObject = t.entityelement[iAnchorEntityIndex].obj;
						}

						// ensure gridentity cleared after duplication
						t.gridentity = 0;

//						if (g.entityrubberbandlist.size() == 1)
//						{
//							//PE: Remove rubberband if we only have one item.
//							g.entityrubberbandlist.clear();
//						}
						bDraggingActive = false; //
						t.onetimeentitypickup = 0;
						iLastSelectedEntityGroup = -1;
						iLastSelectedEntity = -1;


					}
				}
			}
			else if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Delete)) || iExecuteCTRLkey == ImGuiKey_Delete)
			{
				//gridedit_deleteentityfrommap();
				//t.refreshgrideditcursor = 1;
				HandleObjectDeletion();
				lastKeyTime = (float)ImGui::GetTime();
				iExecuteCTRLkey = 0;
			}
			#endif

			/*
			#ifdef HIDE_MOVED_MENU_TO_STORYBOARD
			static bool bReadyToProcessF1Key = true;
			if (bReadyToProcessF1Key && ImGui::IsKeyPressed(0x70)) // 0x70 = F1
			{
				bReadyToProcessF1Key = false;
				if (bHelp_Menu_Image_Window)
					bHelp_Menu_Image_Window = false;
				else
				{
					image_setlegacyimageloading(true);
					strcpy(cHelpMenuImage, "languagebank\\english\\artwork\\quick-help.png");
					LoadImage(cHelpMenuImage, HELPMENU_IMAGE);
					image_setlegacyimageloading(false);
					bHelp_Menu_Image_Window = true;
				}
			}
			else {
				bReadyToProcessF1Key = true;
			}
			#endif
			*/

			#ifndef WICKEDENGINE
			static bool bReadyToProcessF1Key = true;
			if(bReadyToProcessF1Key && ImGui::IsKeyPressed(0x70)) { // 0x70 = F1
				bReadyToProcessF1Key = false;
				if (bHelp_Menu_Image_Window)
					bHelp_Menu_Image_Window = false;
				else {
					image_setlegacyimageloading(true);
					strcpy(cHelpMenuImage, "languagebank\\english\\artwork\\quick-help.png");
					LoadImage(cHelpMenuImage, HELPMENU_IMAGE);
					image_setlegacyimageloading(false);
					bHelp_Menu_Image_Window = true;
				}
			}
			else {
				bReadyToProcessF1Key = true;
			}
			#endif
			

		}

		ImGui::End();

		//####################
		//#### Status bar ####
		//####################

#ifndef WICKEDENGINE
#define ADDCONTROLSTOSTAUSBAR
#endif
		#ifdef EA_WELCOME_SCREEN
		bool bStatusbarActive = true;
		if (gbWelcomeSystemActive == true || bWelcomeScreen_Window) bStatusbarActive = false;
		if (bStatusbarActive)
		{
		#endif
			int iOldWindowBorderSize = ImGui::GetStyle().WindowBorderSize;
			ImGui::GetStyle().WindowRounding = 0.0f;
			ImGui::GetStyle().WindowBorderSize = 1.0f;

			float paddingy = ImGui::GetStyle().WindowPadding.y;
			//float startposy = viewPortSize.y - ImGuiStatusBar_Size - 2.0; //(ImGui::GetStyle().WindowBorderSize*2.0)
			float startposy = viewPortSize.y - 32 - 2.0; // Wicked was 1051 which when you add 32 high is > 1080 height of window!!
			ImGui::SetNextWindowPos(viewPortPos + ImVec2(0.0f, startposy), ImGuiCond_Always);
			ImGui::SetNextWindowSize(ImVec2(ImGui::GetMainViewport()->Size.x, ImGuiStatusBar_Size));
			//ImGuiWindowFlags_NoDocking,ImGuiWindowFlags_MenuBar

			if (pref.current_style == 25)
			{
				ImGui::PushStyleColor(ImGuiCol_WindowBg, ImVec4(0.12f, 0.26f, 0.35f, 1.00f));
				ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.11f, 0.16f, 0.22f, 1.00f)); //org ImVec4(0.58f, 0.58f, 0.58f, 1.00f); // ImGui::PopStyleColor();
			}

			ImGui::Begin("Statusbar", NULL, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize);

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x + 10.0f, ImGui::GetCursorPos().y + (fsy*0.5)));
			ImGui::Text("%s", t.laststatusbar_s.Get());
			ImGui::SameLine();
			//Align right.
			int align_checkbox = 96;
			int align_light_checkbox = 106;
			int align_combo_size = 120;
			#ifndef ADDCONTROLSTOSTAUSBAR
			align_light_checkbox = 0;
			align_checkbox = 0;
			#endif
			#ifdef WICKEDENGINE
			if (fpe_thread_in_progress())
			{
				extern int g_iScannedFiles;
				cstr title = cStr("Scanning FPE Files: ") + cStr(g_iScannedFiles) + cStr("  ");
				float fTextSize = ImGui::CalcTextSize(title.Get()).x * 1.05;
				ImGui::SetCursorPos(ImVec2(ImGui::GetWindowSize().x - fTextSize, ImGui::GetCursorPos().y - 3));
				ImGui::Text(title.Get());
			}
			else
			{
				//PE: Display status, grid mode ...
				float fTextSize = ImGui::CalcTextSize(t.statusbar_s.Get()).x * 1.05;
				ImGui::SetCursorPos(ImVec2(ImGui::GetWindowSize().x - fTextSize - 10.0f, ImGui::GetCursorPos().y - 3));
				ImGui::Text(t.statusbar_s.Get());
			}
			#endif
			#ifdef ADDCONTROLSTOSTAUSBAR

			float fTextSize = ImGui::CalcTextSize(t.statusbar_s.Get()).x * 1.05;
			ImGui::SetCursorPos(ImVec2(ImGui::GetWindowSize().x - fTextSize - align_combo_size - align_checkbox - align_light_checkbox, ImGui::GetCursorPos().y));
			ImGui::Text(t.statusbar_s.Get());

			ImGui::SameLine();
			ImVec2 vPos = ImGui::GetCursorPos();

			ImGui::SetCursorPos(ImVec2(ImGui::GetWindowSize().x - align_combo_size - align_checkbox - align_light_checkbox, ImGui::GetCursorPos().y - 5));

			#ifdef WICKEDENGINE
			if (ImGui::Checkbox(" Editor Light", &bEditorLight))
			{
				WickedCall_EnableCameraLight(bEditorLight);
			}
			#endif
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, 4.0f));


			ImGui::SameLine();
			//		ImVec2 vPos = ImGui::GetCursorPos();
			ImGui::SetCursorPos(vPos);
			ImGui::SetCursorPos(ImVec2(ImGui::GetWindowSize().x - align_combo_size - align_checkbox, ImGui::GetCursorPos().y - 5));
			bool bTopDownStatus = !(bool)t.editorfreeflight.mode;
			if (ImGui::Checkbox(" Top Down", &bTopDownStatus)) {
				bForceKey = true;
				if (!bTopDownStatus)
					csForceKey = "f";
				else
					csForceKey = "g";
			}
			ImGui::SameLine();

			ImGui::SetCursorPos(vPos);

			const char* items_align[] = { "NORMAL", "SNAP", "GRID" };
			int item_current_type_selection = 0;
			item_current_type_selection = t.gridentitygridlock;

			ImGui::SetCursorPos(ImVec2(ImGui::GetWindowSize().x - align_combo_size, ImGui::GetCursorPos().y - 5.0));
			ImGui::PushItemWidth(align_combo_size - 10);
			if (ImGui::Combo("##BehavioursSimpleInput", &item_current_type_selection, items_align, IM_ARRAYSIZE(items_align))) {
				t.gridentitygridlock = item_current_type_selection;
			}
			ImGui::PopItemWidth();
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Alignment");
			//			if (t.gridentitygridlock == 0)  t.statusbar_s = t.statusbar_s + "NORMAL";
			//			if (t.gridentitygridlock == 1)  t.statusbar_s = t.statusbar_s + "SNAP";
			//			if (t.gridentitygridlock == 2)  t.statusbar_s = t.statusbar_s + "GRID";

			#endif

			ImGui::End();
			ImGui::GetStyle().WindowRounding = iOldRounding;
			ImGui::GetStyle().WindowBorderSize = iOldWindowBorderSize;

			if (pref.current_style == 25) {
				ImGui::PopStyleColor(2);
			}

		#ifdef EA_WELCOME_SCREEN
		}
		else
		{
			if (bWelcomeScreen_Window)
			{
				//PE: We need to display it empty, so we can fill it out with background color on welcome screen.
				float startposy = viewPortSize.y - 32 - 2.0;
				ImGui::SetNextWindowPos(viewPortPos + ImVec2(0.0f, startposy), ImGuiCond_Always);
				ImGui::SetNextWindowSize(ImVec2(ImGui::GetMainViewport()->Size.x, ImGuiStatusBar_Size));
				ImGui::Begin("Statusbar", NULL, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize);
				ImGui::End();
			}
			else
			{
				//PE: We need to display it empty, or the z order will be wrong later.
				ImGuiViewport* viewport = ImGui::GetMainViewport();
				ImGui::SetNextWindowViewport(viewport->ID);
				ImGui::SetNextWindowPos(viewPortPos + ImVec2(0.0f, viewPortSize.y + 40), ImGuiCond_Always); //Out of screen.
				ImGui::Begin("Statusbar", NULL, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize);
				ImGui::End();
			}
		}
		#endif


		//Docking.
		#ifdef WICKEDENGINE
		ImVec4 OldImGuiColWindowBg = ImGui::GetStyle().Colors[ImGuiCol_WindowBg];
		ImVec4 OldImGuiColChildBg = ImGui::GetStyle().Colors[ImGuiCol_ChildBg];
		//ImGui::GetStyle().Colors[ImGuiCol_WindowBg] = ImVec4(1.0f, 0.0f, 0.0f, 1.00f);
		//ImGui::GetStyle().Colors[ImGuiCol_ChildBg] = ImVec4(1.0f, 0.0f, 0.0f, 1.00f);
		ImGui::GetStyle().Colors[ImGuiCol_ChildBg] = ImGui::GetStyle().Colors[ImGuiCol_WindowBg];
		//ImGui::GetStyle().Alpha = 1.0f;
		#endif

		//######################################################################
		//#### Default dockspace setup, how is our windows split on screen. ####
		//######################################################################

		ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoDocking; //ImGuiWindowFlags_MenuBar
		viewport = ImGui::GetMainViewport();
		ImGui::SetNextWindowPos(viewport->Pos + ImVec2(0, toolbar_size));
		ImGui::SetNextWindowSize(viewport->Size - ImVec2(0, toolbar_size + ImGuiStatusBar_Size));
		ImGui::SetNextWindowViewport(viewport->ID);
		ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);
		window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove;
		window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;

		#ifdef WICKEDENGINE
		ImGuiWindowFlags oldwindow_flags = window_flags;
		window_flags |= ImGuiWindowFlags_NoBackground;
		#endif

		ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));
		ImGui::Begin("DockSpaceAGK", &dockingopen, window_flags);
		ImGui::PopStyleVar();
		ImGui::PopStyleVar(2);

		#ifdef WICKEDENGINE
		window_flags = oldwindow_flags;
		#endif

		static ImGuiID dock_id_bottom;
		
		//We cant make all windows dock if all windows is NOT undocked first (.ini setup problem ), so refresh_gui_docking == 2
		if (ImGui::DockBuilderGetNode(ImGui::GetID("MyDockspace")) == NULL || refresh_gui_docking == 2)
		{
			//Default docking setup.
			ImGuiID dockspace_id = ImGui::GetID("MyDockspace");
			ImGui::DockBuilderRemoveNode(dockspace_id); // Clear out existing layout
			//int ImGuiDockNodeFlags_Dockspace = 1 << 10;
			ImGui::DockBuilderAddNode(dockspace_id, ImGuiDockNodeFlags_DockSpace); // Add empty node
			ImGui::DockBuilderSetNodePos(dockspace_id, viewport->Pos + ImVec2(0, toolbar_size));
			ImGui::DockBuilderSetNodeSize(dockspace_id, viewport->Size - ImVec2(0, toolbar_size + ImGuiStatusBar_Size));

			ImGuiID dock_main_id = dockspace_id;
			ImGuiID dock_id_top = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Up, 0.12f, NULL, &dock_main_id); //Toolbar


			ImGuiID dock_id_right;
			if (viewport->Size.x > 1300)
				dock_id_right = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Right, 0.14f, NULL, &dock_main_id); //0.20f
			else if (viewport->Size.x < 1100)
				dock_id_right = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Right, 0.23f, NULL, &dock_main_id); //0.20f
			else
				dock_id_right = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Right, 0.21f, NULL, &dock_main_id); //0.20f


			ImGuiID dock_id_right2out;
			ImGuiID dock_id_right2 = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Right, 0.2f, &dock_id_right2out, &dock_main_id); //0.20f

			// create dock ID for above Tutorial Help Window (for Tutorial Video area)
			ImGuiID dock_id_right2below = ImGui::DockBuilderSplitNode(dock_id_right2out, ImGuiDir_Down, 0.26f, NULL, NULL); //0.18

			// leelee, technically not allowed by IMGUI but I fudged the IMGUI code to allow it - seems to work fine!
			ImGuiID dock_id_right3below = ImGui::DockBuilderSplitNode(dock_id_right2out, ImGuiDir_Down, 0.60f, NULL, NULL); //(0.65) PE: Video area must have room for a normal mp4.


			ImGuiID dock_id_left = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Left, 0.15f, NULL, &dock_main_id); //0.15f
			ImGuiID dock_id_left_down = ImGui::DockBuilderSplitNode(dock_id_left, ImGuiDir_Down, 0.15f, NULL, &dock_id_left); //0.15f
			ImGuiID dock_id_left_down_large = ImGui::DockBuilderSplitNode(dock_id_left, ImGuiDir_Down, 0.30f, NULL, &dock_id_left); //0.15f

			ImGuiID dock_id_left2out;
			ImGuiID dock_id_left2 = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Left, 0.30f, &dock_id_left2out, &dock_main_id); //0.20f
			ImGuiID dock_id_left2below = ImGui::DockBuilderSplitNode(dock_id_left2out, ImGuiDir_Down, 0.26f, NULL, NULL); //0.18
			ImGuiID dock_id_left3below = ImGui::DockBuilderSplitNode(dock_id_left2out, ImGuiDir_Down, 0.60f, NULL, NULL); //(0.65) PE: Video area must have room for a normal mp4.

			// Disable tab bar for custom toolbar and statusbar
			ImGuiDockNode* node = ImGui::DockBuilderGetNode(dock_id_top);
			node->LocalFlags |= ImGuiDockNodeFlags_NoTabBar;

			ImGui::DockBuilderDockWindow(TABEDITORNAME, dock_main_id);
			ImGui::DockBuilderDockWindow(TABENTITYNAME, dock_id_left);

#ifdef USELEFTPANELSTRUCTUREEDITOR
			ImGui::DockBuilderDockWindow("Structure Editor##LeftPanel", dock_id_left);
#endif	
			ImGui::DockBuilderDockWindow("Tutorial Video##HelpVideoWindow", dock_id_right2below);
			ImGui::DockBuilderDockWindow("Tutorial Steps##HelpWindow", dock_id_right3below);

			ImGui::DockBuilderDockWindow("Tutorial Video##LeftHelpVideoWindow", dock_id_left2below);
			ImGui::DockBuilderDockWindow("Tutorial Steps##LeftHelpWindow", dock_id_left3below);

			ImGui::DockBuilderDockWindow("Entity Properties##PropertiesWindow", dock_id_right);
			ImGui::DockBuilderDockWindow("Character Creator##PropertiesWindow", dock_id_right);
			ImGui::DockBuilderDockWindow("Structure Properties##BuilderPropertiesWindow", dock_id_right);
			ImGui::DockBuilderDockWindow("Importer##ImporterWindow", dock_id_right);
			#ifdef BUILDINGEDITOR
			ImGui::DockBuilderDockWindow("Building Editor##BuildingEditorSettings", dock_id_right);
			#endif

			ImGui::DockBuilderDockWindow("Terrain Tools##TerrainToolsWindow", dock_id_right);
			ImGui::DockBuilderDockWindow("Sculpt Terrain##TerrainToolsWindow", dock_id_right);
			ImGui::DockBuilderDockWindow("Paint Terrain##TerrainToolsWindow", dock_id_right);
			ImGui::DockBuilderDockWindow("Add Vegetation##TerrainToolsWindow", dock_id_right);
			ImGui::DockBuilderDockWindow("Terrain Tools##Sculpt Terrain##TerrainToolsWindow", dock_id_right);
			ImGui::DockBuilderDockWindow("Terrain Tools##Paint Terrain##TerrainToolsWindow", dock_id_right);
			ImGui::DockBuilderDockWindow("Terrain Tools##Add Vegetation##TerrainToolsWindow", dock_id_right);
			ImGui::DockBuilderDockWindow("Terrain Tools##Add Trees##TerrainToolsWindow", dock_id_right);
			ImGui::DockBuilderDockWindow("Terrain Tools##Add Bushes##TerrainToolsWindow", dock_id_right);
			
			ImGui::DockBuilderDockWindow("Waypoints##WaypointsToolsWindow", dock_id_right);

#ifdef USE_ENTITY_TOOL_WINDOW
			ImGui::DockBuilderDockWindow("Object Tools##EntityToolsWindow", dock_id_right);
#endif	
#ifdef WICKEDENGINE
			ImGui::DockBuilderDockWindow("Environment Effects##VisualsToolsWindow", dock_id_right);
			ImGui::DockBuilderDockWindow("Weather##WeatherEffectsV2", dock_id_right);
			ImGui::DockBuilderDockWindow("Shooter Genre##GameLogicTools", dock_id_right);
			///ImGui::DockBuilderDockWindow("Game Genre##AdditionalIconsWindow", dock_id_left_down);
			ImGui::DockBuilderDockWindow("Current Objects##AdditionalIconsWindow", dock_id_left_down_large);
			ImGui::DockBuilderDockWindow("Bug Reporting System##BugReportingWindow", dock_id_right);

			// Disable tab bar.
			//PE: This will not work if you are able to undock windows.
			if (!pref.iAllowUndocking)
			{
				ImGuiDockNode* newnode = ImGui::DockBuilderGetNode(dock_id_left_down_large);
				if (newnode)
					newnode->LocalFlags |= ImGuiDockNodeFlags_NoTabBar;
			}
#endif	
			//ImGuiDockNodeFlags_AutoHideTabBar
			dock_main_tabs = dock_main_id;
			dock_tools_windows = dock_id_right;
			ImGui::DockBuilderFinish(dockspace_id);
		}
		
		ImGuiID dockspace_id = ImGui::GetID("MyDockspace");
		ImGuiStyle& style = ImGui::GetStyle();
		ImVec2 vOldWindowMinSize = style.WindowMinSize;
		style.WindowMinSize.x = 150.0f;

		ImGui::DockSpace(dockspace_id, ImVec2(0.0f, 0.0f), ImGuiDockNodeFlags_None);

		style.WindowMinSize = vOldWindowMinSize;

		ImGui::End();
		
		#ifdef WICKEDENGINE
		// Restore normal window backdrop color, but leave child backdrop color alone (as copied from window backdrop color)
		ImGui::GetStyle().Colors[ImGuiCol_WindowBg] = OldImGuiColWindowBg;
		#endif

		if (dock_main_tabs == 0)
			dock_main_tabs = dockspace_id;
		
		grideleprof_uniqui_id = 55000; //If using the new properties widgets outside properties window.

		//#######################
		//#### Tutorial Help ####
		//#######################
		if (bHelp_Window && bHelpVideo_Window == false) bHelp_Window = false;
		//PE: Always read in all tutorials.
		if (!bTutorial_Init) 
		{
			//Reset everything.
			tut.bActive = false;
			tut.iSteps = 0;
			strcpy(tut.cStartText, "");
			strcpy(tut.cVideoPath, "");
			tut.bVideoReady = false;
			tut.bVideoInit = false;
			bVideoResumePossible = false;
			for (int il = 0; il < TUTORIALMAXSTEPS; il++) { //Reset
				strcpy(tut.cStepHeader[il], "");
				strcpy(tut.cStepText[il], "");
				strcpy(tut.cStepAction[il], "");
				tut.vOffsetPointer[il] = ImVec2(0, 0);
			}

			get_tutorials();

			//use first entry.
			std::map<std::string, std::string>::iterator it = tutorial_files.begin();
				
			if (it->first.length() > 0) {
				strcpy(cTutorialName, it->first.c_str());
			}

			bTutorial_Init = true;
		}
			
		if (bHelp_Window && current_tutorial != selected_tutorial) 
		{
			current_tutorial = selected_tutorial;

			//Reset everything.
			tut.bActive = false;
			tut.iCurrent_Step = 0;
			tut.iSteps = 0;
			strcpy(tut.cStartText, "");
			strcpy(tut.cVideoPath, "");
			tut.bVideoReady = false;
			tut.bVideoInit = false;
			bVideoResumePossible = false;

			for (int il = 0; il < TUTORIALMAXSTEPS; il++) { //Reset
				strcpy(tut.cStepHeader[il], "");
				strcpy(tut.cStepText[il], "");
				strcpy(tut.cStepAction[il], "");
				tut.vOffsetPointer[il] = ImVec2(0, 0);
			}

			//Read in selected tutorial.
			int count_tut = 0;

			//Find filename to use:
			cstr tut_filename = "";// editors\\uiv3\\tutorial.txt";
			if (tutorial_files.size() > 0) 
			{
				for (std::map<std::string, std::string>::iterator it = tutorial_files.begin(); it != tutorial_files.end(); ++it) 
				{
					if (it->first.length() > 0) 
					{
						if (count_tut++ >= selected_tutorial) 
						{
							tut_filename = it->second.c_str();
							break;
						}
					}
				}
			}

			//Reset active tutorial.
			FILE* fTut = GG_fopen(tut_filename.Get(), "r");
			if (fTut)
			{
				char ctmp[TUTORIALMAXTEXT];
				bool bStart = false;
				while (!feof(fTut))
				{
					fgets(ctmp, TUTORIALMAXTEXT-1, fTut);
					if (strlen(ctmp) > 0 && ctmp[strlen(ctmp) - 1] == '\n')
						ctmp[strlen(ctmp) - 1] = 0;

					if (strncmp(ctmp, "TUT:", 4) == 0)
					{
						if( bStart )
							break; // new section exit.
						//Always take first entry.
//							if (count_tut++ >= selected_tutorial)
						bStart = true;
					}
					if (bStart) {
						//Add to active tutorial.
						bool bFound = false;

						if (strncmp(ctmp, "VIDEO:", 6) == 0)
						{
							strcpy(tut.cVideoPath, &ctmp[7]);

							char resolved[MAX_PATH];
							int retval = GetFullPathNameA(tut.cVideoPath, MAX_PATH, resolved, NULL);
							if (retval > 0) {
								strcpy(tut.cVideoPath, resolved);
							}
							bFound = true;
						}
						if (strncmp(ctmp, "START:", 6) == 0)
						{
							strcpy(tut.cStartText, &ctmp[7]);
							bFound = true;
						}

						if (!bFound) {
							for (int il = 1; il < TUTORIALMAXSTEPS; il++) {

								cstr cmp = "STEP"; cmp = cmp + Str(il); cmp = cmp + "-HEADER:";
								if (strncmp(ctmp, cmp.Get(), cmp.Len()) == 0) {
									strcpy(tut.cStepHeader[il - 1], &ctmp[cmp.Len() + 1]);
									bFound = true;
								}
								cmp = "STEP"; cmp = cmp + Str(il); cmp = cmp + "-TEXT:";
								if (strncmp(ctmp, cmp.Get(), cmp.Len()) == 0) {
									strcpy(tut.cStepText[il - 1], &ctmp[cmp.Len() + 1]);
									bFound = true;
								}
								cmp = "STEP"; cmp = cmp + Str(il); cmp = cmp + "-ACTION:";
								if (strncmp(ctmp, cmp.Get(), cmp.Len()) == 0) {
									strcpy(tut.cStepAction[il - 1], &ctmp[cmp.Len() + 1]);
									bFound = true;
								}
								cmp = "STEP"; cmp = cmp + Str(il); cmp = cmp + "-OFFSETX:";
								if (strncmp(ctmp, cmp.Get(), cmp.Len()) == 0) {
									tut.vOffsetPointer[il - 1].x = atof(&ctmp[cmp.Len() + 1]);
									bFound = true;
								}
								cmp = "STEP"; cmp = cmp + Str(il); cmp = cmp + "-OFFSETY:";
								if (strncmp(ctmp, cmp.Get(), cmp.Len()) == 0) {
									tut.vOffsetPointer[il - 1].y = atof(&ctmp[cmp.Len() + 1]);
									bFound = true;
								}
								if (bFound)
								{
									if (tut.iSteps < il)
										tut.iSteps = il;
									break;
								}
							}
						}
					}
				}
				fclose(fTut);
				if (tut.iSteps > 0) 
				{
					//Add Tutorial Complete
					strcpy(tut.cStepHeader[tut.iSteps], "Final Tutorial Step");
					strcpy(tut.cStepText[tut.iSteps], "");
					strcpy(tut.cStepAction[tut.iSteps], "-=DONE=-");
					tut.iSteps++;
				}
			}
		}

		if (refresh_gui_docking == 0)
		{
			//Make sure window is setup in docking space.
			ImGui::Begin("Tutorial Video##HelpVideoWindow", &bHelpVideo_Window, iGenralWindowsFlags);
			ImGui::End();
			ImGui::Begin("Tutorial Steps##HelpWindow", &bHelp_Window, iGenralWindowsFlags);
			ImGui::End();
			ImGui::Begin("Tutorial Video##LeftHelpVideoWindow", &bHelpVideo_Window, iGenralWindowsFlags);
			ImGui::End();
			ImGui::Begin("Tutorial Steps##LeftHelpWindow", &bHelp_Window, iGenralWindowsFlags);
			ImGui::End();
		}
		else if (bHelp_Window && tutorial_files.size() > 0)
		{
			char cTutWindowVideoName[256];
			char cTutWindowStepsName[256];

			if (bSetTutorialSectionLeft)
			{
				strcpy(cTutWindowVideoName, "Tutorial Video##LeftHelpVideoWindow");
				strcpy(cTutWindowStepsName, "Tutorial Steps##LeftHelpWindow");
			}
			else
			{
				strcpy(cTutWindowVideoName, "Tutorial Video##HelpVideoWindow");
				strcpy(cTutWindowStepsName, "Tutorial Steps##HelpWindow");
			}

			if( iVideoFindFirstFrame > 0) {
				if (iVideoFindFirstFrame == 1) {
					PauseAnim(tut.bVideoID);
					bVideoResumePossible = false;
				}
				iVideoFindFirstFrame--;
			}

			switch (iVideoDelayExecute) {
				case 1: //Play restart
				{
					iVideoDelayExecute = 0;
					StopAnimation(tut.bVideoID);
					PlayAnimation(tut.bVideoID);
					SetRenderAnimToImage(tut.bVideoID, true);
					UpdateAllAnimation();
					Sleep(50); //Sleep so we get a video texture in the next call.
					UpdateAllAnimation();
					SetVideoVolume(100.0);
					bVideoResumePossible = false;
					break;
				}
				case 2: //Resume
				{
					iVideoDelayExecute = 0;
					ResumeAnim(tut.bVideoID);
					break;
				}
				case 3: //Pause
				{
					iVideoDelayExecute = 0;
					PauseAnim(tut.bVideoID);
					bVideoResumePossible = true;
					break;
				}
				default:
					break;
			}

			if (bVideoPlayerMaximized) 
			{
				ImGui::SetNextWindowSize(ImVec2(48 * ImGui::GetFontSize(), 46 * ImGui::GetFontSize()), ImGuiCond_Once);
				ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
				ImGui::Begin("Tutorial Video##Videos2MaxSize", &bVideoPlayerMaximized, 0);
			}
			else 
			{
				ImGui::Begin(cTutWindowVideoName, &bHelpVideo_Window, iGenralWindowsFlags);
			}
			ImGui::Indent(10);
			ImGui::PushItemWidth(-10);

			if (ImGui::BeginCombo("##SelectYourTutorial", cTutorialName) ) // The second parameter is the label previewed before opening the combo.
			{
				int vloop = 0;
				for (std::map<std::string, std::string>::iterator it = tutorial_files.begin(); it != tutorial_files.end(); ++it)
				{
					if (it->first.length() > 0)
					{
						bool is_selected = false;
						if (strcmp(it->first.c_str(), cTutorialName) == 0)
							is_selected = true;
						if (ImGui::Selectable(it->first.c_str(), is_selected))
						{
							//Change Tutorial.
							strcpy(cTutorialName, it->first.c_str());
							selected_tutorial = vloop;
						}
						if (is_selected)
							ImGui::SetItemDefaultFocus();
						vloop++;
					}
				}
				ImGui::EndCombo();
			}
			ImGui::PopItemWidth();

			// and a force tutorial mode
			bool bForceASelection = false;
			if (strlen(cForceTutorialName) > 0)
			{
				strcpy(cTutorialName, cForceTutorialName);
				strcpy(cForceTutorialName, "");
				int vloop = 0;
				for (std::map<std::string, std::string>::iterator it = tutorial_files.begin(); it != tutorial_files.end(); ++it)
				{
					if (it->first.length() > 0)
					{
						if (strcmp(it->first.c_str(), cTutorialName) == 0)
						{
							strcpy(cTutorialName, it->first.c_str());
							selected_tutorial = vloop;
						}
						vloop++;
					}
				}
				bForceASelection = true;
			}

			// use video panel (wait until videos GOOD and other Rick-Requests)
			ImVec4 oldImGuiCol_ChildWindowBg = ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg];
			#ifdef ENABLETUTORIALVIDEOS
			{
				if (!tut.bVideoInit)
				{
					if (tut.bVideoID > 0) {
						if (AnimationExist(tut.bVideoID)) {
							if (AnimationPlaying(tut.bVideoID))
								StopAnimation(tut.bVideoID);

							DeleteAnimation(tut.bVideoID);
							tut.bVideoID = 0;
						}
					}

					t.tvideofile_s = tut.cVideoPath;
					tut.bVideoID = 0;
					t.text_s = Lower(Right(t.tvideofile_s.Get(), 4));
					if (t.text_s == ".ogv" || t.text_s == ".mp4")
					{
						tut.bVideoID = 32;
						for (int itl = 1; itl <= 32; itl++)
						{
							if (AnimationExist(itl) == 0) { tut.bVideoID = itl; break; }
						}
						if (LoadAnimation(t.tvideofile_s.Get(), tut.bVideoID, g.videoprecacheframes, g.videodelayedload, 1) == false)
						{
							tut.bVideoID = -999;
						}
					}
					if (tut.bVideoID > 0) {
						PlaceAnimation(tut.bVideoID, -1, -1, -1, -1);
						SetRenderAnimToImage(tut.bVideoID, true);
						//Try to get first frame.
						StopAnimation(tut.bVideoID);
						PlayAnimation(tut.bVideoID);
						SetRenderAnimToImage(tut.bVideoID, true);
						iVideoFindFirstFrame = 4;
						UpdateAllAnimation();
						bVideoResumePossible = false;
						bVideoPerccentStart = false;
					}
					tut.bVideoInit = true;
				}

				float fRatio = 1.0f / ((float)GetDesktopWidth() / (float)GetDesktopHeight());

				void* lpVideoTexture = GetAnimPointerTexture(tut.bVideoID);
				float fVideoW = GetAnimWidth(tut.bVideoID);
				float fVideoH = GetAnimHeight(tut.bVideoID);
				if (tut.bVideoInit && tut.bVideoID > 0 && lpVideoTexture) {
					fRatio = 1.0f / (fVideoW / fVideoH);
				}

				float videoboxheight = (ImGui::GetContentRegionAvail().x - 10.0) * fRatio;

				oldImGuiCol_ChildWindowBg = ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg];
				ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg] = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
				ImGui::BeginChild("Video##TutorialVideo", ImVec2(ImGui::GetContentRegionAvail().x - 10.0, videoboxheight), true, iGenralWindowsFlags);
				window = ImGui::GetCurrentWindow();
				ImRect image_bb(window->DC.CursorPos, window->DC.CursorPos + ImGui::GetContentRegionAvail());
				if (lpVideoTexture) {
					SetRenderAnimToImage(tut.bVideoID, true);
					float animU = GetAnimU(tut.bVideoID);
					float animV = GetAnimV(tut.bVideoID);
					ImVec2 uv0 = ImVec2(0, 0);
					ImVec2 uv1 = ImVec2(animU, animV);
					window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));
				}

				if( !(tut.bVideoID > 0 && AnimationExist(tut.bVideoID) && AnimationPlaying(tut.bVideoID) ))
				{
					//Display a play button.
					ImVec2 vOldPos = ImGui::GetCursorPos();
					float fPlayButSize = ImGui::GetContentRegionAvail().x * 0.15;
					float fCenterX = (ImGui::GetContentRegionAvail().x*0.5) - (fPlayButSize*0.5);
					float fCenterY = (videoboxheight*0.5) - (fPlayButSize*0.5);
					ImGui::SetCursorPos(ImVec2(fCenterX, fCenterY));
					ImVec4 vColorFade = { 1.0,1.0,1.0,0.5 };
					if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(fPlayButSize, fPlayButSize), ImColor(255, 255, 255, 0), drawCol_normal*vColorFade, drawCol_hover*vColorFade, drawCol_Down*vColorFade, -1, 0, 0, 0, false,false,false,false,false, bBoostIconColors))
					{
						bVideoPerccentStart = true;
						if (bVideoResumePossible) {
							iVideoDelayExecute = 2; //resume
						}
						else {
							iVideoDelayExecute = 1; //play - restart.
						}
					}
					if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Play");

					ImGui::SetCursorPos(vOldPos);
				}

				#ifdef WICKEDENGINE
				if (ImGui::IsMouseHoveringRect(image_bb.Min, image_bb.Max)) 
				{
					if (!bStoryboardWindow && !bProceduralLevel)
					{
						if (ImGui::IsMouseDoubleClicked(0))
						{
							bVideoPlayerMaximized = 1 - bVideoPlayerMaximized;
						}
					}
				}
				#endif

				ImGui::EndChild();
				ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg] = oldImGuiCol_ChildWindowBg;

				if (tut.bVideoID > 0) {
					if (AnimationExist(tut.bVideoID)) {

						//ImGui::SameLine();
						float fdone = GetAnimPercentDone(tut.bVideoID) / 100.0f;
						if (!bVideoPerccentStart) fdone = 0.0f;

						ImGui::ProgressBar(fdone, ImVec2(ImGui::GetContentRegionAvail().x - 10, 6), "");

#define MEDIAICONSIZE 20

						if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false,false,false,false,false, bBoostIconColors))
						{
							bVideoPerccentStart = true;
							if (bVideoResumePossible) {
								iVideoDelayExecute = 2; //resume
							}
							else {
								iVideoDelayExecute = 1; //play - restart.
							}
						}
						if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Play");
						ImGui::SameLine();
						if (ImGui::ImgBtn(MEDIA_PAUSE, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false,false,false,false,false, bBoostIconColors))
						{
							iVideoDelayExecute = 3; // pause
						}
						if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Pause");
						ImGui::SameLine();
						if (ImGui::ImgBtn(MEDIA_REFRESH, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false,false,false,false,false, bBoostIconColors))
						{
							bVideoPerccentStart = true;
							iVideoDelayExecute = 1; //play - restart.
						}
						if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Restart");



						if (!bVideoPlayerMaximized)
						{
							ImGui::SameLine();
							if (ImGui::ImgBtn(MEDIA_MAXIMIZE, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true,false,false,false,false, bBoostIconColors))
							{
								bVideoPlayerMaximized = true;
							}
							if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Maximize");
						}
						else
						{
							ImGui::SameLine();
							if (ImGui::ImgBtn(MEDIA_MINIMIZE, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true,false,false,false,false, bBoostIconColors))
							{
								bVideoPlayerMaximized = false;
							}
							if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Minimize");
						}



					}
				}
			}

			if (bVideoPlayerMaximized) {
				std::map<std::string, std::string>::iterator it = tutorial_description.find(cTutorialName);
				if (it != tutorial_description.end()) {
					cVideoDescription = it->second.c_str();
					ImGui::Separator();
					ImGui::Text("Description");
					ImGui::TextWrapped(cVideoDescription.Get());
				}
				bImGuiGotFocus = true;
			}

			if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
				//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				ImGui::Text("");
				ImGui::Text("");
			}

			#endif

			ImGui::End();

			///

			ImGui::Begin(cTutWindowStepsName, &bHelp_Window, iGenralWindowsFlags);

			ImGui::PushItemWidth(-10);
			if (ImGui::StyleButton(tut.cStartText, ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f))) {
				tut.bActive = true;
				tut.iCurrent_Step = 0;
				//PE: Minimize video player.
				bVideoPlayerMaximized = false;
			}
			ImGui::PopItemWidth();

			for (int il = 0; il < tut.iSteps; il++) {

				int additional_lines = 0;
				char line_split[TUTORIALMAXTEXT], *line_found = NULL, *line_start = NULL;
				strcpy(line_split, tut.cStepText[il]);
				line_start = line_found = &line_split[0];
				while ((line_found = (char *)pestrcasestr(line_found, "\\n"))) {
					line_found++;
					line_found++;
					additional_lines++;
				}
				float stepboxheight = mCharAdvance.y * (3 + additional_lines);

				cstr uniqueid = "##STEP";
				uniqueid += Str(il);

				float fOldChildRounding = ImGui::GetStyle().ChildRounding;
				ImGui::GetStyle().ChildRounding = 10.0f;

				if (tut.bActive && tut.iCurrent_Step == il) { //Set current step color.
					ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg] = ImGui::GetStyle().Colors[ImGuiCol_Button];
					static int last_scroll_set = -1;
					if (tut.iCurrent_Step != last_scroll_set) {
						last_scroll_set = tut.iCurrent_Step;
						ImGui::SetScrollHereY();
					}
				}

				ImGui::BeginChild(uniqueid.Get(), ImVec2(ImGui::GetContentRegionAvail().x-10.0, stepboxheight) , true, iGenralWindowsFlags);
					
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, mCharAdvance.y*0.5 ));

				ImGui::SetWindowFontScale(1.15);
				ImGui::TextCenter(tut.cStepHeader[il]);
				ImGui::SetWindowFontScale(1.0);

				//Update Score:
				tut.fScore = (float) tut.iCurrent_Step / (float) (tut.iSteps-1) * 100.0f;
				if (tut.fScore <= 0.99f) tut.fScore = 0.0f;
				if (tut.fScore >= 99.9f) {
					tut.fScore = 100.0f;
					strcpy(tut.cStepText[tut.iSteps - 1], "COMPLETE - Well Done!");
				}
				else {
					strcpy(tut.cStepText[tut.iSteps - 1], "INCOMPLETE");
				}

//					if(tut.iCurrent_Step >= tut.iSteps-1)
//						sprintf(tut.cStepText[tut.iSteps-1], "Score: %.0f", tut.fScore);
					
				strcpy(line_split, tut.cStepText[il]);
				line_start = line_found = &line_split[0];

				while ((line_found = (char *)pestrcasestr(line_found, "\\n"))) {
					*line_found = 0;
					ImGui::TextCenter(line_start);
					line_found++;
					line_found++;
					line_start = line_found;
				}
				ImGui::TextCenter(line_start);

				ImGui::EndChild();

				ImGui::GetStyle().ChildRounding = fOldChildRounding;
				ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg] = oldImGuiCol_ChildWindowBg;

				ImGui::Spacing();
			}

			ImGui::Indent(-10);

			//Debug info.
			//ImGui::TextCenter("Steps: %ld" , tut.iSteps );
			//ImGui::TextCenter("Current: %ld" , tut.iCurrent_Step );
			//ImGui::Text("current_tutorial: %ld", current_tutorial);

			if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
				//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				ImGui::Text("");
				ImGui::Text("");
			}


			ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
			if (ImGui::IsMouseHoveringRect(bbwin.Min, bbwin.Max))
			{
				bImGuiGotFocus = true;
			}
			if (ImGui::IsAnyItemFocused()) {
				bImGuiGotFocus = true;
			}
			//Tutorial really small min, as we have multiply dock to the same side.
			CheckMinimumDockSpaceSize(20.0f);

			ImGui::End();

		}
		else {
			//Help window closed , check if we ned to free any videos.
			if (tut.bVideoID > 0) {
				current_tutorial = -1; //make sure to reopen when window visible again.
				if (AnimationExist(tut.bVideoID)) {
					if (AnimationPlaying(tut.bVideoID))
						StopAnimation(tut.bVideoID);
					DeleteAnimation(tut.bVideoID);
					tut.bVideoID = 0;
					bVideoResumePossible = false;
				}
			}
		}

		//###############################
		//#### Welcome Screen Window ####
		//###############################
		#ifdef WICKEDENGINE
		if( gbWelcomeSystemActive == false )
		{
			// only show Welcome Screen if the 'old' welcome/announcement is not in effect
			Welcome_Screen();
		}
		#ifdef EA_WELCOME_SCREEN
		else
		{
			Welcome_Screen(); //Also dislay welcome screen behind in new design. to hide 3D editor.
		}
		#endif		
		#endif

		//#############################
		//#### Market place Window ####
		//#############################

		#ifdef WICKEDENGINE

			#define STOREPROMOICONS 8

		float fMarketplacePanelHeight = 45.0f;// 55.0f; fits 4:3 aspect!

			if (g_bFreeTrialVersion == true)
			{
				if (bMarketplace_Window == true)
				{
					bFreeTrial_Window = true;
					bMarketplace_Window = false;
				}
			}
			if (refresh_gui_docking == 0)
			{
				//if(STOREPROMOICONS <= 4)
				//	ImGui::SetNextWindowSize(ImVec2(90 * ImGui::GetFontSize(), 38 * ImGui::GetFontSize()), ImGuiCond_Always); // 4 promo icons.
				//else
				ImGui::SetNextWindowSize(ImVec2(68 * ImGui::GetFontSize(), fMarketplacePanelHeight * ImGui::GetFontSize()), ImGuiCond_Always);
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				bool bTmp = true;
				ImGui::Begin("Marketplace##MarketplaceWindow", &bTmp, 0);
				ImGui::End();
			}
			else if (bMarketplace_Window)
			{
				int StorePromoItems = STOREPROMOICONS;
				static int gg_max_dlc[STOREPROMOICONS];
				static cstr gg_max_link[STOREPROMOICONS];
				static int sketchfab_dlc[STOREPROMOICONS];
				static cstr sketchfab_link[STOREPROMOICONS];
				static int shockwavesound_dlc[STOREPROMOICONS];
				static cstr shockwavesound_link[STOREPROMOICONS];
				static int community_dlc[STOREPROMOICONS];
				static cstr community_link[STOREPROMOICONS];
				static int gcstore_dlc[STOREPROMOICONS];
				static cstr gcstore_imageurl[STOREPROMOICONS];
				static cstr gcstore_link[STOREPROMOICONS];
				static int import_image[STOREPROMOICONS];
				static cstr import_fpe[STOREPROMOICONS];
				if (!bMarketplace_Init)
				{
					for (int i = 0; i < STOREPROMOICONS; i++)
					{
						image_setlegacyimageloading(true);
						if(gg_max_dlc[i] > 0 && ImageExist(gg_max_dlc[i])) DeleteImage(gg_max_dlc[i]);
						if (sketchfab_dlc[i] > 0 && ImageExist(sketchfab_dlc[i])) DeleteImage(sketchfab_dlc[i]);
						if (shockwavesound_dlc[i] > 0 && ImageExist(shockwavesound_dlc[i])) DeleteImage(shockwavesound_dlc[i]);
						if (community_dlc[i] > 0 && ImageExist(community_dlc[i])) DeleteImage(community_dlc[i]);
						if (gcstore_dlc[i] > 0 && ImageExist(gcstore_dlc[i])) DeleteImage(gcstore_dlc[i]);
						if (import_image[i] > 0 && ImageExist(import_image[i])) DeleteImage(import_image[i]);
						image_setlegacyimageloading(false);
						gg_max_dlc[i] = 0;
						gg_max_link[i] = "";
						sketchfab_dlc[i] = 0;
						sketchfab_link[i] = "";
						shockwavesound_dlc[i] = 0;
						shockwavesound_link[i] = "";
						community_dlc[i] = 0;
						community_link[i] = "";
						gcstore_dlc[i] = 0;
						gcstore_imageurl[i] = "";
						gcstore_link[i] = "";	
						import_image[i] = 0;
						import_fpe[i] = "";
					}
					SetMipmapNum(1);
					image_setlegacyimageloading(true);
					
					loadMarketplaceData(gg_max_dlc, gg_max_link, sketchfab_dlc, sketchfab_link, shockwavesound_dlc, shockwavesound_link, 
										community_dlc, community_link, gcstore_dlc, gcstore_imageurl, gcstore_link);

					image_setlegacyimageloading(false);
					SetMipmapNum(-1);
					bMarketplace_Init = true;

					//##################################
					//### Load last imported models. ###
					//##################################

					int iImportPromoIcon = 0;
					for (int i = 0; i < 10; i++)
					{
						if (strlen(pref.last_import_files[i]) > 0)
						{
							//PE: Check if we got a cached thumb in correct format.
							char cTmp[MAX_PATH];
							strcpy(cTmp, "entitybank\\");
							strcat(cTmp, pref.last_import_files[i]);
							CreateBackBufferCacheName(pref.last_import_files[i], 512, 288);
							if (FileExist(BackBufferCacheName.Get()) && FileExist(cTmp) )
							{
								SetMipmapNum(1);
								image_setlegacyimageloading(true);
								import_image[iImportPromoIcon] = MARKETPLACE_ICONS + (STOREPROMOICONS * 3) + iImportPromoIcon;

								LoadImage((char *)BackBufferCacheName.Get(), import_image[iImportPromoIcon]);
								if (ImageExist(import_image[iImportPromoIcon]))
								{
									import_fpe[iImportPromoIcon] = pref.last_import_files[i];
									iImportPromoIcon++;
								}
								image_setlegacyimageloading(false);
								SetMipmapNum(-1);
							}

						}
						if (iImportPromoIcon >= STOREPROMOICONS)
							break;
					}
				}

				// TGC only sell objects right now!
				bool bHideGGMaxMarketplace = false;
				if (iDisplayLibraryType != 0 || iDisplayLibrarySubType !=0)
					bHideGGMaxMarketplace = true;

				if (bHideGGMaxMarketplace)
					ImGui::SetNextWindowSize(ImVec2(((90.0f / 4.0f) * 2) * ImGui::GetFontSize(), 33 * ImGui::GetFontSize()), ImGuiCond_Always);// ImGuiCond_Once);
				else
					ImGui::SetNextWindowSize(ImVec2(((90.0f / 4.0f) * 3) * ImGui::GetFontSize(), fMarketplacePanelHeight * ImGui::GetFontSize()), ImGuiCond_Always);//ImGuiCond_Once);

				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);// ImGuiCond_Once);
				
				ImGui::Begin("Marketplace##MarketplaceWindow", &bMarketplace_Window, ImGuiWindowFlags_None | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
				ImGui::Indent(10);

				ImGui::Text("");
				ImVec2 vCurPos = ImGui::GetCursorPos();
				float fFontSize = ImGui::GetFontSize();
				int icon_size = ImGui::GetFontSize()*3.0;
				ImVec2 VIconSize = { (float)icon_size, (float)icon_size };
				if (ImGui::ImgBtn(TOOL_GOBACK, VIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
				{
					bMarketplace_Window = false;
				}
				if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Exit Marketplace");
				ImGui::SameLine();

				//ImGui::SetWindowFontScale(2.0);
				//ImGui::SetCursorPos(vCurPos + ImVec2(0, fFontSize*0.5));
				//ImGui::TextCenter("Marketplace");
				//ImGui::SetWindowFontScale(1.0);
				ImVec2 VHeaderSize;
				if (bHideGGMaxMarketplace)
				{
					ImGui::SetWindowFontScale(1.0);
					ImGui::Text("");
					VHeaderSize = { 365, 64 };
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(154, -63));
					ImGui::ImgBtn(MARKETPLACE_HEADER, VHeaderSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1), ImVec4(1, 1, 1, 1), ImVec4(1, 1, 1, 1), 0, 0, 0, 0, false, false, false, false, false, false);
					ImGui::Text("");
				}
				else
				{
					VHeaderSize = { 730, 128 };
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(78, -35));
					ImGui::ImgBtn(MARKETPLACE_HEADER, VHeaderSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1), ImVec4(1, 1, 1, 1), ImVec4(1, 1, 1, 1), 0, 0, 0, 0, false, false, false, false, false, false);
				}

				float fButWidth = 150.0f;
				
				if(bHideGGMaxMarketplace)
					ImGui::Columns(2, "Marketplacecolumns4", false);  //false no border
				else
					ImGui::Columns(3, "Marketplacecolumns4", false);  //false no border

				float fContentWidth = ImGui::GetContentRegionAvailWidth();
				float fLogoWidth = fContentWidth;
				float fImageWidth = 460;
				float fImageHeight = 215;

				//Use same size on all logos.
				if (ImageExist(MARKETPLACE_GGMAX))
				{
					fImageWidth = ImageWidth(MARKETPLACE_GGMAX);
					fImageHeight = ImageHeight(MARKETPLACE_GGMAX);
				}
				float fScale = fLogoWidth / fImageWidth;
				float fRatio = fImageHeight / fImageWidth;
				ImVec2 vLogoSize = { fLogoWidth , fImageHeight * fScale };
				ImVec2 vPromoSize = { fLogoWidth , fImageHeight * fScale };

				ImVec2 vSizeOfScrollablePanels = ImVec2(vPromoSize.x, (vPromoSize.y * 3));

				vPromoSize *= 0.5;
				vPromoSize = vPromoSize - ImVec2(5.0f, 5.0f);

				ImVec2 vYOffsetToButtons = ImVec2( 0, (((475/68.6f)*vPromoSize.y)) );
				if (bHideGGMaxMarketplace) vYOffsetToButtons = ImVec2(0, (((150 / 68.6f)*vPromoSize.y)));

				//MAX x=154.25 y=69.432

				int TextureID = MARKETPLACE_FILLER;
				float fPromoHeight = ImGui::GetCursorPosY();
				if (!bHideGGMaxMarketplace)
				{
					if (ImageExist(MARKETPLACE_GGMAX))
						TextureID = MARKETPLACE_GGMAX;
					if (ImGui::ImgBtn(TextureID, vLogoSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1), drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, false))
					{
						if (g_bUpdateAppAvailable == false)
							ExecuteFile("https://store.steampowered.com/app/1247290/GameGuru_MAX/", "", "", 0);
						else
							ExecuteFile("https://www.game-guru.com/max", "", "", 0);
					}
					if (ImGui::IsItemHovered())
					{
						if (g_bUpdateAppAvailable == false)
							ImGui::SetTooltip("%s", "Click to view the GameGuru MAX Steam Store Page");
						else
							ImGui::SetTooltip("%s", "Click to view the GameGuru MAX Webpage");
					}

					//#### Promo icon section. ####
					ImGui::Text("");
					vCurPos = ImGui::GetCursorPos();
					fPromoHeight = ImGui::GetCursorPosY();
					for (int i = 0; i < 3; i++)
					{
						TextureID = MARKETPLACE_FILLER;
						ImVec4 vFadeIcons = { 1.0,1.0,1.0,0.2 };
						if (ImageExist(gg_max_dlc[i]))
						{
							TextureID = gg_max_dlc[i];
							vFadeIcons = { 1.0,1.0,1.0,1.0 };
						}
						if (ImGui::ImgBtn(TextureID, vPromoSize*2, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1)*vFadeIcons, drawCol_hover*vFadeIcons, drawCol_Down*vFadeIcons, -1, 0, 0, 0, false, false, false, false, false, false))
						{
							// already aware of steam and non-steam, assigned directly from "MarketplaceData.json"
							//if (i <= 1)
							{
								if (gg_max_link[i].Len() > 0)
								{
									ExecuteFile(gg_max_link[i].Get(), "", "", 0);
								}
							}
						}
						if (ImGui::IsItemHovered())
						{
							if (g_bUpdateAppAvailable == false)
							{
								if (i == 0) ImGui::SetTooltip("%s", "Click to view the Aztec Game Kit Steam Store Page");
								if (i == 1) ImGui::SetTooltip("%s", "Click to view the GameGuru MAX Booster Steam Store Page");
								if (i == 2) ImGui::SetTooltip("%s", "Click to view the GameGuru MAX Particle Editor Steam Store Page");
							}
							else
							{
								if (i == 0) ImGui::SetTooltip("%s", "Click to view the Aztec Game Kit DLC Page");
								if (i == 1) ImGui::SetTooltip("%s", "Click to view the GameGuru MAX Booster DLC Page");
								if (i == 2) ImGui::SetTooltip("%s", "Click to view the GameGuru MAX DLC Page");
							}
						}
					}
					ImGui::Text("");
					fPromoHeight = ImGui::GetCursorPosY() - fPromoHeight;

					ImGui::SetWindowFontScale(1.4f);		
					ImGui::SetCursorPos(vCurPos + vYOffsetToButtons);
					if (g_bUpdateAppAvailable == false)
					{
						if (ImGui::StyleButton("Get More DLC", ImVec2(vLogoSize.x, fFontSize*2.0)))
						{
							DeleteWaypointsAddedToCurrentCursor();
							CloseDownEditorProperties();
							ExecuteFile("https://store.steampowered.com/dlc/1247290/GameGuru_MAX/", "", "", 0);
							bTriggerCloseEntityWindow = true;
						}
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to view the GameGuru MAX Steam DLC Page");
					}
					else
					{
						if (ImGui::StyleButton("Get More DLC", ImVec2(vLogoSize.x, fFontSize*2.0)))
						{
							DeleteWaypointsAddedToCurrentCursor();
							CloseDownEditorProperties();
							ExecuteFile("https://www.game-guru.com/order?_ga=2.207655313.227153589.1653311971-1982497974.1625668666#dlc", "", "", 0);
							bTriggerCloseEntityWindow = true;
						}
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to view the GameGuru MAX DLC Page");
					}
					ImGui::SetWindowFontScale(1.0);

					ImGui::NextColumn();
				}

				TextureID = MARKETPLACE_FILLER;
				if (ImageExist(MARKETPLACE_GCSTORE))
					TextureID = MARKETPLACE_GCSTORE;

				if (ImGui::ImgBtn(TextureID, vLogoSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1), drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, false))
				{
					ExecuteFile("https://gamecreator.store/max?r=tgc", "", "", 0);
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to view the Game Creator Store Website");

				//#### Promo icon section. ####
				ImGui::Text("");
				vCurPos = ImGui::GetCursorPos();
				if ( iDisplayLibraryType == 0 )
				{
					fPromoHeight = ImGui::GetCursorPosY();
					ImGui::BeginChild("##gamecreatorstorescrollable", vSizeOfScrollablePanels, false, ImGuiWindowFlags_None | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
					for (int i = 0; i < 8; i++)
					{
						TextureID = MARKETPLACE_FILLER;
						ImVec4 vFadeIcons = { 1.0,1.0,1.0,0.2 };
						if (ImageExist(gcstore_dlc[i]))
						{
							TextureID = gcstore_dlc[i];
							vFadeIcons = { 1.0,1.0,1.0,1.0 };
						}
						else
						{
							// slowly load in preview thumbs over time so as not to stall the UI
							if (strlen(gcstore_imageurl[i].Get()) > 0)
							{
								static DWORD g_dwLoadGameCreatorStorePreviewsTimer = 0;
								if (timeGetTime() > g_dwLoadGameCreatorStorePreviewsTimer + 100)
								{
									// attempt a download
									char cUrl[256];
									char pDataReturned[132000];
									memset(pDataReturned, 0, sizeof(pDataReturned));
									DWORD dwDataReturnedSize = 0;
									char pImageFile[256];
									sprintf(pImageFile, "downloads\\gcStore%d.png", 1 + i);
									if (FileExist(pImageFile) == 1) DeleteAFile(pImageFile);
									std::string url = gcstore_imageurl[i].Get();
									replaceAll(url, "\\/", "/");
									replaceAll(url, "https://gcs-product-media.fra1.cdn.digitaloceanspaces.com", "");
									replaceAll(url, "http://gcs-product-media.fra1.cdn.digitaloceanspaces.com", "");
									strcpy(cUrl, url.c_str());
									LPSTR pPassInURL = cUrl;
									int iError = StoreOpenURLForDataOrFile("gcs-product-media.fra1.cdn.digitaloceanspaces.com", pDataReturned, &dwDataReturnedSize, "", "GET", pPassInURL, pImageFile);
									if (iError > 0)
									{
										// error - no image today!
										strcpy (pImageFile, "editors\\marketplace\\gcStore0.png");
									}

									// and load the preview
									image_setlegacyimageloading(true);
									LoadImage(pImageFile, gcstore_dlc[i]);
									image_setlegacyimageloading(false);

									// delay next attempt for a time
									g_dwLoadGameCreatorStorePreviewsTimer = timeGetTime();
								}
							}
						}
						if (ImGui::ImgBtn(TextureID, vPromoSize * 2, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1)*vFadeIcons, drawCol_hover*vFadeIcons, drawCol_Down*vFadeIcons, -1, 0, 0, 0, false, false, false, false, false, false))
						{
							if (gcstore_link[i].Len() > 0)
							{
								ExecuteFile(gcstore_link[i].Get(), "", "", 0);
							}
						}
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to view this object on the Game Creator Store Website");
					}
					ImGui::EndChild();
					/* uses a 2x4 grid - small previews - rejected
					for (int i = 0; i < StorePromoItems; i++)
					{
						TextureID = MARKETPLACE_FILLER;
						ImVec4 vFadeIcons = { 1.0,1.0,1.0,0.2 };
						if (ImageExist(gcstore_dlc[i]))
						{
							TextureID = gcstore_dlc[i];
							vFadeIcons = { 1.0,1.0,1.0,1.0 };
						}
						if (ImGui::ImgBtn(TextureID, vPromoSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1)*vFadeIcons, drawCol_hover*vFadeIcons, drawCol_Down*vFadeIcons, 0, 0, 0, 0, false, false, false, false, false, false))
						{
							if (gcstore_link[i].Len() > 0)
							{
								ExecuteFile(gcstore_link[i].Get(), "", "", 0);
							}
						}
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to view this object on the Game Creator Store Website");
						if (i % 2 == 0) ImGui::SameLine();
					}
					*/
					ImGui::Text("");
					fPromoHeight = ImGui::GetCursorPosY() - fPromoHeight;
				}
				else
				{
					ImGui::Text("");
					if (iDisplayLibraryType == 1)
					{
						float fStoreAudioTextHeight = fPromoHeight * 0.5;
						ImGui::SetCursorPos(vCurPos + ImVec2(0, fStoreAudioTextHeight - (fFontSize*2.5)));
						ImGui::TextCenter("GameGuru MAX supports");
						ImGui::TextCenter("WAV,MP3,OGG files.");
					}
				}

				ImGui::SetWindowFontScale(1.4);
				ImGui::SetCursorPos(vCurPos + vYOffsetToButtons);
				if (ImGui::StyleButton("Access Your Store Items", ImVec2(vLogoSize.x, fFontSize*2.0)))
				{
					CloseAllOpenTools();
					extern int iDownloadStoreProgress;
					extern bool bDownloadStoreError;
					extern char cDownloadStoreError[4096];
					iDownloadStoreProgress = 0;
					bDownloadStoreError = false;
					strcpy(cDownloadStoreError, "");
					bDownloadStore_Window = true;
					bPreferences_Window = false;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Log-in and download items purchased from the store");
				ImGui::SetWindowFontScale(1.0f);
				ImGui::NextColumn();

				if (iDisplayLibraryType == 2 || iDisplayLibraryType == 3 || iDisplayLibraryType == 4 || iDisplayLibraryType == 5)
				{
					TextureID = MARKETPLACE_FILLER;
					if (ImageExist(MARKETPLACE_COMMUNITY))
						TextureID = MARKETPLACE_COMMUNITY;

					if (ImGui::ImgBtn(TextureID, vLogoSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1), drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, false))
					{
						ExecuteFile("https://forum.game-guru.com/board/1", "", "", 0);
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "GameGuru MAX Community");

					//#### Promo icon section. ####
					ImGui::Text("");
					vCurPos = ImGui::GetCursorPos();
					fPromoHeight = ImGui::GetCursorPosY();
					for (int i = 0; i < StorePromoItems; i++)
					{
						TextureID = MARKETPLACE_FILLER;
						ImVec4 vFadeIcons = { 1.0,1.0,1.0,0.2 };

						if (ImageExist(community_dlc[i]))
						{
							TextureID = community_dlc[i];
							vFadeIcons = { 1.0,1.0,1.0,1.0 };
						}
						if (ImGui::ImgBtn(TextureID, vPromoSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1)*vFadeIcons, drawCol_hover*vFadeIcons, drawCol_Down*vFadeIcons, 0, 0, 0, 0, false, false, false, false, false, false))
						{
							if (community_link[i].Len() > 0)
							{
								ExecuteFile(community_link[i].Get(), "", "", 0);
							}
						}
						if (i % 2 == 0) ImGui::SameLine();
					}
					ImGui::Text("");
					fPromoHeight = ImGui::GetCursorPosY() - fPromoHeight;

					ImGui::SetWindowFontScale(1.4);
					ImGui::SetCursorPos(vCurPos + vYOffsetToButtons);
					if (ImGui::StyleButton("Visit GameGuru MAX Community", ImVec2(vLogoSize.x, fFontSize*2.0)))
					{
						DeleteWaypointsAddedToCurrentCursor();
						CloseDownEditorProperties();
						bTriggerCloseEntityWindow = true;
						//bMarketplace_Window = false;
						ExecuteFile("https://forum.game-guru.com/board/1", "", "", 0);
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Visit GameGuru MAX Community");

					ImGui::SetWindowFontScale(1.0);
				}
				else
				{
					if (iDisplayLibraryType == 1)
					{
						TextureID = MARKETPLACE_FILLER;
						if (ImageExist(MARKETPLACE_SHOCKWAVESOUND))
							TextureID = MARKETPLACE_SHOCKWAVESOUND;

						if (ImGui::ImgBtn(TextureID, vLogoSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1), drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, false))
						{
							ExecuteFile("https://www.shockwave-sound.com/a/e43bd272af", "", "", 0);
						}
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to view the Shockwave Sound Website");

						//#### Promo icon section. ####
						ImGui::Text("");
						vCurPos = ImGui::GetCursorPos();
						//fPromoHeight = ImGui::GetCursorPosY();
						/* no previews of sounds for now in shockwave store
						for (int i = 0; i < StorePromoItems; i++)
						{
							TextureID = MARKETPLACE_FILLER;
							ImVec4 vFadeIcons = { 1.0,1.0,1.0,0.2 };

							if (ImageExist(shockwavesound_dlc[i]))
							{
								TextureID = shockwavesound_dlc[i];
								vFadeIcons = { 1.0,1.0,1.0,1.0 };
							}
							if (ImGui::ImgBtn(TextureID, vPromoSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1)*vFadeIcons, drawCol_hover*vFadeIcons, drawCol_Down*vFadeIcons, 0, 0, 0, 0, false, false, false, false, false, false))
							{
								if (shockwavesound_link[i].Len() > 0)
								{
									ExecuteFile(shockwavesound_link[i].Get(), "", "", 0);
								}
							}
							if (i % 2 == 0) ImGui::SameLine();
						}
						*/

						ImGui::Text("");
						float fShockwaveTextHeight = fPromoHeight * 0.5;
						ImGui::SetCursorPos(vCurPos + ImVec2(0, fShockwaveTextHeight - (fFontSize*2.5)));
						ImGui::TextCenter("GameGuru MAX supports");
						ImGui::TextCenter("WAV,MP3,OGG files.");

						ImGui::SetWindowFontScale(1.4);
						ImGui::SetCursorPos(vCurPos + vYOffsetToButtons);
						if (ImGui::StyleButton("Visit Shockwave Sound Store", ImVec2(vLogoSize.x, fFontSize*2.0)))
						{
							DeleteWaypointsAddedToCurrentCursor();
							CloseDownEditorProperties();
							bTriggerCloseEntityWindow = true;
							//bMarketplace_Window = false;
							ExecuteFile("https://www.shockwave-sound.com/a/e43bd272af", "", "", 0);
						}
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to view the Shockwave Sound Website");

						ImGui::SetWindowFontScale(1.0);
					}
					else
					{
						TextureID = MARKETPLACE_FILLER;
						if (ImageExist(MARKETPLACE_SKETCHFAB))
							TextureID = MARKETPLACE_SKETCHFAB;

						if (ImGui::ImgBtn(TextureID, vLogoSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1), drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, false))
						{
							ExecuteFile("https://shareasale.com/r.cfm?b=1507456&u=2865438&m=84042&urllink=&afftrack", "", "", 0);
						}
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to view the Sketchfab Website");

						//#### Promo icon section. ####
						ImGui::Text("");
						vCurPos = ImGui::GetCursorPos();
						fPromoHeight = ImGui::GetCursorPosY();
						ImGui::BeginChild("##sketchfabstorescrollable", vSizeOfScrollablePanels, false, ImGuiWindowFlags_None | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
						for (int i = 0; i < StorePromoItems; i++)
						{
							TextureID = MARKETPLACE_FILLER;
							ImVec4 vFadeIcons = { 1.0,1.0,1.0,0.2 };
							if (ImageExist(sketchfab_dlc[i]))
							{
								TextureID = sketchfab_dlc[i];
								vFadeIcons = { 1.0,1.0,1.0,1.0 };
							}
							if (ImGui::ImgBtn(TextureID, vPromoSize * 2, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1)*vFadeIcons, drawCol_hover*vFadeIcons, drawCol_Down*vFadeIcons, -1, 0, 0, 0, false, false, false, false, false, false))
							{
								if (sketchfab_link[i].Len() > 0)
								{
									ExecuteFile(sketchfab_link[i].Get(), "", "", 0);
								}
							}
							if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to view this object on the Sketchfab Website");
						}
						ImGui::EndChild();
						/* small previews rejected
						for (int i = 0; i < StorePromoItems; i++)
						{
							TextureID = MARKETPLACE_FILLER;
							ImVec4 vFadeIcons = { 1.0,1.0,1.0,0.2 };

							if (ImageExist(sketchfab_dlc[i]))
							{
								TextureID = sketchfab_dlc[i];
								vFadeIcons = { 1.0,1.0,1.0,1.0 };
							}
							if (ImGui::ImgBtn(TextureID, vPromoSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1)*vFadeIcons, drawCol_hover*vFadeIcons, drawCol_Down*vFadeIcons, 0, 0, 0, 0, false, false, false, false, false, false))
							{
								if (sketchfab_link[i].Len() > 0)
								{
									ExecuteFile(sketchfab_link[i].Get(), "", "", 0);
								}
							}
							if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to view this object on the Sketchfab Website");
							if (i % 2 == 0) ImGui::SameLine();
						}
						*/
						ImGui::Text("");
						fPromoHeight = ImGui::GetCursorPosY() - fPromoHeight;

						ImGui::SetWindowFontScale(1.4);
						ImGui::SetCursorPos(vCurPos + vYOffsetToButtons);
						if (ImGui::StyleButton("Visit Sketchfab Store", ImVec2(vLogoSize.x, fFontSize*2.0)))
						{
							DeleteWaypointsAddedToCurrentCursor();
							CloseDownEditorProperties();
							bTriggerCloseEntityWindow = true;
							//bMarketplace_Window = false;
							ExecuteFile("https://shareasale.com/r.cfm?b=1507456&u=2865438&m=84042&urllink=&afftrack", "", "", 0);
						}
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to view the Sketchfab Website");

						ImGui::SetWindowFontScale(1.0);
					}
				}

				ImGui::SetWindowFontScale(1.0);

				/* no more importer in market place
				ImGui::NextColumn();
				ImGui::Text("");

				TextureID = MARKETPLACE_FILLER;
				if (ImageExist(MARKETPLACE_IMPORT))
					TextureID = MARKETPLACE_IMPORT;

				ImGui::ImgBtn(TextureID, vLogoSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1), ImVec4(1, 1, 1, 1), ImVec4(1, 1, 1, 1), 0, 0, 0, 0, false, false, false, false, false, false);

				ImGui::Text("");
				vCurPos = ImGui::GetCursorPos();

				static int import_process = 0;
				static cstr import_filename = "";
				static cstr import_error = "";
				static char import_name[MAX_PATH] = "\0";
				bool bMissing4Icons = true;
				*/

				/* importer has no previews for now
				bool bMissing4Icons = false;
				for (int i = 0; i < StorePromoItems; i++)
				{
					TextureID = MARKETPLACE_FILLER;
					ImVec4 vFadeIcons = { 1.0,1.0,1.0,0.2 };

					if (iDisplayLibraryType == 2) //Image
					{
						//Need its own ?
					}
					else if (iDisplayLibraryType == 1) //Music and Sound
					{
						//Need its own ?
					}
					else if (iDisplayLibraryType == 3) //Video
					{
						//Need its own ?
					}
					else if (iDisplayLibraryType == 4) //Script
					{
						//Need its own ?
					}
					else if (iDisplayLibraryType == 5) //Particles
					{
						//Need its own ?
					}
					else
					{
						if (ImageExist(import_image[i]))
						{
							TextureID = import_image[i];
							vFadeIcons = { 1.0,1.0,1.0,1.0 };
						}
					}
					if (ImGui::ImgBtn(TextureID, vPromoSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1)*vFadeIcons, drawCol_hover*vFadeIcons, drawCol_Down*vFadeIcons, 0, 0, 0, 0, false, false, false, false, false, false))
					{
						if (iDisplayLibraryType == 2)
						{
							//Image
						}
						else if (iDisplayLibraryType == 1)
						{
							//Music
						}
						else if (iDisplayLibraryType == 3)
						{
							//Video
						}
						else if (iDisplayLibraryType == 4)
						{
							//Script
						}
						else if (iDisplayLibraryType == 5)
						{
							//Particles
						}
						else
						{
							if (import_fpe[i].Len() > 0)
							{
								//Add to level ?
								if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
								if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
								if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;

								//Make sure we are in entity mode.
								bForceKey = true;
								csForceKey = "o";

								//bBlockBackBufferUpdating = true;
								DeleteWaypointsAddedToCurrentCursor();
								CloseDownEditorProperties();
								#ifdef WICKEDENGINE
								FreeTempImageList(); //PE: Make sure we free all not used textures before adding new objects.
								iLastEntityOnCursor = 0;
								#endif

								t.addentityfile_s = import_fpe[i];
								if (t.addentityfile_s != "")
								{
									entity_adduniqueentity(false);
									t.tasset = t.entid;
									if (t.talreadyloaded == 0)
									{
										editor_filllibrary();
									}
								}

								iExtractMode = 0; //PE: Always start in find floor mode.

								t.inputsys.constructselection = t.tasset;
								t.gridentity = t.entid;
								t.inputsys.constructselection = t.entid;
								t.inputsys.domodeentity = 1;
								t.grideditselect = 5;

								//Make sure we use a fresh t.grideleprof
								entity_fillgrideleproffromprofile();

								editor_refresheditmarkers();
								//PE: Close window for now.
								bCheckForClosing = true;
								bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.
								bDraggingActive = false;

								bMarketplace_Window = false;
								bTriggerCloseEntityWindow = true;
								bCheckForClosingForce = true; //Force window to close.
							}
						}
					}

					if (iDisplayLibraryType == 1 || iDisplayLibraryType == 2 || iDisplayLibraryType == 3 || iDisplayLibraryType == 4 || iDisplayLibraryType == 5)
					{
						if (i == 3)
						{
							if (import_process > 0)
							{
								//Then we must break;
								bMissing4Icons = true;
								break;
							}
							//No last import music files yet so...
							bMissing4Icons = true;
							break;
						}
					}
					else
					{
						if (i == 3 && !ImageExist(import_image[i + 1]))
						{
							bMissing4Icons = true;
							break;
						}
					}
					if (i % 2 == 0) ImGui::SameLine();
				}
				*/

				//###################################################
				//#### Small importers for different media types ####
				//###################################################

				/* changed minds - move importer out of marketplace :)
				float fImportTextHeight = fPromoHeight * 0.5;// fPromoHeight * 0.75;

				if (iDisplayLibraryType == 5) //Particles
				{
					if (bMissing4Icons)
					{
						ImGui::Text("");
						ImGui::SetCursorPos(vCurPos + ImVec2(0, fImportTextHeight - (fFontSize*2.5)));
						ImGui::TextCenter("GameGuru MAX supports the import");
						ImGui::TextCenter("of ARX files.");
					}

					ImGui::SetWindowFontScale(1.4);
					ImGui::SetCursorPos(vCurPos + vYOffsetToButtons);
					if (ImGui::StyleButton("Import Particles", ImVec2(vLogoSize.x, fFontSize*2.0)))
					{
						//Not needed
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Import Particle");
					ImGui::SetWindowFontScale(1.0);

				}
				else if (iDisplayLibraryType == 4) //Script
				{
					if (bMissing4Icons)
					{
						ImGui::Text("");
						ImGui::SetCursorPos(vCurPos + ImVec2(0, fImportTextHeight - (fFontSize*2.5)));
						ImGui::TextCenter("GameGuru MAX supports the import");
						ImGui::TextCenter("of LUA files.");
					}

					ImGui::SetWindowFontScale(1.4);
					ImGui::SetCursorPos(vCurPos + vYOffsetToButtons);
					if (ImGui::StyleButton("Import Script", ImVec2(vLogoSize.x, fFontSize*2.0)))
					{
						//Not needed
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Import LUA Script");
					ImGui::SetWindowFontScale(1.0);
				}
				else if (iDisplayLibraryType == 3) //Video
				{
					if (bMissing4Icons)
					{
						ImGui::Text("");
						ImGui::SetCursorPos(vCurPos + ImVec2(0, fImportTextHeight - (fFontSize*2.5)));
						ImGui::TextCenter("GameGuru MAX supports the import");
						ImGui::TextCenter("of WMV,MP4 files.");
					}

					ImGui::SetWindowFontScale(1.4);
					ImGui::SetCursorPos(vCurPos + vYOffsetToButtons);
					if (ImGui::StyleButton("Import Video", ImVec2(vLogoSize.x, fFontSize*2.0)))
					{
						//Not needed
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Import Video");
					ImGui::SetWindowFontScale(1.0);

				}
				else if (iDisplayLibraryType == 2) //Images
				{
					if (bMissing4Icons)
					{
						ImGui::Text("");
						ImGui::SetCursorPos(vCurPos + ImVec2(0, fImportTextHeight - (fFontSize*2.5)));
						ImGui::TextCenter("GameGuru MAX supports the import");
						ImGui::TextCenter("of PNG,DDS,BMP,JPG,TIF,GIF files.");
					}

					ImGui::SetWindowFontScale(1.4);
					ImGui::SetCursorPos(vCurPos + vYOffsetToButtons);
					if (ImGui::StyleButton("Import Image", ImVec2(vLogoSize.x, fFontSize*2.0)))
					{
						//Not needed
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Import Image");
					ImGui::SetWindowFontScale(1.0);

				}
				else if (iDisplayLibraryType == 1) //Music
				{
					if (bMissing4Icons)
					{
						if (import_process > 0)
						{
							static char import_to[MAX_PATH];
							strcpy(import_to, "audiobank\\users"); //currently fixed.
							ImGui::PushItemWidth(-10);
							ImGui::Text("Import From");
							ImGui::InputText("##ImportImportFrom", import_filename.Get(), 250, ImGuiInputTextFlags_ReadOnly);
							if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;
							ImGui::Text("To Path");
							if (import_error.Len() > 0)
							{
								ImGui::Text(import_error.Get());
							}
							ImGui::InputText("##ImportToPath", import_to, 250, ImGuiInputTextFlags_ReadOnly);
							if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;
							ImGui::Text("Name");
							ImGui::InputText("##ImportImportName", &import_name[0], 250, 0);
							if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

							ImGui::SetWindowFontScale(1.4);
							ImGui::SetCursorPos(vCurPos + vYOffsetToButtons);
							if (ImGui::StyleButton("Convert", ImVec2((vLogoSize.x*0.5) - 4.0f, fFontSize*2.0)))
							{
								bool bValid = true;
								if (strlen(import_name) < 1)
								{
									import_error = "* Error: Please enter a name.";
									bValid = false;
								}
								if (bValid)
								{
									extern char g_pAbsPathToConverter[MAX_PATH];
									std::string process_name = g_pAbsPathToConverter;
									replaceAll(process_name, "\\Guru-Converter.exe" ,"\\ffmpeg.exe");
									HANDLE g_hConvertImportTOOggProcess = NULL;
									DARKSDK BOOL DB_ExecuteFile(HANDLE* phExecuteFileProcess, char* Operation, char* Filename, char* String, char* Path, bool bWaitForTermination);
									char parameters[MAX_PATH];
									char destination[MAX_PATH];
									strcpy(destination, "audiobank\\user\\");
									strcat(destination, import_name);
									strcat(destination, ".ogg");
									GG_GetRealPath(destination, 1);

									strcpy(parameters, "-i \"");
									strcat(parameters, import_filename.Get());
									strcat(parameters, "\" -c:a libvorbis -q:a 4 \"");
									strcat(parameters, destination);
									strcat(parameters, "\"");

									::SetCursor(::LoadCursor(NULL, IDC_WAIT));
									DB_ExecuteFile(&g_hConvertImportTOOggProcess, "hide", (char *) process_name.c_str(), parameters, "", true);
									int iRunning = 1;
									DWORD dwStartTime = timeGetTime();
									while (iRunning == 1)
									{
										iRunning = 0;
										if (timeGetTime() < dwStartTime + (10*1000)) // forget after 10 seconds!
										{
											DWORD dwStatus;
											if (GetExitCodeProcess(g_hConvertImportTOOggProcess, &dwStatus) == TRUE)
												if (dwStatus == STILL_ACTIVE)
													iRunning = 1;
										}
										else
										{
											// otherwise kill process, it has frozen!
											TerminateProcess (g_hConvertImportTOOggProcess, 0);
										}
									}
									CloseHandle(g_hConvertImportTOOggProcess);
									::SetCursor(::LoadCursor(NULL, IDC_ARROW));

									//Done close down.
									bMarketplace_Window = false;
									import_process = 0;
									iLastDisplayLibraryType = -1; //Update search and refresh if any new files found.
								}
							}
							if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Start Converting File");

							ImGui::SameLine();
							if (ImGui::StyleButton("Cancel", ImVec2((vLogoSize.x*0.5) - 4.0f, fFontSize*2.0)))
							{
								import_process = 0;
							}
							if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Cancel Import");

							ImGui::SetWindowFontScale(1.0);

							ImGui::PopItemWidth();
						}
						else
						{
							ImGui::Text("");
							ImGui::SetCursorPos(vCurPos + ImVec2(0, fImportTextHeight - (fFontSize*2.5)));
							ImGui::TextCenter("GameGuru MAX supports the import");
							ImGui::TextCenter("of WAV,MP3,OGG files.");
						}
					}

					if (import_process == 0)
					{
						ImGui::SetWindowFontScale(1.4);
						ImGui::SetCursorPos(vCurPos + vYOffsetToButtons);
						if (ImGui::StyleButton("Import Music And Sound", ImVec2(vLogoSize.x, fFontSize*2.0)))
						{
							//Select File.
							//Select name.
							//Convert and copy to 'audiobank/users'.
							//ffmpeg can be used.
							cStr tOldDir = GetDir();
							char * cFileSelected;
							cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "wav\0*.wav\0ogg\0*.ogg\0mp3\0*.mp3\0", g.mysystem.mapbankAbs_s.Get(), NULL);
							SetDir(tOldDir.Get());
							if (cFileSelected && strlen(cFileSelected) > 0)
							{
								import_filename = cFileSelected;

								//import_name
								cstr importer_getfilenameonly(LPSTR pFileAndPossiblePath);
								cstr tmp = importer_getfilenameonly(import_filename.Get());
								strcpy(import_name, tmp.Get());
								if (tmp.Len() > 4)
								{
									import_name[strlen(import_name) - 4] = 0;
								}
								import_process = 1;
							}
						}
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Import Music or Sound");
					}
					ImGui::SetWindowFontScale(1.0);
				}
				else
				{
					ImGui::Text("");
					if (bMissing4Icons)
					{
						ImGui::SetCursorPos(vCurPos + ImVec2(0, fImportTextHeight - (fFontSize*2.5)));
						ImGui::TextCenter("GameGuru MAX supports the import");
						ImGui::TextCenter("of OBJ, FBX, GLTF and DBO formats for models");
						ImGui::TextCenter("and PNG, JPG and DDS for textures.");
					}

					ImGui::SetWindowFontScale(1.4);
					ImGui::SetCursorPos(vCurPos + vYOffsetToButtons);
					if (ImGui::StyleButton("Import 3D Models", ImVec2(vLogoSize.x, fFontSize*2.0))) 
					{
						DeleteWaypointsAddedToCurrentCursor();
						CloseDownEditorProperties();
						CloseAllOpenTools();
						iLaunchAfterSync = 8; //Import model
						iSkibFramesBeforeLaunch = 5;
						bMarketplace_Window = false;
						bTriggerCloseEntityWindow = true;
						bCheckForClosingForce = true; //Force window to close.
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Import Your Own 3D Model");
					ImGui::SetWindowFontScale(1.0);
				}
				*/

				// completed marketplace
				ImGui::Columns(1);
				ImGui::Indent(-10);
				bImGuiGotFocus = true;
				ImGui::End();
			}

		#endif

		//###########################
		//#### Free Trial Window ####
		//###########################

		#ifdef WICKEDENGINE
		static int iCountingFreeDialogClicks = 0;
		if (refresh_gui_docking == 0)
		{
			ImGui::SetNextWindowSize(ImVec2(68 * ImGui::GetFontSize(), (fMarketplacePanelHeight+2.0f) * ImGui::GetFontSize()), ImGuiCond_Always);
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bool bTmp = true;
			ImGui::Begin("FreeTrial##FreeTrialWindow", &bTmp, 0);
			ImGui::End();
		}
		else if (bFreeTrial_Window)
		{
			if (!bFreeTrial_Init)
			{
				bFreeTrial_Init = true;
			}
			ImGui::SetNextWindowSize(ImVec2(((90.0f / 4.0f) * 3) * ImGui::GetFontSize(), (fMarketplacePanelHeight + 2.0f) * ImGui::GetFontSize()), ImGuiCond_Always);
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			ImGui::Begin("FreeTrial##FreeTrialWindow", &bFreeTrial_Window, ImGuiWindowFlags_None | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
			ImGui::Indent(10);
			ImGui::Text("");
			float fFontSize = ImGui::GetFontSize();
			int icon_size = ImGui::GetFontSize()*3.0;
			ImVec2 VIconSize = { (float)icon_size, (float)icon_size };
			bool bClickAlreadyHandled = false;
			if (ImGui::ImgBtn(TOOL_GOBACK, VIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
			{
				bClickAlreadyHandled = true;
				if (g_bFreeTrialNowExitsApp == true)
					PostQuitMessage(0);
				else
					bFreeTrial_Window = false;
			}
			if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0)
			{
				if (g_bFreeTrialNowExitsApp == true)
					ImGui::SetTooltip("%s", "Exit GameGuru MAX Free Trial Version");
				else
					ImGui::SetTooltip("%s", "Exit Free Trial Window");
			}
			ImGui::SameLine();

			ImVec2 VHeaderSize;
			VHeaderSize = { 730, 128 };
			ImVec2 pOldPos = ImGui::GetCursorPos();
			ImGui::SetCursorPos(pOldPos + ImVec2(78 - 18, -35));
			int iHeaderImgID = FREETRIAL_HEADER;
			if (g_iFreeTrialDaysLeft == 1) iHeaderImgID = FREETRIAL_COUNTER_ONEDAY;
			ImGui::ImgBtn(iHeaderImgID, VHeaderSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1), ImVec4(1, 1, 1, 1), ImVec4(1, 1, 1, 1), 0, 0, 0, 0, false, false, false, false, false, false);
			ImVec2 pAfterPos = ImGui::GetCursorPos();

			// demo countdown numeric 
			ImGui::SetCursorPos(pOldPos + ImVec2(78+568, -4));
			ImGui::ImgBtn(FREETRIAL_COUNTER_BASE, ImVec2(50,64), ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1), ImVec4(1, 1, 1, 1), ImVec4(1, 1, 1, 1), 0, 0, 0, 0, false, false, false, false, false, false);
			ImGui::SetCursorPos(pOldPos + ImVec2(78+338, -9));
			ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.5f, 0.0f, 1.0f));
			ImGui::SetWindowFontScale(5.0f);
			// days left in free trial
			char pDays[32];
			sprintf(pDays, "%d", g_iFreeTrialDaysLeft);
			ImGui::TextCenter(pDays);
			ImGui::PopStyleColor();
			ImGui::SetCursorPos(pAfterPos);

			float fContentWidth = ImGui::GetContentRegionAvailWidth();
			float fLogoWidth = fContentWidth - 10;
			float fImageWidth = 460;
			float fImageHeight = 215;
			if (ImageExist(FREETRIAL_BODY))
			{
				fImageWidth = ImageWidth(FREETRIAL_BODY);
				fImageHeight = ImageHeight(FREETRIAL_BODY);
			}
			float fScale = fLogoWidth / fImageWidth;
			ImVec2 vLogoSize = { fLogoWidth , fImageHeight * fScale };
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, -20));
			if (ImGui::ImgBtn(FREETRIAL_BODY, vLogoSize, ImVec4(0, 0, 0, 0), ImVec4(1, 1, 1, 1), ImVec4(1, 1, 1, 1), ImVec4(1, 1, 1, 1), 0, 0, 0, 0, false, false, false, false, false, false))
			{
				bClickAlreadyHandled = true;
				ExecuteFile("https://store.steampowered.com/app/1247290/GameGuru_MAX/", "", "", 0);
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click here to go to the Steam page to buy GameGuru MAX");

			ImGui::SetWindowFontScale(0.5f);
			ImGui::Text("");
			ImGui::SetWindowFontScale(2.8f);
			ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.0f, 0.0f, 0.0f, 1.00f));
			ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(1.0f, 0.5f, 0.0f, 1.00f));
			ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(1.0f, 0.6f, 0.1f, 1.00f));
			ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(1.0f, 0.5f, 0.0f, 1.00f));
			if (ImGui::StyleButton("Buy GameGuru MAX", ImVec2(vLogoSize.x, fFontSize*4.0)))
			{
				bClickAlreadyHandled = true;
				#ifdef FREETRIALONDISCOUNT
				ExecuteFile("https://store.steampowered.com/bundle/25504/GameGuru_Twin_Pack/", "", "", 0);
				#else
				ExecuteFile("https://store.steampowered.com/app/1247290/GameGuru_MAX/", "", "", 0);
				#endif
			}
			ImGui::PopStyleColor();
			ImGui::PopStyleColor();
			ImGui::PopStyleColor();
			ImGui::PopStyleColor();
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click here to go to the Steam page to buy GameGuru MAX");
			ImGui::SetWindowFontScale(1.0);

			// completed free trial window
			ImGui::Indent(-10);
			bImGuiGotFocus = true;
			ImGui::End();

			// if any click not uised above, close dialog on general principal (clicke doutside of dialog most likely)
			ImGuiIO& io = ImGui::GetIO();
			if (io.MouseReleased[0] > 0 && bClickAlreadyHandled == false)
			{
				iCountingFreeDialogClicks++;
				if (iCountingFreeDialogClicks >= 2)
				{				
					bFreeTrial_Window = false;
				}
			}
		}
		if (bFreeTrial_Window == false)
		{
			iCountingFreeDialogClicks = 0; 
		}
		#endif

		//#####################
		//#### Info Window ####
		//#####################
		
		iInfoUniqueId = 500001;
		if (refresh_gui_docking == 0) 
		{
			#ifdef WICKEDENGINE
			ImGui::SetNextWindowSize(ImVec2(46 * ImGui::GetFontSize(), 32 * ImGui::GetFontSize()), ImGuiCond_Once); //ImGuiCond_FirstUseEver
			#endif
			ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
			bool bTmp = true;
			ImGui::Begin("Information##InformationWindow", &bTmp, ImGuiWindowFlags_NoDocking);
			ImGui::End();
		}
		else if (bInfo_Window) {
			if (bInfo_Window_First_Run)
			{
				#ifdef WICKEDENGINE
				ImGui::SetNextWindowSize(ImVec2(46 * ImGui::GetFontSize(), 32 * ImGui::GetFontSize()), ImGuiCond_Once); //ImGuiCond_FirstUseEver
				#endif
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				bInfo_Window_First_Run = false;
			}
			if (bInfo_Reload || cInfoImageLast != cInfoImage )
			{
				//Load new image.
				//cInfoImage
				image_setlegacyimageloading(true);
				//  Load editor images
				SetMipmapNum(1); //PE: mipmaps not needed.
				if (GetImageExistEx(INFOIMAGE))
					DeleteImage(INFOIMAGE);
				LoadImage(cInfoImage.Get(), INFOIMAGE);
				if (!GetImageExistEx(INFOIMAGE))
				{
					//Get default information image.
					LoadImage("tutorialbank\\information-default.jpg", INFOIMAGE);
				}
				SetMipmapNum(-1);
				image_setlegacyimageloading(false);
				cInfoImageLast = cInfoImage;
			}
			ImGui::Begin("Information##InformationWindow", &bInfo_Window, ImGuiWindowFlags_NoDocking);

			if (GetImageExistEx(INFOIMAGE))
			{
				float fRegionWidth = ImGui::GetContentRegionAvailWidth();
				float img_w = ImageWidth(INFOIMAGE);
				float img_h = ImageHeight(INFOIMAGE);
				float fRatio = img_h / img_w;
#ifndef REMOVED_EARLYACCESS

				ImGui::ImgBtn(INFOIMAGE, ImVec2(fRegionWidth, fRegionWidth*fRatio), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), 0, 0, 0, 0, false);

			}
			ImGui::TextWrapped(cInfoMessage.Get());

#else

			}

			char newLine[MAX_PATH];
			char textToDisplay[MAX_PATH];
			strcpy(textToDisplay, cInfoMessage.Get());

			ImGui::SetWindowFontScale(1.75f);
			ImVec2 windowSize = ImGui::GetWindowSize();
			ImVec2 textSize = ImGui::CalcTextSize(cInfoMessage.Get());

			int iTotalLinesAllowed = windowSize.y / textSize.y;
			iTotalLinesAllowed++;

			// Reduce window size in calculations for margins.
			windowSize.x *= 0.8f;
			
			int iNumberOfLines = textSize.x / windowSize.x;
			// Add another line to accomodate for anything after the decimal place.
			iNumberOfLines++;

			// Work out where cursor should be placed to have the text block centered.
 			ImGui::SetCursorPosY((iTotalLinesAllowed - iNumberOfLines) * 0.5f * textSize.y);

			int iOffset = 0;
			int iLength = cInfoMessage.Len();

			// Work out the target number of characters per line.
			int iIncrement = iLength / iNumberOfLines;
			iIncrement++;

			int iPreviousOffset = 0;
			
			// Split cInfoMessage to display centered text over multiple lines.
			for (int i = 0; i < iNumberOfLines; i++)
			{
				strcpy(newLine, cInfoMessage.Get() + iOffset);
				iPreviousOffset = iOffset;
				iOffset += iIncrement;

				// Find a suitable place to end the line.
				for (int j = iOffset; j < iLength; j++)
				{
					if (textToDisplay[j] == ' ')
					{
						if (textToDisplay[j + 1] == '.' || textToDisplay[j + 1] == ',')
							iOffset++;
						break;
					}
					else if (textToDisplay[j] == '.' || textToDisplay[j] == ',')
						break;
					else
						iOffset++;
				}
				newLine[iOffset - iPreviousOffset ] = 0;
				ImGui::TextCenter(newLine);
				
			}
		
			ImGui::SetWindowFontScale(1.0f);
#endif
			ImGui::End();
		}
		else
		{
			bInfo_Reload = true; //Reload on new run.
		}

		//###############
		//#### About ####
		//###############

		#ifdef WICKEDENGINE
			About_Screen();
		#else
		//PE: PRODUCTV3 version.
		if (refresh_gui_docking == 0 ) {
			ImGui::SetNextWindowSize(ImVec2(28 * ImGui::GetFontSize(), 44 * ImGui::GetFontSize()), ImGuiCond_Once); //ImGuiCond_FirstUseEver
			ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
			ImGui::Begin("About##AboutWindow", &bAbout_Window, 0);
			ImGui::End();
		}
		else if (bAbout_Window) {
			if (!bAbout_Init) {

				FILE* fAbout = GG_fopen("editors\\uiv3\\about.txt", "r");
				if (fAbout)
				{
					char ctmp[MAX_PATH];
					while (!feof(fAbout))
					{
						fgets(ctmp, MAX_PATH - 1, fAbout);
						if (strlen(ctmp) > 0 && ctmp[strlen(ctmp) - 1] == '\n')
							ctmp[strlen(ctmp) - 1] = 0;

						about_text.push_back(&ctmp[0]);
					}
					fclose(fAbout);
				}
				bAbout_Init = true;
			}
			if (bAbout_Window_First_Run)
			{
				ImGui::SetNextWindowSize(ImVec2(28 * ImGui::GetFontSize(), 44 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				bAbout_Window_First_Run = false;
			}

			ImGui::Begin("About##AboutWindow", &bAbout_Window, 0);

			ImGui::Text("");

			float fRegionWidth = ImGui::GetWindowContentRegionWidth();
			float img_w = ImageWidth(ABOUT_LOGO);
			float img_h = ImageHeight(ABOUT_LOGO);

			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((fRegionWidth*0.5) - (img_w*0.5), 0.0f));

			ImGui::ImgBtn(ABOUT_LOGO, ImVec2(img_w, img_h), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), 0, 0, 0, 0, false);

			ImGui::TextCenter("");
			char pBuildText[1024];
			sprintf(pBuildText, "Build: %s", g.version_s.Get());
			ImGui::TextCenter(pBuildText);
			ImGui::TextCenter("");

			for (int vloop = 0; vloop < about_text.size(); vloop++) {

				if (pestrcasestr(about_text[vloop].Get(), "https://") || pestrcasestr(about_text[vloop].Get(), "http://")) {
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((fRegionWidth*0.5) - (150.0f*0.5), 0.0f));
					char *tmp;
					cstr sUrl = about_text[vloop].Upper();
					if (pestrcasestr(about_text[vloop].Get(), "https://"))
						tmp = sUrl.Get() + 8;
					else
						tmp = sUrl.Get() + 7;
					if (tmp[strlen(tmp) - 1] == '/')
						tmp[strlen(tmp) - 1] = 0;
					ImGui::SetWindowFontScale(0.90);
					if (ImGui::StyleButton(tmp, ImVec2(150.0f, 0.0f))) {
						ExecuteFile(about_text[vloop].Get(), "", "", 0);
					}
					ImGui::SetWindowFontScale(1.0);
				}
				else {
					ImGui::TextCenter(about_text[vloop].Get());
				}

			}
			ImGui::Text("");

			float fTotalWidth = ImageWidth(ABOUT_TGC);
			#ifdef PRODUCTV3
			fTotalWidth += ImageWidth(ABOUT_HB);
			fTotalWidth += 30.0f;
			#endif

			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((fRegionWidth*0.5) - (fTotalWidth*0.5), 0.0f));
			img_w = ImageWidth(ABOUT_TGC);
			img_h = ImageHeight(ABOUT_TGC);
			ImGui::ImgBtn(ABOUT_TGC, ImVec2(img_w, img_h), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), 0, 0, 0, 0, false);
			#ifdef PRODUCTV3
			ImGui::SameLine();
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(20.0f,0.0f));
			img_w = ImageWidth(ABOUT_HB);
			img_h = ImageHeight(ABOUT_HB);
			ImGui::ImgBtn(ABOUT_HB, ImVec2(img_w, img_h), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), 0, 0, 0, 0, false);
			#endif

			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((fRegionWidth*0.5) - (fTotalWidth*0.5), 0.0f));
			ImGui::SetWindowFontScale(0.90);
			if (ImGui::StyleButton("THEGAMECREATORS.COM", ImVec2(ImageWidth(ABOUT_TGC),0))) {
				ExecuteFile("https://www.thegamecreators.com", "", "", 0);
			}
			#ifdef PRODUCTV3
			ImGui::SetWindowFontScale(1.0);
			ImGui::SameLine();
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(20.0f, 0.0f));
			ImGui::SetWindowFontScale(0.90);
			if (ImGui::StyleButton("HAMILTONBUHL.COM", ImVec2(ImageWidth(ABOUT_HB), 0))) {
				ExecuteFile("https://www.hamiltonbuhl.com", "", "", 0);
			}
			#endif
			ImGui::SetWindowFontScale(1.0);
			ImGui::Text("");

			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((fRegionWidth*0.5) - (100.0f*0.5), 0.0f));
			if (ImGui::StyleButton("OK", ImVec2(100.0f, 0.0f))) {
				bAbout_Window = false;
			}
			ImGui::Text("");
			bImGuiGotFocus = true;
			ImGui::End();
		}
		#endif

		//##################
		//#### Importer ####
		//##################

		if (refresh_gui_docking == 0 && !bImporter_Window) 
		{
			//Make sure window is setup in docking space.
			ImGui::Begin("Importer##ImporterWindow", &bImporter_Window, iGenralWindowsFlags);
			ImGui::End();
		}

		imgui_importer_loop();

		//#########################
		//#### Help Menu Image ####
		//#########################
		static bool bReadyToProcessMouse = false;
		if(bHelp_Menu_Image_Window) {
				
			if (GetImageExistEx(HELPMENU_IMAGE)) {
				ImGui::OpenPopup("Help##HelpMenuImage");

				float img_w = ImageWidth(HELPMENU_IMAGE);
				float img_h = ImageHeight(HELPMENU_IMAGE);

				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);

				if (ImGui::BeginPopupModal("Help##HelpMenuImage", &bHelp_Menu_Image_Window, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings )) { //ImGuiWindowFlags_AlwaysAutoResize
					//@Lee if you only want 1:1 pixel remove the below (but it could go outside windows).
					//@Lee if 1:1 is possible it will do it.
					if (img_w > viewPortSize.x || img_h > viewPortSize.y) {
						float fRatio = 1.0f / (img_w / img_h);
						img_w = viewPortSize.x;
						img_h = viewPortSize.x * fRatio;
						if (img_h > viewPortSize.y) {
							float fRatio = 1.0f / (img_h / img_w);
							img_h = viewPortSize.y;
							img_w = viewPortSize.y * fRatio;
						}
					}
					ImGui::ImgBtn(HELPMENU_IMAGE, ImVec2(img_w, img_h), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), 0, 0, 0, 0, false);
					bImGuiGotFocus = true;
					ImGui::EndPopup();
				}

			}
			else {
				bHelp_Menu_Image_Window = false;
			}

			//Close no matter where is clicked.
			ImGuiIO& io = ImGui::GetIO();
			if (ImGui::IsKeyPressed(27)) {
				bHelp_Menu_Image_Window = false;
			}
			if (bReadyToProcessMouse && ImGui::IsMouseReleased(0) ) {
				bHelp_Menu_Image_Window = false;
			}
			if (io.MouseClicked[0] > 0) {
				bReadyToProcessMouse = true; //next frame
			}
		}
		else {
			bReadyToProcessMouse = false;
		}

		//###########################
		//#### Export Standalone ####
		//###########################
		static bool bModalInformation = false;

		if (g_bFreeTrialVersion == true)
		{
			if (bExport_Standalone_Window == true)
			{
				bFreeTrial_Window = true;
				bExport_Standalone_Window = false;
			}
		}
		if (bExport_Standalone_Window) 
		{
			static char cStandalonePath[MAX_PATH] = "\0";
			static int iStandaloneCycle = 0;
			if (cStandalonePath[0] == 0) {
				g.exedir_s = g.myownrootdir_s;//GetDir();
				if(cstr(Right(g.myownrootdir_s.Get(), 1)) == "\\" )
					g.exedir_s += "My Games\\";
				else
					g.exedir_s += "\\My Games\\";
				strcpy(cStandalonePath, g.exedir_s.Get());

				//PE: Last saved overwrite default path.
				if (strlen(pref.cDefaultStandalonePath) > 0)
				{
					strcpy(cStandalonePath,pref.cDefaultStandalonePath);
				}

			}

			/*ImGui::OpenPopup("Save Standalone##SaveStandaloneWindow");*/
			ImGui::OpenPopup("Export: Save Standalone Game##SaveStandaloneWindow");

			//ImGui::SetNextWindowPos(viewPortPos + ImVec2(180, 140), ImGuiCond_Appearing);// ImGuiCond_Once); //ImGuiCond_FirstUseEver
#ifdef WICKEDENGINE
			ImGui::SetNextWindowSize(ImVec2(43 * ImGui::GetFontSize(), 32 * ImGui::GetFontSize()), ImGuiCond_Once); //ImGuiCond_FirstUseEver (was 13)
#else
			ImGui::SetNextWindowSize(ImVec2(34 * ImGui::GetFontSize(), 24 * ImGui::GetFontSize()), ImGuiCond_Once); //ImGuiCond_FirstUseEver (was 13)
#endif
			ImGui::SetNextWindowPosCenter(ImGuiCond_Appearing);// ImGuiCond_Once);

			if (ImGui::BeginPopupModal("Export: Save Standalone Game##SaveStandaloneWindow", &bExport_Standalone_Window, 0)) { //ImGuiWindowFlags_AlwaysAutoResize

				ImGui::Indent(10);
				float col_start = 80.0f;
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

				#ifndef WICKEDENGINE
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::Text("Choose where you would like your standalone to be saved:");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::Text("Path");
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
				ImGui::SetCursorPos(ImVec2(col_start, ImGui::GetCursorPosY()));
				//ImGui::PushItemWidth(-10);

				float path_gadget_size = ImGui::GetFontSize()*2.0;

				ImGui::PushItemWidth(-10 - path_gadget_size);
				ImGui::InputText("##InputPathCCP", &cStandalonePath[0], 250, ImGuiInputTextFlags_ReadOnly);
				if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;
				ImGui::PopItemWidth();

				ImGui::SameLine();
				ImGui::PushItemWidth(path_gadget_size);
				if (ImGui::StyleButton("...##ccppath")) {
					//PE: filedialogs change dir so.
					cStr tOldDir = GetDir();
					char * cFileSelected;
					cstr fulldir = cStandalonePath;

					cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_DIR, "All\0*.*\0", fulldir.Get() , NULL);

					SetDir(tOldDir.Get());

					if (cFileSelected && strlen(cFileSelected) > 0) {
						strcpy(cStandalonePath, cFileSelected);
						if (cStandalonePath[strlen(cStandalonePath) - 1] != '\\')
							strcat(cStandalonePath, "\\");
						strcpy(pref.cDefaultStandalonePath, cStandalonePath);
					}
				}
				ImGui::PopItemWidth();
				#endif


				#ifdef WICKEDENGINE
				#ifndef REMOVED_EARLYACCESS
				ImGui::Text("Standalone Settings:");
				#endif
				/*
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX()+35, ImGui::GetCursorPosY() + 3));
				ImGui::Text("Single Player");
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(20, ImGui::GetCursorPosY() - 3));
				if (ImGui::Checkbox("##setSinglePlayerEnabled", &g_bStandaloneSinglePlayer))
				{
					g_bStandaloneSinglePlayer = true;
					g_bStandaloneMultiPlayer = false;
				}
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX()+35, ImGui::GetCursorPosY() + 3));
				ImGui::Text("Multiplayer");
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(20, ImGui::GetCursorPosY() - 3));
				if (ImGui::Checkbox("##setMultiPlayerEnabled", &g_bStandaloneMultiPlayer)) 
				{
					#ifdef DISABLEMULTIPLAYERFORMAX
					MessageBoxA(NULL, "Multiplayer export currently not supported in MAX", "GameGuru MAX Warning", MB_OK | MB_TOPMOST);
					g_bStandaloneSinglePlayer = true;
					g_bStandaloneMultiPlayer = false;
					#else
					g_bStandaloneMultiPlayer = true;
					g_bStandaloneSinglePlayer = false;
					#endif
				}
				*/
				g_bStandaloneSinglePlayer = true;
				g_bStandaloneMultiPlayer = false;

				#ifndef REMOVED_EARLYACCESS
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX()+35, ImGui::GetCursorPosY() + 3));
				ImGui::Text(" VR Mode");
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(20, ImGui::GetCursorPosY() - 3));
				if (ImGui::Checkbox("##setVRModeEnabled", &g_bStandaloneVRMode)) 
				{
					// VR Mode changed
				}
				#endif

				//ImGui::Text("");
				ImGui::SetWindowFontScale(1.2);
				ImGui::Text("You can export your chosen levels as a self-contained standalone game that can");
				ImGui::Text("then be shared and played without the need for GameGuru MAX:");
				ImGui::Text("");
				#ifdef WICKEDENGINE
				
				ImGui::TextWrapped("PLEASE NOTE:  During the Early Access development phase, all games saved as standalone are considered test games. The games will include a startup message informing users that the game has been made with the Early Access version. If you would like to apply for the EA restriction to be lifted please follow this LINK and fill out the short form. Note you don't need to do this for personal non-commercial purposes.");
				ImVec2 prevCursor = ImGui::GetCursorPos();
				ImGui::SetCursorPos(prevCursor + ImVec2(431, -50));
				if (ImGui::HyberlinkButton("", ImVec2(ImGui::GetFontSize() * 2.2f, ImGui::GetFontSize() * 1.5f)))
				{
					ExecuteFile("https://www.game-guru.com/publish-request", 0, 0);
				}
				ImGui::SetCursorPos(prevCursor);
				ImGui::Text("");
				ImGui::PushID(iInfoUniqueId++);
				if (ImGui::ImgBtn(ICON_INFO, ImVec2(20, 20), ImColor(0, 0, 0, 0), ImColor(220, 220, 220, 220), ImColor(255, 255, 255, 255), ImColor(180, 180, 160, 255), -1, 0, 0, 0, false, false, false, false, false)) //, bBoostIconColors
				{
					//PE: We are modal here, so need the special modal information window.
					cInfoMessage = "Games made with GameGuru MAX are designed for PCs with this minimum specification:\n\nWindows 10\nIntel Dual-Core 2GHz or AMD Dual-Core 2GHz CPU\n8 GB Ram\nNVIDIA GeForce GTX960 or similar\nDirectX 11\n30 GB device storage\nDirectX Compatabible Sound Card";
					cInfoImage = ""; //Image that descripe this information window. "tutorialbank\\information-default.jpg".
					//bInfo_Window = true; //Open information window.
					bModalInformation = true;
				}
				ImGui::PopID();
				if (ImGui::IsItemHovered())
				{
					ImGui::SetTooltip("%s", "Click For More Information");
				}
				ImGui::SameLine();

				ImGui::TextWrapped("Ensure that anyone you share your standalone game with has a PC system that meets the minimum requirements of GameGuru MAX.");
				ImGui::Text("");
				#endif

				ImGui::PushID(iInfoUniqueId++);
				if (ImGui::ImgBtn(ICON_INFO, ImVec2(20, 20), ImColor(0, 0, 0, 0), ImColor(220, 220, 220, 220), ImColor(255, 255, 255, 255), ImColor(180, 180, 160, 255), -1, 0, 0, 0, false, false, false, false, false)) //, bBoostIconColors
				{
					//PE: We are modal here, so need the special modal information window.
					cInfoMessage = "When your game has been saved as a standalone game, Windows File Explorer will open to the folder where your game has been saved.\n\nThe path will be similar to this:\nC:\\Users\\username_\Documents\\GameGuruApps\\GameGuruMAX\\My Games\\nameofgame\n\nYou can then run your game from that location without using GameGuru MAX and you can share the game with friends and family.";
					cInfoImage = ""; //Image that descripe this information window. "tutorialbank\\information-default.jpg".
					//bInfo_Window = true; //Open information window.
					bModalInformation = true;
				}
				ImGui::PopID();
				if (ImGui::IsItemHovered())
				{
					ImGui::SetTooltip("%s", "Click For More Information");
				}
				ImGui::SameLine();
				static bool bOpenFolder = false;
				ImGui::Checkbox("Open folder after game has been saved and close GameGuru MAX", &bOpenFolder);
				ImGui::Text("");

				ImGui::SetWindowFontScale(1.0);

				#endif

				// Save or Cancel button
				ImGui::Indent(-10);
				float save_gadget_size = ImGui::GetFontSize()*16.0;
				float w = ImGui::GetWindowContentRegionWidth();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (save_gadget_size*0.5), 0.0f));
				ImGui::SetWindowFontScale(1.4);
				if (iStandaloneCycle == 0) 
				{
					extern float g_mapfile_fProgress;
					g_mapfile_fProgress = 0.0f;
					#ifdef WICKEDENGINE
					if (ImGui::StyleButton("SAVE TEST STANDALONE", ImVec2(save_gadget_size, 0))) {
						g.exedir_s = cStandalonePath;
						iStandaloneCycle = 1;
					}
					#else
					if (ImGui::StyleButton("SAVE STANDALONE", ImVec2(save_gadget_size, 0))) {
						g.exedir_s = cStandalonePath;
						iStandaloneCycle = 1;
					}
					#endif
				}
				else 
				{
					if (ImGui::StyleButton("CANCEL", ImVec2(save_gadget_size, 0))) {
						iStandaloneCycle = 5;
					}
				}
				ImGui::SetWindowFontScale(1.0);

				#ifdef WICKEDENGINE
				ImGui::Text("");
				#endif

				ImGui::Indent(10);

				#ifdef WICKEDENGINE
				//New settings here!
				if (iStandaloneCycle == 0)
				{
					ImGui::SetWindowFontScale(1.2);
					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
					ImGui::Text("Choose where you would like your standalone to be saved:");
					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
					ImGui::Text("Path");
					ImGui::SameLine();
					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
					ImGui::SetCursorPos(ImVec2(col_start, ImGui::GetCursorPosY()));
					//ImGui::PushItemWidth(-10);

					float path_gadget_size = ImGui::GetFontSize()*2.0;

					ImGui::PushItemWidth(-10 - path_gadget_size);
					ImGui::InputText("##InputPathCCP", &cStandalonePath[0], 250, ImGuiInputTextFlags_ReadOnly);
					if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;
					ImGui::PopItemWidth();

					ImGui::SameLine();
					ImGui::PushItemWidth(path_gadget_size);
					if (ImGui::StyleButton("...##ccppath")) {
						//PE: filedialogs change dir so.
						cStr tOldDir = GetDir();
						char * cFileSelected;
						cstr fulldir = cStandalonePath;

						cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_DIR, "All\0*.*\0", fulldir.Get(), NULL);

						SetDir(tOldDir.Get());

						if (cFileSelected && strlen(cFileSelected) > 0) {
							strcpy(cStandalonePath, cFileSelected);
							if (cStandalonePath[strlen(cStandalonePath) - 1] != '\\')
								strcat(cStandalonePath, "\\");
							strcpy(pref.cDefaultStandalonePath, cStandalonePath);
						}
					}
					ImGui::PopItemWidth();
					ImGui::SetWindowFontScale(1.0);
				}
				#endif

				float fdone = (float)mapfile_savestandalone_getprogress() / 100.0f;

				if (iStandaloneCycle == 1) fdone = 0.01f;

				if (fdone > 0.0f) {
					#ifdef WICKEDENGINE
					ImGui::SetWindowFontScale(1.2);
					#endif
					char tmp[32];
					sprintf(tmp, "Progress: %.0f%%", fdone*100.0f);
					ImGui::ProgressBar(fdone, ImVec2(ImGui::GetContentRegionAvail().x - 10, 28), tmp); //, ""
					#ifdef WICKEDENGINE
					ImGui::SetWindowFontScale(1.0);
					#endif
				}

				if (iStandaloneCycle == 2)
				{
					// start save standalone creation
					mapfile_savestandalone_start();
					iStandaloneCycle = 3;
				}
				if (iStandaloneCycle == 3)
				{
					// run standalone creation calls
					if (mapfile_savestandalone_continue() == 1)
					{
						// complete standalone creation
						iStandaloneCycle = 4;
					}
				}
				if (iStandaloneCycle == 4)
				{
					// complete standalone creation
					mapfile_savestandalone_finish();
					iStandaloneCycle = 0;
					strcpy(cTriggerMessage, "Save Standalone Done");
					bTriggerMessage = true;
					bExport_Standalone_Window = false; //Close window.
					#ifdef WICKEDENGINE

					void InjectIconToExe(char *icon, char *exe, int intresourcenumber);
					char projectico[MAX_PATH];
					char projectfinal_ico[MAX_PATH];
					strcpy(projectico, "projectbank\\");
					strcat(projectico, Storyboard.gamename);

					strcpy(projectico, projectico);
					strcat(projectico, "\\project256.ico");
					GG_GetRealPath(projectico, 1);
					if (FileExist(projectico))
					{
						t.dest_s = t.exepath_s + t.exename_s + "\\" + t.exename_s + ".exe";
						InjectIconToExe(projectico, t.dest_s.Get(), 1);
						//PE: Update window 10 icon cache.
						HINSTANCE hinstance = ShellExecuteA(NULL, "open", "ie4uinit.exe", "-show", "", SW_SHOWDEFAULT);
						Sleep(100); //PE: Let it update
					}


					if (bOpenFolder)
					{
						cstr open_folder = cStandalonePath;
						if (g.bUseStoryBoardSetup)
						{
							//Use project name as exename
							if (strlen(Storyboard.gamename) > 0)
							{
								open_folder = open_folder + cstr(Storyboard.gamename) + "\\";
							}
						}
						HINSTANCE hinstance = ShellExecuteA(NULL, "open", open_folder.Get(), "", "", SW_SHOWDEFAULT);
						g_bCascadeQuitFlag = true;
					}
					#endif
				}
				if (iStandaloneCycle == 5)
				{
					// cancel standalone creation
					mapfile_savestandalone_restoreandclose();
					iStandaloneCycle = 0;
					strcpy(cTriggerMessage, "Save Standalone Cancelled");
					bTriggerMessage = true;
					bExport_Standalone_Window = false; //Close window.
				}
				if (iStandaloneCycle == 1) iStandaloneCycle = 2;

				ImGui::Indent(-10);

				bImGuiGotFocus = true;


				//#######################################################
				//#### Modal Popup Information , must do it this way ####
				//#######################################################

				#ifdef WICKEDENGINE
				if (bModalInformation)
				{
					ImGui::OpenPopup("Information##modalinformationwindow");

					ImGui::SetNextWindowSize(ImVec2(46 * ImGui::GetFontSize(), 28 * ImGui::GetFontSize()), ImGuiCond_Once);
					ImGui::SetNextWindowPosCenter(ImGuiCond_Appearing);// ImGuiCond_Once);
					if (ImGui::BeginPopupModal("Information##modalinformationwindow", &bModalInformation, 0))
					{
						ImGui::Indent(10);
						ImGui::SetWindowFontScale(1.75f);
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 4));
						ImGui::TextWrapped(cInfoMessage.Get());

						/* PE: This dont work if we have \n\n in the text.
						//char newLine[MAX_PATH];
						//char textToDisplay[MAX_PATH];
						//strcpy(textToDisplay, cInfoMessage.Get());
						ImVec2 windowSize = ImGui::GetWindowSize();
						ImVec2 textSize = ImGui::CalcTextSize(cInfoMessage.Get());

						int iTotalLinesAllowed = windowSize.y / textSize.y;
						iTotalLinesAllowed++;

						// Reduce window size in calculations for margins.
						windowSize.x *= 0.8f;

						int iNumberOfLines = textSize.x / windowSize.x;
						// Add another line to accomodate for anything after the decimal place.
						iNumberOfLines++;

						// Work out where cursor should be placed to have the text block centered.
						ImGui::SetCursorPosY((iTotalLinesAllowed - iNumberOfLines) * 0.5f * textSize.y);

						int iOffset = 0;
						int iLength = cInfoMessage.Len();

						// Work out the target number of characters per line.
						int iIncrement = iLength / iNumberOfLines;
						iIncrement++;

						int iPreviousOffset = 0;

						// Split cInfoMessage to display centered text over multiple lines.
						for (int i = 0; i < iNumberOfLines; i++)
						{
							strcpy(newLine, cInfoMessage.Get() + iOffset);
							iPreviousOffset = iOffset;
							iOffset += iIncrement;

							// Find a suitable place to end the line.
							for (int j = iOffset; j < iLength; j++)
							{
								if (textToDisplay[j] == ' ')
								{
									if (textToDisplay[j + 1] == '.' || textToDisplay[j + 1] == ',')
										iOffset++;
									break;
								}
								else if (textToDisplay[j] == '.' || textToDisplay[j] == ',')
									break;
								else
									iOffset++;
							}
							newLine[iOffset - iPreviousOffset] = 0;
							ImGui::TextCenter(newLine);

						}
						*/
						ImGui::SetWindowFontScale(1.0f);
						ImGui::Indent(-10);
						ImGui::EndPopup();
					}
				}
				#endif

				ImGui::EndPopup();
			}
		}

		//######################
		//#### Object Tools ####
		//######################

#ifdef USE_ENTITY_TOOL_WINDOW

		#ifdef WICKEDENGINE
		g_selected_editor_object = NULL;
		if (t.widget.pickedObject > 0) {
			if (t.widget.pickedObject < g_iObjectListCount)
			{
				if (g_ObjectList[t.widget.pickedObject])
				{
					if (t.widget.pickedEntityIndex > 0) {

						if (t.entityelement[t.widget.pickedEntityIndex].staticflag)
							g_selected_editor_color = XMSTATICCOLOR;
						else
							g_selected_editor_color = XMDYNAMICCOLOR;
					}
					g_selected_editor_object = g_ObjectList[t.widget.pickedObject];
				}
			}
		}

		//bool bTriggerScrollToTop = false;
		static sObject* g_last_selected_editor_object = NULL;
		//PE: Dont change window if Game Genre tools is open.
		//LB: Shooter now a filter mode if (!Shooter_Tools_Window)
		{
			if (g_selected_editor_object && g_last_selected_editor_object != g_selected_editor_object)
			{
				g_last_selected_editor_object = g_selected_editor_object;
				ImGui::SetWindowFocus("Object Tools##EntityToolsWindow");

				// Check if we no longer have a group selected and then switch back to the " Current Objects" tab if so
				if (current_selected_group >= 0)
				{
					bool bIsNewObjectInGroup = false;

					for (int j = 0; j < MAXGROUPSLISTS; j++)
					{
						for (int i = 0; i < vEntityGroupList[j].size(); i++)
						{
							if (t.widget.pickedObject == vEntityGroupList[j].at(i).e)
							{
								bIsNewObjectInGroup = true;
								break;
							}
						}
					}

					if (!bIsNewObjectInGroup)
						i_switch_group_tab = 1;
					else
						i_switch_group_tab = 2;
				}
				else
				{
					i_switch_group_tab = 1;
				}
					
				//bTriggerScrollToTop = true;
			}
		}
		#endif

		if (refresh_gui_docking == 0 && !Entity_Tools_Window) 
		{
			//Make sure window is setup in docking space.
			ImGui::Begin("Object Tools##EntityToolsWindow", &Entity_Tools_Window, iGenralWindowsFlags);
			ImGui::End();
		}
		else 
		{

			int iEntityIndex = t.widget.pickedEntityIndex;
			int iActiveObj = t.widget.activeObject;
			bool bUpdateGrideleprof = false;
			#ifdef WICKEDENGINE
			if (t.gridentityextractedindex > 0)
			{
				iEntityIndex = t.gridentityextractedindex;
				bUpdateGrideleprof = true;
				if (t.gridentityobj > 0)
					iActiveObj = t.gridentityobj;
			}
			else
			{
				iEntityIndex = t.widget.pickedEntityIndex;
				if (t.widget.activeObject == 0 && t.widget.pickedEntityIndex < t.entityelement.size() )
				{
					if(t.widget.pickedEntityIndex > 0)
						iActiveObj = t.tentityobj = t.entityelement[t.widget.pickedEntityIndex].obj;
					else
					{
						if (1==2 && t.tentitytoselect > 0)
						{
							//Temp enable widget , reset is set in next run of gridedit_mapediting();
							iEntityIndex = t.tentitytoselect;
							t.widget.activeObject = t.entityelement[t.tentitytoselect].obj;
							if (!ObjectExist(t.widget.activeObject))
							{
								t.widget.activeObject = 0;
							}
						}
						iActiveObj = t.widget.activeObject;
					}
				}
			}

			active_tools_obj = iActiveObj;
			active_tools_entity_index = iEntityIndex;

			#endif

			if (Entity_Tools_Window && ( current_mode == TOOL_ENTITY || current_mode == TOOL_MARKERS || (t.gridentity > 0 && t.entityprofile[t.gridentity].isebe != 0)  )) 
			{
				#ifdef WICKEDENGINE
				if (!g_selected_editor_object && iActiveObj > 0)
				{
					if (g_ObjectList[iActiveObj])
					{
						if (iEntityIndex > 0) {

							if (t.entityelement[iEntityIndex].staticflag)
								g_selected_editor_color = XMSTATICCOLOR;
							else
								g_selected_editor_color = XMDYNAMICCOLOR;
						}
						g_selected_editor_object = g_ObjectList[iActiveObj];
					}
				}
				#endif

				#ifdef PEWORKINGONPROPERTIES
				int iMasterID = t.entityelement[iEntityIndex].bankindex;

				#ifdef WICKEDENGINE
				if (bDraggingActive && t.widget.pickedEntityIndex > 0 && t.gridentity > 0)
				{
					//PE: Keep displaying old info, while dragging a gridentity around.
					iMasterID = t.gridentity;
				}
				#endif

				#endif

				bool bWithNoScrollbar = false;
				if (iEntityIndex > 0 && iMasterID > 0 && iActiveObj > 0 && ObjectExist(iActiveObj) && pref.iEnableIdentityProperties )
				{
					//
					ImGui::Begin("Object Tools##EntityToolsWindow", &Entity_Tools_Window, iGenralWindowsFlags | ImGuiWindowFlags_NoScrollbar);
					bWithNoScrollbar = true;
				}
				else
				{
					ImGui::Begin("Object Tools##EntityToolsWindow", &Entity_Tools_Window, iGenralWindowsFlags);
				}

				// LB: inserted shooter properties at top of Object Tools if filter mode active
				if (Shooter_Tools_Window)
				{
					imgui_shooter_tools();
				}

				bool bRunExtractDuplicate = false;
				bool bDuplicate = false;
				bool bChildWindowOpen = false;
				bool bClickedTheLockUnlockButton = false;
				
				if (iActiveObj > 0)
				{
					bool bIsEBEWidget = false;
					int iEntID = 0;
					if (iEntityIndex > 0)
					{
						iEntID = t.entityelement[iEntityIndex].bankindex;
						if (iEntID > 0)
							if (t.entityprofile[iEntID].isebe != 0)
								bIsEBEWidget = true;
					}
					// rubber band or selected parent
					bool bRealRubberBand = false;
					int iEntityInGroupList = -1;
					if (g.entityrubberbandlist.size() > 0)
					{
						bRealRubberBand = true;
						if (iEntityIndex > 0)
						{
							bool bPartOfParentChildGroup = false;
							editor_rec_checkifindexinparentchain(iEntityIndex, &bPartOfParentChildGroup);
							if (bPartOfParentChildGroup == true)
								bRealRubberBand = false;
						}
					}
					else
					{
						iEntityInGroupList = isEntityInGroupList(iEntityIndex);
					}
					
					bool bToolPosition = false; // widgetPOSObj;
					bool bToolRotation = false; // widgetROTObj;
					bool bToolScale = false; // widgetSCLObj;
					bool bToolProperties = false; // widgetPRPObj;
					bool bToolExtract = false; // widgetDUPObj;
					bool bToolDelete = false; // widgetDELObj;
					bool bToolLock = false; // widgetLCKObj;
					bool bToolEdit = false;
					bool bToolSave = false;
					bool bToolDublicate = false; // 
					bool bToolFindFloor = true; //always on.,

					// show all or just POS
					if (bRealRubberBand == true)
					{
						// Rubber band select POS, DELETE and LOCK only
						bToolPosition = true;
						bToolRotation = true;
						bToolScale = true;
						bToolDelete = true;
						bToolLock = true;

						bToolFindFloor = false;
					}
					else
					{
						// POS, ROT, SCALE, etc
						bToolPosition = true;
						bToolRotation = true;
						bToolScale = true;
						bToolProperties = true;
						bToolExtract = true;
						bToolDelete = true;
						bToolLock = true;

						bToolDublicate = true;

						// hide if EBE widget
						if (bIsEBEWidget == true)
						{
							bToolProperties = false;
							bToolScale = false;
							bToolEdit = true;
							//bToolSave = true; inside EBE editor
						}
					}

					//  hide any buttons and widgets if entity is a 'waypoint zone type'
					t.ttte = iEntityIndex;
					if (t.ttte > 0)
					{
						t.tttwi = t.entityelement[t.ttte].eleprof.trigger.waypointzoneindex;
						if (t.tttwi > 0)
						{
							bToolRotation = false;
							bToolScale = false;
							bToolDublicate = false;
						}
						else if (iEntID > 0)
						{
							if (t.entityprofile[iEntID].islightmarker == 1 || t.entityprofile[iEntID].ischaracter == 1)
							{
								bToolScale = false;
							}
							else if (t.entityprofile[iEntID].ismarker > 0)
							{
								// but allow Particles to have rotation and scale control
								if (t.entityprofile[iEntID].ismarker != 10 )
								{
									bToolRotation = false;
									bToolScale = false;

									// allow the player start marker to be rotated.
									if (t.entityprofile[iEntID].ismarker == 1)
										bToolRotation = true;
								}
							}
						}
					}

					#ifdef PEWORKINGONPROPERTIES
					//#############################
					//#### PE: New properties. ####
					//#############################

					int iObject = t.entityelement[iEntityIndex].obj;
					int media_icon_size = 64;
					sObject* pObject = g_ObjectList[iActiveObj];

					if (iEntityIndex > 0 && iMasterID > 0 && ObjectExist(iActiveObj))
					{
						grideleprof_uniqui_id = 35000;

						static int iLastActiveEntityIndex = -1, iLastActiveObj = -1;
						if (iLastActiveEntityIndex != iEntityIndex || iLastActiveObj != iActiveObj)
						{
							if (iLastActiveObj != 70000 && iLastActiveEntityIndex > 0)
							{
								if (iLastActiveEntityIndex < t.entityelement.size())
								{
									if (t.entityelement[iLastActiveEntityIndex].obj == iLastActiveObj)
									{
										//PE: InstanceObject - convert old one that we edited to a instance id possible.
										t.tupdatee = iLastActiveEntityIndex;
										entity_updateentityobj();
									}
								}
							}
							fpe_current_loaded_script = -1; //Make sure dlua is loaded in next call to DisplayFPEBehavior.
							iLastActiveEntityIndex = iEntityIndex;
							iLastActiveObj = iActiveObj;
							// Ensure that the rotation values are updated when switching objects
							g_bRefreshRotationValuesFromObjectOnce = true;
							g_bRefreshScaleValuesFromObjectOnce = true;
						}
						imgui_set_openproperty_flags(iMasterID);
						if (pref.iEnableIdentityProperties)
						{
							bChildWindowOpen = true;

							if (ImGui::StyleCollapsingHeader("Identity##2", ImGuiTreeNodeFlags_DefaultOpen)) //ImGuiTreeNodeFlags_None
							{

								//Display icon.
								if (pref.iObjectEnableAdvanced == 2)
								{
									// no icon when in compact mode
								}
								else
								{
									if (t.entityprofile[iMasterID].iThumbnailSmall > 0)
									{
										float w = ImGui::GetContentRegionAvailWidth();
										float fRatio = (float)ImageWidth(t.entityprofile[iMasterID].iThumbnailLarge) / (float)ImageHeight(t.entityprofile[iMasterID].iThumbnailLarge);
										if (ImageExist(t.entityprofile[iMasterID].iThumbnailLarge) && fRatio > 1.0)
										{
											float fwidth = media_icon_size * fRatio;
											ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (fwidth*0.5), 0.0f));
											ImGui::ImgBtn(t.entityprofile[iMasterID].iThumbnailLarge, ImVec2(fwidth, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, false);
										}
										else
										{
											ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (media_icon_size*0.5), 0.0f));
											ImGui::ImgBtn(t.entityprofile[iMasterID].iThumbnailSmall, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
										}
									}
								}

								ImGui::Indent(10);
								t.entityelement[iEntityIndex].eleprof.name_s = imgui_setpropertystring2_v2(t.group, t.entityelement[iEntityIndex].eleprof.name_s.Get(), "", t.strarr_s[204].Get(), false);
								ImGui::Indent(-10);

								ImGui::Separator();
							}
						}
					}

					//PE: Add a child here!
					if (bWithNoScrollbar)
					{
						ImGui::BeginChild("##objectpropertieswithnoscrollbar", ImVec2(0, 0), false, iGenralWindowsFlags);
					}

					//bChildWindowOpen = true;

					static int iLastEntityIndex = -1;
					if (iEntityIndex != iLastEntityIndex)
					{
						iLastEntityIndex = iEntityIndex;
						ImGui::SetScrollY(0);
						//bTriggerScrollToTop = false;
					}

					#endif

					//##########################
					//#### Entity Transform ####
					//##########################

					bool bReadOnlyMode = false;
					if (t.entityelement[iEntityIndex].editorlock == 1)
						bReadOnlyMode = true;

					if (bToolPosition || bToolRotation || bToolScale)
					{
						// Object tools headers range from 14-20.
						// Default to the positioning header when selecting an object for the first time.
						if (g_selected_editor_object && g_last_selected_editor_object != g_selected_editor_object && (iLastOpenHeader < 13 || iLastOpenHeader > 18))
							iLastOpenHeader = 14;

						if (pref.bAutoClosePropertySections && iLastOpenHeader != 14)
							ImGui::SetNextItemOpen(false, ImGuiCond_Always);

						if (pref.iObjectEnableAdvanced == 2)
							ImGui::SetNextItemOpen(true, ImGuiCond_Always);

						if (ImGui::StyleCollapsingHeader("Positioning, Rotating and Scaling", ImGuiTreeNodeFlags_DefaultOpen)) //ImGuiTreeNodeFlags_DefaultOpen
						{
							// header prep
							if (pref.iObjectEnableAdvanced == 2)
							{
								// compact mode allows another component to be regarded as last opened header - keeps posrotscl open
							}
							else
							{
								iLastOpenHeader = 14;
							}
							//if (bReadOnlyMode)
							//{
							//	// When the object is locked, a child window is created so a tooltip can display even when the items are disabled.
							//	ImGui::BeginChild("##transform");
							//}
							float w = ImGui::GetWindowContentRegionWidth() - 30.0f;

							// if change these, update the object
							bool bUpdatePosition = false;
							bool bUpdateRoataion = false;
							bool bUpdateScale = false;
							float fPos[3], fScale[3];
							static float fAngle[3];
							static float fOldAngle[3];
							static float fScaleOrg[3];
							static int iLastPickedEntID = -1;
							static float fScaleMul = 100.0f;
							float fOldActiveObjectSX,fOldActiveObjectSY,fOldActiveObjectSZ;

							// Need these buttons for switching the widget type (when its on).
							ImGui::Indent(10);
							if (!pref.iEnableDragDropEntityMode || pref.iEnableDragDropWidgetSelect)
							{
								// widget mode 
								ImGui::TextCenter("Developer Widget Mode");
								float fFontSize = ImGui::GetFontSize();
								int iLockButton = 0; if (pref.iObjectEnableAdvanced == 2) iLockButton = 1;
								float fButtonSize = (w-10) / ((int)bToolPosition + (int)bToolRotation + (int)bToolScale + iLockButton);
								if (bToolPosition)
								{
									ImGui::PushItemWidth(fButtonSize);								
									bool bSelected = (t.widget.mode == 0);
									if (bSelected) ImGui::PushStyleColor(ImGuiCol_Button, ImGui::GetStyle().Colors[ImGuiCol_ButtonHovered]);											
									if (ImGui::StyleButton("Position", ImVec2(fButtonSize, 0)))
									{
										t.widget.mode = 0;
										widget_show_widget();
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Position (F2)");							
									ImGui::PopItemWidth();
									if (bSelected) ImGui::PopStyleColor();
								}
								if (bToolRotation)
								{
									ImGui::SameLine();
									ImGui::PushItemWidth(fButtonSize);							
									bool bSelected = (t.widget.mode == 1);
									if (bSelected) ImGui::PushStyleColor(ImGuiCol_Button, ImGui::GetStyle().Colors[ImGuiCol_ButtonHovered]);							
									if (ImGui::StyleButton("Rotation", ImVec2(fButtonSize, 0)))
									{
										t.widget.mode = 1;
										widget_show_widget();
										g_bRefreshRotationValuesFromObjectOnce = true;
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Rotation (F3)");
									ImGui::PopItemWidth();							
									if (bSelected) ImGui::PopStyleColor();
								}
								if (bToolScale)
								{
									ImGui::SameLine();
									ImGui::PushItemWidth(fButtonSize);							
									bool bSelected = (t.widget.mode == 2);
									if (bSelected) ImGui::PushStyleColor(ImGuiCol_Button, ImGui::GetStyle().Colors[ImGuiCol_ButtonHovered]);						
									if (ImGui::StyleButton("Scale", ImVec2(fButtonSize, 0)))
									{
										t.widget.mode = 2;
										widget_show_widget();
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Scale (F4)");						
									ImGui::PopItemWidth();
									if (bSelected) ImGui::PopStyleColor();
								}
								if (iLockButton)
								{
									ImGui::SameLine();
									ImGui::PushItemWidth(fButtonSize);
									bool bSelected = false;
									if (bSelected) ImGui::PushStyleColor(ImGuiCol_Button, ImGui::GetStyle().Colors[ImGuiCol_ButtonHovered]);
									LPSTR pLockButtonText = "Lock";
									if (g.entityrubberbandlist.size() == 0 && iEntityIndex > 0 && t.entityelement[iEntityIndex].editorlock == 1) pLockButtonText = "Unlock";
									if (ImGui::StyleButton(pLockButtonText, ImVec2(fButtonSize, 0)))
									{
										bClickedTheLockUnlockButton = true;
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Lock/Unlock Object");
									ImGui::PopItemWidth();
									if (bSelected) ImGui::PopStyleColor();
								}
							}

							if (iEntityIndex != iLastPickedEntID)
							{
								iLastPickedEntID = iEntityIndex;
								fScaleMul = 100.0f;
								fScaleOrg[0] = ObjectScaleX(iActiveObj);
								fScaleOrg[1] = ObjectScaleY(iActiveObj);
								fScaleOrg[2] = ObjectScaleZ(iActiveObj);
							}

							fPos[0] = ObjectPositionX(iActiveObj);
							fPos[1] = ObjectPositionY(iActiveObj);
							fPos[2] = ObjectPositionZ(iActiveObj);
							if (g_bRefreshRotationValuesFromObjectOnce == true)
							{
								// should only snapshot eulers once as otherwise they
								// mess up when pulling from newer quaternion method
								g_bRefreshRotationValuesFromObjectOnce = false;
								if (t.entityprofile[iMasterID].ischaracter == 1)
								{
									// quats are the true rotations of objects, but refresh euler for characters to ONLY use the Y axis
									entity_calculateeuleryfromquat(iEntityIndex);

									// characters are simpler, just the Y angle from the entity properties
									fOldAngle[0] = 0;
									fOldAngle[1] = t.entityelement[iEntityIndex].ry;
									fOldAngle[2] = 0;
									fAngle[0] = 0;
									fAngle[1] = t.entityelement[iEntityIndex].ry;
									fAngle[2] = 0;
								}
								else
								{
									fOldAngle[0] = ObjectAngleX(iActiveObj);
									fOldAngle[1] = ObjectAngleY(iActiveObj);
									fOldAngle[2] = ObjectAngleZ(iActiveObj);
									fAngle[0] = ObjectAngleX(iActiveObj);
									fAngle[1] = ObjectAngleY(iActiveObj);
									fAngle[2] = ObjectAngleZ(iActiveObj);
								}
							}
							ImGui::PushStyleColor(ImGuiCol_ChildWindowBg, ImVec4(0, 0, 0, 0));
							float fPushItemWidth = -2.0;
							ImGui::Indent(-10);

							// store for rubber band position
							float fOldActiveObjectRX = ObjectAngleX(iActiveObj);
							float fOldActiveObjectRY = ObjectAngleY(iActiveObj);
							float fOldActiveObjectRZ = ObjectAngleZ(iActiveObj);

							// LB: only need to show smart buttons if not showing widget
							if (pref.iEnableDragDropWidgetSelect == 0)
							{
								// title for three position modes 
								if (pref.iEnableDragDropEntityMode && pref.iObjectEnableAdvanced != 2)
								{
									LPSTR pEditPositionTitle = "Positioning mode";
									if (iObjectMoveMode == 0) pEditPositionTitle = "Positioning mode: Horizontal only";
									if (iObjectMoveMode == 1) pEditPositionTitle = "Positioning mode: Vertical only";
									if (iObjectMoveMode == 2) pEditPositionTitle = "Positioning mode: Smart";
									ImGui::TextCenter(pEditPositionTitle);
								}

								// LB: Is not a HOLD action, it must be a single press toggle
								static bool bReadyToChange = true;
								bool bPressTAB = t.inputsys.keytab == 1;
								if (!bPressTAB) bReadyToChange = true;
								if (bReadyToChange && bPressTAB)
								{
									if (t.inputsys.keyshift == 1)
									{
										iObjectMoveMode--;
										if (iObjectMoveMode < 0 || iObjectMoveMode > 2)
											iObjectMoveMode = 2;
									}
									else
									{
										iObjectMoveMode++;
										if (iObjectMoveMode > 2 || iObjectMoveMode < 0)
											iObjectMoveMode = 0;
									}
									bReadyToChange = false; //toggle, wait until tab is released again.
								}

								// center buttons
								ImVec2 padding = { 3.0, 3.0 };
								w = ImGui::GetContentRegionAvail().x - 10.0f;
								float icon_spacer = 10.0f;
								int max_icon_size = 56;
								int control_image_size = 26; //lowest possible icon size.
								float center_icons_numbers = 3.0f;
								if (pref.iObjectEnableAdvanced == 2)
								{
									// compact mode for positioning buttons
									center_icons_numbers = 6.0f;
									icon_spacer = 5.0f;
									max_icon_size = 28.0f;
									control_image_size = 13.0f;
								}
								float control_width = (control_image_size + 3.0) * center_icons_numbers + 6.0;
								int indent = 10;
								if (w > control_width)
								{
									//PE: fit perfectly with window width.
									control_image_size = (w - 20.0) / center_icons_numbers;
									control_image_size -= 4.0; //Padding.
									if (control_image_size > max_icon_size) control_image_size = max_icon_size;
									control_width = (control_image_size + 3.0) * center_icons_numbers + 6.0;
									if (control_image_size == max_icon_size)
									{
										indent = (w*0.5) - (control_width*0.5);
										if (indent < 10)
											indent = 10;
									}
								}
								else
								{
									indent = (w*0.5) - (control_width*0.5);
									if (indent < 10)
										indent = 10;
								}
								if (pref.iObjectEnableAdvanced == 2)
								{
									// smaller buttons dont need too much indent
									indent -= 10;
								}

								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, 4.0f));

								if (pref.iEnableDragDropEntityMode)
								{
									ImGui::Indent(indent);

									if (iObjectMoveMode == 2)
									{
										const ImRect image_bb((ImGui::GetCurrentWindow()->DC.CursorPos - padding), ImGui::GetCurrentWindow()->DC.CursorPos + padding + ImVec2(control_image_size, control_image_size));
										ImGui::GetCurrentWindow()->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
									}
									if (ImGui::ImgBtn(OBJECT_MOVE_SURFACESCAN, ImVec2(control_image_size, control_image_size), ImVec4(1.0, 1.0, 1.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors)) {
										iObjectMoveMode = 2;
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("Move object and optionally find surface and orientation");

									ImGui::SameLine();
									ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(icon_spacer, 0.0f));

									if (iObjectMoveMode == 0)
									{
										const ImRect image_bb((ImGui::GetCurrentWindow()->DC.CursorPos - padding), ImGui::GetCurrentWindow()->DC.CursorPos + padding + ImVec2(control_image_size, control_image_size));
										ImGui::GetCurrentWindow()->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
									}
									if (ImGui::ImgBtn(OBJECT_MOVE_XZ, ImVec2(control_image_size, control_image_size), ImVec4(1.0, 1.0, 1.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
									{
										iObjectMoveMode = 0;
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("Move object horizontally, keeping current Y coordinate");

									ImGui::SameLine();
									ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(icon_spacer, 0.0f));

									if (iObjectMoveMode == 1)
									{
										const ImRect image_bb((ImGui::GetCurrentWindow()->DC.CursorPos - padding), ImGui::GetCurrentWindow()->DC.CursorPos + padding + ImVec2(control_image_size, control_image_size));
										ImGui::GetCurrentWindow()->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
									}
									if (ImGui::ImgBtn(OBJECT_MOVE_Y, ImVec2(control_image_size, control_image_size), ImVec4(1.0, 1.0, 1.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors)) {
										iObjectMoveMode = 1;
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("Move object vertically, keeping current X and Z coordinates");

									#ifdef NEWOBJECTTOOLSLAYOUTV5
									// title for stack and lock buttons
									LPSTR pEditPositionTitle = "Stack, Orientation, Lock";
									if(pref.iObjectEnableAdvanced != 2) ImGui::TextCenter(pEditPositionTitle);

									// find center of buttons for second row (repeat code from above - urg)
									if (pref.iObjectEnableAdvanced == 2)
									{
										// tag second row ofr icons to end of first for compact choices
										ImGui::SameLine();
									}
									else
									{
										ImGui::Indent(-(indent));
										center_icons_numbers = 3.0f;
										control_width = (control_image_size + 3.0) * center_icons_numbers + 6.0;
										if (w > control_width)
										{
											control_image_size = (w - 20.0) / center_icons_numbers;
											control_image_size -= 4.0;
											if (control_image_size > max_icon_size) control_image_size = max_icon_size;
											control_width = (control_image_size + 3.0) * center_icons_numbers + 6.0;
											if (control_image_size == max_icon_size)
											{
												indent = (w*0.5) - (control_width*0.5);
												if (indent < 10)
													indent = 10;
											}
										}
										else
										{
											indent = (w*0.5) - (control_width*0.5);
											if (indent < 10)
												indent = 10;
										}
										ImGui::Indent(indent);
									}

									// decide button colors
									ImVec4 buttonColor = ImVec4(1.0, 1.0, 1.0, 1.0);
									ImVec4 hoverColor = ImVec4(0.8, 0.8, 0.8, 0.8);
									if (iObjectMoveMode == 2)
									{
										if (g_iStackToSurfaceMode == 1)
										{
											const ImRect image_bb((ImGui::GetCurrentWindow()->DC.CursorPos - padding), ImGui::GetCurrentWindow()->DC.CursorPos + padding + ImVec2(control_image_size, control_image_size));
											ImGui::GetCurrentWindow()->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
										}
									}
									else
									{
										buttonColor = ImVec4(0.5, 0.5, 0.5, 0.5);
										hoverColor = ImVec4(0.5, 0.5, 0.5, 0.5);
									}

									if (ImGui::ImgBtn(OBJECT_MOVE_FINDFLOOR, ImVec2(control_image_size, control_image_size), ImVec4(1.0, 1.0, 1.0, 0.0), buttonColor, hoverColor, ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
									{
										if (iObjectMoveMode == 2)
										{
											g_iStackToSurfaceMode = 1 - g_iStackToSurfaceMode;
										}
									}
									if (ImGui::IsItemHovered())
									{
										ImGui::SetTooltip("Find a position beneath or above the object to stack it");
									}

									ImGui::SameLine();
									ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(icon_spacer, 0.0f));

									buttonColor = ImVec4(1.0, 1.0, 1.0, 1.0);
									hoverColor = ImVec4(0.8, 0.8, 0.8, 0.8);
									if (iObjectMoveMode == 2 && g_iStackToSurfaceMode == 1)
									{
										if (g_iOrientToSurfaceMode == 1)
										{
											const ImRect image_bb((ImGui::GetCurrentWindow()->DC.CursorPos - padding), ImGui::GetCurrentWindow()->DC.CursorPos + padding + ImVec2(control_image_size, control_image_size));
											ImGui::GetCurrentWindow()->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
										}
									}
									else
									{
										buttonColor = ImVec4(0.5, 0.5, 0.5, 0.5);
										hoverColor = ImVec4(0.5, 0.5, 0.5, 0.5);
									}
									if (ImGui::ImgBtn(OBJECT_MOVE_ORIENTATION, ImVec2(control_image_size, control_image_size), ImVec4(1.0, 1.0, 1.0, 0.0), buttonColor, hoverColor, ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
									{
										if (iObjectMoveMode == 2 && g_iStackToSurfaceMode == 1)
										{
											// toggle orientation mode
											g_iOrientToSurfaceMode = 1 - g_iOrientToSurfaceMode;
										}
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("Orient object inline with angle of any surface we stack onto");
									#endif

									ImGui::SameLine();
									ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(icon_spacer, 0.0f));

									//OBJECT_MOVE_LOCK
									int iIcon = OBJECT_MOVE_LOCK;
									if (g.entityrubberbandlist.size() == 0 && iEntityIndex > 0 && t.entityelement[iEntityIndex].editorlock == 1) iIcon = OBJECT_MOVE_UNLOCK;
									if (iIcon == OBJECT_MOVE_UNLOCK)
									{
										const ImRect image_bb((ImGui::GetCurrentWindow()->DC.CursorPos - padding), ImGui::GetCurrentWindow()->DC.CursorPos + padding + ImVec2(control_image_size, control_image_size));
										ImGui::GetCurrentWindow()->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
									}
									if (g.entityrubberbandlist.size() > 0)
									{
										bool bAllLocked = true;
										for (int i = 0; i < g.entityrubberbandlist.size(); i++)
										{
											int e = g.entityrubberbandlist[i].e;
											if (e > 0)
											{
												if (t.entityelement[e].editorlock == 0)
												{
													bAllLocked = false;
													break;
												}
											}
										}
										if (iEntityIndex > 0 && t.entityelement[iEntityIndex].editorlock == 0)
											bAllLocked = false;
										if (bAllLocked)
											iIcon = OBJECT_MOVE_UNLOCK;
									}
									if (ImGui::ImgBtn(iIcon, ImVec2(control_image_size, control_image_size), ImVec4(1.0, 1.0, 1.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
									{
										// entity lock/unlock
										bClickedTheLockUnlockButton = true;
									}
									if (ImGui::IsItemHovered())
									{
										if (iIcon == OBJECT_MOVE_UNLOCK)
										{
											if (g.entityrubberbandlist.size() == 0)
												ImGui::SetTooltip("Unlock object to allow it to be moved again");
											else
												ImGui::SetTooltip("Unlock all objects to allow them to be moved again");
										}
										else
										{
											if (g.entityrubberbandlist.size() == 0)
												ImGui::SetTooltip("Lock object to prevent it from being moved");
											else
												ImGui::SetTooltip("Lock all objects to prevent them from being moved");
										}
									}

									ImGui::Indent(-(indent));
								}
								bObjectAllowOverlapping = 1;
							}
							else
							{
								// lock/unlock code repeated above too for non-widget version
								if (pref.iEnableDragDropEntityMode && pref.iObjectEnableAdvanced != 2)
								{
									// is locked or unlocked
									int iIcon = OBJECT_MOVE_LOCK;
									if (g.entityrubberbandlist.size() == 0 && iEntityIndex > 0 && t.entityelement[iEntityIndex].editorlock == 1) iIcon = OBJECT_MOVE_UNLOCK;
									if (g.entityrubberbandlist.size() > 0)
									{
										bool bAllLocked = true;
										for (int i = 0; i < g.entityrubberbandlist.size(); i++)
										{
											int e = g.entityrubberbandlist[i].e;
											if (e > 0)
											{
												if (t.entityelement[e].editorlock == 0)
												{
													bAllLocked = false;
													break;
												}
											}
										}
										if (iEntityIndex > 0 && t.entityelement[iEntityIndex].editorlock == 0) bAllLocked = false;
										if (bAllLocked) iIcon = OBJECT_MOVE_UNLOCK;
									}

									// show lock and unlock button
									ImGui::Indent(10);
									float fFontSize = ImGui::GetFontSize();
									float fButtonSize = w / 3;
									ImGui::PushItemWidth(fButtonSize);
									LPSTR pLockUnlockTitle = "Lock Object";
									if (g.entityrubberbandlist.size() > 0)
									{
										pLockUnlockTitle = "Lock Objects";
										if (iIcon == OBJECT_MOVE_UNLOCK) pLockUnlockTitle = "Unlock Objects";
									}
									else
									{
										if (iIcon == OBJECT_MOVE_UNLOCK) pLockUnlockTitle = "Unlock Object";
									}

									int control_image_size = 56;
									ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w * 0.5) - (control_image_size * 0.5) + 7.0f , 4.0f));
									if (ImGui::ImgBtn(iIcon, ImVec2(control_image_size, control_image_size), ImVec4(1.0, 1.0, 1.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
									{
										// entity lock/unlock
										bClickedTheLockUnlockButton = true;
									}
									if (ImGui::IsItemHovered())
									{
										if (iIcon == OBJECT_MOVE_UNLOCK)
										{
											if (g.entityrubberbandlist.size() == 0)
												ImGui::SetTooltip("Unlock object to allow it to be moved again");
											else
												ImGui::SetTooltip("Unlock all objects to allow them to be moved again");
										}
										else
										{
											if (g.entityrubberbandlist.size() == 0)
												ImGui::SetTooltip("Lock object to prevent it from being moved");
											else
												ImGui::SetTooltip("Lock all objects to prevent them from being moved");
										}
									}
									ImGui::PopItemWidth();
									ImGui::Indent(-10);
								}
							}

							if (bReadOnlyMode)
							{
								//PE: Disable ALL gadgets and moving/rotation/scaling.
								ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
								ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
							}

							// input field size
							float inputsize = w / 3.0f;
							inputsize -= 10.0f; //For text.
							inputsize -= 5.0f; //For padding.

							ImVec2 vStorePos = ImGui::GetCursorPos();

							if (pref.iObjectEnableAdvanced || !pref.iEnableDragDropEntityMode)
							{
								if(pref.iObjectEnableAdvanced != 2) ImGui::TextCenter("Position");

								// X Y Z layout
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(8.0f, 3.0f));
								ImGui::Text("PX");
								ImGui::SameLine();
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, -3.0f));
								ImGui::PushItemWidth(inputsize - ImGui::GetFontSize());
								if (ImGui::InputFloat("##XYZpositionX", &fPos[0], 0.0f, 0.0f, "%.1f")) 	bUpdatePosition = true;
								if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Object Position X");
								ImGui::PopItemWidth();
								ImGui::SameLine();
								ImGui::Text("PY");
								ImGui::SameLine();
								ImGui::PushItemWidth(inputsize - ImGui::GetFontSize());
								if (ImGui::InputFloat("##XYZpositionY", &fPos[1], 0.0f, 0.0f, "%.1f")) 	bUpdatePosition = true;
								if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Object Position Y");
								ImGui::PopItemWidth();
								ImGui::SameLine();
								ImGui::Text("PZ");
								ImGui::SameLine();
								ImGui::PushItemWidth(inputsize - ImGui::GetFontSize());
								if (ImGui::InputFloat("##XYZpositionZ", &fPos[2], 0.0f, 0.0f, "%.1f")) 	bUpdatePosition = true;
								if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Object Position Z");
								ImGui::PopItemWidth();
							}

							if (bReadOnlyMode)
							{
								ImGui::PopItemFlag();
								ImGui::PopStyleVar();
							}

							if (bReadOnlyMode)
							{
								//PE: Disable ALL gadgets and moving/rotation/scaling.
								ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
								ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
							}

							// rotation stuff
							if (fAngle[0] > 360.0) fAngle[0] -= 360.0f;
							if (fAngle[0] < 0.0) fAngle[0] += 360.0f;
							if (fAngle[1] > 360.0) fAngle[1] -= 360.0f;
							if (fAngle[1] < 0.0) fAngle[1] += 360.0f;
							if (fAngle[2] > 360.0) fAngle[2] -= 360.0f;
							if (fAngle[2] < 0.0) fAngle[2] += 360.0f;

							bool bIsStartMarker = false;
							// Player start marker should still allow Y-axis rotations
							if (t.entityprofile[t.entityelement[t.ttte].bankindex].ismarker == 1)
								bIsStartMarker = true;

							if (!bToolRotation && !bIsStartMarker)
							{
								ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
								ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);		
							}
							if (pref.iObjectEnableAdvanced == 2)
							{
								// compact rotation layout
								bool bChangeYAngleOnly = false;
								if (g.entityrubberbandlist.size() > 0 || iEntityInGroupList >= 0) bChangeYAngleOnly = true;
								if (t.entityprofile[t.entityelement[t.ttte].bankindex].ischaracter || bIsStartMarker) bChangeYAngleOnly = true;

								// X Y Z layout
								if (bChangeYAngleOnly == true)
								{
									ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
									ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
								}
								ImGui::SetCursorPos(ImVec2(vStorePos.x, ImGui::GetCursorPos().y) + ImVec2(8.0f, 3.0f));
								ImGui::Text("RX");
								ImGui::SameLine();
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, -3.0f));
								ImGui::PushItemWidth(inputsize - ImGui::GetFontSize());
								if (bChangeYAngleOnly == true)
								{
									float fZero = 0.0f;
									ImGui::InputFloat("##Xrotation", &fZero, 0.0f, 0.0f, "%.1f");
								}
								else
								{
									if (ImGui::InputFloat("##Xrotation", &fAngle[0], 0.0f, 0.0f, "%.1f")) 	bUpdateRoataion = true;
								}
								if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Object Rotation X");
								ImGui::PopItemWidth();
								ImGui::SameLine();
								if (bChangeYAngleOnly == true)
								{
									ImGui::PopItemFlag();
									ImGui::PopStyleVar();
								}
								ImGui::Text("RY");
								ImGui::SameLine();
								ImGui::PushItemWidth(inputsize - ImGui::GetFontSize());
								if (ImGui::InputFloat("##Yrotation", &fAngle[1], 0.0f, 0.0f, "%.1f")) 	bUpdateRoataion = true;
								if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Object Rotation Y");
								ImGui::PopItemWidth();
								ImGui::SameLine();
								if (bChangeYAngleOnly == true)
								{
									ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
									ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
								}
								ImGui::Text("RZ");
								ImGui::SameLine();
								ImGui::PushItemWidth(inputsize - ImGui::GetFontSize());
								if (bChangeYAngleOnly == true)
								{
									float fZero = 0.0f;
									ImGui::InputFloat("##Zrotation", &fZero, 0.0f, 0.0f, "%.1f");
								}
								else
								{
									if (ImGui::InputFloat("##Zrotation", &fAngle[2], 0.0f, 0.0f, "%.1f")) 	bUpdateRoataion = true;
								}
								if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Object Rotation Z");
								ImGui::PopItemWidth();
								if (bChangeYAngleOnly == true)
								{
									ImGui::PopItemFlag();
									ImGui::PopStyleVar();
								}
							}
							else
							{
								ImGui::Indent(10);
								if (g.entityrubberbandlist.size() > 0 || iEntityInGroupList >= 0)
								{
									ImGui::TextCenter("Rotation Angle Y");
									if (ImGui::MaxSliderInputFloat("##Yrotation", &fAngle[1], 0.0f, 360.0f, "Adjust Object Rotation Y", 0, 360)) bUpdateRoataion = true;
								}
								else
								{
									ImGui::TextCenter("Rotation Angle Y");
									if (ImGui::MaxSliderInputFloat("##Yrotation", &fAngle[1], 0.0f, 360.0f, "Adjust Object Rotation Y", 0, 360)) bUpdateRoataion = true;
									if (t.entityprofile[t.entityelement[t.ttte].bankindex].ischaracter || bIsStartMarker)
									{
										ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
										ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
									}
									if (pref.iObjectEnableAdvanced)
									{
										ImGui::TextCenter("Rotation Angle X");
										if (ImGui::MaxSliderInputFloat("##Xrotation", &fAngle[0], 0.0f, 360.0f, "Adjust Object Rotation X", 0, 360)) bUpdateRoataion = true;
										bool bIsLight = false;
										if (!bIsLight)
										{
											ImGui::TextCenter("Rotation Angle Z");
											if (ImGui::MaxSliderInputFloat("##Zrotation", &fAngle[2], 0.0f, 360.0f, "Adjust Object Rotation Z", 0, 360)) bUpdateRoataion = true;
										}
									}
									if (t.entityprofile[t.entityelement[t.ttte].bankindex].ischaracter || bIsStartMarker)
									{
										ImGui::PopItemFlag();
										ImGui::PopStyleVar();
									}
								}
							}
							if (!bToolRotation && !bIsStartMarker)
							{
								ImGui::PopItemFlag();
								ImGui::PopStyleVar();
							}

							#ifdef WICKEDENGINE
							static std::vector<std::array<float, 3>> startRotations;
							static std::vector<std::array<int, 1>> startQuatRotationMode;
							static std::vector<std::array<float, 4>> startQuatRotations;
							static std::vector <std::array<float, 3>> startPositions;
							static bool bStartedRotationUpdate = false;

							if (bUpdateRoataion && ImGui::GetIO().MouseClicked[0])
							{
								// Store initial rotations before any have been applied.
								bStartedRotationUpdate = true;
								if (g.entityrubberbandlist.size() == 0)
								{
									std::array<float, 3> prevRotation = { t.entityelement[t.ttte].rx, t.entityelement[t.ttte].ry, t.entityelement[t.ttte].rz };
									startRotations.push_back(prevRotation);
									std::array<float, 4> prevQuatRotation = { t.entityelement[t.ttte].quatx, t.entityelement[t.ttte].quaty, t.entityelement[t.ttte].quatz, t.entityelement[t.ttte].quatw };
									startQuatRotations.push_back(prevQuatRotation);
									std::array<int, 1> prevQuatRotationMode = { t.entityelement[t.ttte].quatmode };
									startQuatRotationMode.push_back(prevQuatRotationMode);
								}
								else
								{
									for (int i = 0; i < g.entityrubberbandlist.size(); i++)
									{
										int e = g.entityrubberbandlist[i].e;
										std::array<float, 3> prevRotation = { t.entityelement[e].rx, t.entityelement[e].ry, t.entityelement[e].rz };
										startRotations.push_back(prevRotation);
										std::array<float, 4> prevQuatRotation = { t.entityelement[e].quatx, t.entityelement[e].quaty, t.entityelement[e].quatz, t.entityelement[e].quatw };
										startQuatRotations.push_back(prevQuatRotation);
										std::array<int, 1> prevQuatRotationMode = { t.entityelement[e].quatmode };
										startQuatRotationMode.push_back(prevQuatRotationMode);
										// Need to store positions for rubberband, since they rotate about a point. 
										std::array<float, 3> prevPosition = { t.entityelement[e].x, t.entityelement[e].y, t.entityelement[e].z };
										startPositions.push_back(prevPosition);
									}
								}				
							}

							if (bStartedRotationUpdate && ImGui::GetIO().MouseReleased[0])
							{
								// Pass the initial rotations to the undo system.
								if (g.entityrubberbandlist.size() == 0)
								{
									undosys_object_changeposrotscl(t.ttte, t.entityelement[t.ttte].x, t.entityelement[t.ttte].y, t.entityelement[t.ttte].z, 
										startRotations[0][0], startRotations[0][1], startRotations[0][2], 
										startQuatRotationMode[0][0], startQuatRotations[0][0], startQuatRotations[0][1], startQuatRotations[0][2], startQuatRotations[0][3],
										t.entityelement[t.ttte].scalex,	t.entityelement[t.ttte].scaley, t.entityelement[t.ttte].scalez);
								}
								else
								{
									undosys_multiplevents_start();
									for (int i = 0; i < startPositions.size(); i++)
									{
										int e = g.entityrubberbandlist[i].e;
										undosys_object_changeposrotscl(e, startPositions[i][0], startPositions[i][1], startPositions[i][2], 
											startRotations[i][0], startRotations[i][1], startRotations[i][2],
											startQuatRotationMode[i][0], startQuatRotations[i][0], startQuatRotations[i][1], startQuatRotations[i][2], startQuatRotations[i][3],
											t.entityelement[e].scalex, t.entityelement[e].scaley, t.entityelement[e].scalez);
									}
									undosys_multiplevents_finish();
								}

								bStartedRotationUpdate = false;

								startRotations.clear();
								startPositions.clear();
							}
							#endif

							if (bReadOnlyMode)
							{
								ImGui::PopItemFlag();
								ImGui::PopStyleVar();
							}

							if (bReadOnlyMode)
							{
								//PE: Disable ALL gadgets and moving/rotation/scaling.
								ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
								ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
							}

							ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, 4.0f));

							// scale stuff
							float fImporterScaleMultiply = 1.0f;//GetScaleMultiply(iActiveObj);
							fScale[0] = ObjectScaleX(iActiveObj);
							fScale[1] = ObjectScaleY(iActiveObj);
							fScale[2] = ObjectScaleZ(iActiveObj);

							// store old active object scales for rubber band
							if (g_bRefreshScaleValuesFromObjectOnce)
							{
								bUpdateScale = true;
								g_bRefreshScaleValuesFromObjectOnce = false;
							}
							fOldActiveObjectSX = ObjectScaleX(iActiveObj);
							fOldActiveObjectSY = ObjectScaleY(iActiveObj);
							fOldActiveObjectSZ = ObjectScaleZ(iActiveObj);

							if (!bToolScale)
							{
								ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
								ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
							}

							// Disable advanced scaling options for particles
							bool enableSettings = true;
							if (t.ttte > 0)
							{
								int entid = t.entityelement[t.ttte].bankindex;
								if (entid > 0)
								{
									if (t.entityprofile[entid].ismarker == 10)
									{
										enableSettings = false; 
									}
								}
							}

							if (pref.iObjectEnableAdvanced == 2)
							{
								// compact scale layout
								// X Y Z layout
								ImGui::SetCursorPos(ImVec2(vStorePos.x, ImGui::GetCursorPos().y) + ImVec2(8.0f, 3.0f));
								ImGui::Text("SX");
								ImGui::SameLine();
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, -3.0f));
								ImGui::PushItemWidth(inputsize - ImGui::GetFontSize());
								bool bChangedAScaleValue = false;
								if (ImGui::InputFloat("##Xscale", &fScale[0], 0.0f, 0.0f, "%.1f")) 	bChangedAScaleValue = true;
								if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Object Scale X");
								ImGui::PopItemWidth();
								ImGui::SameLine();
								ImGui::Text("SY");
								ImGui::SameLine();
								ImGui::PushItemWidth(inputsize - ImGui::GetFontSize());
								if (ImGui::InputFloat("##Yscale", &fScale[1], 0.0f, 0.0f, "%.1f")) 	bChangedAScaleValue = true;
								if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Object Scale Y");
								ImGui::PopItemWidth();
								ImGui::SameLine();
								ImGui::Text("SZ");
								ImGui::SameLine();
								ImGui::PushItemWidth(inputsize - ImGui::GetFontSize());
								if (ImGui::InputFloat("##Zscale", &fScale[2], 0.0f, 0.0f, "%.1f")) 	bChangedAScaleValue = true;
								if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Object Scale Z");
								ImGui::PopItemWidth();
								if (bChangedAScaleValue == true)
								{
									ScaleObject(iActiveObj, fScale[0], fScale[1], fScale[2]);
									fScaleOrg[0] = ObjectScaleX(iActiveObj);
									fScaleOrg[1] = ObjectScaleY(iActiveObj);
									fScaleOrg[2] = ObjectScaleZ(iActiveObj);
									fScaleMul = 0.0f;
									if (t.ttte > 0)
									{
										bUpdateScale = true;
									}
								}

								ImGui::Indent(10);
							}
							else
							{
								ImGui::PushItemWidth(fPushItemWidth);
								ImGui::TextCenter("Scale Multiplier Percentage");
								if (ImGui::MaxSliderInputFloat("##EntityScaleAll", &fScaleMul, 0.0f, 1000.0f, "Use this slider to multiply or divide the scale on all three axis", 0, 1000))
								{
									float fSm = fScaleMul / 100.0f;
									ScaleObject(iActiveObj, fScaleOrg[0] * fSm, fScaleOrg[1] * fSm, fScaleOrg[2] * fSm);
									if (t.ttte > 0)
									{
										bUpdateScale = true;
									}
								}
								if (pref.iObjectEnableAdvanced)
								{
									if (enableSettings)
									{
										ImGui::TextCenter("Scale X");
										if (ImGui::MaxSliderInputFloat("##XScaleOnly", &fScale[0], 0.0f, 1000.0f, "Scale X axis only", 0, 1000))
										{
											ScaleObject(iActiveObj, fScale[0], fScale[1], fScale[2]);
											//Need to update org.
											fScaleOrg[0] = ObjectScaleX(iActiveObj);
											fScaleOrg[1] = ObjectScaleY(iActiveObj);
											fScaleOrg[2] = ObjectScaleZ(iActiveObj);
											fScaleMul = 0.0f;
											if (t.ttte > 0)
											{
												bUpdateScale = true;
											}
										}
										ImGui::TextCenter("Scale Y");
										if (ImGui::MaxSliderInputFloat("##YScaleOnly", &fScale[1], 0.0f, 1000.0f, "Scale Y axis only", 0, 1000))
										{
											ScaleObject(iActiveObj, fScale[0], fScale[1], fScale[2]);
											//Need to update org.
											fScaleOrg[0] = ObjectScaleX(iActiveObj);
											fScaleOrg[1] = ObjectScaleY(iActiveObj);
											fScaleOrg[2] = ObjectScaleZ(iActiveObj);
											fScaleMul = 0.0f;
											if (t.ttte > 0)
											{
												bUpdateScale = true;
											}
										}
										ImGui::TextCenter("Scale Z");
										if (ImGui::MaxSliderInputFloat("##ZScaleOnly", &fScale[2], 0.0f, 1000.0f, "Scale Z axis only", 0, 1000))
										{
											ScaleObject(iActiveObj, fScale[0], fScale[1], fScale[2]);
											//Need to update org.
											fScaleOrg[0] = ObjectScaleX(iActiveObj);
											fScaleOrg[1] = ObjectScaleY(iActiveObj);
											fScaleOrg[2] = ObjectScaleZ(iActiveObj);
											fScaleMul = 0.0f;
											if (t.ttte > 0)
											{
												bUpdateScale = true;
											}
										}
									}
								}
								ImGui::PopItemWidth();
							}
							if (!bToolScale)
							{
								ImGui::PopItemFlag();
								ImGui::PopStyleVar();
							}

							if (bReadOnlyMode)
							{
								ImGui::PopItemFlag();
								ImGui::PopStyleVar();
							}

							// random spray object mode
							ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, 4.0f));
							ImGui::PushItemWidth(fPushItemWidth);
							bool bSpray = t.gridedit.entityspraymode;
							if (ImGui::Checkbox("Randomly Spray Objects", &bSpray))
							{
							}
							t.gridedit.entityspraymode = bSpray;
							if (t.gridedit.entityspraymode)
							{
								ImGui::TextCenter("Spray Radius");
								if (ImGui::MaxSliderInputInt("##SetSpray Radius", &t.gridedit.entitysprayrange, 30, 1000, "Set Spray Radius"))
								{
									iDisplayCircleFrames = 20;
								}
							}
							ImGui::PopItemWidth();
							static bool bOldSprayMode = t.gridedit.entityspraymode;//t.gridedit.entitysprayrange 50-1000
							static uint32_t oldflag = 0;
							static float oldbrushSize = 0;

							if (t.gridedit.entityspraymode)
							{
								if (bOldSprayMode != t.gridedit.entityspraymode)
								{
									oldflag = ggterrain_global_render_params2.flags2;
									oldbrushSize = ggterrain_global_render_params2.brushSize;
									bOldSprayMode = t.gridedit.entityspraymode;
								}
								void set_terrain_sculpt_mode(int mode);
								void set_terrain_edit_mode(int mode);
								set_terrain_sculpt_mode(0);
								set_terrain_edit_mode(0);
								ggterrain_global_render_params2.flags2 |= GGTERRAIN_SHADER_FLAG2_SHOW_BRUSH_SIZE;
								ggterrain_global_render_params2.brushSize = (float)t.gridedit.entitysprayrange * 1.5f; //PE: A bit larger.
							}
							else
							{
								if (bOldSprayMode != t.gridedit.entityspraymode)
								{
									if (oldflag != 0) ggterrain_global_render_params2.flags2 = oldflag;
									if (oldbrushSize != 0) ggterrain_global_render_params2.brushSize = oldbrushSize;
									bOldSprayMode = t.gridedit.entityspraymode;
								}
							}

							// advanced toggle
							if (pref.iObjectEnableAdvanced != 2)
							{
								ControlAdvancedSetting(pref.iObjectEnableAdvanced, "Advanced Object Tools");
							}

							ImGui::PopStyleColor();
							ImGui::Indent(-10);

							// When the object is locked, a child window is created so a tooltip can display even when the items are disabled.
							//if (bReadOnlyMode)
							//{
								//ImGui::EndChild();
								//bReadOnlyMode = false;
							//}

							// update any position, rotation or scale changes
							if (!bReadOnlyMode && bUpdatePosition == true)
							{
								// work out difference for rubber band positioning
								float fOldActiveObjectX = ObjectPositionX(iActiveObj);
								float fOldActiveObjectY = ObjectPositionY(iActiveObj);
								float fOldActiveObjectZ = ObjectPositionZ(iActiveObj);
								if (iEntityInGroupList >= 0)
								{
									//Add all groups with entity to rubberband.
									CheckGroupListForRubberbandSelections(t.ttte);
								}
								else if (g.entityrubberbandlist.size() > 0)
								{
									//Make sure all groups is selected from within rubberband selecting.
									for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
									{
										int e = g.entityrubberbandlist[i].e;
										CheckGroupListForRubberbandSelections(e);
									}
								}

								// move the target entity
								PositionObject(iActiveObj, fPos[0], fPos[1], fPos[2]);
								t.entityelement[t.ttte].x = ObjectPositionX(iActiveObj);
								t.entityelement[t.ttte].y = ObjectPositionY(iActiveObj);
								t.entityelement[t.ttte].z = ObjectPositionZ(iActiveObj);

								// if we need to also move rubber band highlighted objects, do so now
								if (g.entityrubberbandlist.size() > 0)
								{
									float fMovedActiveObjectX = ObjectPositionX(iActiveObj) - fOldActiveObjectX;
									float fMovedActiveObjectY = ObjectPositionY(iActiveObj) - fOldActiveObjectY;
									float fMovedActiveObjectZ = ObjectPositionZ(iActiveObj) - fOldActiveObjectZ;
									for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
									{
										int e = g.entityrubberbandlist[i].e;
										int tobj = t.entityelement[e].obj;
										if (tobj > 0 && t.entityelement[e].editorlock == 0)
										{
											if (ObjectExist(tobj) == 1)
											{
												if (tobj != iActiveObj)
												{
													// reposition this entity
													PositionObject(tobj, ObjectPositionX(tobj) + fMovedActiveObjectX, ObjectPositionY(tobj) + fMovedActiveObjectY, ObjectPositionZ(tobj) + fMovedActiveObjectZ);
													t.entityelement[e].x = ObjectPositionX(tobj);
													t.entityelement[e].y = ObjectPositionY(tobj);
													t.entityelement[e].z = ObjectPositionZ(tobj);
													if (t.entityelement[e].staticflag == 1) g.projectmodifiedstatic = 1;
													widget_movezonesandlights(e);
												}
											}
										}
									}
								}
							}
							if (!bReadOnlyMode && bUpdateRoataion)
							{
								if (iEntityInGroupList >= 0)
								{
									//Add all groups with entity to rubberband.
									CheckGroupListForRubberbandSelections(t.ttte);
								}
								else if (g.entityrubberbandlist.size() > 0)
								{
									//Make sure all groups is selected from within rubberband selecting.
									for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
									{
										int e = g.entityrubberbandlist[i].e;
										CheckGroupListForRubberbandSelections(e);
									}
								}

								// rotate the target entity now (one way euler values)
								int iObj = iActiveObj;
								if (ObjectExist(iObj) == 1)
								{
									// rotation event
									float fMoveAngleX = fAngle[0] - fOldAngle[0];
									float fMoveAngleY = fAngle[1] - fOldAngle[1];
									float fMoveAngleZ = fAngle[2] - fOldAngle[2];
									fOldAngle[0] = fAngle[0];
									fOldAngle[1] = fAngle[1];
									fOldAngle[2] = fAngle[2];
									GGQUATERNION quatRotationEvent, QuatAroundX, QuatAroundY, QuatAroundZ;
									GGQuaternionRotationAxis(&QuatAroundX, &GGVECTOR3(1, 0, 0), GGToRadian(fMoveAngleX));
									GGQuaternionRotationAxis(&QuatAroundY, &GGVECTOR3(0, 1, 0), GGToRadian(fMoveAngleY));
									GGQuaternionRotationAxis(&QuatAroundZ, &GGVECTOR3(0, 0, 1), GGToRadian(fMoveAngleZ));
									quatRotationEvent = QuatAroundX * QuatAroundY * QuatAroundZ;

									// current orientation from eulers
									// fundamentally, sliders and values for X Y Z and EULER, so can only set them this way!
									if (g.entityrubberbandlist.size() > 0)
									{
										// when object part of selected, use quat and only use "Y" value as a movement delta via rotation event
										GGQUATERNION QuatAroundX, QuatAroundY, QuatAroundZ;
										GGQuaternionRotationAxis(&QuatAroundX, &GGVECTOR3(1, 0, 0), GGToRadian(ObjectAngleX(iObj)));
										GGQuaternionRotationAxis(&QuatAroundY, &GGVECTOR3(0, 1, 0), GGToRadian(ObjectAngleY(iObj)));
										GGQuaternionRotationAxis(&QuatAroundZ, &GGVECTOR3(0, 0, 1), GGToRadian(ObjectAngleZ(iObj)));
										GGQUATERNION quatCurrentOrientation;
										quatCurrentOrientation = QuatAroundX * QuatAroundY * QuatAroundZ;
										GGQUATERNION quatNewOrientation;
										GGQuaternionMultiply(&quatNewOrientation, &quatCurrentOrientation, &quatRotationEvent);
										RotateObjectQuat(iObj, quatNewOrientation.x, quatNewOrientation.y, quatNewOrientation.z, quatNewOrientation.w);
										// and also rotate the selected!
										SetStartPositionsForRubberBand(iObj);
										RotateAndMoveRubberBand(iObj, 0, 0, 0, quatRotationEvent);
									}
									else
									{
										// when single object, treat as euler X Y Z 
										RotateObject(iObj, fAngle[0], fAngle[1], fAngle[2]);
										if (t.ttte > 0)
										{
											t.entityelement[t.ttte].rx = ObjectAngleX(iActiveObj);
											t.entityelement[t.ttte].ry = ObjectAngleY(iActiveObj);
											t.entityelement[t.ttte].rz = ObjectAngleZ(iActiveObj);
										}
									}

									// update entity quat as the preferred source rotation
									entity_updatequatfromeuler(t.ttte);
								}
							}
							if (!bReadOnlyMode && bUpdateScale == true)
							{
								// scale the target entity
								t.entityelement[t.ttte].scalex = ObjectScaleX(iActiveObj) - 100.0;
								t.entityelement[t.ttte].scaley = ObjectScaleY(iActiveObj) - 100.0;
								t.entityelement[t.ttte].scalez = ObjectScaleZ(iActiveObj) - 100.0;

								if (iEntityInGroupList >= 0)
								{
									//Add all groups with entity to rubberband.
									CheckGroupListForRubberbandSelections(t.ttte);
								}
								else if (g.entityrubberbandlist.size() > 0)
								{
									//Make sure all groups is selected from within rubberband selecting.
									for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
									{
										int e = g.entityrubberbandlist[i].e;
										CheckGroupListForRubberbandSelections(e);
									}
								}

								// if we need to also scale rubber band highlighted objects, do so now
								if (g.entityrubberbandlist.size() > 0)
								{
									float fMovedActiveObjectSX = ObjectScaleX(iActiveObj) - fOldActiveObjectSX;
									float fMovedActiveObjectSY = ObjectScaleY(iActiveObj) - fOldActiveObjectSY;
									float fMovedActiveObjectSZ = ObjectScaleZ(iActiveObj) - fOldActiveObjectSZ;
									for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
									{
										int e = g.entityrubberbandlist[i].e;
										int tobj = t.entityelement[e].obj;
										if (tobj > 0 && t.entityelement[e].editorlock == 0)
										{
											if (ObjectExist(tobj) == 1)
											{
												if (tobj != iActiveObj)
												{
													//LB: oops! if (t.entityprofile[e].ischaracter == 0 && t.entityprofile[e].ismarker == 0)
													int entid = t.entityelement[e].bankindex;
													if (entid > 0)
													{
														if (t.entityprofile[entid].ischaracter == 0 && t.entityprofile[entid].ismarker == 0)
														{
															ScaleObject(tobj, ObjectScaleX(tobj) + fMovedActiveObjectSX, ObjectScaleY(tobj) + fMovedActiveObjectSY, ObjectScaleZ(tobj) + fMovedActiveObjectSZ);
															t.entityelement[e].scalex = ObjectScaleX(tobj) - 100;
															t.entityelement[e].scaley = ObjectScaleY(tobj) - 100;
															t.entityelement[e].scalez = ObjectScaleZ(tobj) - 100;
															if (t.entityelement[e].staticflag == 1) g.projectmodifiedstatic = 1;
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}

					// GRID SETTINGS WAS HERE ON 27/04/22!

					#ifdef PEWORKINGONPROPERTIES
					//#############################
					//#### PE: New properties. ####
					//#############################

					if (iEntityIndex > 0 && iMasterID > 0 && ObjectExist(iActiveObj))
					{		
						#ifdef WICKEDENGINE
						bool bGeneralActive = false;
						if ((t.entityprofile[iMasterID].ismarker == 0 /*|| t.entityprofile[iMasterID].islightmarker == 1 */ || t.tflagspawn == 1))
							bGeneralActive = true;
						if (t.tflagchar == 0 && t.tflagvis == 1 && t.tflagsimpler == 0)
							bGeneralActive = true;

						if (bGeneralActive)
						{
							char title[24] = "General##2";
							if (t.entityprofile[iMasterID].ischaracter == 1)
								strcpy(title, "Character Settings##2");

							if (pref.bAutoClosePropertySections && iLastOpenHeader != 17)
								ImGui::SetNextItemOpen(false, ImGuiCond_Always);

							if (ImGui::StyleCollapsingHeader(title, ImGuiTreeNodeFlags_None)) //ImGuiTreeNodeFlags_DefaultOpen
							{
								iLastOpenHeader = 17;
								DisplayFPEGeneral(false, iMasterID, &t.entityelement[iEntityIndex].eleprof, iEntityIndex);
							}
						}
						#endif

						bool bMaterialsUsed = true;
						cStr HeaderName = "Behavior##2";
						if (t.entityprofile[iMasterID].ismarker == 1)
						{
							HeaderName = "Customize##2";
						}
						if (t.tflaglight == 1 || t.entityprofile[iMasterID].ismarker == 2)
						{
							HeaderName = "Color Palette##2";
						}
						if (t.entityprofile[iMasterID].ismarker == 10)
						{
							HeaderName = "Particles##2";
							bMaterialsUsed = false;
						}
						if (t.entityprofile[iMasterID].bIsDecal)
						{
							HeaderName = "Decal##99";
						}

						bool bAllowBehaviorChange = true;
						bool bIsThisAnEBE = false;
						if (t.entityprofile[iMasterID].isebe != 0 && t.widget.pickedEntityIndex > 0)
						{
							HeaderName = "Structure Editor Object##99";
							bIsThisAnEBE = true;
						}
						else
						{
							if (t.entityprofile[iMasterID].ismarker == 0)
							{
								if (t.entityelement[iEntityIndex].staticflag != 0)
								{
									// cannot change behavior of a static object!
									bAllowBehaviorChange = false;
								}
							}
						}

						// rubber band awareness
						bool bRubberbandActive = false;
						if (g.entityrubberbandlist.size() > 0) bRubberbandActive = true;
						if (g.entityrubberbandlist.size() == 1 && g.entityrubberbandlist[0].e == iEntityIndex) bRubberbandActive = false;
						if (!bRubberbandActive )
						{
							if (pref.bAutoClosePropertySections && iLastOpenHeader != 16)
								ImGui::SetNextItemOpen(false, ImGuiCond_Always);

							if (ImGui::StyleCollapsingHeader(HeaderName.Get(), ImGuiTreeNodeFlags_DefaultOpen))//ImGuiTreeNodeFlags_None))
							{
								iLastOpenHeader = 16;

								ImGui::Indent(10);
								if (bIsThisAnEBE == true)
								{
									// Edit Structure Editor Object
									float edit_gadget_size = ImGui::GetFontSize()*10.0;
									float w = ImGui::GetWindowContentRegionWidth();
									ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (edit_gadget_size*0.5), 0.0f));
									if (ImGui::StyleButton("Edit Structure Object", ImVec2(edit_gadget_size, 0)))
									{
										t.widget.propertybuttonselected = 1;
										t.ebe.bReleaseMouseFirst = true;
									}
								}
								else
								{
									if (bAllowBehaviorChange == true)
									{
										DisplayFPEBehavior(false, iMasterID, &t.entityelement[iEntityIndex].eleprof, iEntityIndex);
									}
									else
									{
										// inform user cannot use behaviors for static objects
										ImGui::TextCenter("No Behavior For Static Objects");
									}
								}
								ImGui::Indent(-10);
							}
						}

						// Custom Materials now an advanced feature
						if (!bRubberbandActive && bMaterialsUsed == true && pref.iObjectEnableAdvanced && t.entityprofile[iMasterID].ismarker == 0 && bIsThisAnEBE == false)
						{
							bool bNeedMaterialUpdate = false;
							// detect if object changed while showing materials, ensure the switch happens in the UI
							static void* pLastObjectPtr;
							if ((void*)pObject != pLastObjectPtr)
							{
								//PE: reset mesh names, as we got a new object.
								t.importer.bModelMeshNamesSet = false;
								t.importer.cModelMeshNames.clear();

								bNeedMaterialUpdate = true;

								pLastObjectPtr = (void*)pObject;
							}

							if (pref.bAutoClosePropertySections && iLastOpenHeader != 13)
								ImGui::SetNextItemOpen(false, ImGuiCond_Always);

							if (ImGui::StyleCollapsingHeader("Materials##2", ImGuiTreeNodeFlags_None))
							{
								iLastOpenHeader = 13;

								ImGui::Indent(10);

								if (ImGui::Checkbox("Enable Custom Materials##2", &t.entityelement[iEntityIndex].eleprof.bCustomWickedMaterialActive))
								{
									bNeedMaterialUpdate = true;
									t.importer.bModelMeshNamesSet = false;
									t.importer.cModelMeshNames.clear();
								}

								//if (!t.entityelement[iEntityIndex].eleprof.bCustomWickedMaterialActive)
								//{
								//	//t.grideleprof.WEMaterial.MaterialActive = false;
								//
								//	if (ImGui::Checkbox("Enable Custom Materials##2", &t.entityelement[iEntityIndex].eleprof.bCustomWickedMaterialActive))
								//	{
								//		bNeedMaterialUpdate = true;
								//	}
								//	if (ImGui::IsItemHovered()) ImGui::SetTooltip("This can break instancing and add additional draw calls");
								//
								//	t.importer.bModelMeshNamesSet = false;
								//	t.importer.cModelMeshNames.clear();
								//	////PE: Copy master material settings to t.grideleprof.WEMaterial
								//	//if (t.entityelement[iEntityIndex].eleprof.bCustomWickedMaterialActive)
								//	//{
								//	//	//PE: reset mesh names, as we got a new object.
								//	//	t.importer.bModelMeshNamesSet = false;
								//	//	t.importer.cModelMeshNames.clear();
								//	//
								//	//	//PE: Get defaults from wicked directly.
								//	//	Wicked_Copy_Material_To_Grideleprof((void*)pObject, 0, &t.entityelement[iEntityIndex].eleprof);
								//	//	//PE: Set materials (variables) from new WEMaterial.
								//	//	Wicked_Set_Material_From_grideleprof((void*)pObject, 0, &t.entityelement[iEntityIndex].eleprof);
								//	//	t.entityelement[iEntityIndex].eleprof.WEMaterial.MaterialActive = true;
								//	//}
								//}
								//else
								//{
								//	if (ImGui::Checkbox("Enable Custom Materials##2", &t.entityelement[iEntityIndex].eleprof.bCustomWickedMaterialActive))
								//	{
								//		bNeedMaterialUpdate = true;
								//	}
								//	t.importer.bModelMeshNamesSet = false;
								//	t.importer.cModelMeshNames.clear();
								//	//t.grideleprof.WEMaterial.MaterialActive = true;
								//	//if (!t.entityelement[iEntityIndex].eleprof.bCustomWickedMaterialActive)
								//	//{
								//	//	//PE: reset mesh names, as we got a new object.
								//	//	t.importer.bModelMeshNamesSet = false;
								//	//	t.importer.cModelMeshNames.clear();
								//	//
								//	//	//PE: Get material from master object. and copy to t.entityelement[iEntityIndex].eleprof.
								//	//	sObject* pMasterObject = g_ObjectList[g.entitybankoffset + iMasterID];
								//	//	Wicked_Copy_Material_To_Grideleprof((void*)pMasterObject, 0, &t.entityelement[iEntityIndex].eleprof);
								//	//	if (t.entityprofile[iMasterID].WEMaterial.dwBaseColor[0] == -1)
								//	//		SetObjectDiffuse(iActiveObj, Rgb(255, 255, 255));
								//	//
								//	//	Wicked_Set_Material_From_grideleprof((void*)pObject, 0, &t.entityelement[iEntityIndex].eleprof);
								//	//}
								//	//else
								//	//{
								//	//	t.grideleprof.WEMaterial.MaterialActive = false;
								//	//}
								//
								//	//// detect if object changed while showing materials, ensure the switch happens in the UI
								//	//static void* pLastObjectPtr;
								//	//if ((void*)pObject != pLastObjectPtr)
								//	//{
								//	//	//PE: reset mesh names, as we got a new object.
								//	//	t.importer.bModelMeshNamesSet = false;
								//	//	t.importer.cModelMeshNames.clear();
								//
								//	//	Wicked_Set_Material_From_grideleprof((void*)pObject, 0, &t.entityelement[iEntityIndex].eleprof);
								//	//	pLastObjectPtr = (void*)pObject;
								//	//}
								//
								//	#ifdef WICKEDENGINE
								//	WickedSetEntityId(iMasterID);
								//	WickedSetElementId(iEntityIndex);
								//	#endif
								//	
								//	// display custom material settings
								//	Wicked_Change_Object_Material((void*)pObject, 0, &t.entityelement[iEntityIndex].eleprof);
								//	
								//	#ifdef WICKEDENGINE
								//	WickedSetEntityId(-1);
								//	WickedSetElementId(0);
								//	#endif
								//
								//}

								if (t.entityelement[iEntityIndex].eleprof.bCustomWickedMaterialActive)
								{
									#ifdef WICKEDENGINE
									WickedSetEntityId(iMasterID);
									WickedSetElementId(iEntityIndex);
									#endif
									
									// display custom material settings
									Wicked_Change_Object_Material((void*)pObject, 0, &t.entityelement[iEntityIndex].eleprof);
									
									#ifdef WICKEDENGINE
									WickedSetEntityId(-1);
									WickedSetElementId(0);
									#endif
								}
									
								ImGui::Indent(-10);
							}

							if (bNeedMaterialUpdate)
							{
								if (!t.entityelement[iEntityIndex].eleprof.bCustomWickedMaterialActive)
								{
									// Set material settings from master object.
									sObject* pMasterObject = g_ObjectList[g.entitybankoffset + iMasterID];
									Wicked_Copy_Material_To_Grideleprof((void*)pMasterObject, 0, &t.entityelement[iEntityIndex].eleprof);
									if (t.entityprofile[iMasterID].WEMaterial.dwBaseColor[0] == -1)
										SetObjectDiffuse(iActiveObj, Rgb(255, 255, 255));
							
									Wicked_Set_Material_From_grideleprof((void*)pObject, 0, &t.entityelement[iEntityIndex].eleprof);
									t.grideleprof.WEMaterial.MaterialActive = false;
								}
								else
								{
									// Set custom material settings.
									Wicked_Copy_Material_To_Grideleprof((void*)pObject, 0, &t.entityelement[iEntityIndex].eleprof);
									Wicked_Set_Material_From_grideleprof((void*)pObject, 0, &t.entityelement[iEntityIndex].eleprof);
									t.grideleprof.WEMaterial.MaterialActive = true;
								}
							}
						}

						#ifndef WICKEDENGINE
						bool bGeneralActive = false;
						if ((t.entityprofile[iMasterID].ismarker == 0 /*|| t.entityprofile[iMasterID].islightmarker == 1 */|| t.tflagspawn == 1) )
							bGeneralActive = true;
						if (t.tflagchar == 0 && t.tflagvis == 1 && t.tflagsimpler == 0)
							bGeneralActive = true;

						if (bGeneralActive)
						{
							char title[24] = "General##2";
							if (t.entityprofile[iMasterID].ischaracter == 1)
								strcpy(title, "Character Settings##2");
							//if (t.tflaglight == 0)
							//{
								if (ImGui::StyleCollapsingHeader(title, ImGuiTreeNodeFlags_None)) //ImGuiTreeNodeFlags_DefaultOpen
								{
									DisplayFPEGeneral(false, iMasterID, &t.entityelement[iEntityIndex].eleprof, iEntityIndex);
								}
							//}
						}
						#endif

						#ifdef WICKEDENGINE
						// Moved into its own settings.
						if (pref.iEnableDeveloperObjectTools)
						#else
						if(pref.iEnableDeveloperProperties)
						#endif
						{
							char title[24] = "Developer Settings##2";

							if (pref.bAutoClosePropertySections && iLastOpenHeader != 18)
								ImGui::SetNextItemOpen(false, ImGuiCond_Always);

							//Need pref. default closed.
							if (ImGui::StyleCollapsingHeader(title, ImGuiTreeNodeFlags_None)) //ImGuiTreeNodeFlags_DefaultOpen
							{
								iLastOpenHeader = 18;
								DisplayFPEAdvanced(false, iMasterID, &t.entityelement[iEntityIndex].eleprof, iEntityIndex);
							}
						}
					}
					#endif

					//if (!pref.iEnableDragDropEntityMode)
					#ifdef WICKEDENGINE
					#ifdef HIDEOBJECTMODES
					if (0) // Disabled in new design.
					#endif
					#endif
					{
						if (ImGui::StyleCollapsingHeader("Mode", ImGuiTreeNodeFlags_DefaultOpen))
						{
							// new method uses icons
							ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

							float w = ImGui::GetWindowContentRegionWidth();
							int control_image_size = 34;
							float control_width = (control_image_size + 3.0) * 6.0f + 8.0;
							int indent = (w*0.5) - (control_width*0.5);
							if (indent < 10) indent = 10;
							ImGui::Indent(indent);

							ImVec2 restore_cursorpos = ImGui::GetCursorPos();
							// five buttons
							for (int b = 0; b < 6; b++)
							{
								int iIconID = 0;
								LPSTR pLabelToolTip = "";
								if (b == 0 && bToolEdit) { iIconID = TOOL_ENT_EDIT; pLabelToolTip = "Edit Structure"; }
								if (b == 0 && bToolProperties) { iIconID = TOOL_ENT_EDIT; pLabelToolTip = "Edit Properties"; }
								if (b == 1 && bToolExtract) { iIconID = TOOL_ENT_EXTRACT; pLabelToolTip = "Extract to Cursor"; }
								if (b == 2 && bToolDublicate) { iIconID = TOOL_ENT_DUPLICATE; pLabelToolTip = "Duplicate In-Place"; }
								if (b == 3 && bToolLock) { iIconID = TOOL_ENT_LOCK; pLabelToolTip = "Lock Entity"; }
								if (b == 4 && bToolFindFloor) { iIconID = TOOL_ENT_FINDFLOOR; pLabelToolTip = "Find Floor"; }
								if (b == 5 && bToolDelete) { iIconID = TOOL_ENT_DELETE; pLabelToolTip = "Delete"; }

								if (iIconID > 0)
								{
									ImVec2 padding = { 3.0, 3.0 };
									const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + ImVec2(control_image_size, control_image_size));
									//window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
									if (ImGui::ImgBtn(iIconID, ImVec2(control_image_size, control_image_size), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false,false, bBoostIconColors))
									{
										// clicked mode button
										if (iIconID == TOOL_ENT_EDIT)
										{
											if (bToolEdit)
											{
												// edit structure
												t.widget.propertybuttonselected = 1;
												t.ebe.bReleaseMouseFirst = true;
												widget_show_widget();
											}
											else
											{
												// entity properties
												t.widget.propertybuttonselected = 2;
												widget_show_widget();
											}
										}
										if (iIconID == TOOL_ENT_EXTRACT)
										{
											widget_show_widget();
											bRunExtractDuplicate = true;
										}
										if (iIconID == TOOL_ENT_DUPLICATE)
										{
											// duplicate 
											widget_show_widget();
											bRunExtractDuplicate = true;
											bDuplicate = true;
										}
										if (iIconID == TOOL_ENT_LOCK)
										{
											bClickedTheLockUnlockButton = true;
											/*
											// entity lock/unlock
											if (iEntityIndex > 0)
											{
												int iLoopMax = 1;
												if (g.entityrubberbandlist.size() > 0) iLoopMax = g.entityrubberbandlist.size();
												for (int i = 0; i < iLoopMax; i++)
												{
													// get entity index
													int e = iEntityIndex;
													if (g.entityrubberbandlist.size() > 0)
														e = g.entityrubberbandlist[i].e;

													// toggle lock flag
													t.entityelement[e].editorlock = 1 - t.entityelement[e].editorlock;

													sObject* pObject;
													if (t.entityelement[e].obj > 0) 
													{
														pObject = g_ObjectList[t.entityelement[e].obj];
														if (pObject) 
														{
															if (t.entityelement[e].editorlock) 
															{
																#ifndef ALLOWSELECTINGLOCKEDOBJECTS
																WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_CURSOROBJECT);
																#endif
																sRubberBandType vEntityLockedItem;
																vEntityLockedItem.e = e;
																vEntityLockedList.push_back(vEntityLockedItem);
															}
															else {
																//Delete from list.
																for (int i = 0; i < vEntityLockedList.size(); i++)
																{
																	if (vEntityLockedList[i].e == e) {
																		vEntityLockedList.erase(vEntityLockedList.begin() + i);
																		break;
																	}
																}
																WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
															}
														}
													}

												}
												gridedit_clearentityrubberbandlist();
											}
											*/
											// exit widget when lock entity
											t.widget.pickedSection = 0;
											widget_show_widget();
										}
										if (iIconID == TOOL_ENT_FINDFLOOR)
										{
											iForceScancode = 13;
										}
										if (iIconID == TOOL_ENT_DELETE)
										{
											t.widget.deletebuttonselected = 1;
											widget_show_widget();
										}
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip(pLabelToolTip);
									restore_cursorpos = ImGui::GetCursorPos();
									if (b < 5) ImGui::SameLine();
									//PE: Support wrapping of icons.
									float caw = (ImGui::GetContentRegionAvailWidth() + (control_image_size*0.5));
									if (caw < control_image_size)
										ImGui::SetCursorPos(restore_cursorpos);
								}
							}
							ImGui::SetCursorPos(restore_cursorpos); //Restore cursor.
							ImGui::Indent(-indent);
						}
					}
				}

				// entity lock/unlock
				if ( bClickedTheLockUnlockButton == true )
				{
					if (iEntityIndex > 0)
					{
						int iLoopMax = 1;
						if (g.entityrubberbandlist.size() > 0) iLoopMax = g.entityrubberbandlist.size();
						for (int i = 0; i < iLoopMax; i++)
						{
							// get entity index
							int e = iEntityIndex;
							if (g.entityrubberbandlist.size() > 0)
								e = g.entityrubberbandlist[i].e;

							// toggle lock flag
							t.entityelement[e].editorlock = 1 - t.entityelement[e].editorlock;

							sObject* pObject;
							if (t.entityelement[e].obj > 0)
							{
								pObject = g_ObjectList[t.entityelement[e].obj];
								if (pObject)
								{
									if (t.entityelement[e].editorlock)
									{
										#ifndef ALLOWSELECTINGLOCKEDOBJECTS
										WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_CURSOROBJECT);
										#endif
										sRubberBandType vEntityLockedItem;
										vEntityLockedItem.e = e;
										vEntityLockedList.push_back(vEntityLockedItem);
									}
									else 
									{
										//Delete from list.
										for (int i = 0; i < vEntityLockedList.size(); i++)
										{
											if (vEntityLockedList[i].e == e) 
											{
												vEntityLockedList.erase(vEntityLockedList.begin() + i);
												break;
											}
										}
										WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
									}
								}
							}
						}
						gridedit_clearentityrubberbandlist();
					}
				}
				//##############################
				//#### Grid/Editor Settings ####
				//##############################
				// grid and alignment moved here from above (no longer need a host object)
				if (1)
				{
					if (pref.bAutoClosePropertySections && iLastOpenHeader != 15)
						ImGui::SetNextItemOpen(false, ImGuiCond_Always);

					if (ImGui::StyleCollapsingHeader("Grid and Alignment Settings", ImGuiTreeNodeFlags_None))
					{
						iLastOpenHeader = 15;
						ImGui::Indent(10);

						static bool bEditorGridFitObjectSize = false;
						static int iGridOffsetMode = 0;
						if (t.gridentitygridlock > 0)
						{
							bEditorGridFitObjectSize = true;
							if (t.gridentitygridlock == 2)
								iGridOffsetMode = 0;
							else
								iGridOffsetMode = 1;
						}
						else
						{
							bEditorGridFitObjectSize = false;
							iGridOffsetMode = 0;
						}
						ImGui::Checkbox("Enable Grid Mode", &bEditorGridFitObjectSize);
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select to snap the object to an aligned position");
						if (bEditorGridFitObjectSize == false) t.gridentitygridlock = 0;
						if (bEditorGridFitObjectSize == true)
						{
							ImGui::RadioButton("Use Grid Positions", &iGridOffsetMode, 0);
							if (ImGui::IsItemHovered()) ImGui::SetTooltip("Snaps the selected object to the chosen grid positions");
							ImGui::RadioButton("Snap Mode", &iGridOffsetMode, 1);
							if (ImGui::IsItemHovered()) ImGui::SetTooltip("Snap the object to the nearest object bound box");
							t.gridentitygridlock = 2 - iGridOffsetMode;
						}

						// grid size only avaiulable in advanced mode
						ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
						if (pref.iObjectEnableAdvanced)
						{
							if (t.gridentitygridlock == 2)
							{
								ImGui::TextCenter("Grid Offset");
								float w = ImGui::GetContentRegionAvail().x - 10.0f;
								float inputsize = w / 2.0f;
								inputsize -= 10.0f; //For text.
								inputsize -= 5.0f; //For padding.
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(18.0f, 3.0f));
								ImGui::Text("X");
								ImGui::SameLine();
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, -3.0f));
								ImGui::PushItemWidth(inputsize - ImGui::GetFontSize());
								ImGui::InputFloat("##XYZgridoffsetX", &fEditorGridOffsetX, 0.0f, 0.0f, "%.1f");
								if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Grid Offset X");
								ImGui::PopItemWidth();
								ImGui::SameLine();
								ImGui::Text("Z");
								ImGui::SameLine();
								ImGui::PushItemWidth(inputsize - ImGui::GetFontSize());
								ImGui::InputFloat("##XYZgridoffsetZ", &fEditorGridOffsetZ, 0.0f, 0.0f, "%.1f");
								if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Grid Offset Z");
								ImGui::PopItemWidth();
								ImGui::TextCenter("Grid Size");
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(18.0f, 3.0f));
								ImGui::Text("X");
								ImGui::SameLine();
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, -3.0f));
								ImGui::PushItemWidth(inputsize - ImGui::GetFontSize());
								ImGui::InputFloat("##XYZgridsizeX", &fEditorGridSizeX, 0.0f, 0.0f, "%.1f");
								if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Grid Size X");
								ImGui::PopItemWidth();
								ImGui::SameLine();
								ImGui::Text("Z");
								ImGui::SameLine();
								ImGui::PushItemWidth(inputsize - ImGui::GetFontSize());
								ImGui::InputFloat("##XYZgridsizeZ", &fEditorGridSizeZ, 0.0f, 0.0f, "%.1f");
								if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Grid Size Z");
								ImGui::PopItemWidth();

								// clever button to align grid to object (for older levels with arbitary alignments mixed together)
								if (iEntityIndex > 0 && g.entityrubberbandlist.size() == 0)
								{
									float w = ImGui::GetWindowContentRegionWidth();
									float but_gadget_size = ImGui::GetFontSize()*15.0;
									ImGui::Text("");
									ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
									if (ImGui::StyleButton("Align Grid Offset To Object", ImVec2(but_gadget_size, 0)))
									{
										float x = t.entityelement[iEntityIndex].x;
										float z = t.entityelement[iEntityIndex].z;
										int iSizeRoundedX = int(x / fEditorGridSizeX)*fEditorGridSizeX;
										fEditorGridOffsetX = x - iSizeRoundedX;
										int iSizeRoundedZ = int(z / fEditorGridSizeZ)*fEditorGridSizeZ;
										fEditorGridOffsetZ = z - iSizeRoundedZ;
									}
									ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
									if (ImGui::StyleButton("Align Grid Size To Object", ImVec2(but_gadget_size, 0)))
									{
										float sx = ObjectSizeX(t.entityelement[iEntityIndex].obj);
										float sz = ObjectSizeZ(t.entityelement[iEntityIndex].obj);
										fEditorGridSizeX = sx;
										fEditorGridSizeZ = sz;
									}
								}

								// can never have a grid size below one
								if (fEditorGridSizeX <= 1) fEditorGridSizeX = 1.0f;
								if (fEditorGridSizeZ <= 1) fEditorGridSizeZ = 1.0f;
							}
						}

						/* this will eventually be in the advanced object rotation section
						ImGui::Checkbox("Calculate Pivot", &bExtractFixPivot);
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("Calculate Objects Pivot");

						//							ImGui::RadioButton("Normal Y", &iExtractMode, 0);
						//							if (ImGui::IsItemHovered()) ImGui::SetTooltip("Adjust Y Depending on Object Selection System");
						if (!pref.iEnableDragDropEntityMode)
						{
							ImGui::RadioButton("Find Floor", &iExtractMode, 0);
							if (ImGui::IsItemHovered()) ImGui::SetTooltip("Place Object on Floor");

							ImGui::SameLine();
							ImGui::SetCursorPos(ImVec2(w*0.5, ImGui::GetCursorPos().y));
							ImGui::Text("(%.3f)", t.gridentityposy_f);

							ImGui::RadioButton("Extracted Y", &iExtractMode, 1);
							if (ImGui::IsItemHovered()) ImGui::SetTooltip("Place Object Using Extracted Y");
							ImGui::SameLine();
							ImGui::SetCursorPos(ImVec2(w*0.5, ImGui::GetCursorPos().y));
							ImGui::Text("(%.3f)", fExtractYValue);

							ImGui::RadioButton("Fixed Y", &iExtractMode, 2);
							if (ImGui::IsItemHovered()) ImGui::SetTooltip("Place Object Using Fixed Y");
							ImGui::SameLine();

							ImGui::SetCursorPos(ImVec2(w*0.5, ImGui::GetCursorPos().y));
							ImGui::InputFloat("##FixedYExtract", &fExtractFixedYValue, 0.5);
							if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set Object Fixed Y");
						}
						else
						{
							iExtractMode = 0;
							static bool bUseFixedY = false;

							ImGui::Checkbox("Fixed Y", &bUseFixedY);
							if (ImGui::IsItemHovered()) ImGui::SetTooltip("Place Object Using Fixed Y");
							if (bUseFixedY)
							{
								ImGui::SameLine();
								ImGui::SetCursorPos(ImVec2(w*0.5, ImGui::GetCursorPos().y));
								ImGui::InputFloat("##FixedYExtract", &fExtractFixedYValue, 0.5);
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set Object Fixed Y");
							}
							if (bUseFixedY)
								iExtractMode = 2;

						}
						*/

						// button to unlock any objects in locked list
						if (vEntityLockedList.size() > 0)
						{
							float w = ImGui::GetWindowContentRegionWidth();
							float but_gadget_size = ImGui::GetFontSize()*10.0;
							ImGui::Text("");
							ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
							cStr unlockstr = cStr("Unlock ") + cStr((int)vEntityLockedList.size()) + cStr(" Objects");
							if (ImGui::StyleButton(unlockstr.Get(), ImVec2(but_gadget_size, 0))) 
							{
								for (int i = 0; i < vEntityLockedList.size(); i++)
								{
									int e = vEntityLockedList[i].e;
									t.entityelement[e].editorlock = 0;
									sObject* pObject;
									if (t.entityelement[e].obj > 0) 
									{
										pObject = g_ObjectList[t.entityelement[e].obj];
										if (pObject) 
										{
											WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
										}
									}
								}
								vEntityLockedList.clear();
							}
						}
						ImGui::Indent(-10);
						ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
					}
				}

				// tutorial component
				if (!pref.bHideTutorials)
				{
					// Default to tutorial panel if no object is selected.
					// if (Entity_Tools_Window && !g_selected_editor_object && !Visuals_Tools_Window && iLastOpenHeader != 20)
					//LB: can keep tutorial closed now even if no object selected 
					if (Entity_Tools_Window && !g_selected_editor_object && !Visuals_Tools_Window && iLastOpenHeader != 15 && iLastOpenHeader != 20) // 20 is keyboard shortcxuts, 15 is grid component
						iLastOpenHeader = 19;

					if (pref.bAutoClosePropertySections && iLastOpenHeader != 19)
						ImGui::SetNextItemOpen(false, ImGuiCond_Always);
					
					if (ImGui::StyleCollapsingHeader("Tutorial", ImGuiTreeNodeFlags_DefaultOpen))
					{
						iLastOpenHeader = 19;

						ImGui::Indent(10);
						cstr cShowTutorial = "0201 - Level Editing";
						char* tutorial_combo_items[] = { "0201 - Level Editing", "0301 - Object Library", "0401 - Object Grouping", "0601 - Terrain Editing", "0202 - Particle Editor" };
						SmallTutorialVideo(cShowTutorial.Get(), tutorial_combo_items, ARRAYSIZE(tutorial_combo_items), SECTION_ENTITY_TOOLS, true );
						float but_gadget_size = ImGui::GetFontSize()*12.0;
						float w = ImGui::GetWindowContentRegionWidth() - 10.0;
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
						#ifdef INCLUDESTEPBYSTEP
						if (ImGui::StyleButton("View Step by Step Tutorial", ImVec2(but_gadget_size, 0)))
						{
							// pre-select tutorial 03
							bHelp_Window = true;
							bHelpVideo_Window = true;
							bSetTutorialSectionLeft = false;
							strcpy(cForceTutorialName, cShowTutorial.Get());
						}
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("Start Step by Step Tutorial");
						#endif
						ImGui::Indent(-10);
					}
				}

				// insert a keyboard shortcut component into panel
				UniversalKeyboardShortcut(eKST_ObjectMode);

				/* will be a new method for unlocking
				if (ImGui::StyleCollapsingHeader("Keyboard Shortcuts", ImGuiTreeNodeFlags_DefaultOpen))
				{
					ImGui::Indent(10);
					ImGui::Text("R=Rotate Entity");
					ImGui::Text("Enter=Find Floor");

					if (vEntityLockedList.size() > 0)
					{
						ImGui::Separator();
						float w = ImGui::GetWindowContentRegionWidth();
						float but_gadget_size = ImGui::GetFontSize()*10.0;
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));

						cStr unlockstr = cStr("Unlock ") + cStr( (int) vEntityLockedList.size()) + cStr(" Objects");
						if (ImGui::StyleButton(unlockstr.Get(), ImVec2(but_gadget_size, 0) )) {
							for (int i = 0; i < vEntityLockedList.size(); i++)
							{
								int e = vEntityLockedList[i].e;
								t.entityelement[e].editorlock = 0;
								sObject* pObject;
								if (t.entityelement[e].obj > 0) {
									pObject = g_ObjectList[t.entityelement[e].obj];
									if (pObject) {
										WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
									}
								}
							}
							vEntityLockedList.clear();
						}
					}

					ImGui::Separator();
					ImGui::TextCenter(t.statusbar_s.Get());
					ImGui::Separator();

					ImGui::Indent(-10);
					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				}
				*/

				if (bRunExtractDuplicate) 
				{
					t.tentitytoselect = iEntityIndex;
					t.widget.duplicatebuttonselected = 0;
					t.gridentityautofind = 7;

					t.widget.pickedObject = 0;
					widget_updatewidgetobject();

					t.onetimeentitypickup = 1;

					//  extract entity from the map
					if (t.tentitytoselect > 0)
					{
						if (t.entityelement[t.tentitytoselect].editorfixed == 0)
						{
//							int iExtractMode = 0; //0 = find floor, 1 = extracted y value. , 3 = fixed y value.
//							float fExtractYValue = 0, fExtractFixedYValue = GGORIGIN_Y;
							fExtractYValue = t.entityelement[t.tentitytoselect].y;

							t.gridentityeditorfixed = t.entityelement[t.tentitytoselect].editorfixed;
							t.gridentity = t.entityelement[t.tentitytoselect].bankindex;
							t.ttrygridentitystaticmode = t.entityelement[t.tentitytoselect].staticflag;
							t.ttrygridentity = t.gridentity; editor_validatestaticmode();
							t.gridedit.autoflatten = t.entityprofile[t.gridentity].autoflatten;
							t.gridedit.entityspraymode = 0;
							if (t.gridentityautofind == 7)
							{
								//  widget extracts without forcing entity to Floor
								t.gridentityautofind = 0;
								t.gridentityposoffground = 1;
								t.gridentityusingsoftauto = 0;
							}
							else
							{
								t.gridentityposoffground = 0;
								t.gridentityusingsoftauto = 1;
								#ifdef WICKEDENGINE
								// MAX handles its own positioning system
								#else
								if (t.entityprofile[t.gridentity].defaultstatic == 0 && t.entityprofile[t.gridentity].isimmobile == 1)
								{
									t.gridentityautofind = 1;
								}
								else
								#endif
								{
									t.gridentityautofind = 0;
								}
							}
							t.gridentitysurfacesnap = 0; // surfacesnap off as messes up extract offset for entity
							t.gridentityextractedindex = t.tentitytoselect;
							t.gridentityhasparent = 0;//t.entityelement[t.tentitytoselect].iHasParentIndex; 210317 - break association when extract so can place free of parent
							t.gridentityposx_f = t.entityelement[t.tentitytoselect].x;
							t.gridentityposy_f = t.entityelement[t.tentitytoselect].y;
							t.gridentityposz_f = t.entityelement[t.tentitytoselect].z;
							t.gridentityrotatex_f = t.entityelement[t.tentitytoselect].rx;
							t.gridentityrotatey_f = t.entityelement[t.tentitytoselect].ry;
							t.gridentityrotatez_f = t.entityelement[t.tentitytoselect].rz;
							t.gridentityrotatequatmode = t.entityelement[t.tentitytoselect].quatmode;
							t.gridentityrotatequatx_f = t.entityelement[t.tentitytoselect].quatx;
							t.gridentityrotatequaty_f = t.entityelement[t.tentitytoselect].quaty;
							t.gridentityrotatequatz_f = t.entityelement[t.tentitytoselect].quatz;
							t.gridentityrotatequatw_f = t.entityelement[t.tentitytoselect].quatw;
							if (t.entityprofile[t.gridentity].ismarker == 10)
							{
								t.gridentityscalex_f = 100.0f + t.entityelement[t.tentitytoselect].scalex;
								t.gridentityscaley_f = 100.0f + t.entityelement[t.tentitytoselect].scaley;
								t.gridentityscalez_f = 100.0f + t.entityelement[t.tentitytoselect].scalez;
							}
							else
							{
								t.gridentityscalex_f = ObjectScaleX(t.entityelement[t.tentitytoselect].obj);
								t.gridentityscaley_f = ObjectScaleY(t.entityelement[t.tentitytoselect].obj);
								t.gridentityscalez_f = ObjectScaleZ(t.entityelement[t.tentitytoselect].obj);
							}
							t.grideleprof = t.entityelement[t.tentitytoselect].eleprof;
							t.grideleproflastname_s = t.grideleprof.name_s;

							//  Transfer any waypoint association
							t.waypointindex = t.entityelement[t.tentitytoselect].eleprof.trigger.waypointzoneindex;
							t.grideleprof.trigger.waypointzoneindex = t.waypointindex;
							t.waypoint[t.waypointindex].linkedtoentityindex = 0;
							
							if (!bDuplicate) 
							{
								iLastEntityOnCursor = t.tentitytoselect;
								gridedit_deleteentityfrommap();
							}
							else
							{
								iLastEntityOnCursor = 0;
							}

							t.refreshgrideditcursor = 1;

							// remove entity index from rubber band selection
							for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
								if (g.entityrubberbandlist[i].e == t.tentitytoselect)
									g.entityrubberbandlist[i].e = 0;

							//Just place under cursor.
							t.inputsys.dragoffsetx_f = 0;
							t.inputsys.dragoffsety_f = 0;
						}
					}
				}

				CheckMinimumDockSpaceSize(250.0f);

				if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
					//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
					ImGui::Text("");
					ImGui::Text("");
				}

				//PE: End child here if active
				//bChildWindowOpen = true;
				if (bWithNoScrollbar)
				{
					ImGui::EndChild();
				}

				ImGui::End();
			}
		}

#endif

		//############################
		//#### Save To Level Cloud ###
		//############################
		#ifndef WICKEDENGINE

		// allows flag to be reset if user closes save cloud popup directly
		static bool bSaveToGameCloudInitList = false;
		if (bExport_SaveToGameCloud_Window == false) bSaveToGameCloudInitList = false;
		if (bExport_SaveToGameCloud_Window)
		{
			// made static so retains last strings and values given
			static char pLicenseID[MAX_PATH];
			static char pShortLicenseID[MAX_PATH];
			static char cSaveToGameCloudPath[MAX_PATH] = "\0";
			static int iSaveToGameCloudCycle = 0;

			//bool bJustWantToDeleteSomeOldFiles = false;
			//bool bInternalModeToDeleteGames = false;
			//if (1)
			//{
			//	// use this code to WIPE ALL LEVELS FROM ALL CLOUDS ON SERVER!
			//	bJustWantToDeleteSomeOldFiles = true;
			//	bInternalModeToDeleteGames = true;
			//}
			if (cSaveToGameCloudPath[0] == 0)
			{
				strcpy(cSaveToGameCloudPath, g.fpscrootdir_s.Get());
				strcat(cSaveToGameCloudPath, "\\mapbank\\");
			}

			ImGui::OpenPopup("Save To Level Cloud##SaveToLevelCloudWindow");
			ImGui::SetNextWindowSize(ImVec2(34 * ImGui::GetFontSize(), 26 * ImGui::GetFontSize()), ImGuiCond_Once); //ImGuiCond_FirstUseEver
			ImGui::SetNextWindowPosCenter(ImGuiCond_Once);

			if (ImGui::BeginPopupModal("Save To Level Cloud##SaveToLevelCloudWindow", &bExport_SaveToGameCloud_Window, 0)) 
			{
				ImGui::Indent(10);
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

				ImGui::Text("Choose the level you would like to upload:");

				float col_start = 80.0f;

				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::Text("File");
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));

				ImGui::SetCursorPos(ImVec2(col_start, ImGui::GetCursorPosY()));

				float path_gadget_size = ImGui::GetFontSize()*2.0;

				ImGui::PushItemWidth(-10 - path_gadget_size);
				ImGui::InputText("##InputPathCCP", &cSaveToGameCloudPath[0], 250, ImGuiInputTextFlags_ReadOnly);
				if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;
				ImGui::PopItemWidth();

				ImGui::SameLine();
				ImGui::PushItemWidth(path_gadget_size);
				if (ImGui::StyleButton("...##ccppath"))
				{
					cStr tOldDir = GetDir();
					char * cFileSelected;
					cstr currentfile = cSaveToGameCloudPath;
					cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "All\0*.*\0", currentfile.Get(), NULL);
					SetDir(tOldDir.Get());

					if (cFileSelected && strlen(cFileSelected) > 0) 
					{
						strcpy(cSaveToGameCloudPath, cFileSelected);
					}
				}
				ImGui::PopItemWidth();
				ImGui::Indent(-10);

				float save_gadget_size = ImGui::GetFontSize()*10.0;
				float w = ImGui::GetWindowContentRegionWidth();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (save_gadget_size*0.5), 0.0f));

				static int iCloudLevelListCount = 0;
				static char** pCloudLevelList = NULL;
				static char** pCloudLevelListDisplay = NULL;
				extern std::vector<cstr> g_gamecloud_gamelist;
				static int iTeacherCode = 0;

				if (iSaveToGameCloudCycle == 0) 
				{
					// initially get game list
					if (bSaveToGameCloudInitList == false)
					{
						// as it speeds up potential delete game step as getlist moved earlier
						bSaveToGameCloudInitList = true;
						mp_gamecloud_getlist();

						// LICENSE-ID is used to schools/users can identify their game from all the others
						strcpy(pLicenseID, "NOSITE");
						cstr SiteName_s;
						char pObfSitename[1024];
						strcpy(pObfSitename, "12345-12345-12345-12345");
						if (FileExist(cstr(g.fpscrootdir_s + "\\cleverbooksmode.ini").Get()) == 1)
						{
							OpenToRead(1, cstr(g.fpscrootdir_s + "\\cleverbooksmode.ini").Get());
							cstr ActuallyUserEmailAddress_s = ReadString(1);
							// convert to a serial key format = 12345-12345-12345-12345
							SiteName_s = Left(Upper(ActuallyUserEmailAddress_s.Get()), 23);
							char pSiteNameConverted[25];
							memset(pSiteNameConverted, 0, sizeof(pSiteNameConverted));
							strcpy(pSiteNameConverted, SiteName_s.Get());
							for (int n = 0; n < 23; n++)
							{
								if (pSiteNameConverted[n] >= '0' && pSiteNameConverted[n] <= '9')
								{
									// numerics okay
								}
								else
								{
									// cap everything else into upper case alpha characters
									if (pSiteNameConverted[n] < 'A') pSiteNameConverted[n] = 'A';
									if (pSiteNameConverted[n] > 'Z') pSiteNameConverted[n] = 'Z';
								}
							}
							while (strlen(pSiteNameConverted) < 23) strcat(pSiteNameConverted, "Z");
							// to ensure emails contribute to unique first-five-digits, compount repeated sets of five on the first five
							for (int first = 0; first < 5; first++)
							{
								for (int rest = 5 + first; rest < 23; rest += 5)
								{
									int iShiftPlaces = pSiteNameConverted[rest] - 'A';
									for (int shift = 0; shift < iShiftPlaces; shift++)
									{
										pSiteNameConverted[first] = pSiteNameConverted[first] + 1;
										if (pSiteNameConverted[first] > 'Z')
											pSiteNameConverted[first] = 'A';
									}
								}
							}
							strrev(pSiteNameConverted);
							strcpy(pObfSitename, pSiteNameConverted);
							CloseFile(1);
							strcpy(pLicenseID, pObfSitename);
						}
						else
						{
							if (FileExist(cstr(g.fpscrootdir_s + "\\vrqcontrolmode.ini").Get()) == 1)
							{
								OpenToRead(1, cstr(g.fpscrootdir_s + "\\vrqcontrolmode.ini").Get());
								SiteName_s = ReadString(1);
								strcpy(pObfSitename, SiteName_s.Get());
								for (int n = 0; n < strlen(pObfSitename); n++)
								{
									if (pObfSitename[n] == '-')
										pObfSitename[n] = 'Z';
									else
										pObfSitename[n] = pObfSitename[n] + 1;
								}
								CloseFile(1);
								strcpy(pLicenseID, pObfSitename);
							}
						}

						// recreate list for combo
						if (pCloudLevelList)
						{
							for (int l = 0; l < iCloudLevelListCount; l++)
								delete pCloudLevelList[l];
							delete pCloudLevelList;
							for (int l = 0; l < iCloudLevelListCount; l++)
								delete pCloudLevelListDisplay[l];
							delete pCloudLevelListDisplay;
							iCloudLevelListCount = 0;
							pCloudLevelList = NULL;
						}
						if (pCloudLevelList == NULL)
						{
							iCloudLevelListCount = 1;
							for (int l = 0; l < g_gamecloud_gamelist.size(); l++)
							{
								LPSTR pLevelFile = g_gamecloud_gamelist[l].Get();
								if (strnicmp (pLevelFile, pLicenseID, strlen(pLicenseID)) == NULL)
								{
									iCloudLevelListCount++;
								}
							}
							pCloudLevelList = new char*[iCloudLevelListCount];
							pCloudLevelList[0] = new char[256];
							strcpy (pCloudLevelList[0], "");
							pCloudLevelListDisplay = new char*[iCloudLevelListCount];
							pCloudLevelListDisplay[0] = new char[256];
							strcpy (pCloudLevelListDisplay[0], "No Level Selected");
							iCloudLevelListCount = 1;
							if (strlen(pLicenseID) > 0)
							{
								for (int l = 0; l < g_gamecloud_gamelist.size(); l++)
								{
									LPSTR pLevelFile = g_gamecloud_gamelist[l].Get();
									if (strnicmp (pLevelFile, pLicenseID, strlen(pLicenseID)) == NULL)
									{
										pCloudLevelList[iCloudLevelListCount] = new char[1024];
										strcpy (pCloudLevelList[iCloudLevelListCount], pLevelFile);
										pCloudLevelListDisplay[iCloudLevelListCount] = new char[1024];
										strcpy (pCloudLevelListDisplay[iCloudLevelListCount], pLevelFile + strlen(pLicenseID) + 1);
										iCloudLevelListCount++;
									}
								}
							}
						}

						// ensures teacher can delete a level, then return software to user safely!
						iTeacherCode = 0; 
				
						// now create short license ID (five digits)
						strcpy(pShortLicenseID, pLicenseID);
						pShortLicenseID[5] = 0;
					}

					extern float g_mapfile_fProgress;
					g_mapfile_fProgress = 0.0f;

					// only used a few times
					//if (bInternalModeToDeleteGames == true)
					//{
					//	if (ImGui::StyleButton("DELETE LEVEL CLOUD", ImVec2(save_gadget_size, 0)))
					//	{
					//		bJustWantToDeleteSomeOldFiles = true;
					//		iSaveToGameCloudCycle = 1;
					//	}
					//}
					//else
					{
						if (ImGui::StyleButton("SAVE TO LEVEL CLOUD", ImVec2(save_gadget_size, 0)))
						{
							if (FileExist(cSaveToGameCloudPath) == 1)
								iSaveToGameCloudCycle = 1;
							else
								MessageBoxA(NULL, "You must specify an FPM to save to level cloud", "Save To Level Cloud", MB_OK);
						}
					}

					// instructions for Oculus levels
					ImGui::Indent(10);
					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
					ImGui::TextWrapped("As the Standalone VR Headset runs on different graphics hardware, ensure your levels only contain a small number of characters and no imported models. This ensures the VR experience remains at full speed.");

					// about the school code
					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
					ImGui::TextWrapped("When you launch the Standalone VR Player for the first time, you will be required to enter a School Code. Enter one of these codes:");

					// the code
					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
					ImGui::Text(pShortLicenseID);
					ImGui::Text(pLicenseID);

					// new delete cloud levels feature
					ImGui::Text("");
					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
					ImGui::TextWrapped("You can delete levels from the level cloud. Use your Teacher Code to view all the levels that can be deleted.");
					if (iTeacherCode != 12345)
					{
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (save_gadget_size*0.5), 0.0f));
						ImGui::PushItemWidth(save_gadget_size);
						if (ImGui::InputInt("##Teacher Code", &iTeacherCode, 0, 0, ImGuiInputTextFlags_Password | ImGuiInputTextFlags_EnterReturnsTrue))
						{
						}
						ImGui::PopItemWidth();
					}
					else
					{
						// present combo of all levels
						static int iCurrentlySelectedCloudLevel = 0;
						if (bSaveToGameCloudInitList == true)
						{
							ImGui::PushItemWidth(w-20);
							if (ImGui::Combo("##Cloud Levels", &iCurrentlySelectedCloudLevel, pCloudLevelListDisplay, iCloudLevelListCount, 20))
							{
							}
							ImGui::PopItemWidth();
						}

						// button to delete
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (save_gadget_size*0.5), 0.0f));
						if (ImGui::StyleButton("DELETE LEVEL", ImVec2(save_gadget_size, 0)))
						{
							if (iCurrentlySelectedCloudLevel == 0)
							{
								MessageBoxA (NULL, "You must first select a level from the list above", "Delete Level Confirmation", MB_OK);
							}
							else
							{
								LPSTR pLevelToDelete = pCloudLevelList[iCurrentlySelectedCloudLevel];
								LPSTR pLevelToDeleteDisplay = pCloudLevelListDisplay[iCurrentlySelectedCloudLevel];
								char pMessage[2048];
								sprintf(pMessage, "Are you sure you want to delete %s?", pLevelToDeleteDisplay);
								if (MessageBoxA(NULL, pMessage, "Delete Level Confirmation", MB_YESNO) == IDYES)
								{
									// delete level in cloud
									mp_gamecloud_delete(pLevelToDelete);

									// and force a refresh of the list
									bSaveToGameCloudInitList = false;
								}
							}
						}
					}
				}
				else 
				{
					if (ImGui::StyleButton("CANCEL", ImVec2(save_gadget_size, 0)))
					{
						iSaveToGameCloudCycle = 5;
					}
				}

				ImGui::Indent(10);

				float fdone = (float)mp_gamecloud_getprogress() / 100.0f;

				if (iSaveToGameCloudCycle == 1) fdone = 0.01f;

				if (fdone > 0.01f && fdone < 1.0f)
				{
					char tmp[32];
					sprintf(tmp, "Uploading: %.0f%%", fdone*100.0f);
					ImGui::ProgressBar(fdone, ImVec2(ImGui::GetContentRegionAvail().x - 10, 26), tmp); //, ""
				}

				if (iSaveToGameCloudCycle == 2)
				{
					// get file only, strip path (to check game list for duplicates)
					char pFileOnly[MAX_PATH];
					strcpy(pFileOnly, cSaveToGameCloudPath);
					for (int n = strlen(cSaveToGameCloudPath); n > 0; n--)
					{
						if (cSaveToGameCloudPath[n] == '/' || cSaveToGameCloudPath[n] == '\\')
						{
							strcpy(pFileOnly, cSaveToGameCloudPath + n + 1);
							break;
						}
					}

					//

					// Construct filename that will be used for the upload
					char pFinalFilenameToUse[MAX_PATH];
					//if (bJustWantToDeleteSomeOldFiles == false)
					{
						// normal use 
						strcpy(pFinalFilenameToUse, pLicenseID);
						strcat(pFinalFilenameToUse, "-");

						// cannot allow special character & in the filename (messes up delete later on)
						//strcat(pFinalFilenameToUse, pFileOnly);
						char pFormatFilenameToDeleteCorrectly[MAX_PATH];
						strcpy (pFormatFilenameToDeleteCorrectly, "");
						for (int n = 0; n < strlen(pFileOnly); n++)
						{
							if (pFileOnly[n] == '&')
							{
								char pChar[3];
								strcpy(pChar, "and");
								strcat(pFormatFilenameToDeleteCorrectly, pChar);
							}
							else
							{
								char pChar[2];
								pChar[0] = pFileOnly[n];
								pChar[1] = 0;
								strcat(pFormatFilenameToDeleteCorrectly, pChar);
							}
						}
						strcat(pFinalFilenameToUse, pFormatFilenameToDeleteCorrectly);
					}
					//else
					//{
					//	// to delete old filenames
					//	strcpy(pFinalFilenameToUse, pFileOnly);
					//}

					// can remove ALL game files
					//if (bInternalModeToDeleteGames==true)
					//{
					//	mp_gamecloud_deleteALLgamefiles(NULL);
					//	iSaveToGameCloudCycle = 4;
					//}
					//else
					{
						// start save to level cloud, first check existing games up there
						if (mp_gamecloud_overwriteexisting(pFinalFilenameToUse) != -1)
						{
							//if (bJustWantToDeleteSomeOldFiles == false)
							{
								int iUploadResult = mp_gamecloud_upload(true, cSaveToGameCloudPath, pFinalFilenameToUse);
								if (iUploadResult != -1)
								{
									if (iUploadResult == 1)
										iSaveToGameCloudCycle = 4;
									else
										iSaveToGameCloudCycle = 3;
								}
								else
									iSaveToGameCloudCycle = 6;
							}
							//else
							//	iSaveToGameCloudCycle = 6;
						}
						else
							iSaveToGameCloudCycle = 6;
					}
				}
				if (iSaveToGameCloudCycle == 3)
				{
					// upload cycle
					int iResultAsync = mp_gamecloud_upload(false, cSaveToGameCloudPath, NULL);
					if (iResultAsync != 0 )
					{
						// complete standalone creation
						if (iResultAsync == 1 )
							iSaveToGameCloudCycle = 4;
						else
							iSaveToGameCloudCycle = 6;
					}
				}
				if (iSaveToGameCloudCycle == 4)
				{
					// complete save to level cloud
					iSaveToGameCloudCycle = 0;
					bSaveToGameCloudInitList = false;
					strcpy(cTriggerMessage, "Save to Level Cloud Complete");
					bTriggerMessage = true;
					bExport_SaveToGameCloud_Window = false; //Close window.
				}
				if (iSaveToGameCloudCycle == 5)
				{
					// cancel standalone creation
					iSaveToGameCloudCycle = 0;
					bSaveToGameCloudInitList = false;
					strcpy(cTriggerMessage, "Save to Level Cloud Cancelled");
					bTriggerMessage = true;
					bExport_SaveToGameCloud_Window = false; //Close window.
				}
				if (iSaveToGameCloudCycle == 6)
				{
					// cancel popup
					iSaveToGameCloudCycle = 0;
					bSaveToGameCloudInitList = false;
					strcpy(cTriggerMessage, mp_gamecloud_geterror());
					bTriggerMessage = true;
					bExport_SaveToGameCloud_Window = false; //Close window.
				}
				if (iSaveToGameCloudCycle == 1) iSaveToGameCloudCycle = 2;

				ImGui::Indent(-10);

				bImGuiGotFocus = true;

				ImGui::EndPopup();
			}
		}
		#endif

		//########################
		//#### Download Store ####
		//########################

		//Waypoints##WaypointsToolsWindow
		if (refresh_gui_docking == 0 && !bDownloadStore_Window) 
		{
			//Make sure window is setup in docking space.
			ImGui::SetNextWindowSize(ImVec2(40 * ImGui::GetFontSize(), 30 * ImGui::GetFontSize()), ImGuiCond_Once);
			ImGui::SetNextWindowPosCenter(ImGuiCond_Once);

			ImGui::Begin("Game Creator Store Downloader##DownloadStoreWindow", &bDownloadStore_Window, 0);
			ImGui::End();
		}
		imgui_download_store();

		#ifdef WICKEDENGINE
		//#######################
		//#### Shooter Tools ####
		//#######################
		if (Shooter_Tools_Window )
		{
			//PE: Need own docking window.
			//LB: Shooter now a filter mode 
			//ImGui::Begin("Shooter Genre##GameLogicTools", &Shooter_Tools_Window, 0);
			//imgui_shooter_tools();
			//ImGui::End();
			iIncludeLeftIconSet = 1;
			g_bDotsAreVisible = true;
			//DrawCharacterDots(true);
			//DrawLogicNodes(true);
			if (t.showeditorelements == 1)
			{
				g_bDotsAreVisible = true;
				DrawLogicNodes(true);
			}
		}
		else 
		{
			if(iIncludeLeftIconSet == 1) iIncludeLeftIconSet = 0;
			Shooter_Tools_Window_Active = false;
			if (g_bDotsAreVisible)
			{
				//DrawCharacterDots(false);
				DrawLogicNodes(false);
				g_bDotsAreVisible = false;
			}
		}

		//########################
		//#### Weather Window ####
		//########################

		if (Weather_Tools_Window) 
		{
			//PE: Need own docking window.
			ImGui::Begin("Weather##WeatherEffectsV2", &Weather_Tools_Window, 0);
			imgui_Customize_Weather_V2(3);
			ImGui::End();
		}
		#endif

		//#####################
		//#### Preferences ####
		//#####################

		#ifdef WICKEDENGINE
		ProcessPreferences();
		#endif

		//########################
		//#### Waypoint Tools ####
		//########################

		//Waypoints##WaypointsToolsWindow
		if (refresh_gui_docking == 0 && !bWaypoint_Window) 
		{
			//Make sure window is setup in docking space.
			ImGui::Begin("Waypoints##WaypointsToolsWindow", &bWaypoint_Window, iGenralWindowsFlags);
			ImGui::End();
		}
		waypoint_imgui_loop();

		//#######################
		//#### Terrain Tools ####
		//#######################
#ifdef WICKEDENGINE
		static bool bTerrainToolsDocked = false;
#else
		static bool bTerrainToolsDocked = true;
#endif

		if (!bTerrainToolsDocked || (refresh_gui_docking == 0 && !bTerrain_Tools_Window ))
		{
			//Make sure window is setup in docking space.
			bool bTrue = true;
			ImGui::Begin("Terrain Tools##TerrainToolsWindow", &bTerrain_Tools_Window, iGenralWindowsFlags);
			ImGui::End();
			#ifdef WICKEDENGINE
			ImGui::Begin("Sculpt Terrain##TerrainToolsWindow", &bTrue, iGenralWindowsFlags);
			ImGui::End();
			ImGui::Begin("Paint Terrain##TerrainToolsWindow", &bTrue, iGenralWindowsFlags);
			ImGui::End();
			ImGui::Begin("Add Vegetation##TerrainToolsWindow", &bTrue, iGenralWindowsFlags);
			ImGui::End();
			ImGui::Begin("Terrain Tools##Sculpt Terrain##TerrainToolsWindow", &bTrue, iGenralWindowsFlags);
			ImGui::End();
			ImGui::Begin("Terrain Tools##Paint Terrain##TerrainToolsWindow", &bTrue, iGenralWindowsFlags);
			ImGui::End();
			ImGui::Begin("Terrain Tools##Add Vegetation##TerrainToolsWindow", &bTrue, iGenralWindowsFlags);
			ImGui::End();
			ImGui::Begin("Terrain Tools##Add Trees##TerrainToolsWindow", &bTrue, iGenralWindowsFlags);
			ImGui::End();
			ImGui::Begin("Terrain Tools##Add Bushes##TerrainToolsWindow", &bTrue, iGenralWindowsFlags);
			ImGui::End();
		
			#endif
			bTerrainToolsDocked = true;
		}
		else
		{
			#ifdef WICKEDENGINE
			if (pref.iTerrainDebugMode)
			{
				imgui_terrain_loop_v2(); //PE: New design.
			}
			else
			{
				#ifdef GGTERRAIN_USE_NEW_TERRAIN
				imgui_terrain_loop_v3(); //PE: New design for Paul's new terrain system :)
				#else
				imgui_terrain_loop_v2(); //PE: New design.
				#endif
			}
			#else
			imgui_terrain_loop();
			#endif
		}

		//############################
		//#### Builder Properties ####
		//############################

		if (refresh_gui_docking == 0 && !bBuilder_Properties_Window) 
		{
			//Make sure window is setup in docking space.
			ImGui::Begin("Structure Properties##BuilderPropertiesWindow", &bBuilder_Properties_Window, iGenralWindowsFlags);
			ImGui::End();
		}
		else {
			if(!bBuilder_Properties_Window)
				if (t.ebe.on == 1) ebe_hide();
		}
		imgui_ebe_loop();


		//###########################
		//#### Character Creator ####
		//###########################

		if (refresh_gui_docking == 0 && !g_bCharacterCreatorPlusActivated) 
		{
			//Make sure window is setup in docking space.
			ImGui::Begin("Character Creator##PropertiesWindow", &g_bCharacterCreatorPlusActivated, iGenralWindowsFlags);
			ImGui::End();
		}
		#ifdef USE_NEW_CCP_DESIGN_V3
		charactercreatorplus_imgui_v3();
		#else
		charactercreatorplus_imgui();
		#endif

		//################################
		//#### Building Editor - 2022 ####
		//################################
#ifdef BUILDINGEDITOR
		bool bBuildingEditorActive = BuildingEditor::isActive();
		if (refresh_gui_docking == 0 && !bBuildingEditorActive)
		{
			//Make sure window is setup in docking space.
			ImGui::Begin("Building Editor##BuildingEditorSettings", &bBuildingEditorActive, iGenralWindowsFlags);
			ImGui::End();
		}
		BuildingEditor::loopimgui();
#endif


		//###########################
		//#### Entity Properties ####
		//###########################
			
		static int iOldPickedEntityIndex = -1;

		if (refresh_gui_docking == 0) ImGui::SetNextWindowPos(viewPortPos + ImVec2(400, 140), ImGuiCond_Always); //ImGuiCond_FirstUseEver,ImGuiCond_Once
		if (refresh_gui_docking == 0) ImGui::SetNextWindowSize(ImVec2(30 * ImGui::GetFontSize(), 40 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver

		if (refresh_gui_docking == 0) 
		{
			//Need to be here while first time docking.
			ImGui::Begin("Entity Properties##PropertiesWindow", &bEntity_Properties_Window, iGenralWindowsFlags);
			ImGui::End();
		}
		else if (bEntity_Properties_Window) {
				

			if (t.widget.pickedEntityIndex > 0 && t.cameraviewmode == 2) {

				//We are in properties mode.
				grideleprof_uniqui_id = 35000;

				static int current_loaded_script = -1;
				static int current_selected_script = 0;
				static bool current_loaded_script_has_dlua = false;

				int iParentEntid = t.ttrygridentity;
					
				if (iOldPickedEntityIndex != t.widget.pickedEntityIndex) 
				{
					//New item , backup grideleprof , for cancel function.
					//PE: NOTE this do not backup position ...
					//backup_grideleprof = t.grideleprof; //PE: We dont use a cancel system anymore.

					#ifdef WICKEDENGINE
					//PE: Setup "Materials" defaults.
					//PE: NOTE: we also need a way to get this info from t.entityelement[t.e].eleprof.WEMaterial
					//PE: should also be placed inside t.grideleprof
					int picked_object = t.gridentityobj;
					if (t.gridentityobj > 0 && t.gridentityobj < g_iObjectListCount ) 
					{
						if (g_ObjectList[t.gridentityobj])
						{
							if(t.grideleprof.WEMaterial.MaterialActive)
								Wicked_Set_Material_From_grideleprof(g_ObjectList[t.gridentityobj], 0);
							else
								Wicked_Set_Material_Defaults(g_ObjectList[t.gridentityobj], 0);
						}
					}
					//LB:suspected mem crash - will find a global way to remember different preferred folders
					//PE: Default material file selection always same folder as .fpe
					//extern cstr oldtextimportpath;
					//oldtextimportpath = g.rootdir_s + "entitybank\\" + t.entitybank_s[t.gridentity];
					//oldtextimportpath = getpath(oldtextimportpath.Get());
					#endif

					iOldPickedEntityIndex = t.widget.pickedEntityIndex;

					//t.gridentity can be changed when keys like "r" is used , so make a backup.
					iOldgridentity = t.gridentity;

					// get voices sets
					if (g_voiceList_s.size() == 0) 
					{
						if (CreateListOfVoices() > 0) 
						{
							pCCPVoiceSet = g_voiceList_s[0].Get();
							CCP_SelectedToken = g_voicetoken[0];
						}
					}

					// entity may have voice preferences set to check that
					pCCPVoiceSet = t.grideleprof.voiceset_s.Get();
					CCP_Speak_Rate = t.grideleprof.voicerate;
					if (strlen(pCCPVoiceSet) > 0)
					{
						// find token for this voiceset
						for (int n = 0; n < g_voiceList_s.size(); n++)
						{
							if (stricmp(g_voiceList_s[n].Get(), pCCPVoiceSet) == NULL)
							{
								CCP_SelectedToken = g_voicetoken[n];
								break;
							}
						}
					}
					else
					{
						// default if blank
						if ( g_voiceList_s.size() > 0 ) 
							pCCPVoiceSet = g_voiceList_s[0].Get();
						else
							pCCPVoiceSet = "";
						if (g_voicetoken.size() > 0)
							CCP_SelectedToken = g_voicetoken[0];
						else
							CCP_SelectedToken = NULL;
						CCP_Speak_Rate = 0;
					}

					//Make sure to read DLUA.
					current_loaded_script = -1;
				}

				#ifdef WICKEDENGINE
				g_selected_editor_object = NULL;
				if (iOldgridentity > 0) 
				{
					int picked_object = t.gridentityobj;
					if (picked_object > 0) 
					{
						if (picked_object < g_iObjectListCount)
						{
							if (g_ObjectList[picked_object])
							{
								if(t.gridentitystaticmode)
									g_selected_editor_color = XMSTATICCOLOR;
								else
									g_selected_editor_color = XMDYNAMICCOLOR;
								g_selected_editor_object = g_ObjectList[picked_object];
							}
						}
					}
				}
				#endif

				ImGui::Begin("Entity Properties##PropertiesWindow", &bEntity_Properties_Window, iGenralWindowsFlags);

				int media_icon_size = 64;
				ImGui::BeginChild("##cEntitiesPropertiesHeader", ImVec2(0, 0),false, iGenralWindowsFlags);
					
				ImGui::SetWindowFontScale(0.90);
				ImGui::PushItemWidth(ImGui::GetFontSize()*10.0);

				if (bEntity_Properties_Window)
				{
					t.gridentity = iOldgridentity;

					//Collect the flags to use.
					imgui_set_openproperty_flags(t.gridentity);
					int tflagtext = 0, tflagimage=0;
					if (t.entityprofile[t.gridentity].ismarker == 3)
					{
						if (!t.entityprofile[t.gridentity].markerindex <= 1)
						{
							#ifdef VRTECH
							#else
								if (t.entityprofile[t.gridentity].markerindex == 2) tflagtext = 1;
								if (t.entityprofile[t.gridentity].markerindex == 3) tflagimage = 1;
							#endif
						}
					}

					LPSTR pAIRoot = "scriptbank\\";
					if (t.tflagai == 1)
					{
						if (g.quickparentalcontrolmode == 2)
						{
							if (t.entityprofile[t.gridentity].ismarker == 0)
							{
								if (t.tflagchar == 1)
									pAIRoot = "scriptbank\\people\\";
								else
									pAIRoot = "scriptbank\\objects\\";
							}
							else
							{
								pAIRoot = "scriptbank\\markers\\";
							}
						}
					}
						

					if (t.tsimplecharview == 1)
					{
						//  Wizard (simplified) property editing
						t.group = 0;
						if (ImGui::StyleCollapsingHeader("Character Info", ImGuiTreeNodeFlags_DefaultOpen)) {

							t.grideleprof.name_s = imgui_setpropertystring2(t.group, t.grideleprof.name_s.Get(), t.strarr_s[413].Get(), "Choose a unique name for this character");
							t.grideleprof.aimain_s = imgui_setpropertylist2(t.group, t.controlindex, t.grideleprof.aimain_s.Get(), "Behaviour", "Select a behaviour for this character", 11);
							t.grideleprof.soundset1_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset1_s.Get(), "Voiceover", "Select t.a WAV or OGG file this character will use during their behavior", "audiobank\\");
							t.grideleprof.ifused_s = imgui_setpropertystring2(t.group, t.grideleprof.ifused_s.Get(), "If Used", "Sometimes used to specify the name of an entity to be activated");
						}
					}
					else
					{

						bool bUnfoldAdvanced = false;
						ImGui::SetWindowFontScale(1.0);
						float fRegionWidth = ImGui::GetWindowContentRegionWidth();
						float textwidth;
						fPropertiesColoumWidth = 90.0f;
						int adv_flasgs = ImGuiTreeNodeFlags_DefaultOpen;
						if (g.vrqcontrolmode > 0) 
						{
							//Simple version.
							adv_flasgs = ImGuiTreeNodeFlags_None;
								
							//##################################################################
							//#### Simple , perhaps based on current .lua script.           ####
							//#### We need unique id here so add ##SimpleInput to all items ####
							//##################################################################
								
							if (t.entityprofile[t.gridentity].ischaracter > 0) {
								//Chars.

								if (ImGui::StyleCollapsingHeader("Character Properties", ImGuiTreeNodeFlags_DefaultOpen)) {

									//Display icon.
									if (t.entityprofile[iParentEntid].iThumbnailSmall > 0) {
										float w = ImGui::GetWindowContentRegionWidth();
										ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (media_icon_size*0.5), 0.0f));
										ImGui::ImgBtn(t.entityprofile[iParentEntid].iThumbnailSmall, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
									}

									ImGui::Indent(10);

									t.grideleprof.name_s = imgui_setpropertystring2(t.group, t.grideleprof.name_s.Get(), "Name", t.strarr_s[204].Get());
									//bSoundSet , Male/Female
									//PE: Type removed.
									//t.grideleprof.soundset_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset_s.Get(), "Type", t.strarr_s[255].Get(), "audiobank\\voices\\");

									ImGui::Indent(-10);
								}

								int speech_entries = 0;
								bool bUpdateMainString = false;

								for (int speech_loop = 0; speech_loop < 5; speech_loop++)
									speech_ids[speech_loop] = -1;
								//behavior
								if (ImGui::StyleCollapsingHeader("Character Behavior", ImGuiTreeNodeFlags_DefaultOpen)) {

									ImGui::Indent(10);

									ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
									ImGui::Text("Behaviors");
									ImGui::SameLine();
									ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
									ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));

									ImGui::PushItemWidth(-10);

									// scan PEOPLE folder for complete list of script
									std::vector<cstr> scriptList_s; scriptList_s.clear();
									std::vector<cstr> scriptListTitle_s; scriptListTitle_s.clear();
									cstr oldDir_s = GetDir();
									SetDir(g.fpscrootdir_s.Get());
									SetDir("Files\\scriptbank\\people");
									ChecklistForFiles();
									for ( int f = 1; f <= ChecklistQuantity(); f++)
									{
										cstr tfile_s = ChecklistString(f);
										LPSTR pFilename = tfile_s.Get();
										if (tfile_s != "." && tfile_s != "..")
										{
											if (strnicmp(pFilename + strlen(pFilename) - 4, ".lua", 4) == NULL)
											{
												// create a readable title from file
												char pTitleName[256];
												strcpy(pTitleName, pFilename);
												pTitleName[strlen(pTitleName) - 4] = 0;
												for (int n = 0; n < strlen(pTitleName); n++)
												{
													if (n == 0)
													{
														if (pTitleName[n] >= 'a' && pTitleName[n] <= 'z' )
															pTitleName[n] -= ('a' - 'A');
													}
													else
													{
														if (pTitleName[n] >= 'A' && pTitleName[n] <= 'Z' )
															pTitleName[n] += ('a' - 'A');
													}
													if (pTitleName[n] == '_') pTitleName[n] = ' ';
												}

												// add script and title to list
												scriptList_s.push_back(cstr("people\\")+tfile_s);
												scriptListTitle_s.push_back(cstr(pTitleName));
											}
										}
									}
									scriptList_s.push_back(cstr(""));
									scriptListTitle_s.push_back(cstr("Custom"));
									SetDir(oldDir_s.Get());

									// and create items list
									static int g_scriptpeople_item_count = 0;
									static char** g_scriptpeople_items = NULL;
									if (g_scriptpeople_item_count != scriptList_s.size())
									{
										if (g_scriptpeople_items)
										{
											for (int i = 0; i < g_scriptpeople_item_count; i++) SAFE_DELETE(g_scriptpeople_items[i]);
											SAFE_DELETE(g_scriptpeople_items);
										}
										g_scriptpeople_item_count = scriptList_s.size();
										g_scriptpeople_items = new char*[g_scriptpeople_item_count];
										for (int i = 0; i < g_scriptpeople_item_count; i++)
										{
											g_scriptpeople_items[i] = new char[256];
											strcpy(g_scriptpeople_items[i], scriptListTitle_s[i].Get());
										}
									}

									int item_current_type_selection = g_scriptpeople_item_count - 1; //Default Custom.
									for (int i = 0; i < g_scriptpeople_item_count - 1; i++) 
									{
										if (pestrcasestr(t.grideleprof.aimain_s.Get(), scriptList_s[i].Get())) 
										{
											item_current_type_selection = i;
											break;
										}
									}

									if (current_loaded_script != item_current_type_selection) 
									{
										//Load in lua and check for custom properties.
										cstr script_name = "scriptbank\\";
										if (item_current_type_selection < g_scriptpeople_item_count - 1)
											script_name += (char *) scriptList_s[item_current_type_selection].Get();
										else
											script_name += t.grideleprof.aimain_s;
										//Try to parse script.
										ParseLuaScript(&t.grideleprof,script_name.Get());
										current_loaded_script = item_current_type_selection;

										if (t.grideleprof.PropertiesVariableActive == 1) 
										{
											bUpdateMainString = true;
											current_loaded_script_has_dlua = true;
										}
										else 
										{
											if (current_loaded_script_has_dlua) 
											{
												//Reset t.grideleprof.soundset4_s that contain the dlua calls.
												t.grideleprof.soundset4_s = "";
												current_loaded_script_has_dlua = false;
											}
										}
									}

									if (ImGui::Combo("##BehavioursSimpleInput", &item_current_type_selection, g_scriptpeople_items, g_scriptpeople_item_count, 20)) 
									{
										if (item_current_type_selection < g_scriptpeople_item_count - 1) 
										{
											t.grideleprof.aimain_s = scriptList_s[item_current_type_selection].Get();
										}
										else 
										{
											t.grideleprof.aimain_s = "";
										}
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Character Behavior");

									ImGui::PopItemWidth();

									if (item_current_type_selection == g_scriptpeople_item_count - 1) 
									{
										//Custom script , display directly.
										std::string ms = t.strarr_s[417].Get();
										ms = "Script";
										cstr aim = t.grideleprof.aimain_s;
										t.grideleprof.aimain_s = imgui_setpropertyfile2(t.group, t.grideleprof.aimain_s.Get(), (char *)ms.c_str(), t.strarr_s[207].Get(), pAIRoot);
										if (aim != t.grideleprof.aimain_s)
											current_loaded_script = -1;
									}

									if (t.grideleprof.PropertiesVariableActive == 1) {
										speech_entries = DisplayLuaDescription(&t.grideleprof);
									}
									else {
										if (t.grideleprof.PropertiesVariable.VariableDescription.Len() > 0) {
											DisplayLuaDescriptionOnly(&t.grideleprof);
										}
									}

									ImGui::Indent(-10);
								}

								if(speech_entries > 0)
								{
									//@Lee all SPEECH control is moved to this function.
									SpeechControls(speech_entries, bUpdateMainString);
								}

								if (ImGui::StyleCollapsingHeader("Customize", ImGuiTreeNodeFlags_DefaultOpen)) {

									ImGui::Indent(10);

									ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
									ImGui::Text("Move Speed");
									ImGui::SameLine();
									ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
									ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
									ImGui::PushItemWidth(-10);
									ImGui::MaxSliderInputInt("##Movement SpeedSimpleInput", &t.grideleprof.speed, 1, 500, "Set Movement Speed");

									if (t.playercontrol.thirdperson.enabled == 1) t.tanimspeed_f = t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed;
									else t.tanimspeed_f = t.grideleprof.animspeed;

									ImGui::PopItemWidth();
									ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
									ImGui::Text("Anim Speed");
									ImGui::SameLine();
									ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
									ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
									ImGui::PushItemWidth(-10);
									int tmpint = t.tanimspeed_f;
									ImGui::MaxSliderInputInt("##Animation Speed Simple", &tmpint, 1, 500, "Set Animation Speed");

									t.tanimspeed_f = tmpint;
									ImGui::PopItemWidth();
									if (t.playercontrol.thirdperson.enabled == 1) t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed = t.tanimspeed_f;
									else t.grideleprof.animspeed = t.tanimspeed_f;

									ImGui::Indent(-10);
								}
							}
							else if (t.tflaglight == 1)
							{
								if (ImGui::StyleCollapsingHeader("Name", ImGuiTreeNodeFlags_DefaultOpen)) {

									//Display icon.
									if (t.entityprofile[iParentEntid].iThumbnailSmall > 0) {
										float w = ImGui::GetWindowContentRegionWidth();
										ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (media_icon_size*0.5), 0.0f));
										ImGui::ImgBtn(t.entityprofile[iParentEntid].iThumbnailSmall, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
									}

									ImGui::Indent(10);

									//Name and color setup only.
									ImGui::Text("");
									t.grideleprof.name_s = imgui_setpropertystring2(t.group, t.grideleprof.name_s.Get(), "Name", t.strarr_s[204].Get());
									//ImGui::Text("");

									ImGui::Indent(-10);

								}

								if (ImGui::StyleCollapsingHeader("Customize", ImGuiTreeNodeFlags_DefaultOpen)) {

									ImGui::Indent(10);

									ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
									ImGui::Text("Light Distance");
									ImGui::SameLine();
									ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
									ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
									ImGui::PushItemWidth(-10);

									ImGui::SliderInt("##Light RangeSimpleInput", &t.grideleprof.light.range, 1, 3000);
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", t.strarr_s[250].Get() );
									ImGui::PopItemWidth();

									#ifdef WICKEDENGINE
									// ZJ: Removed for now.
									/*if (pref.iObjectEnableAdvanced)
									{
										ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
										ImGui::Text("Light Probe Scale");
										ImGui::SameLine();
										ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
										ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
										ImGui::PushItemWidth(-10);
										if (ImGui::SliderFloat("##fLightProbeScaleSimpleInput", &t.grideleprof.light.fLightHasProbe, 0.0f, 5.0f, "%.2f") == true)
										{
											// triggers probe debug to show
											g_bLightProbeScaleChanged = true;
										}
										if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Specify the scaling of the environment probe attached to the light");
										ImGui::PopItemWidth();
									}
									*/
									#endif

									ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
									ImGui::Text("Light Color");
									ImGui::SameLine();
									ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
									ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
									ImGui::PushItemWidth(-10);
									ImGui::Text(""); //place it below text, so it get larger.

									float colors[5];
									colors[3] = ((t.grideleprof.light.color & 0xff000000) >> 24) / 255.0f;
									colors[0] = ((t.grideleprof.light.color & 0x00ff0000) >> 16) / 255.0f;
									colors[1] = ((t.grideleprof.light.color & 0x0000ff00) >> 8) / 255.0f;
									colors[2] = (t.grideleprof.light.color & 0x000000ff) / 255.0f;
									ImGui::ColorPicker3("##Light ColorSimpleInput", colors, ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoLabel);
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", t.strarr_s[251].Get() );

									colors[0] *= 255.0f;
									colors[1] *= 255.0f;
									colors[2] *= 255.0f;
									colors[3] *= 255.0f;
									t.grideleprof.light.color = 0xff000000 + ((unsigned int)colors[0] << 16) + ((unsigned int)colors[1] << 8) + +((unsigned int)colors[2]);
									ImGui::PopItemWidth();

									// update the light live
									#ifdef WICKEDENGINE
									if (t.gridentitywickedlightindex == 0)
									{
										int iLightType = 1;
										if (t.grideleprof.usespotlighting) iLightType = 2;
										t.gridentitywickedlightindex = WickedCall_AddLight(iLightType);
									}
									if (t.gridentitywickedlightindex > 0)
									{
										float lightx = t.gridentityposx_f;
										float lighty = t.gridentityposy_f;
										float lightz = t.gridentityposz_f;
										float lightax = t.gridentityrotatex_f;
										float lightay = t.gridentityrotatey_f;
										float lightaz = t.gridentityrotatez_f;
										float lightrange = t.grideleprof.light.range;
										float lightspotradius = t.grideleprof.light.offsetup;
										int colr = colors[0];
										int colg = colors[1];
										int colb = colors[2];
										bool bCastShadow = true;
										if (t.grideleprof.castshadow == 1) bCastShadow = false;
										WickedCall_UpdateLight(t.gridentitywickedlightindex, lightx, lighty, lightz, lightax, lightay, lightaz, lightrange, lightspotradius, colr, colg, colb, bCastShadow);
									}
									#endif

									ImGui::Indent(-10);
								}
							}
							else if (t.entityprofile[t.gridentity].ismarker == 1) 
{
								//Start Marker.
								if (ImGui::StyleCollapsingHeader("Name", ImGuiTreeNodeFlags_DefaultOpen))
								{
									//Display icon.
									if (t.entityprofile[iParentEntid].iThumbnailSmall > 0) {
										float w = ImGui::GetWindowContentRegionWidth();
										ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (media_icon_size*0.5), 0.0f));
										ImGui::ImgBtn(t.entityprofile[iParentEntid].iThumbnailSmall, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
									}

									ImGui::Indent(10);

									//Name only.
									ImGui::Text("");
									t.grideleprof.name_s = imgui_setpropertystring2(t.group, t.grideleprof.name_s.Get(), "Name", t.strarr_s[204].Get());

									ImGui::Indent(-10);

								}

								// DLUA support added here.
								int speech_entries = 0;
								bool bUpdateMainString = false;
								for (int speech_loop = 0; speech_loop < 5; speech_loop++)
									speech_ids[speech_loop] = -1;
								if (current_loaded_script != current_selected_script) 
								{
									//Load in lua and check for custom properties.
									cstr script_name = "scriptbank\\";
									script_name += t.grideleprof.aimain_s;
									//Try to parse script.
									ParseLuaScript(&t.grideleprof, script_name.Get());
									current_loaded_script = current_selected_script;

									if (t.grideleprof.PropertiesVariableActive == 1) {
										bUpdateMainString = true;
										current_loaded_script_has_dlua = true;
									}
									else {
										if (current_loaded_script_has_dlua) {
											//Reset t.grideleprof.soundset4_s that contain the dlua calls.
											t.grideleprof.soundset4_s = "";
											current_loaded_script_has_dlua = false;
										}
									}

								}

								// Markers behaviours
								if (t.grideleprof.PropertiesVariableActive == 1 || t.grideleprof.PropertiesVariable.VariableDescription.Len() > 0)
								{
									if (ImGui::StyleCollapsingHeader("Behaviors", ImGuiTreeNodeFlags_DefaultOpen)) {

										ImGui::Indent(10);

										if (t.grideleprof.PropertiesVariableActive == 1) {
											speech_entries = DisplayLuaDescription(&t.grideleprof);
										}
										else {
											if (t.grideleprof.PropertiesVariable.VariableDescription.Len() > 0) {
												DisplayLuaDescriptionOnly(&t.grideleprof);
											}
										}

										ImGui::Indent(-10);
									}
								}

								if (speech_entries > 0)
								{
									// all SPEECH control is moved to this function.
									SpeechControls(speech_entries, bUpdateMainString);
								}


								if (ImGui::StyleCollapsingHeader("Customize", ImGuiTreeNodeFlags_DefaultOpen)) {

									ImGui::Indent(10);

									ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
									ImGui::Text("Player Speed");
									ImGui::SameLine();
									ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
									ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));

									ImGui::PushItemWidth(-10);

									//ImGui::SliderInt("##Movement SpeedSimpleInput", &t.grideleprof.speed, 1, 500);
									ImGui::MaxSliderInputInt("##Movement SpeedSimpleInput", &t.grideleprof.speed, 1, 500, "Set Player Speed");
									//if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set Player Speed");

									if (t.playercontrol.thirdperson.enabled == 1) t.tanimspeed_f = t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed;
									else t.tanimspeed_f = t.grideleprof.animspeed;

									ImGui::PopItemWidth();

									// Object Has Weapon
									if (t.tflaghasweapon == 1 && t.playercontrol.thirdperson.enabled == 0 && g.quickparentalcontrolmode != 2)
									{
										t.grideleprof.hasweapon_s = imgui_setpropertylist2c(t.group, t.controlindex, t.grideleprof.hasweapon_s.Get(), "Attachment", t.strarr_s[209].Get(), 1);
									}

									ImGui::Indent(-10);
								}
							}
							else 
							{
								//#################
								//#### Objects ####
								//################# 

								t.tokay = 1;
								if (ObjectExist(g.entitybankoffset + t.gridentity) == 1)
								{
									if (GetNumberOfFrames(g.entitybankoffset + t.gridentity) > 0)
									{
										t.tokay = 0;
									}
								}

								int speech_entries = 0;
								bool bUpdateMainString = false;

								for (int speech_loop = 0; speech_loop < 5; speech_loop++)
									speech_ids[speech_loop] = -1;

								//health.lua
								cstr aimain = t.grideleprof.aimain_s.Lower();
								//new: trigger anyting not a marker.
								if (t.entityprofile[t.gridentity].ismarker == 0 )// || aimain == "key.lua" || aimain == "objects\\key.lua" || aimain == "door.lua" || aimain == "default.lua" || aimain == "health.lua" || aimain == "pickuppable.lua" ) ) 
								{
									if (ImGui::StyleCollapsingHeader("Name", ImGuiTreeNodeFlags_DefaultOpen))
									{
										//Display icon.
										if (t.entityprofile[iParentEntid].iThumbnailSmall > 0) {
											float w = ImGui::GetWindowContentRegionWidth();
											ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (media_icon_size*0.5), 0.0f));
											ImGui::ImgBtn(t.entityprofile[iParentEntid].iThumbnailSmall, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
										}

										ImGui::Indent(10);

										t.grideleprof.name_s = imgui_setpropertystring2(t.group, t.grideleprof.name_s.Get(), "Name", t.strarr_s[204].Get());

										ImGui::Indent(-10);
									}
										
									// Object behaviours
									if (ImGui::StyleCollapsingHeader("Behaviors", ImGuiTreeNodeFlags_DefaultOpen))
									{
										ImGui::Indent(10);

										// scan OBJECTS folder for complete list of script
										std::vector<cstr> scriptList_s; scriptList_s.clear();
										std::vector<cstr> scriptListTitle_s; scriptListTitle_s.clear();
										cstr oldDir_s = GetDir();
										SetDir(g.fpscrootdir_s.Get());
										SetDir("Files\\scriptbank\\objects");
										ChecklistForFiles();
										for ( int f = 1; f <= ChecklistQuantity(); f++)
										{
											cstr tfile_s = ChecklistString(f);
											LPSTR pFilename = tfile_s.Get();
											if (tfile_s != "." && tfile_s != "..")
											{
												if (strnicmp(pFilename + strlen(pFilename) - 4, ".lua", 4) == NULL)
												{
													// create a readable title from file
													char pTitleName[256];
													strcpy(pTitleName, pFilename);
													pTitleName[strlen(pTitleName) - 4] = 0;
													for (int n = 0; n < strlen(pTitleName); n++)
													{
														if (n == 0)
														{
															if (pTitleName[n] >= 'a' && pTitleName[n] <= 'z' )
																pTitleName[n] -= ('a' - 'A');
														}
														else
														{
															if (pTitleName[n] >= 'A' && pTitleName[n] <= 'Z' )
																pTitleName[n] += ('a' - 'A');
														}
														if (pTitleName[n] == '_') pTitleName[n] = ' ';
													}

													// add script and title to list
													scriptList_s.push_back(cstr("objects\\")+tfile_s);
													scriptListTitle_s.push_back(cstr(pTitleName));
												}
											}
										}
										scriptList_s.push_back(cstr(""));
										scriptListTitle_s.push_back(cstr("Custom"));
										SetDir(oldDir_s.Get());

										// and create items list
										static int g_scriptobjects_item_count = 0;
										static char** g_scriptobjects_items = NULL;
										if (g_scriptobjects_item_count != scriptList_s.size())
										{
											if (g_scriptobjects_items)
											{
												for (int i = 0; i < g_scriptobjects_item_count; i++) SAFE_DELETE(g_scriptobjects_items[i]);
												SAFE_DELETE(g_scriptobjects_items);
											}
											g_scriptobjects_item_count = scriptList_s.size();
											g_scriptobjects_items = new char*[g_scriptobjects_item_count];
											for (int i = 0; i < g_scriptobjects_item_count; i++)
											{
												g_scriptobjects_items[i] = new char[256];
												strcpy(g_scriptobjects_items[i], scriptListTitle_s[i].Get());
											}
										}

										// find selection
										int item_current_type_selection = g_scriptobjects_item_count - 1; //Default Custom.
										for (int i = 0; i < g_scriptobjects_item_count - 1 ; i++) 
										{
											if (pestrcasestr(t.grideleprof.aimain_s.Get(), scriptList_s[i].Get())) 
											{
												item_current_type_selection = i;
												break;
											}
										}
												
										ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
										ImGui::Text("Behaviors");
										ImGui::SameLine();
										ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
										ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
										ImGui::PushItemWidth(-10);

										if (ImGui::Combo("##Behaviours2SimpleInput", &item_current_type_selection, g_scriptobjects_items, g_scriptobjects_item_count, 20 ))
										{
											if (item_current_type_selection >= 0) 
												t.grideleprof.aimain_s = scriptList_s[item_current_type_selection];
											else 
												t.grideleprof.aimain_s = "default.lua";
											aimain = t.grideleprof.aimain_s.Lower();
										}
										if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Object Behavior");
										ImGui::PopItemWidth();

										if (current_loaded_script != item_current_type_selection) 
										{
											//Load in lua and check for custom properties.
											cstr script_name = "scriptbank\\";
											if (item_current_type_selection < g_scriptobjects_item_count - 1) //PE: Need to check for custom
												script_name += scriptList_s[item_current_type_selection];
											else
												script_name += t.grideleprof.aimain_s;
											//Try to parse script.
											ParseLuaScript(&t.grideleprof, script_name.Get());
											current_loaded_script = item_current_type_selection;

											if (t.grideleprof.PropertiesVariableActive == 1) 
											{
												bUpdateMainString = true;
												current_loaded_script_has_dlua = true;
											}
											else 
											{
												if (current_loaded_script_has_dlua) 
												{
													//Reset t.grideleprof.soundset4_s that contain the dlua calls.
													t.grideleprof.soundset4_s = "";
													current_loaded_script_has_dlua = false;
												}
											}
										}

										if (item_current_type_selection == g_scriptobjects_item_count - 1)
										{
											//Custom Behaviours , display directly.
											std::string ms = t.strarr_s[417].Get();
											ms = "Script";
											cstr aim = t.grideleprof.aimain_s;
											t.grideleprof.aimain_s = imgui_setpropertyfile2(t.group, t.grideleprof.aimain_s.Get(), (char *)ms.c_str(), t.strarr_s[207].Get(), pAIRoot);
											aimain = t.grideleprof.aimain_s.Lower();
											if (aim != t.grideleprof.aimain_s)
												current_loaded_script = -1;
										}

										if (t.grideleprof.PropertiesVariableActive == 1) 
										{
											speech_entries = DisplayLuaDescription(&t.grideleprof);
										}
										else 
										{
											if (t.grideleprof.PropertiesVariable.VariableDescription.Len() > 0) 
											{
												DisplayLuaDescriptionOnly(&t.grideleprof);
											}
										}

										ImGui::Indent(-10);
									}

									if (speech_entries > 0)
									{
										// all SPEECH control is moved to this function.
										SpeechControls(speech_entries, bUpdateMainString);
									}
								}
								else
									bUnfoldAdvanced = true;
							}
						}

						ImGui::SetWindowFontScale(1.0); //0.90

						fPropertiesColoumWidth = 120.0f; //Advanced coloum need to be larger as we have large fields.

						// All objects need 'certain fields' as pretty commmon  to have it for the script
						if (t.entityprofile[t.gridentity].ismarker == 0) // so as not to interfere with markers
						{
							bool bSound0Mentioned = false;
							bool bSound1Mentioned = false;
							bool bSound2Mentioned = false;
							bool bSound3Mentioned = false;
							bool bVideoSlotMentioned = false;
							bool bIfUsedMentioned = false;
							bool bUseKeyMentioned = false;
							bool bShootingWeaponMentioned = false;
							bool bMeleeWeaponMentioned = false;
							int iAnimationSetMentioned = 0;
							char pCaptureAnyScriptDesc[10240 + (80 * 300) + (80 * 300)];
							strcpy(pCaptureAnyScriptDesc, t.grideleprof.PropertiesVariable.VariableDescription.Get());
							for (int i = 0; i < t.grideleprof.PropertiesVariable.iVariables; i++)
							{
								strcat(pCaptureAnyScriptDesc, t.grideleprof.PropertiesVariable.VariableSectionDescription[i]);
							}
							for (int i = 0; i < t.grideleprof.PropertiesVariable.iVariables; i++)
							{
								strcat(pCaptureAnyScriptDesc, t.grideleprof.PropertiesVariable.VariableSectionEndDescription[i]);
							}
							if (strstr(pCaptureAnyScriptDesc, "<Sound0>") != 0) bSound0Mentioned = true;
							if (strstr(pCaptureAnyScriptDesc, "<Sound1>") != 0) bSound1Mentioned = true;
							if (strstr(pCaptureAnyScriptDesc, "<Sound2>") != 0) bSound2Mentioned = true;
							if (strstr(pCaptureAnyScriptDesc, "<Sound3>") != 0) bSound3Mentioned = true;
							if (strstr(pCaptureAnyScriptDesc, "<Video Slot>") != 0) bVideoSlotMentioned = true;
							if (strstr(pCaptureAnyScriptDesc, "<If Used>") != 0) bIfUsedMentioned = true;
							if (strstr(pCaptureAnyScriptDesc, "<Shooting Weapon>") != 0) bShootingWeaponMentioned = true;
							if (strstr(pCaptureAnyScriptDesc, "<Melee Weapon>") != 0) bMeleeWeaponMentioned = true;
							if (strstr(pCaptureAnyScriptDesc, "<Soldier Animations>") != 0) iAnimationSetMentioned = 1;
							if (strstr(pCaptureAnyScriptDesc, "<Melee Animations>") != 0) iAnimationSetMentioned = 2;
							if (strstr(pCaptureAnyScriptDesc, "<Zombie Animations>") != 0) iAnimationSetMentioned = 3;
							if (strstr(pCaptureAnyScriptDesc, "<Default Animations>") != 0) iAnimationSetMentioned = 4;

							if (bVideoSlotMentioned == true) t.grideleprof.soundset1_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset1_s.Get(), "Video Slot", t.strarr_s[601].Get(), "videobank\\");
							if (bSound0Mentioned == true) t.grideleprof.soundset_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset_s.Get(), "Sound0", t.strarr_s[254].Get(), "audiobank\\");
							if (bSound1Mentioned == true) t.grideleprof.soundset1_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset1_s.Get(), "Sound1", t.strarr_s[254].Get(), "audiobank\\");
							if (bSound2Mentioned == true) t.grideleprof.soundset2_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset2_s.Get(), "Sound2", t.strarr_s[254].Get(), "audiobank\\");
							if (bSound3Mentioned == true) t.grideleprof.soundset3_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset3_s.Get(), "Sound3", t.strarr_s[254].Get(), "audiobank\\");
							if (bIfUsedMentioned == true) t.grideleprof.ifused_s = imgui_setpropertystring2(t.group, t.grideleprof.ifused_s.Get(), t.strarr_s[437].Get(), t.strarr_s[226].Get());
							if (bUseKeyMentioned == true) t.grideleprof.usekey_s = imgui_setpropertystring2(t.group, t.grideleprof.usekey_s.Get(), t.strarr_s[436].Get(), t.strarr_s[225].Get());
							bool readonly = false;
							if (bShootingWeaponMentioned == true || bMeleeWeaponMentioned == true)
							{
								if (t.entityprofile[t.gridentity].ischaracter == 1)
								{
									extern void animsystem_weaponproperty (int, bool, entityeleproftype*, bool, bool);
									animsystem_weaponproperty(t.entityprofile[t.gridentity].characterbasetype, readonly, &t.grideleprof, bShootingWeaponMentioned, bMeleeWeaponMentioned);
								}
							}
							if (iAnimationSetMentioned > 0)
							{
								extern void animsystem_animationsetproperty (int, bool, entityeleproftype*, int, int);
								animsystem_animationsetproperty(t.entityprofile[t.gridentity].characterbasetype, readonly, &t.grideleprof, iAnimationSetMentioned, -1);
							}
						}

						#ifdef WICKEDENGINE
						sObject* pObject = NULL;
						if( t.gridentityobj > 0) pObject = g_ObjectList[t.gridentityobj];
						if (ObjectExist(g.entitybankoffset + t.gridentity) == 1 && pObject )
						{
							if (ImGui::StyleCollapsingHeader("Materials", ImGuiTreeNodeFlags_DefaultOpen))
							{
								ImGui::Indent(10);
								if (!t.grideleprof.bCustomWickedMaterialActive) 
								{
									ImGui::Checkbox("Enable Custom Materials", &t.grideleprof.bCustomWickedMaterialActive);
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("This can break instancing and add additional draw calls");

									//PE: Copy master material settings to t.grideleprof.WEMaterial
									if (t.grideleprof.bCustomWickedMaterialActive) 
									{
										Wicked_Copy_Material_To_Grideleprof((void*)pObject, 0);
										t.grideleprof.WEMaterial.MaterialActive = true;
									}
									else 
									{
										t.grideleprof.WEMaterial.MaterialActive = false;
									}
								}
								else 
								{
									ImGui::Checkbox("Enable Custom Materials", &t.grideleprof.bCustomWickedMaterialActive);

									//sMesh * pMesh = NULL;
									Wicked_Change_Object_Material((void*)pObject, 0);
								}
								ImGui::Indent(-10);
							}
						}
						#endif

						// And finally the ADVANCED section
						bool bAdvencedOpen = false;
						if (g.vrqcontrolmode > 0) 
						{
							if(bUnfoldAdvanced)
								bAdvencedOpen = true;
							else if (ImGui::StyleCollapsingHeader("Advanced", adv_flasgs)) { //ImGuiTreeNodeFlags_None //ImGuiTreeNodeFlags_DefaultOpen
								bAdvencedOpen = true;
							}
						}
						else 
						{
							bAdvencedOpen = true;
						}
						if (bAdvencedOpen) 
						{
							t.group = 0;
							if (ImGui::StyleCollapsingHeader(t.strarr_s[412].Get(), ImGuiTreeNodeFlags_DefaultOpen)) 
							{
								if (bUnfoldAdvanced) 
								{
									//Display icon.
									if (t.entityprofile[iParentEntid].iThumbnailSmall > 0) 
									{
										float w = ImGui::GetWindowContentRegionWidth();
										ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (media_icon_size*0.5), 0.0f));
										ImGui::ImgBtn(t.entityprofile[iParentEntid].iThumbnailSmall, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
									}
								}
								if (bUnfoldAdvanced)
								{
									if (t.entityprofile[t.gridentity].ischaracter > 0)
									{
										//478 missing.
										//t.grideleprof.name_s = imgui_setpropertystring2(t.group, t.grideleprof.name_s.Get(), t.strarr_s[478].Get(), t.strarr_s[204].Get());
										t.grideleprof.name_s = imgui_setpropertystring2(t.group, t.grideleprof.name_s.Get(), "Name", t.strarr_s[204].Get());
									}
									else
									{
										if (t.entityprofile[t.gridentity].ismarker > 0)
										{
											if (t.entityprofile[t.gridentity].islightmarker > 0) {
												//483 missing.
												//t.grideleprof.name_s = imgui_setpropertystring2(t.group, t.grideleprof.name_s.Get(), t.strarr_s[483].Get(), t.strarr_s[204].Get());
												t.grideleprof.name_s = imgui_setpropertystring2(t.group, t.grideleprof.name_s.Get(), "Name", t.strarr_s[204].Get());
											}
											else {
												//479 missing.
												//t.grideleprof.name_s = imgui_setpropertystring2(t.group, t.grideleprof.name_s.Get(), t.strarr_s[479].Get(), t.strarr_s[204].Get());
												t.grideleprof.name_s = imgui_setpropertystring2(t.group, t.grideleprof.name_s.Get(), "Name", t.strarr_s[204].Get());
											}
										}
										else {
											//t.grideleprof.name_s = imgui_setpropertystring2(t.group, t.grideleprof.name_s.Get(), t.strarr_s[413].Get(), t.strarr_s[204].Get());
											t.grideleprof.name_s = imgui_setpropertystring2(t.group, t.grideleprof.name_s.Get(), "Name", t.strarr_s[204].Get());
										}
									}
								}

								if (t.entityprofile[t.gridentity].ismarker == 0 || t.entityprofile[t.gridentity].islightmarker == 1)
								{
									if (g.gentitytogglingoff == 0)
									{
										t.tokay = 1;
										if (ObjectExist(g.entitybankoffset + t.gridentity) == 1)
										{
											if (GetNumberOfFrames(g.entitybankoffset + t.gridentity) > 0)
											{
												t.tokay = 0;
											}
										}
										if (t.tokay == 1)
										{
											//PE: 414=Static Mode
											t.gridentitystaticmode = imgui_setpropertylist2(t.group, t.controlindex, Str(t.gridentitystaticmode), t.strarr_s[414].Get(), t.strarr_s[205].Get(), 0);
										}
									}
								}

								// 101016 - Additional General Parameters
								if (t.tflagchar == 0 && t.tflagvis == 1)
								{
									if (t.tflagsimpler == 0)
									{
										t.grideleprof.isocluder = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.isocluder), "Occluder", "Set to YES makes this object an occluder", 0); ++t.controlindex;
										t.grideleprof.isocludee = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.isocludee), "Occludee", "Set to YES makes this object an occludee", 0); ++t.controlindex;
									}
									// these will be back when EBE needs doors and windows
									//setpropertystring2(t.group,Str(t.grideleprof.parententityindex),"Parent Index","Selects another entity element to be a parent") ; ++t.controlindex;
									//setpropertystring2(t.group,Str(t.grideleprof.parentlimbindex),"Parent Limb","Specifies the limb index of the parent to connect with") ; ++t.controlindex;
								}

								// 281116 - added Specular Control per entity
								if (t.tflagvis == 1)
								{
									if (t.tflagsimpler == 0)
									{
										#ifdef WICKEDENGINE
										#else
										t.grideleprof.specularperc = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.specularperc), "Specular", "Set specular percentage to modulate entity specular effect"));
										#endif
									}
								}

								if (ImGui::IsAnyItemFocused()) {
									bImGuiGotFocus = true;
								}
							}

							int speech_entries = 0;
							//Add DLUA here id
							if (bUnfoldAdvanced && t.entityprofile[t.gridentity].ismarker > 1) {
								//ismarker = 1 has its own function.
								//DLUA support added here.
								bool bUpdateMainString = false;
								for (int speech_loop = 0; speech_loop < 5; speech_loop++)
									speech_ids[speech_loop] = -1;
								if (current_loaded_script != current_selected_script) {
									//Load in lua and check for custom properties.
									cstr script_name = "scriptbank\\";
									script_name += t.grideleprof.aimain_s;
									//Try to parse script.
									ParseLuaScript(&t.grideleprof, script_name.Get());
									current_loaded_script = current_selected_script;

									if (t.grideleprof.PropertiesVariableActive == 1) {
										bUpdateMainString = true;
										current_loaded_script_has_dlua = true;
									}
									else {
										if (current_loaded_script_has_dlua) {
											//Reset t.grideleprof.soundset4_s that contain the dlua calls.
											t.grideleprof.soundset4_s = "";
											current_loaded_script_has_dlua = false;
										}
									}

								}

								if (t.grideleprof.PropertiesVariableActive == 1 || t.grideleprof.PropertiesVariable.VariableDescription.Len() > 0)
								{
									if (ImGui::StyleCollapsingHeader("Behavior", ImGuiTreeNodeFlags_DefaultOpen)) {

										ImGui::Indent(10);

										if (t.grideleprof.PropertiesVariableActive == 1) {
											speech_entries = DisplayLuaDescription(&t.grideleprof);
										}
										else {
											if (t.grideleprof.PropertiesVariable.VariableDescription.Len() > 0) {
												DisplayLuaDescriptionOnly(&t.grideleprof);
											}
										}

										ImGui::Indent(-10);
									}
								}

								if (speech_entries > 0)
								{
									// all SPEECH control is moved to this function.
									SpeechControls(speech_entries, bUpdateMainString);
								}

							}

							t.group = 1;
							if (ImGui::StyleCollapsingHeader(t.strarr_s[415].Get(), ImGuiTreeNodeFlags_DefaultOpen))
							{
								//  Basic AI
								if (t.tflagai == 1)
								{
									// can redirect to better folders if in g.quickparentalcontrolmode
									LPSTR pAIRoot = "scriptbank\\";
									if (g.quickparentalcontrolmode == 2)
									{
										if (t.entityprofile[t.gridentity].ismarker == 0)
										{
											if (t.tflagchar == 1)
												pAIRoot = "scriptbank\\people\\";
											else
												pAIRoot = "scriptbank\\objects\\";
										}
										else
										{
											pAIRoot = "scriptbank\\markers\\";
										}
									}
									cstr tmpvalue;
									tmpvalue = imgui_setpropertyfile2(t.group, t.grideleprof.aimain_s.Get(), t.strarr_s[417].Get(), t.strarr_s[207].Get(), pAIRoot);
									if (t.grideleprof.aimain_s != tmpvalue) 
									{
										t.grideleprof.aimain_s = tmpvalue;
										current_loaded_script = -1;
									}
								}


								//  Has Weapon
								if (t.tflaghasweapon == 1 && t.playercontrol.thirdperson.enabled == 0 && g.quickparentalcontrolmode != 2)
								{
									t.grideleprof.hasweapon_s = imgui_setpropertylist2c(t.group, t.controlindex, t.grideleprof.hasweapon_s.Get(), t.strarr_s[419].Get(), t.strarr_s[209].Get(), 1);
								}

								//  Is Weapon (FPGC - 280809 - filtered fpgcgenre=1 is shooter genre)
								if (t.tflagweap == 1 && g.fpgcgenre == 1)
								{
									t.grideleprof.damage = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.damage), t.strarr_s[420].Get(), t.strarr_s[210].Get()));
									t.grideleprof.accuracy = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.accuracy), t.strarr_s[421].Get(), "Increases the inaccuracy of conical distribution by 1/100th of t.a degree"));
									if (t.grideleprof.weaponisammo == 0)
									{
										t.grideleprof.reloadqty = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.reloadqty), t.strarr_s[422].Get(), t.strarr_s[212].Get()));
										t.grideleprof.fireiterations = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.fireiterations), t.strarr_s[423].Get(), t.strarr_s[213].Get()));
										t.grideleprof.range = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.range), "Range", "Maximum range of bullet travel"));
										t.grideleprof.dropoff = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.dropoff), "Dropoff", "Amount in inches of vertical dropoff per 100 feet of bullet travel"));
									}
									else
									{
										t.grideleprof.lifespan = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.lifespan), t.strarr_s[424].Get(), t.strarr_s[214].Get()));
										t.grideleprof.throwspeed = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.throwspeed), t.strarr_s[425].Get(), t.strarr_s[215].Get()));
										t.grideleprof.throwangle = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.throwangle), t.strarr_s[426].Get(), t.strarr_s[216].Get()));
										t.grideleprof.bounceqty = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.bounceqty), t.strarr_s[427].Get(), t.strarr_s[217].Get()));
										t.grideleprof.explodeonhit = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.explodeonhit), t.strarr_s[428].Get(), t.strarr_s[218].Get(), 0);
									}
									if (t.tflagsimpler == 0)
									{
										t.grideleprof.usespotlighting = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.usespotlighting), "Spot Lighting", "Set whether emits dynamic spot lighting", 0);
									}
								}

								//  Is Character
								if (t.tflagchar == 1)
								{
									if (t.tflagsimpler == 0)
									{

										// 020316 - special check to avoid offering can take weapon if no HUD.X
										t.tfile_s = cstr("gamecore\\guns\\") + t.grideleprof.hasweapon_s + cstr("\\HUD.X");
										if (FileExist(t.tfile_s.Get()) == 1)
										{
											t.grideleprof.cantakeweapon = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.cantakeweapon), t.strarr_s[429].Get(), t.strarr_s[219].Get(), 0);
											//Take Weapon's Ammo
											cstr fieldname = t.strarr_s[430];
											if (fieldname == "Take Weapon's Ammo") fieldname = "Take Weapon Ammo"; //Need to be shorter.
											t.grideleprof.quantity = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.quantity), fieldname.Get() , t.strarr_s[220].Get()));
										}
										t.grideleprof.rateoffire = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.rateoffire), t.strarr_s[431].Get(), t.strarr_s[221].Get()));
									}
								}
								if (t.tflagquantity == 1 && g.quickparentalcontrolmode != 2)
								{
									t.grideleprof.quantity = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.quantity), t.strarr_s[432].Get(), t.strarr_s[222].Get()));
								}

								//  AI Extra
								if (t.tflagvis == 1 && t.tflagai == 1)
								{
									if (t.tflagchar == 1)
									{
										t.grideleprof.coneangle = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.coneangle), t.strarr_s[434].Get(), t.strarr_s[224].Get()));
										t.grideleprof.conerange = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.conerange), "View Range", "The range within which the AI may see the player. Zero triggers the characters default range."));
										t.grideleprof.ifused_s = imgui_setpropertystring2(t.group, t.grideleprof.ifused_s.Get(), t.strarr_s[437].Get(), t.strarr_s[226].Get());
										if (g.quickparentalcontrolmode != 2)
											t.grideleprof.isviolent = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.isviolent), "Blood Effects", "Sets whether blood and screams should be used", 0);
										if (t.tflagsimpler == 0)
										{
											t.grideleprof.colondeath = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.colondeath), "End Collision", "Set to NO switches off collision when die", 0);
										}
									}
									else
									{
										if (t.tflagweap == 0 && t.tflagammo == 0)
										{
											//t.propfield[t.group] = t.controlindex;
											//++t.group; startgroup(t.strarr_s[435].Get()); t.controlindex = 0;
											t.grideleprof.usekey_s = imgui_setpropertystring2(t.group, t.grideleprof.usekey_s.Get(), t.strarr_s[436].Get(), t.strarr_s[225].Get());
											if (t.tflagsimpler != 0 & t.entityprofile[t.gridentity].ismarker == 3 && t.entityprofile[t.gridentity].trigger.stylecolor == 1)
											{
												// only one level - no winzone chain option
											}
											else
											{
												t.grideleprof.ifused_s = imgui_setpropertystring2(t.group, t.grideleprof.ifused_s.Get(), t.strarr_s[437].Get(), t.strarr_s[226].Get());
											}
										}
									}
								}
								if (t.tflagifused == 1)
								{
									if (t.tflagusekey == 1)
									{
										t.grideleprof.usekey_s = imgui_setpropertystring2(t.group, t.grideleprof.usekey_s.Get(), t.strarr_s[436].Get(), t.strarr_s[225].Get());
									}
									if (t.tflagsimpler != 0 & t.entityprofile[t.gridentity].ismarker == 3 && t.entityprofile[t.gridentity].trigger.stylecolor == 1)
									{
										// only one level - no winzone chain option
									}
									else
									{
										t.grideleprof.ifused_s = imgui_setpropertystring2(t.group, t.grideleprof.ifused_s.Get(), t.strarr_s[438].Get(), t.strarr_s[227].Get());
									}
								}

							}

							if (t.tflagspawn == 1)
							{
								t.group = 1;
								if (ImGui::StyleCollapsingHeader(t.strarr_s[439].Get(), ImGuiTreeNodeFlags_DefaultOpen)) {

									t.grideleprof.spawnatstart = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.spawnatstart), t.strarr_s[562].Get(), t.strarr_s[563].Get(), 0);
									//     `setpropertystring2(group,Str(grideleprof.spawnmax),strarr$(440),strarr$(231)) ; inc controlindex
									//     `setpropertystring2(group,Str(grideleprof.spawnupto),strarr$(441),strarr$(232)) ; inc controlindex
									//     `setpropertylist2(group,controlindex,Str(grideleprof.spawnafterdelay),strarr$(442),strarr$(233),0) ; inc controlindex
									//     `setpropertylist2(group,controlindex,Str(grideleprof.spawnwhendead),strarr$(443),strarr$(234),0) ; inc controlindex
									//     `setpropertystring2(group,Str(grideleprof.spawndelay),strarr$(444),strarr$(235)) ; inc controlindex
									//     `setpropertystring2(group,Str(grideleprof.spawndelayrandom),strarr$(564),strarr$(565)) ; inc controlindex
									//     `setpropertystring2(group,Str(grideleprof.spawnqty),strarr$(445),strarr$(236)) ; inc controlindex
									//     `setpropertystring2(group,Str(grideleprof.spawnqtyrandom),strarr$(566),strarr$(567)) ; inc controlindex
									//     `setpropertystring2(group,Str(grideleprof.spawnvel),strarr$(568),strarr$(569)) ; inc controlindex
									//     `setpropertystring2(group,Str(grideleprof.spawnvelrandom),strarr$(570),strarr$(571)) ; inc controlindex
									//     `setpropertystring2(group,Str(grideleprof.spawnangle),strarr$(572),strarr$(573)) ; inc controlindex
									//     `setpropertystring2(group,Str(grideleprof.spawnanglerandom),strarr$(574),strarr$(575)) ; inc controlindex
									//     `setpropertystring2(group,Str(grideleprof.spawnlife),strarr$(576),strarr$(577)) ; inc controlindex

								}
							}


							//  Statistics
							if ((t.tflagvis == 1 || t.tflagobjective == 1 || t.tflaglives == 1 || t.tflagstats == 1) && t.tflagweap == 0 && t.tflagammo == 0)
							{
								t.group = 1;
								if (ImGui::StyleCollapsingHeader(t.strarr_s[451].Get(), ImGuiTreeNodeFlags_DefaultOpen)) {

									#ifdef VRTECH
									#else
										if (t.tflaglives == 1)
										{
										t.grideleprof.lives = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.lives), t.strarr_s[452].Get(), t.strarr_s[242].Get()));
										}
										if (t.tflagvis == 1 || t.tflagstats == 1)
										{
										if (t.tflaglives == 1)
										{
											t.grideleprof.strength = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.strength), t.strarr_s[453].Get(), t.strarr_s[243].Get()));
										}
										else
										{
											if (t.tflagnotionofhealth == 1)
											{
												t.grideleprof.strength = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.strength), t.strarr_s[454].Get(), t.strarr_s[244].Get()));
											}
										}
										if (t.tflagplayersettings == 1)
										{
											if (g.quickparentalcontrolmode != 2)
											{
												t.grideleprof.isviolent = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.isviolent), "Blood Effects", "Sets whether blood and screams should be used", 0);
											}
											if (t.tflagnotionofhealth == 1)
											{
												t.playercontrol.regenrate = atol(imgui_setpropertystring2(t.group, Str(t.playercontrol.regenrate), "Regeneration Rate", "Sets the increase value at which the players health will restore"));
												t.playercontrol.regenspeed = atol(imgui_setpropertystring2(t.group, Str(t.playercontrol.regenspeed), "Regeneration Speed", "Sets the speed in milliseconds at which the players health will regenerate"));
												t.playercontrol.regendelay = atol(imgui_setpropertystring2(t.group, Str(t.playercontrol.regendelay), "Regeneration Delay", "Sets the delay in milliseconds after last damage hit before health starts regenerating"));
											}
										}
										t.grideleprof.speed = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.speed), t.strarr_s[455].Get(), t.strarr_s[245].Get()));
										if (t.playercontrol.thirdperson.enabled == 1)
										{
											t.tanimspeed_f = t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed;
										}
										else
										{
											t.tanimspeed_f = t.grideleprof.animspeed;
										}
										//477 missing.
										//t.tanimspeed_f = atof(imgui_setpropertystring2(t.group, Str(t.tanimspeed_f), t.strarr_s[477].Get(), "Sets the default speed of any animation associated with this entity"));
										t.tanimspeed_f = atof(imgui_setpropertystring2(t.group, Str(t.tanimspeed_f), "Anim Speed", "Sets the default speed of any animation associated with this entity"));

										if (t.playercontrol.thirdperson.enabled == 1)
										{
											t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed = t.tanimspeed_f;
										}
										else
										{
											t.grideleprof.animspeed = t.tanimspeed_f;
										}

										}
										if (t.tflaghurtfall == 1) {
										t.grideleprof.hurtfall = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.hurtfall), t.strarr_s[456].Get(), t.strarr_s[246].Get()));
										}
									#endif
									if (t.tflagplayersettings == 1)
									{
										t.playercontrol.jumpmax_f = atof(imgui_setpropertystring2(t.group, Str(t.playercontrol.jumpmax_f), "Jump Speed", "Sets the jump speed of the player which controls overall jump height"));
										t.playercontrol.gravity_f = atof(imgui_setpropertystring2(t.group, Str(t.playercontrol.gravity_f), "Gravity", "Sets the modified force percentage of the players own gravity"));
										t.playercontrol.fallspeed_f = atof(imgui_setpropertystring2(t.group, Str(t.playercontrol.fallspeed_f), "Fall Speed", "Sets the maximum speed percentage at which the player will fall"));
										t.playercontrol.climbangle_f = atof(imgui_setpropertystring2(t.group, Str(t.playercontrol.climbangle_f), "Climb Angle", "Sets the maximum angle permitted for the player to ascend a slope"));
										if (t.playercontrol.thirdperson.enabled == 0)
										{
											t.playercontrol.wobblespeed_f = atof(imgui_setpropertystring2(t.group, Str(t.playercontrol.wobblespeed_f), "Wobble Speed", "Sets the rate of motion applied to the camera when moving"));
											t.playercontrol.wobbleheight_f = atof(imgui_setpropertystring2(t.group, Str(t.playercontrol.wobbleheight_f * 100), "Wobble Height", "Sets the degree of motion applied to the camera when moving")) / 100.0f;
											t.playercontrol.footfallpace_f = atof(imgui_setpropertystring2(t.group, Str(t.playercontrol.footfallpace_f * 100), "Footfall Pace", "Sets the rate at which the footfall sound is played when moving")) / 100.0f;
										}
										t.playercontrol.accel_f = atof(imgui_setpropertystring2(t.group, Str(t.playercontrol.accel_f * 100), "Acceleration", "Sets the acceleration curve used when t.moving from t.a stood position")) / 100.0f;
									}
									if (t.tflagmobile == 1) 
									{
										t.grideleprof.isimmobile = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.isimmobile), t.strarr_s[457].Get(), t.strarr_s[247].Get(), 0);
									}
									if (t.tflagmobile == 1)
									{
										if (t.tflagsimpler == 0)
										{
											t.grideleprof.lodmodifier = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.lodmodifier), "LOD Modifier", "Modify when the LOD transition takes effect. The default value is 0, increase this to a percentage reduce the LOD effect."));
										}
									}
								}
							}

							//  Team field
#ifdef PHOTONMP
#else
							if (t.tflagteamfield == 1)
							{
								//							setpropertylist3(t.group, t.controlindex, Str(t.grideleprof.teamfield), "Team", "Specifies any team affiliation for multiplayer start marker", 0); ++t.controlindex;
							}
#endif



							//  Physics Data (non-multiplayer)
							if (t.entityprofile[t.gridentity].ismarker == 0 && t.entityprofile[t.gridentity].islightmarker == 0)
							{
								//t.propfield[t.group] = t.controlindex;
								//++t.group; startgroup(t.strarr_s[596].Get()); t.controlindex = 0;
								t.group = 1;
								if (ImGui::StyleCollapsingHeader(t.strarr_s[596].Get(), ImGuiTreeNodeFlags_DefaultOpen)) {

									if (t.grideleprof.physics != 1)  t.grideleprof.physics = 0;
									t.grideleprof.physics = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.physics), t.strarr_s[580].Get(), t.strarr_s[581].Get(), 0);
									t.grideleprof.phyalways = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.phyalways), t.strarr_s[582].Get(), t.strarr_s[583].Get(), 0);
									t.grideleprof.phyweight = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.phyweight), t.strarr_s[584].Get(), t.strarr_s[585].Get()));
									t.grideleprof.phyfriction = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.phyfriction), t.strarr_s[586].Get(), t.strarr_s[587].Get()));
									//     `setpropertystring2(group,Str(grideleprof.phyforcedamage),strarr$(588),strarr$(589)) ; inc controlindex
									//     `setpropertystring2(group,Str(grideleprof.rotatethrow),strarr$(590),strarr$(591)) ; inc controlindex
									if (t.tflagsimpler == 0)
									{
										t.grideleprof.explodable = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.explodable), t.strarr_s[592].Get(), t.strarr_s[593].Get(), 0);
										t.grideleprof.explodedamage = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.explodedamage), t.strarr_s[594].Get(), t.strarr_s[595].Get()));
									}
								}
							}

							//  Ammo data (FPGC - 280809 - filtered fpgcgenre=1 is shooter genre
							if (g.fpgcgenre == 1)
							{
								if (t.tflagammo == 1 || t.tflagammoclip == 1)
								{
									if (ImGui::StyleCollapsingHeader(t.strarr_s[459].Get(), ImGuiTreeNodeFlags_DefaultOpen)) {
										t.grideleprof.quantity = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.quantity), t.strarr_s[460].Get(), t.strarr_s[249].Get()));
									}

								}
							}

							//  Light data
							if (t.tflaglight == 1)
							{
								if (ImGui::StyleCollapsingHeader(t.strarr_s[461].Get(), ImGuiTreeNodeFlags_DefaultOpen)) {
									t.grideleprof.light.range = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.light.range), t.strarr_s[462].Get(), t.strarr_s[250].Get())); //PE: 462=Light Range
										
									ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
									ImGui::Text(t.strarr_s[463].Get());
									ImGui::SameLine();
									ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
									ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
									ImGui::PushItemWidth(-10);

									float colors[5];
									colors[3] = ((t.grideleprof.light.color & 0xff000000) >> 24) / 255.0f;
									colors[0] = ((t.grideleprof.light.color & 0x00ff0000) >> 16) / 255.0f;
									colors[1] = ((t.grideleprof.light.color & 0x0000ff00) >> 8) / 255.0f;
									colors[2] = (t.grideleprof.light.color & 0x000000ff) / 255.0f;
									ImGui::ColorEdit3("##LightColorSetupField", colors, 0);
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", t.strarr_s[251].Get());
									colors[0] *= 255.0f;
									colors[1] *= 255.0f;
									colors[2] *= 255.0f;
									colors[3] *= 255.0f;
									t.grideleprof.light.color = 0xff000000 + ((unsigned int)colors[0] << 16) + ((unsigned int)colors[1] << 8) + +((unsigned int)colors[2]);

									ImGui::PopItemWidth();

									//setpropertycolor2(t.group, t.grideleprof.light.color, t.strarr_s[463].Get(), t.strarr_s[251].Get()); ++t.controlindex; //PE: 463=Light Color
									if (t.tflagsimpler == 0)
									{
										t.grideleprof.usespotlighting = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.usespotlighting), "Spot Lighting", "Change dynamic light to spot lighting", 0);
									}
								}
							}

							//  Decal data
							if (t.tflagtdecal == 1)
							{
								t.propfield[t.group] = t.controlindex;

								//  FPGC - 300710 - could never change base decal, so comment out this property (entity denotes decal choice)
								//     `inc group ; startgroup(strarr$(464)) ; controlindex=0
								//     `setpropertyfile2(group,grideleprof.basedecal$,strarr$(465),strarr$(252),"gamecore\\decals\\") ; inc controlindex

								//  Decal Particle data
								if (t.tflagdecalparticle == 1)
								{
									//++t.group; startgroup("Decal Particle"); t.controlindex = 0;
									if (ImGui::StyleCollapsingHeader("Decal Particle", ImGuiTreeNodeFlags_DefaultOpen)) {

										t.grideleprof.particleoverride = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.particleoverride), "Custom Settings", "Whether you wish to override default settings", 0);
										t.grideleprof.particle.offsety = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.offsety), "OffsetY", "Vertical adjustment of start position"));
										t.grideleprof.particle.scale = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.scale), "Scale", "A value from 0 to 100, denoting size of particle"));
										t.grideleprof.particle.randomstartx = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.randomstartx), "Random Start X", "Random start area"));
										t.grideleprof.particle.randomstarty = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.randomstarty), "Random Start Y", "Random start area"));
										t.grideleprof.particle.randomstartz = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.randomstartz), "Random Start Z", "Random start area"));
										t.grideleprof.particle.linearmotionx = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.linearmotionx), "Linear Motion X", "Constant motion direction"));
										t.grideleprof.particle.linearmotiony = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.linearmotiony), "Linear Motion Y", "Constant motion direction"));
										t.grideleprof.particle.linearmotionz = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.linearmotionz), "Linear Motion Z", "Constant motion direction"));
										t.grideleprof.particle.randommotionx = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.randommotionx), "Random Motion X", "Random motion direction"));
										t.grideleprof.particle.randommotiony = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.randommotiony), "Random Motion Y", "Random motion direction"));
										t.grideleprof.particle.randommotionz = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.randommotionz), "Random Motion Z", "Random motion direction"));
										t.grideleprof.particle.mirrormode = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.mirrormode), "Mirror Mode", "Set to one to reverse the particle"));
										t.grideleprof.particle.camerazshift = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.camerazshift), "Camera Z Shift", "Shift t.particle towards camera"));
										t.grideleprof.particle.scaleonlyx = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.scaleonlyx), "Scale Only X", "Percentage X over Y scale"));
										t.grideleprof.particle.lifeincrement = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.lifeincrement), "Life Increment", "Control lifespan of particle"));
										t.grideleprof.particle.alphaintensity = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.particle.alphaintensity), "Alpha Intensity", "Control alpha percentage of particle"));
										//  V118 - 060810 - knxrb - Decal animation setting (Added animation choice setting).
										t.grideleprof.particle.animated = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.particle.animated), "Animated Particle", "Sets whether the t.particle t.decal Texture is animated or static.", 0);
									}
								}
							}

							// moved Particle to main

							// Sound
							if (t.tflagsound == 1 || t.tflagsoundset == 1 || tflagtext == 1 || tflagimage == 1)
							{
								cstr group_text;
								if (tflagtext == 1 || tflagimage == 1)
								{
									if (tflagtext == 1) group_text = "Text";
									if (tflagimage == 1) group_text = "Image";
								}
								else
								{
									group_text = "Media";
								}
									
								if (speech_entries > 0)
								{
								}

								if (ImGui::StyleCollapsingHeader(group_text.Get(), ImGuiTreeNodeFlags_DefaultOpen))
								{
									if (g.fpgcgenre == 1)
									{
										if (t.entityprofile[t.gridentity].ischaracter > 0) 
										{
											t.grideleprof.soundset_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset_s.Get(), "Sound0", t.strarr_s[254].Get(), "audiobank\\");
										}
										else 
										{
											if (g.vrqcontrolmode != 0)
											{
												if (t.tflagsound == 1 && t.tflagsoundset != 1) 
												{
													//PE: changed from 469 to 467 , should be sound0
													t.grideleprof.soundset_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\");
												}
											}
											else
											{
												if (t.tflagsound == 1 && t.tflagsoundset != 1) 
												{
													t.grideleprof.soundset_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\");
												}
											}
											if (t.tflagsoundset == 1) 
											{
												t.grideleprof.soundset_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset_s.Get(), t.strarr_s[469].Get(), t.strarr_s[255].Get(), "audiobank\\voices\\");
											}
											if (tflagtext == 1) 
											{
												t.grideleprof.soundset_s = imgui_setpropertystring2(t.group, t.grideleprof.soundset_s.Get(), "Text to Appear", "Enter text to appear in-game");
											}
											if (tflagimage == 1) 
											{
												t.grideleprof.soundset_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset_s.Get(), "Image File", "Select image to appear in-game", "scriptbank\\images\\imagesinzone\\");
											}
										}

										if (t.tflagnosecond == 0)
										{
											if (t.tflagsound == 1 || t.tflagsoundset == 1)
											{
												//We got some missing translations.
												if (t.strarr_s[468] == "") t.strarr_s[468] = "Sound1";
												if (t.strarr_s[480] == "") t.strarr_s[480] = "Sound2";
												if (t.strarr_s[481] == "") t.strarr_s[481] = "Sound3";
												if (t.strarr_s[482] == "") t.strarr_s[482] = "Sound4";
												t.grideleprof.soundset1_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset1_s.Get(), t.strarr_s[468].Get(), t.strarr_s[254].Get(), "audiobank\\");
												t.grideleprof.soundset2_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset2_s.Get(), t.strarr_s[480].Get(), t.strarr_s[254].Get(), "audiobank\\");
												t.grideleprof.soundset3_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset3_s.Get(), t.strarr_s[481].Get(), t.strarr_s[254].Get(), "audiobank\\");
												t.grideleprof.soundset5_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset5_s.Get(), t.strarr_s[482].Get(), t.strarr_s[254].Get(), "audiobank\\");
												t.grideleprof.soundset6_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset6_s.Get(), "Sound5", t.strarr_s[254].Get(), "audiobank\\");
											}
										}
									}
									else
									{
										if (t.tflagsoundset == 1)
										{
											t.grideleprof.soundset_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset_s.Get(), t.strarr_s[469].Get(), t.strarr_s[255].Get(), "audiobank\\voices\\");
										}
										else
										{
											t.grideleprof.soundset_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\"); ++t.controlindex;
										}
										t.grideleprof.soundset1_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset1_s.Get(), t.strarr_s[468].Get(), t.strarr_s[254].Get(), "audiobank\\"); ++t.controlindex;
									}
								}
							}

							// Video
							if (t.tflagvideo == 1)
							{
								if (ImGui::StyleCollapsingHeader(t.strarr_s[597].Get(), ImGuiTreeNodeFlags_DefaultOpen)) {

									//t.grideleprof.soundset_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[599].Get(), "audiobank\\");
									t.grideleprof.soundset1_s = imgui_setpropertyfile2(t.group, t.grideleprof.soundset1_s.Get(), "Video Slot", t.strarr_s[601].Get(), "videobank\\");
								}
							}

							//  Third person settings
							if (t.tflagplayersettings == 1 && t.playercontrol.thirdperson.enabled == 1)
							{
								if (ImGui::StyleCollapsingHeader("Third Person", ImGuiTreeNodeFlags_DefaultOpen)) {

									t.livegroupforthirdperson = t.group;
									t.playercontrol.thirdperson.cameralocked = imgui_setpropertylist2(t.group, t.controlindex, Str(t.playercontrol.thirdperson.cameralocked), "Camera Locked", "Fixes camera height and angle for third person view", 0);
									t.playercontrol.thirdperson.cameradistance = atol(imgui_setpropertystring2(t.group, Str(t.playercontrol.thirdperson.cameradistance), "Camera Distance", "Sets the distance of the third person camera"));
									t.playercontrol.thirdperson.camerashoulder = atol(imgui_setpropertystring2(t.group, Str(t.playercontrol.thirdperson.camerashoulder), "Camera X Offset", "Sets the distance to shift the camera over shoulder"));
									t.playercontrol.thirdperson.cameraheight = atol(imgui_setpropertystring2(t.group, Str(t.playercontrol.thirdperson.cameraheight), "Camera Y Offset", "Sets the vertical height of the third person camera. If more than twice the camera distance, camera collision disables"));
									t.playercontrol.thirdperson.camerafocus = atol(imgui_setpropertystring2(t.group, Str(t.playercontrol.thirdperson.camerafocus), "Camera Focus", "Sets the camera X angle offset to align focus of the third person camera"));
									t.playercontrol.thirdperson.cameraspeed = atol(imgui_setpropertystring2(t.group, Str(t.playercontrol.thirdperson.cameraspeed), "Camera Speed", "Sets the retraction speed percentage of the third person camera"));
									t.playercontrol.thirdperson.camerafollow = imgui_setpropertylist2(t.group, t.controlindex, Str(t.playercontrol.thirdperson.camerafollow), "Run Mode", "If set to yes, protagonist uses WASD t.movement mode", 0);
									t.playercontrol.thirdperson.camerareticle = imgui_setpropertylist2(t.group, t.controlindex, Str(t.playercontrol.thirdperson.camerareticle), "Show Reticle", "Show the third person 'crosshair' reticle Dot ( ", 0);
								}
							}

						}
					} //Advenced open


					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
					}


					ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
					if (ImGui::IsMouseHoveringRect(bbwin.Min, bbwin.Max))
					{
						bImGuiGotFocus = true;
					}
					if (ImGui::IsAnyItemFocused()) {
						bImGuiGotFocus = true;
					}
				}
//					ImGui::Text("iParentEntid: %ld pEIndex: %ld", iParentEntid, t.widget.pickedEntityIndex );
				ImGui::PopItemWidth();
				ImGui::SetWindowFontScale(1.0);

				ImGui::EndChild();

				CheckMinimumDockSpaceSize(250.0f);

				ImGui::End();

				if(!bEntity_Properties_Window) //Window closed.
					iOldPickedEntityIndex = -1;

				if (t.inputsys.mclick == 1 && ImGui::IsWindowHovered()) {
					//Click start , block until mouse is release.
					bProperties_Window_Block_Mouse = true;
				}

			}
			else {
				iOldPickedEntityIndex = -1;
			}
		}
		else 
		{
			//PRoperties closed , check if we need to exit zoommode.
			if (t.gridentityinzoomview > 0) 
			{
				t.tpressedtoleavezoommode = 2; //Exit zoom and save.
				if (t.grideditselect < 3 || t.grideditselect > 4) 
				{
					//Make sure to exit fast.
					int igridentity = t.gridentity;

					if( iOldgridentity != t.gridentity && iOldgridentity > -1)
						t.gridentity = iOldgridentity;

					int olges = t.grideditselect;
					t.grideditselect = 4;
					editor_viewfunctionality();
					t.grideditselect = olges;
					t.gridentity = igridentity;
				}
			}

			//PE: Bug if open properties, close and delete object, then add object and properties, failed and use old id.
			iOldPickedEntityIndex = -1;
		}


		//####################################
		//#### Procedural Level Generator ####
		//####################################

		#ifdef PROCEDURALTERRAINWINDOW
		//No resetting needed fixed.
		void procedural_new_level(void);
		procedural_new_level();
		#endif

		//###########################
		//#### External Entities ####
		//###########################

		static std::map<std::string, std::int32_t> entity_folders;
#ifdef WICKEDENGINE
		//if (refresh_gui_docking == 0) ImGui::SetNextWindowPos(viewPortPos + ImVec2(280, 140), ImGuiCond_Always); //ImGuiCond_FirstUseEver
//		if (refresh_gui_docking == 0 || bResetObjectLibrarySize) ImGui::SetNextWindowSize(ImVec2(68 * ImGui::GetFontSize(), (39 * ImGui::GetFontSize()) + 12.0), ImGuiCond_Always); //ImGuiCond_FirstUseEver
		//PE: Exactly fit for 9 normal object, and 6 that include dlua description.
		if (refresh_gui_docking == 0 || bResetObjectLibrarySize) ImGui::SetNextWindowSize(ImVec2(66 * ImGui::GetFontSize(), (43 * ImGui::GetFontSize()) + 19.0), ImGuiCond_Always); //ImGuiCond_FirstUseEver
		if (refresh_gui_docking == 0 || bResetObjectLibrarySize) ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
		if (refresh_gui_docking == 0) init_Left_Categories_Column_Width = 3;
#else
		if (refresh_gui_docking == 0) ImGui::SetNextWindowPos(viewPortPos + ImVec2(180, 140), ImGuiCond_Always); //ImGuiCond_FirstUseEver
		if (refresh_gui_docking == 0) ImGui::SetNextWindowSize(ImVec2(54 * ImGui::GetFontSize(), 33 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver
#endif
		ImGuiWindowFlags ex_window_flags = 0;
		if (refresh_gui_docking == 0 && !bExternal_Entities_Window)
		{
			ImGui::Begin("##Object Library ExternalWindow", &bExternal_Entities_Window, ex_window_flags);
			ImGui::End();
		}
		#ifdef WICKEDENGINE
		if (refresh_gui_docking <= 2 )
			pref.iSetColumnsEntityLib = 3;
		#endif

		#ifdef WICKEDENGINE
		#ifdef USENEWLIBRARY
		process_entity_library_v2();
		#else
		process_entity_library();
		#endif
		#else
		process_entity_library();
		#endif

		// collect an entire list of all relevant filders (entitybank, scriptbank, images, particles, etc)
		mapeditorexecutable_full_folder_refresh();

		//Display thread progress , Debug
		//if(fpe_thread_in_progress())
		//{
		//	sprintf(cTriggerMessage, "Scanning %d", g_iScannedFiles);
		//	bTriggerMessage = true;
		//}

		#endif
		//########################
		//#### Level Entities ####
		//########################

		#ifdef WICKEDENGINE
		if (iDragDropActive > 0)
			iDragDropActive--;

		//PE: V2SEARCHBAR will display the new search layout.
		#define V2SEARCHBAR

		#endif

		if (refresh_gui_docking == 0) 
		{
			//ImGuiWindowFlags_NoDocking
			bool bOpen = true;
			ImGui::Begin(TABENTITYNAME, &bOpen, iGenralWindowsFlags);
			ImGui::End();
			ImGui::Begin("Current Objects##AdditionalIconsWindow", &bOpen, iGenralWindowsFlags);
			ImGui::End();
		}
		if (refresh_gui_docking > 0) 
		{
			bool bToolTipActive = true;
			#ifdef WICKEDENGINE
			if (pref.iEnableDragDropEntityMode && bDraggingActive)
			{
				if (t.gridentity != 0 || t.gridentityobj != 0)
				{
					bToolTipActive = false;
				}
			}
			if (bTrashcanIconActive || bTrashcanIconActive2)
				bToolTipActive = false;
			#endif

			int iWinFlags = 0;
			bool bAlwaysOpen = true;
			ImGui::Begin(TABENTITYNAME, &bAlwaysOpen, iGenralWindowsFlags | ImGuiWindowFlags_NoScrollbar); //, &bAlwaysOpen, iWinFlags);
			static char cSearchEntities[1024] = "\0";

			ImGui::BeginChild("##ChirlEntitiesLeftPanel", ImVec2(ImGui::GetWindowSize().x - 2.0f, fsy*2.0), false, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoNavInputs); //ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar

			ImGui::PushItemWidth(-1);

			CheckTutorialAction("+##+", 8.0f); //Tutorial: check if we are waiting for this action

			#ifdef WICKEDENGINE
			#ifdef V2SEARCHBAR
			//PE: We need more room in this setup.
			if (ImGui::StyleButton("Add##+", ImVec2(ImGui::GetWindowSize().x *0.25, fsy*1.5)))
			#else
			if (ImGui::StyleButton("Add##+", ImVec2(ImGui::GetWindowSize().x *0.333, fsy*1.5)))
			#endif
			#else
			if (ImGui::StyleButton("+##+", ImVec2(ImGui::GetWindowSize().x *0.5, fsy*1.5)))
			#endif
			{
				if ( 1 )
				{
					if (bTutorialCheckAction) TutorialNextAction(); //Clicked get next tutorial action.

					//Open Add item page.
					//Clear any selection marks.
					cFolderItem *pSearchFolder = &MainEntityList;
					pSearchFolder = pSearchFolder->m_pNext;
					while (pSearchFolder) {
						if (pSearchFolder->m_pFirstFile) {
							cFolderItem::sFolderFiles * searchfiles = pSearchFolder->m_pFirstFile->m_pNext;
							while (searchfiles) {
								searchfiles->iFlags = 0;
								searchfiles = searchfiles->m_pNext;
							}
						}
						pSearchFolder = pSearchFolder->m_pNext;
					}

					bExternal_Entities_Window = true;
					iDisplayLibraryType = 0;
					iDisplayLibrarySubType = 0;
				}
			}
			if (bToolTipActive && ImGui::IsItemHovered()) ImGui::SetTooltip("Click here to add a new object to the game level");

		
			ImGui::SameLine();
			ImGui::PopItemWidth();

			//	Display info icon to give user more information on adding objects to the level.
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(-6.0, 0));
			if (ImGui::ImgBtn(ICON_INFO, ImVec2(ImGui::GetFontSize(), ImGui::GetFontSize()), ImColor(0, 0, 0, 0), ImColor(220, 220, 220, 220), ImColor(255, 255, 255, 255),
				ImColor(180, 180, 160, 255), -1, 0, 0, 0, false, false, false, false, false))
			{
				bInfo_Window = true;
				cInfoMessage = "By pressing the Add button, you can browse the object library to choose game objects that you would like to add to your game level. You also have the option to import your own models or even create your own character with the built in character creator.";
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Click here to learn how to add objects to your level.");

			ImGui::PushItemWidth(-1);

			//	ImGui::Begin("Information##AddObjectInformation", &bInformationWindow);
		
				////	Display the tutorial on adding objects to the world (not yet implemented).
				//if (GetImageExistEx(INFOIMAGE))
				//{
				//	float fRegionWidth = ImGui::GetContentRegionAvailWidth();
				//	float img_w = ImageWidth(INFOIMAGE);
				//	float img_h = ImageHeight(INFOIMAGE);
				//	float fRatio = img_h / img_w;
				//	ImGui::ImgBtn(INFOIMAGE, ImVec2(fRegionWidth, fRegionWidth*fRatio), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0),
				//		ImVec4(1.0, 1.0, 1.0, 1.0), 0, 0, 0, 0, false);
				//}
				
				//ImGui::End();

			
			
			
			ImGui::PopItemWidth();
			ImGui::SameLine();
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(-6.0, 0));

			float fDropDownWidth = 0.0f;
			#ifdef WICKEDENGINE
			fDropDownWidth = 34.0f;
			#endif
			ImGui::PushItemWidth(-6 - fDropDownWidth);
			window = ImGui::GetCurrentWindow();

			ImVec2 current_pos = ImGui::GetCursorPos();
			float current_item_width = ImGui::GetItemRectSize().x;

			#ifdef V2SEARCHBAR
			//ImGuiStyle& style = ImGui::GetStyle();
			float fOldSpacing = style.FramePadding.x;
			style.FramePadding.x = 22.0; //Make room for search icon.
			ImVec2 vSearchPos = ImGui::GetCursorPos();
			#endif

			ImVec2 search_icon_pos = window->DC.CursorPos + ImVec2(ImGui::GetContentRegionAvailWidth() - 10.0 - 16.0 - fDropDownWidth,2.0f);
			ImGui::SetItemAllowOverlap();
			// Force the keyboard focus to the input text field when the user presses the clear search button (set below).
			static bool bSetKeyboardFocus = false;
			if (bSetKeyboardFocus)
			{
				ImGui::SetKeyboardFocusHere(0);
				bSetKeyboardFocus = false;
			}
			if (ImGui::InputText(" ##cSearchEntities", &cSearchEntities[0], MAX_PATH, ImGuiInputTextFlags_EnterReturnsTrue))
			{
				if (strlen(cSearchEntities) > 1)
				{
					bool already_there = false;
					for (int l = 0; l < MAXSEARCHHISTORY; l++) {
						if (strcmp(cSearchEntities, pref.small_search_history[l]) == 0) {
							already_there = true;
							break;
						}
					}
					if (!already_there) {
						bool foundspot = false;
						for (int l = 0; l < MAXSEARCHHISTORY; l++) {
							if (strlen(pref.small_search_history[l]) <= 0) {
								strcpy(pref.small_search_history[l], cSearchEntities);
								foundspot = true;
								break;
							}
						}
						if (!foundspot) {
							//Move entry list.
							for (int l = 0; l < MAXSEARCHHISTORY; l++) {
								strcpy(pref.small_search_history[l], pref.small_search_history[l + 1]);
							}
							strcpy(pref.small_search_history[MAXSEARCHHISTORY - 1], cSearchEntities);
						}
					}
				}

			}
			if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered() && bToolTipActive ) ImGui::SetTooltip("%s", "Type here to search for an object in your level");
			if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

			ImGui::PopItemWidth();
			ImGui::SameLine();

			ImVec2 restore_pos = ImGui::GetCursorPos();
			current_pos.y = ImGui::GetCursorPosY();

			#ifdef V2SEARCHBAR
			style.FramePadding.x = fOldSpacing;
			//Only display closebut if we have room.
			if (restore_pos.x > 110 ) // ? not sure if we only activate after search begin ? && strlen(cSearchEntities) > 0
			{
				ImGui::SetItemAllowOverlap();
				if (ImGui::CloseButton(ImGui::GetCurrentWindow()->GetID("#ClearSearchv2"), ImGui::GetWindowPos() + ImGui::GetCursorPos() + ImVec2(-38, 0)))
				{
					strcpy(cSearchEntities, "");
					bSetKeyboardFocus = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Clear search");
				ImGui::SameLine();
			}
			#endif

			static bool bSearchWinToggle = false;
			bool search_img_hovered = false, search_img_held = false;
			void* lpTexture = GetImagePointer(TOOL_ENT_SEARCH);
			if (lpTexture)
			{
				ImGui::SetItemAllowOverlap();
				#ifdef V2SEARCHBAR
				ImVec2 search_icon_pos = ImGui::GetWindowPos() + vSearchPos + ImVec2(3.0, 3.0);
				#endif
				ImRect bb(search_icon_pos, search_icon_pos + ImVec2(16, 16));
				ImGui::PushID(TOOL_ENT_SEARCH);
				const ImGuiID id = window->GetID("#image");
				ImGui::PopID();
				ImGui::ItemSize(bb);
				if (ImGui::ItemAdd(bb, id)) {
					bool pressed = ImGui::ButtonBehavior(bb, id, &search_img_hovered, &search_img_held);
					if (pressed) {
						bSearchWinToggle = 1 - bSearchWinToggle;
					}
					if (ImGui::IsItemHovered()) {
						ImGui::SetMouseCursor(ImGuiMouseCursor_Arrow);
					}
					ImGuiWindow* window = ImGui::GetCurrentWindow();
					window->DrawList->AddImage((ImTextureID)lpTexture, search_icon_pos, search_icon_pos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
				}
			}

			if (bSearchWinToggle)
			{
				//Do we have a search history.
				bool display_history = true; //false;
				//for (int l = 0; l < MAXSEARCHHISTORY; l++) {
				//	if (strlen(pref.small_search_history[l]) > 0) {
				//		display_history = true;
				//		break;
				//	}
				//}
				if (display_history)
				{
					ImGui::SameLine();
					//ImGui::SetCursorPos(current_pos);
					
					ImGui::SetNextWindowPos(ImGui::GetWindowPos() + current_pos);
					//ImGui::SetNextWindowSize({ current_item_width, 0 });
					if (ImGui::Begin("##searchselectpopup", &bSearchWinToggle, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_Tooltip )) //| ImGuiWindowFlags_Tooltip
					{
						#ifndef V2SEARCHBAR
						if( ImGui::StyleButton("Clear Search Field",ImVec2(ImGui::GetContentRegionAvailWidth(),0.0f) ) )
						{
							strcpy(cSearchEntities, "");
							bSearchWinToggle = false;
						}
						ImGui::Separator();
						#endif

						//ImGui::Indent(10);
						for (int l = 0; l < MAXSEARCHHISTORY; l++) {
							if (strlen(pref.small_search_history[l]) > 0) {
								bool is_selected = false;
								if (ImGui::Selectable(pref.small_search_history[l], is_selected)) {
									strcpy(cSearchEntities, pref.small_search_history[l]);
									bSearchWinToggle = false;
								}
								//if (is_selected)
								//	ImGui::SetItemDefaultFocus();
							}
						}
						//ImGui::Indent(-10);
					}
					ImGui::End();
				}
			}

			ImGui::SetCursorPos(current_pos);

			if (!search_img_hovered)
			{
				if (ImGui::IsMouseReleased(0)) //ImGui::IsAnyMouseDown())
				{
					bSearchWinToggle = false;
				}
			}

			//if (strlen(cSearchEntities) > 0) {
			//}
#ifdef WICKEDENGINE
			ImGui::SetCursorPos(ImVec2(restore_pos.x-8.0f, restore_pos.y));
			const char* sortby_modes[] = { "A-Z", "Z-A","Newest", "Oldest", "Detailed Object List" };

			int isortbySize = IM_ARRAYSIZE(sortby_modes);
			#ifdef ADD_DETAIL_LEFT_PANEL_ENTITY_LIST
			if (!pref.iEnableAdvancedEntityList)
				isortbySize--;
			#else
				isortbySize--;
			#endif

			int comboflags = ImGuiComboFlags_NoPreview | ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge;
			ImGui::PushItemWidth(-24);
			if (ImGui::BeginCombo("##combosortbymodesentotyleft", sortby_modes[current_sort_order], comboflags))
			{
				for (int n = 0; n < isortbySize; n++)
				{
					bool is_selected = (current_sort_order == n);
					if (ImGui::Selectable(sortby_modes[n], is_selected)) {
						current_sort_order = n;
					}
					if (is_selected)
						ImGui::SetItemDefaultFocus();
				}

				ImGui::EndCombo();
			}
#endif
			//ImGui::PopItemWidth();
			

			ImGui::EndChild();

			ImVec2 content_avail = ImVec2(0.0, 0.0);
			#ifdef WICKEDENGINE
			#ifdef NEWGAMEELEMENTGRID
			
			content_avail = ImGui::GetContentRegionAvail();
			content_avail.y -= fsy * 3.0;
			if (content_avail.y < fsy) content_avail.y = fsy;
			
			// Size of icons.
			int entity_icons = 12, entity_icons_columns = 6;
			float entity_w = ImGui::GetContentRegionAvailWidth() - 10.0f;
			float fSpacer = 0.0f;
			float entity_image_size = entity_w / (float)entity_icons_columns;
			entity_image_size -= ((1.125f) * entity_icons_columns);
			if (entity_w > 360)
			{
				//Switch to 12 per row.
				entity_icons_columns = 12;
				entity_image_size = entity_w / (float)entity_icons_columns;
				entity_image_size -= 7.5f;
			}
			
			#else
			//PE: This should always run when we dont have the old "help button".
			//if (!pref.bHideTutorials)
			{
				content_avail = ImGui::GetContentRegionAvail();
				content_avail.y -= fsy * 3.0;
				if (content_avail.y < fsy) content_avail.y = fsy;
			}

			int entity_icons = 10, entity_icons_columns = 6;// 4;
			float entity_w = ImGui::GetContentRegionAvailWidth() - 10.0f;
			float fSpacer = 0.0f;
			//New icons.
			float entity_image_size = entity_w / (float)entity_icons_columns;
			entity_image_size -= ((2.0f) * entity_icons_columns) - 2.0f;
			if (entity_w > 320)
			{
				//Switch to 10 per row.
				entity_icons_columns = 10;
				entity_image_size = entity_w / (float)entity_icons_columns;
				entity_image_size -= ((1.0f) * entity_icons_columns) - 2.0f;
			}
			if (entity_w < 100)
			{
				//Switch to 10 per row.
				entity_icons_columns = 2;
				entity_image_size = entity_w / (float)entity_icons_columns;
				entity_image_size -= ((5.0f) * entity_icons_columns) - 2.0f;
			}
			#endif
			

			//PE: New object tool icons.
			#ifdef INCLUDELEFTENTITYTOOLICONS
			if (1) // t.grideditselect == 5)
			{
				#ifdef NEWGAMEELEMENTGRID
				if (content_avail.x <= 1)
				{
					content_avail = ImGui::GetContentRegionAvail();
					content_avail.y -= (fsy*0.5);
				}
				
				content_avail.y -= 3.0f;
				content_avail.y -= ((entity_w / entity_icons_columns) * (entity_icons / entity_icons_columns));
				content_avail.y -= 10.0f;

				#else
				if (content_avail.x <= 1)
				{
					content_avail = ImGui::GetContentRegionAvail();
					content_avail.y -= (fsy*0.5);
				}
				if (Shooter_Tools_Window)
				{
					//int shooter_icons = 5, shooter_icons_columns = 5;
					//PE: New design display 15 icons.
					content_avail.y -= 3.0f;
					int shooter_icons = 15, shooter_icons_columns = 5;
					content_avail.y -= (entity_image_size * (shooter_icons / shooter_icons_columns));
					content_avail.y -= (3.0f * (shooter_icons / shooter_icons_columns)); //Y padding.
				}
				else
				{
					content_avail.y -= (entity_image_size * (entity_icons / entity_icons_columns));
					content_avail.y -= (3.0f * (entity_icons / entity_icons_columns)); //Y padding.
				}
				if (entity_w < 100)
				{
					content_avail.y -= (fsy*0.5);
				}
				if (content_avail.y < fsy) content_avail.y = fsy;
				#endif
				
			}
			#endif

			#endif
			#ifdef WICKEDENGINE
			static bool bViewOptionsOpen = false;
			if(bViewOptionsOpen)
				ImGui::BeginChild("##MainEntitiesLeftPanel", content_avail - ImVec2(0.0f, 205.0f), false, iGenralWindowsFlags); //, false, ImGuiWindowFlags_HorizontalScrollbar);
			else
				ImGui::BeginChild("##MainEntitiesLeftPanel", content_avail, false, iGenralWindowsFlags); //, false, ImGuiWindowFlags_HorizontalScrollbar);
			#else
			ImGui::BeginChild("##MainEntitiesLeftPanel", content_avail, false, iGenralWindowsFlags); //, false, ImGuiWindowFlags_HorizontalScrollbar);
			#endif
			#ifdef WICKEDENGINE			
			ImGui::TextCenter(sortby_modes[current_sort_order]);
			#endif

			//static std::map<std::string, std::int32_t> sorted_files;
			static std::vector<std::pair<std::string,int>> sorted_entity_files;

			static int last_entidmaster = 0;
			static int last_include_icon_set = -1;

			int iMasterEntid = g.entidmaster;
			#ifdef WICKEDENGINE
			if (iRestoreEntidMaster >= 0 && bExternal_Entities_Window)
			{
				iMasterEntid = iRestoreEntidMaster;
			}
			#endif
			#ifdef WICKEDENGINE
			static int last_sortby = -1;
			if (last_entidmaster != iMasterEntid || last_include_icon_set != iIncludeLeftIconSet || current_sort_order != last_sortby )
			#else
			if (last_entidmaster != iMasterEntid)
			#endif
			{
				//Sort new list.
				sorted_entity_files.clear();
				if (iMasterEntid >= 1)
				{
					//Sort list.
					for (t.entid = 1; t.entid <= iMasterEntid; t.entid++)
					{
						//std::string stmp = t.entityprofile[t.entid].model_s.Get();
						std::string stmp = Lower(t.entityprofileheader[t.entid].desc_s.Get());
						#ifdef WICKEDENGINE
						if (current_sort_order == 2 || current_sort_order == 3)
						{
							//Convert to sortable by string.
							if(t.entid < 10)
								stmp = "000" + std::to_string(t.entid);
							else if (t.entid < 100)
								stmp = "00" + std::to_string(t.entid);
							else if (t.entid < 1000)
								stmp = "0" + std::to_string(t.entid);
							else
								stmp = std::to_string(t.entid);
						}
						#endif
						stmp += "###"; //We need it to be unique so add this.
						stmp += t.entityprofile[t.entid].model_s.Get();
						stmp += "###";
						stmp += std::to_string(t.entid);
						int itmp = t.entid;
						sorted_entity_files.push_back(std::make_pair(stmp, itmp));
					}
					std::sort(sorted_entity_files.begin(), sorted_entity_files.end());
					#ifdef WICKEDENGINE
					if (current_sort_order == 1 || current_sort_order == 2)
						std::reverse(sorted_entity_files.begin(), sorted_entity_files.end());
					#endif
				}
				//PE: Add seperate window instead of this, keep it here as its usefull.
				#ifdef WICKEDENGINE
				if (iIncludeLeftIconSet == 1) 
				#else
				if (0) 
				#endif
				{
					//PE: Add additional files here. , include commands like seperator , text ...
					//std::string sFind = "ZZZZ-Seperator";
					//sorted_entity_files.insert(std::make_pair(sFind, 999999));
					//sFind = "ZZZZ-This is a text";
					//sorted_entity_files.insert(std::make_pair(sFind, 999998));
					//int val = 999999;
					//auto mFind = std::find_if(sorted_entity_files.begin(), sorted_entity_files.end(), [val](const auto& mo) {return mo.second == val; });
					//if (mFind != sorted_entity_files.end())
					//{
					//	//Found.
					//}
				}
				last_entidmaster = iMasterEntid;
				#ifdef WICKEDENGINE
				last_include_icon_set = iIncludeLeftIconSet;
				last_sortby = current_sort_order;
				#endif
			}

			int uniqueId = 15000;

			int preview_count = 0;
			media_icon_size_leftpanel = 64;
			iColumnsWidth_leftpanel = 110;
			iColumns_leftpanel = 0;
			bDisplayText_leftpanel = true;
			fFontSize_leftpanel = SMALLFONTSIZE;
			ImGui::SetWindowFontScale(fFontSize_leftpanel);
			float fWinWidth = ImGui::GetWindowSize().x - 10.0; // Flicker - ImGui::GetCurrentWindow()->ScrollbarSizes.x;
			if (iColumnsWidth_leftpanel >= fWinWidth && fWinWidth > media_icon_size_leftpanel) {
				iColumnsWidth_leftpanel = fWinWidth;
				fFontSize_leftpanel = SMALLESTFONTSIZE;
				ImGui::SetWindowFontScale(fFontSize_leftpanel);
			}
			if (fWinWidth <= media_icon_size_leftpanel + 10) {
				iColumnsWidth_leftpanel = media_icon_size_leftpanel;
				fFontSize_leftpanel = SMALLESTFONTSIZE;
				ImGui::SetWindowFontScale(fFontSize_leftpanel);
			}
			if (fWinWidth <= 42) {
				media_icon_size_leftpanel = 32;
				iColumnsWidth_leftpanel = media_icon_size_leftpanel + 16;
				bDisplayText_leftpanel = false;
			}
			iColumns_leftpanel = (int)(ImGui::GetWindowSize().x / (iColumnsWidth_leftpanel));
			if (iColumns_leftpanel <= 1)
				iColumns_leftpanel = 1;

			#ifdef ADD_DETAIL_LEFT_PANEL_ENTITY_LIST
			if(current_sort_order == 4) //PE: Detailed display in one column.
				iColumns_leftpanel = 1;
			#endif

			if (!sorted_entity_files.empty())
			{
				ImGui::Columns(iColumns_leftpanel, "mycolumns4entities", false);  //false no border

				bool bHoveredUsed = false;
				for (int iloop = 0; iloop < 2; iloop++)
				{
					for (std::vector< std::pair<std::string, std::int32_t>>::iterator it = sorted_entity_files.begin(); it != sorted_entity_files.end(); ++it)
					{
						if (it->second == 999999)
						{
							if (iloop == 1)
							{
								//Seperator.
								if (iColumns_leftpanel == 1)
								{
									ImGui::Separator();
									preview_count++;
									ImGui::NextColumn();
								}
								else
								{
									if (iColumns_leftpanel == 1)
									{
										ImGui::Separator();
										preview_count++;
										ImGui::NextColumn();
									}
									else
									{
										for (int i = preview_count % iColumns_leftpanel; i < iColumns_leftpanel; i++)
										{
											preview_count++;
											ImGui::NextColumn();
										}
										ImGui::Separator();
									}
								}
							}
						}
						else if (it->second == 999998)
						{
							if (iloop == 1)
							{
								std::string sString = it->first;
								replaceAll(sString, "ZZZZ-", "");
								ImGui::Text(sString.c_str());
								preview_count++;
								ImGui::NextColumn();
							}
						}
						else if (it->second > 0)
						{
#ifdef ADD_DETAIL_LEFT_PANEL_ENTITY_LIST
							if (iloop == 0 && current_sort_order == 4)
							{
								//Display detailed list of entities.

								ImGui::SetWindowFontScale(1.0);

								bool DisplayEntry = true;
								char cName[512];
								strcpy(cName, t.entityprofileheader[it->second].desc_s.Get());

								if (strlen(cSearchEntities) > 0)
								{
									//PE: This will search the desc. and the object name.
									if (!pestrcasestr(cName, cSearchEntities))
										DisplayEntry = false;
								}

								bool bUseWideThumb = false;
								int iTextureID = t.entityprofile[it->second].iThumbnailSmall;
								if (t.entityprofile[it->second].iThumbnailLarge > 0)
								{
									bUseWideThumb = true;
									iTextureID = t.entityprofile[it->second].iThumbnailLarge;
								}

								if (t.entityprofile[it->second].groupreference != -1)
								{
									//PE: Dont display smartobjects as they are not really a object.
									DisplayEntry = false;
								}

								if (DisplayEntry && iTextureID > 0)
								{

									ImGui::PushID(uniqueId++);
									float fFramePadding = (iColumnsWidth_leftpanel - media_icon_size_leftpanel)*0.5;
									float fCenterX = ImGui::GetContentRegionAvail().x * 0.5;
									ImVec2 vIconSize = { (float)media_icon_size_leftpanel , (float)media_icon_size_leftpanel };

									if (!bUseWideThumb)
									{
										//ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + (fCenterX - (media_icon_size_leftpanel*0.5)), ImGui::GetCursorPosY()));
									}
									else
									{
										//512x288
										float fRatio = 288.0f / 512.0f;
										float fImageWidth = ImGui::GetContentRegionAvail().x - 4.0f;
										vIconSize = { fImageWidth ,fImageWidth*fRatio };
									}

									char *cFind = strstr(cName, "###");
									if (cFind)
										cFind[0] = '\0';

									if (t.entityprofile[it->second].groupreference != -1)
									{
										strcat(cName, " (Smart Object)");
									}
									//if (ImGui::ImgBtn(iTextureID, vIconSize, drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true, false, false, false, true, false))

									ImGuiTreeNodeFlags node_flags = ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_OpenOnArrow; //Got sub selections.

									//node_flags = ImGuiTreeNodeFlags_Leaf; //No sub selections.

									bool bSelected = false;

									//Find selection here.
									//if (bSelected)
									//	node_flags |= ImGuiTreeNodeFlags_Selected;
									//else
									//	node_flags &= ~ImGuiTreeNodeFlags_Selected;

									ImGui::PushItemWidth(-20.0); //PE: Room for a icon.
									std::string treename = cName;
									//treename[0] = toupper(treename[0]);
									bool TreeNodeOpen = ImGui::TreeNodeEx((void*)(intptr_t)(it->second + 99000), node_flags, treename.c_str());
									bool bHovered = ImGui::IsItemHovered();
									ImGui::PopItemWidth();

#ifdef WICKEDENGINE
									cstr find = t.entitybank_s[it->second];
									BeginDragDropFPE(find.Get(), iTextureID, bToolTipActive, vIconSize);
#endif
									if (!bHoveredUsed && bHovered && bToolTipActive && !bDraggingActive)
									{
										bHoveredUsed = true;
										ImGui::BeginTooltip();
										ImGui::ImgBtn(iTextureID, vIconSize, drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true, false, false, false, true, false);
										//ImGui::Text(treename.c_str());
										ImGui::EndTooltip();
									}

									bool bTreeNodeSelected = false;

									//if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(0))
									//{
									//	//Only allow drag/drop.
									//	//bTreeNodeSelected = true;
									//}

									if (TreeNodeOpen) {
										ImGui::Indent(-5);
										//Display any sub nodes
										DoTreeNodeEntity(it->second);
										ImGui::Indent(5);
										ImGui::TreePop();
									}

									if (bTreeNodeSelected)
									{
										//Only if we are not dragging in a trashcan.
										if (bToolTipActive)
										{
											if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
											if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
											if (bImporter_Window) { importer_quit(); bImporter_Window = false; }

#ifdef WICKEDENGINE
											FreeTempImageList();
#endif

											DeleteWaypointsAddedToCurrentCursor();
											//CheckTooltipObjectDelete();
											CloseDownEditorProperties();
											//Make sure we are in entity mode.
											bForceKey = true;
#ifdef WICKEDENGINE
											csForceKey = "o";
											iExtractMode = 0; //PE: Always start in find floor mode.
#else
											csForceKey = "e";
#endif
											t.gridentity = it->second;
											t.inputsys.constructselection = it->second;
											t.inputsys.domodeentity = 1;
											t.grideditselect = 5;
											#ifdef WICKEDENGINE
											//Make sure we use a fresh t.grideleprof
											t.entid = t.gridentity;
											entity_fillgrideleproffromprofile();
											t.inputsys.dragoffsetx_f = 0;
											t.inputsys.dragoffsety_f = 0;
											fHitPointX = 0;
											fHitPointY = HITPOINTYSTARTPOS;
											fHitPointZ = 0;
											fHitOffsetX = 0;
											fHitOffsetY = 0;
											fHitOffsetZ = 0;
											bDraggingActive = false;
											g_bHoldGridEntityPosWhenManaged = true;
											g_fHoldGridEntityPosX = t.gridentityposx_f;
											g_fHoldGridEntityPosY = t.gridentityposy_f;
											g_fHoldGridEntityPosZ = t.gridentityposz_f;
											#endif
											editor_refresheditmarkers();
										}
									}

									ImGui::PopID();
									preview_count++;
									ImGui::NextColumn();
								}

							}
							else
							{
#endif
#ifdef WICKEDENGINE
								// no longer list markers in left entity panel, we have the game elements buttons now
								if ((iloop == 0 && t.entityprofile[it->second].ismarker == 0 && t.entityprofile[it->second].ischildofgroup == 0))
#else
								if ((iloop == 0 && t.entityprofile[it->second].ismarker == 0) || (iloop == 1 && t.entityprofile[it->second].ismarker > 0))
#endif
								{
									bool DisplayEntry = true;
									char cName[512];
									strcpy(cName, t.entityprofileheader[it->second].desc_s.Get());

									if (strlen(cSearchEntities) > 0)
									{
										//PE: This will search the desc. and the object name.
										if (!pestrcasestr(cName, cSearchEntities))
											DisplayEntry = false;
									}

									bool bUseWideThumb = false;
									int iTextureID = t.entityprofile[it->second].iThumbnailSmall;
#ifdef USEWIDEICONSEVERYWHERE
									if (t.entityprofile[it->second].iThumbnailLarge > 0)
									{
										bUseWideThumb = true;
										iTextureID = t.entityprofile[it->second].iThumbnailLarge;
									}
#endif
									if (DisplayEntry && iTextureID > 0)
									{
										// get ready to overlay a smart object icon
										ImVec2 vSmartObjectIconPos = ImGui::GetCursorPos();

										ImGui::PushID(uniqueId++);
										float fFramePadding = (iColumnsWidth_leftpanel - media_icon_size_leftpanel)*0.5;
										//float fCenterX = iColumnsWidth * 0.5;
										float fCenterX = ImGui::GetContentRegionAvail().x * 0.5;
										ImVec2 vIconSize = { (float)media_icon_size_leftpanel , (float)media_icon_size_leftpanel };

										//ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(fFramePadding, 2.0f));
										if (!bUseWideThumb)
										{
											ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + (fCenterX - (media_icon_size_leftpanel*0.5)), ImGui::GetCursorPosY()));
										}
										else
										{
											//512x288
											float fRatio = 288.0f / 512.0f;
											float fImageWidth = ImGui::GetContentRegionAvail().x - 4.0f;
											vIconSize = { fImageWidth ,fImageWidth*fRatio };
										}

										// Entity Left Panel.
										//if (ImGui::ImgBtn(iTextureID, vIconSize, drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true, false, false, false, true, false))
										if (ImGui::ImgBtn(iTextureID, vIconSize, drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false, false, false, false, true, false))
										{
											//Only if we are not dragging in a trashcan.
											if (bToolTipActive)
											{
												if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
												if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
												if (bImporter_Window) { importer_quit(); bImporter_Window = false; }

#ifdef WICKEDENGINE
												FreeTempImageList();
#endif

												DeleteWaypointsAddedToCurrentCursor();
												//CheckTooltipObjectDelete();
												CloseDownEditorProperties();
												//Make sure we are in entity mode.
												bForceKey = true;
#ifdef WICKEDENGINE
												iExtractMode = 0; //PE: Always start in find floor mode.
												csForceKey = "o";
#else
												csForceKey = "e";
#endif
												t.gridentity = it->second;
												t.inputsys.constructselection = it->second;
												t.inputsys.domodeentity = 1;
												t.grideditselect = 5;
												#ifdef WICKEDENGINE
												//Make sure we use a fresh t.grideleprof
												t.entid = t.gridentity;
												entity_fillgrideleproffromprofile();
												t.inputsys.dragoffsetx_f = 0;
												t.inputsys.dragoffsety_f = 0;
												fHitPointX = 0;
												fHitPointY = HITPOINTYSTARTPOS;
												fHitPointZ = 0;
												fHitOffsetX = 0;
												fHitOffsetY = 0;
												fHitOffsetZ = 0;
												bDraggingActive = false;
												g_bHoldGridEntityPosWhenManaged = true;
												g_fHoldGridEntityPosX = t.gridentityposx_f;
												g_fHoldGridEntityPosY = t.gridentityposy_f;
												g_fHoldGridEntityPosZ = t.gridentityposz_f;
												#endif
												editor_refresheditmarkers();
											}
										}

										#ifdef WICKEDENGINE
										cstr find = t.entitybank_s[it->second];
										BeginDragDropFPE(find.Get(), iTextureID, bToolTipActive, vIconSize);
										#endif

										char *cFind = strstr(cName, "###");
										if (cFind)
											cFind[0] = '\0';
										if (ImGui::IsItemHovered() && bToolTipActive) ImGui::SetTooltip("%s", cName);

										if (bDisplayText_leftpanel)
										{
#ifdef USEWIDEICONSEVERYWHERE
											ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, -5.0f));
#endif
											ImGui::TextCenter("%s", cName); //no wrap.
										}

										// show when object is a smart object
#ifdef WICKEDENGINE
										if (t.entityprofile[it->second].groupreference != -1)
										{
											int iImageSize = 20;
											ImVec2 opos = ImGui::GetCursorPos();
#ifdef USEWIDEICONSEVERYWHERE
											ImGui::SetCursorPos(ImVec2(vSmartObjectIconPos.x + vIconSize.x - 17.0f, vSmartObjectIconPos.y - 19.0f + vIconSize.y));
#else
											ImGui::SetCursorPos(ImVec2(vSmartObjectIconPos.x + vIconSize.x - 16.0f, vSmartObjectIconPos.y - 16.0f + vIconSize.y));
#endif
											ImGui::SetItemAllowOverlap();
											if (ImGui::ImgBtn(TOOL_SMARTOBJECT, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
											{
												// clicking does nothing
											}
											ImGui::SetCursorPos(opos);
											if (ImGui::IsItemHovered()) ImGui::SetTooltip("This is a Smart Object");
										}
#endif

										ImGui::PopID();
										preview_count++;
										ImGui::NextColumn();
									}
								}

#ifdef ADD_DETAIL_LEFT_PANEL_ENTITY_LIST
									}
#endif
								}
							}
						}
				ImGui::Columns(1);
					}

			ImGui::SetWindowFontScale(1.00);
			if (ImGui::IsWindowHovered() || ImGui::IsAnyItemHovered())
				bImGuiGotFocus = true;

			//PE: display additional debug information.
#ifdef WICKEDENGINE



//if (wiRenderer::GetDevice())
//{
//	ID3D11Texture2D *pBackBuffer = (ID3D11Texture2D *)wiRenderer::GetDevice()->GetBackBufferForGG();
//	if (pBackBuffer)
//	{
//		GGSURFACE_DESC ddsd;
//		pBackBuffer->GetDesc(&ddsd);
//		ImGui::Text("Back Size: %ld,%ld", (int)ddsd.Width, (int)ddsd.Height);
//	}
//}


//			ImGui::Text("fDebug: %f", fDebug);
//			ImGui::Text("fDebug1: %f", fDebug1);
//			ImGui::Text("fDebug2: %f", fDebug2);
//			ImGui::Text("fDebug3: %f", fDebug3);
//			ImGui::Text("bDraggingActive: %d", bDraggingActive);
//			ImGuiContext& gui = *GImGui;
//			ImGui::Text("DragDropActive: %d", gui.DragDropActive);

			//ImGui::Text("t.widget.pickedEntityIndex: %d", t.widget.pickedEntityIndex);
			//ImGui::Text("t.tentitytoselect: %d", t.tentitytoselect);
			//ImGui::Text("t.gridentityobj: %ld", t.gridentityobj);
			//ImGui::Text("t.gridentity: %ld", t.gridentity);
			//ImGui::Text("bReadyToDropEntity: %ld", bReadyToDropEntity);
			//ImGui::Text("iDragDropActive: %ld", iDragDropActive);

//			ImGui::Text("originallocalx_f: %f,%f", t.inputsys.originallocalx_f, t.inputsys.originallocaly_f);
//			ImGui::Text("dragoffsetx_f: %f", t.inputsys.dragoffsetx_f);
//			ImGui::Text("dragoffsety_f: %f", t.inputsys.dragoffsety_f);
////			ImGui::Text("bImGuiRenderTargetFocus: %d", bImGuiRenderTargetFocus);
//			ImGui::Text("fHitPointY: %f", fHitPointY);
//			ImGui::Text("fHitRayFrom: %f", fHitRayFrom);
//			ImGui::Text("bMouseInputSystemUsed: %d", bMouseInputSystemUsed);
//			ImGui::Text("fHitOffsetY: %f", fHitOffsetY);
//			ImGui::Text("fHitOffsetX: %f", fHitOffsetX);
//			ImGui::Text("fHitOffsetZ: %f", fHitOffsetZ);

			//if(g_hovered_pobject)
			//	ImGui::Text("g_hovered_pobject: %ld", g_hovered_pobject->dwObjectNumber);
			//else
			//	ImGui::Text("g_hovered_pobject: 0");
			//ImGui::Text("iLastHitObjectID: %d",iLastHitObjectID);
			//ImGui::Text("iReusePickEntityID: %d", iReusePickEntityID);

//			ImVec2 test = Convert3DTo2D(GGORIGIN_X, GGORIGIN_Y+200, GGORIGIN_Z);
//			WickedCall_SetSpriteBoundBox(true, test.x, test.y, test.x+10, test.y+10);
//			ImGui::Text("XY: %f,%f", test.x, test.y);
//			ImGui::Text("t.gridentityextractedindex: %ld", t.gridentityextractedindex);
//			ImGui::Text("t.gridentityposy_f: %f", t.gridentityposy_f);
//			ImGui::Text("t.gridentitydroptoground: %d", t.gridentitydroptoground);
			//ImGui::Text("Mouse1: %d", ImGui::IsMouseDown(1));
//			ImGui::Text("Mouse2: %d", ImGui::IsMouseDown(2)); //mouse wheel but.
//			ImGui::Text("MouseC2: %d", ImGui::IsMouseClicked(2)); //mouse wheel but.
			//ImGui::Text("Mouse3: %d", ImGui::IsMouseDown(3));

//			ImVec2 label_size = ImGui::CalcTextSize("Advanced Settings", NULL, true)+ImVec2(8.0f,0.0f);
//			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvailWidth()*0.5) - (label_size.x*0.5), 0.0f));
//			ImGui::HyberlinkButton("Advanced Settings",ImVec2(label_size.x,0));

			//for (int i = 0; i < 512; i++)
			//{
			//	if (ImGui::IsKeyPressed(i))
			//		ImGui::Text("Key: %d", i);
			//}

			//ImGui::Text("bDraggingActive: %d", bDraggingActive);
			//ImGui::Text("bImGuiGotFocus: %d", bImGuiGotFocus);
			//ImGui::Text("bLastImGuiGotFocus: %d", bLastImGuiGotFocus);

			/*
			ImGui::Text("iObjectMoveMode: %d", iObjectMoveMode);
			ImGui::Text("t.gridentitydroptoground: %d", t.gridentitydroptoground);
			ImGui::Text("iObjectMoveModeDropSystem: %d", iObjectMoveModeDropSystem);
			ImGui::Text("t.tforceentityfindfloor: %d", t.tforceentityfindfloor);
			ImGui::Text("t.gridentityobj: %d", t.gridentityobj);
			*/
			// choose all entities and associated files

			/* Debug particle emitter ID's
			for (int i = 0; i <= g.entityelementlist; i++)
			{
				if (t.entityelement[i].bankindex > 0)
				{
					if (t.entityprofile[t.entityelement[i].bankindex].ismarker == 10)
					{
						char debug[1024];
						sprintf(debug, "%d: emitterid: %d", i, t.entityelement[i].eleprof.newparticle.emitterid);
						ImGui::Text(debug);
					}
				}
			}
			*/
#ifdef STORYBOARD
			/* Test code
						//PE: Test code for standalone.
						static bool bTestStandalone = false;
						static int iFakeLoadGameTest = 0;
						static bool bStartLoadingGame = false;
						static char startpage[255], lastpage[255], msgpage[255] = "\0";
						if (strlen(msgpage) > 0) ImGui::Text(msgpage);
						if (ImGui::Checkbox("Test Standalone", &bTestStandalone))
						{
							if (bTestStandalone)
							{
								load_storyboard("cold game demo");
								strcpy(startpage, "title");
								strcpy(lastpage, "title");
								strcpy(msgpage, "");
							}
						}
						if (bStartLoadingGame)
						{
							if (iFakeLoadGameTest-- > 0)
							{
								strcpy(lastpage, startpage);
								strcpy(startpage, "loading");
								int iret = screen_editor(-1, true, startpage);
							}
							else
							{
								bTestStandalone = false;
								bStartLoadingGame = false;
							}
						}
						else if (bTestStandalone)
						{
							int iret = screen_editor(-1, true, startpage);
							//STORYBOARD_ACTIONS_GOTOLEVEL
							if (iret == STORYBOARD_ACTIONS_CONTINUE)
							{
								//Restart
								strcpy(startpage, "title");
								strcpy(lastpage, "title");
								strcpy(msgpage, "");
							}
							if (iret == STORYBOARD_ACTIONS_BACK)
							{
								strcpy(startpage, lastpage);
							}
							if (iret == STORYBOARD_ACTIONS_EXITGAME)
							{
								bTestStandalone = false;
							}
							if (iret == STORYBOARD_ACTIONS_STARTGAME)
							{
								bStartLoadingGame = true;
								iFakeLoadGameTest = 300;
								//strcpy(lastpage, startpage);
								//strcpy(startpage, "loading");
								//strcpy(msgpage, "Loading level 1");
								//bTestStandalone = false;
							}
							if (iret == STORYBOARD_ACTIONS_GOTOSCREEN)
							{
								if (strlen(t.game.pSwitchToPage) == 0)
								{
									strcpy(lastpage, startpage);
									strcpy(startpage, "loading");
								}
								else
								{
									strcpy(lastpage, startpage);
									strcpy(startpage, t.game.pSwitchToPage);
								}
							}
						}
			*/
#endif

			//PE: Test Performance modes.
			/*
			const char* quaity_items[] = { "Graphics Low", "Graphics Medium", "Graphics High", "Graphics Ultra" };
			static int quaity_item_current_selection = 2; //Default Custom.
			if (ImGui::Combo("##GraphicsQualityTest", &quaity_item_current_selection, quaity_items, IM_ARRAYSIZE(quaity_items))) {
				SetGlobalGraphicsSettings(quaity_item_current_selection);
			}
			*/

			//bool bTmp2 = t.game.gameisexe;
			//ImGui::Checkbox("t.game.gameisexe", &bTmp2);
			//t.game.gameisexe = bTmp2;

			//ImGui::Text("g_iActiveMonitors: %ld", g_iActiveMonitors);
			//wiRenderer::SetToDrawDebugEnvProbes(true);
			/* Test fov
			if (ImGui::MaxSliderInputFloat("##WickedCameraFov", &t.visuals.CameraFOV_f, 20.0f, 110.0f, "Camera FOV"))
			{
				t.gamevisuals.CameraFOV_f = t.visuals.CameraFOV_f;
				float fCameraFov = XM_PI / (t.visuals.CameraFOV_f / 15.0f); //Fit GG settings.
				if (bImGuiInTestGame == true)
				{
					//PE: Visual change also need reerse fov in test game and standalone.
					// when in game, weapon FOV correction
					fCameraFov = GGToRadian(t.visuals.CameraFOV_f); // Oops - backwards logic, lower FOV needs lower angle passed in
				}
				wiScene::GetCamera().CreatePerspective((float)master.masterrenderer.GetLogicalWidth(), (float)master.masterrenderer.GetLogicalHeight(), t.visuals.CameraNEAR_f, t.visuals.CameraFAR_f, fCameraFov);
			}
			*/

			//if (ImGui::StyleButton("Memory Dump")) {
			//	timestampactivity(0, "Memory Dump:");
			//	DumpImageList(); // PE: Dump image usage after level.
			//}

			//PE: Doubble click to move closer to terrain. disabled for objects as we might end up into walls ...
			extern float fLastTerrainHitX, fLastTerrainHitY, fLastTerrainHitZ;
			if (!bImGuiGotFocus && bImGuiRenderTargetFocus && g_hovered_pobject == 0 && t.thighlighterobj == 0)
			{
				if (fLastTerrainHitY > g.gdefaultwaterheight && t.grideditselect == 5)
				{
					static float traveltox = 0, traveltoy = 0, traveltoz = 0;
					//ImGui::Text("traveltox: %f", traveltox);
					//ImGui::Text("traveltoy: %f", traveltoy);
					//ImGui::Text("traveltoz: %f", traveltoz);

					if(ImGui::IsMouseDoubleClicked(0))
					{
						//PE: Get a fresh.
						wiInput::MouseState mouseState = wiInput::GetMouseState();
						RAY pickRay = wiRenderer::GetPickRay((long)mouseState.position.x, (long)mouseState.position.y, master.masterrenderer);
						if (!GGTerrain::GGTerrain_RayCast(pickRay, &fLastTerrainHitX, &fLastTerrainHitY, &fLastTerrainHitZ, 0, 0, 0, 0))
						{
							fLastTerrainHitX = 0, fLastTerrainHitY = 0, fLastTerrainHitZ = 0;
						}
						else
						{
							if (fLastTerrainHitY > g.gdefaultwaterheight)
							{
								float composx, composy, composz, comangx, comangy, comangz;

								composx = CameraPositionX(0);
								composy = CameraPositionY(0);
								composz = CameraPositionZ(0);
								comangx = CameraAngleX(0);
								comangy = CameraAngleY(0);
								comangz = CameraAngleZ(0);

								float step = 10; //PE: This will move us 10% from the total distance to the target.
								float dx = (composx-fLastTerrainHitX) / step;
								float dy = (composy-fLastTerrainHitY) / step;
								float dz = (composz-fLastTerrainHitZ) / step;

								traveltox = fLastTerrainHitX + dx;
								traveltoy = fLastTerrainHitY + dy;
								traveltoz = fLastTerrainHitZ + dz;

								t.editorfreeflight.mode = 3;
								t.editorfreeflight.s.x_f = traveltox;
								t.editorfreeflight.s.y_f = traveltoy;
								t.editorfreeflight.s.z_f = traveltoz;
								PositionCamera(traveltox, traveltoy, traveltoz);
								PointCamera(fLastTerrainHitX, fLastTerrainHitY, fLastTerrainHitZ);
								t.editorfreeflight.s.angx_f = CameraAngleX(0);
								t.editorfreeflight.s.angy_f = CameraAngleY(0);
								t.editorfreeflight.c = t.editorfreeflight.s;
								PositionCamera(composx, composy, composz);
								RotateCamera(comangx, comangy, comangz);
								//PointCamera(fLastTerrainHitX, fLastTerrainHitY, fLastTerrainHitZ);
							}
						}
					}
				}
			}

			if (bProfilerEnable)
			{
				ImGui::Separator();
				wiScene::Scene* pScene = &wiScene::GetScene();
				int iMeshes = pScene->meshes.GetCount();
				int iMaterials = pScene->materials.GetCount();
				//int iAnimations = pScene->animations.GetCount();
				//int iArmatures = pScene->armatures.GetCount();
				//int iTransforms = pScene->transforms.GetCount();
				//int iObjects = pScene->objects.GetCount();
				//int iHierarchy = pScene->hierarchy.GetCount();
				//int iPrev_transforms = pScene->prev_transforms.GetCount();

				int dc = wiProfiler::GetDrawCalls();
				int dcs = wiProfiler::GetDrawCallsShadows();
				int dct = wiProfiler::GetDrawCallsTransparent();

				int tris = wiProfiler::GetPolygons();
				int trisShadow = wiProfiler::GetPolygonsShadows();
				int trisTransparent = wiProfiler::GetPolygonsTransparent();

				//int iSkinable = WickedCall_GetSkinable();
				//int iSkinableV = WickedCall_GetSkinableVisible();

				ImGui::Text("FPS: %.1f", ImGui::GetIO().Framerate);
				ImGui::Text("DrawCalls: %d", dc);
				ImGui::Text("DrawCallsShadows: %d", dcs);
				ImGui::Text("DrawCallsTransparent: %d", dct);
				ImGui::Text("Triangles: %d", tris);
				ImGui::Text("TrianglesShadows: %d", trisShadow);
				ImGui::Text("TrianglesTransparent: %d", trisTransparent);
				ImGui::Text("Scene Meshes: %d", iMeshes);
				ImGui::Text("Scene Materials: %d", iMaterials);
				//ImGui::Text("Scene Animations: %d", iAnimations);
				//ImGui::Text("Scene Armatures: %d", iArmatures);
				ImGui::Text("Scene Transforms: %d", (int)pScene->transforms.GetCount());
				//ImGui::Text("Scene Objects: %d", iObjects);
				ImGui::Text("Scene Hierarchy: %d", (int)pScene->hierarchy.GetCount());
				//ImGui::Text("Scene Prev_transforms: %d", iPrev_transforms);
				//ImGui::Text("Scene iSkinable: %d", iSkinable);
				//ImGui::Text("Scene iSkinableV: %d", iSkinableV);

				ImGui::Separator();
				std::string profiler_data = wiProfiler::GetProfilerData();
				ImGui::Text(profiler_data.c_str());

			}

			//for (int i = 0;i < 255;i++)
			//{
			//	if (ImGui::IsKeyDown(i))
			//	{
			//		ImGui::Text("Key: %d", i);
			//	}
			//}
#endif
//ImGui::Text("FPS: %.1f", ImGui::GetIO().Framerate);
//ImGui::Text("DrawCalls: %d", g_pGlob->dwNumberOfPrimCalls);
//ImGui::Text("Poly: %d", g_pGlob->dwNumberOfPolygonsDrawn);

//ImGui::Text("triggerfindundercursor: %d", triggerfindundercursor);
//ImGui::Text("bImGuiRenderTargetFocus: %d", (int) bImGuiRenderTargetFocus);
//ImGui::Text("t.inputsys.mclick: %d", (int)t.inputsys.mclick);
//ImGui::Text("t.onedrag: %d", t.onedrag);
//ImGui::Text("io.WantCaptureKeyboard: %d", (int) io.WantCaptureKeyboard);
//ImGui::Text("IsAnyItemActive(): %d", (int)ImGui::IsAnyItemActive());


//				ImGui::Text("object_preload_still_running: %d", (int)object_preload_still_running());

			//PE: enable below for statup time and memory dump function.
			//PE: Now with wicked textures directly from all resources

			//PE: Memory and wicked scene component counts.
			/*
			static int iClickCount = 0;
			float fGBMemUsed = (float) SMEMAvailable(1) / 1024.0 / 1024.0;
			char memtmp[255];
			static int iTargetMem = 0;
			ImGui::RadioButton("Target 8gb ", &iTargetMem, 0); ImGui::SameLine();
			ImGui::RadioButton("12gb ", &iTargetMem, 1); ImGui::SameLine();
			ImGui::RadioButton("16gb", &iTargetMem, 2);
			float fTotalTarget = 8.0;
			if( iTargetMem == 1) fTotalTarget = 12.0;
			if (iTargetMem == 2) fTotalTarget = 16.0;
			//ImGui::Text("Mem Used GB: %.3f", fGBMemUsed);
			sprintf(memtmp, "Mem Used GB: %.3f", fGBMemUsed);
			float percent = fGBMemUsed / fTotalTarget;
			ImVec4 col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
			if (percent > 0.85 ) // 1 gb left.
			{
				ImGui::PushStyleColor(ImGuiCol_PlotHistogram, ImVec4(1.0,0.5,0.2,0.5));
			}
			else
			{
				ImGui::PushStyleColor(ImGuiCol_PlotHistogram, ImVec4(col.x, col.y, col.z, 0.5));
			}
			if (percent < 0.0) percent = 0.0;
			if (percent >= 100.0f) percent = 100.0f;
			ImGui::ProgressBar(percent, ImVec2(ImGui::GetContentRegionAvailWidth() - 10, 26), memtmp);
			ImGui::PopStyleColor();

			if (ImGui::StyleButton("Click Mem Reg."))
			{
				char tmp[255];
				sprintf(tmp, "Click Mem Reg. (%d)", iClickCount++);
				timestampactivity(0, tmp);
			}

			if (ImGui::StyleButton("Memory Dump")) {
				timestampactivity(0, "Memory Dump:");
				DumpImageList(); // PE: Dump image usage after level.
			}

			wiScene::Scene* pScene = &wiScene::GetScene();
			auto size = pScene->materials.GetCount();
			ImGui::Text("pScene->materials: %lld", size);
			size = pScene->meshes.GetCount();
			ImGui::Text("pScene->meshes: %lld", size);
			size = pScene->objects.GetCount();
			ImGui::Text("pScene->objects: %lld", size);
			size = pScene->animations.GetCount();
			ImGui::Text("pScene->animations: %lld", size);
			size = pScene->animation_datas.GetCount();
			ImGui::Text("pScene->animation_datas: %lld", size);
			size = pScene->layers.GetCount();
			ImGui::Text("pScene->layers: %lld", size);
			size = pScene->hierarchy.GetCount();
			ImGui::Text("pScene->hierarchy: %lld", size);
			size = pScene->transforms.GetCount();
			ImGui::Text("pScene->transforms: %lld", size);

			*/

			//ImGui::Text("Startup Time: %d", iStartupTime);
			//extern int LoadImageCoreRetainNameTime;
			//ImGui::Text("LoadImageTime: %d", LoadImageCoreRetainNameTime);



			//Test code for direct center hit
			/*
			float placeatx_f, placeatz_f;
			extern ImVec2 OldrenderTargetSize;
			extern ImVec2 OldrenderTargetPos;
			ImVec2 vCenterPos = { (OldrenderTargetSize.x*0.5f) + OldrenderTargetPos.x , (OldrenderTargetSize.y*0.45f) + OldrenderTargetPos.y };

			int omx = t.inputsys.xmouse, omy = t.inputsys.ymouse, oldgridentitysurfacesnap = t.gridentitysurfacesnap, oldonedrag = t.onedrag;;
			bool owdm = bWaypointDrawmode;

			//Always target terrain only.
			float RatioX = ((float)GetDisplayWidth() / (float)renderTargetAreaSize.x) * ((float)GetDisplayWidth() / (float)GetChildWindowWidth(-1));
			float RatioY = ((float)GetDisplayHeight() / (float)renderTargetAreaSize.y) * ((float)GetDisplayHeight() / (float)GetChildWindowHeight(-1));
			t.inputsys.xmouse = (vCenterPos.x - renderTargetAreaPos.x) * RatioX;
			t.inputsys.ymouse = (vCenterPos.y - renderTargetAreaPos.y) * RatioY;

			t.gridentitysurfacesnap = 0; t.onedrag = 0; bWaypointDrawmode = false;
			input_calculatelocalcursor();
			placeatx_f = t.inputsys.localx_f;
			placeatz_f = t.inputsys.localy_f;
			t.onedrag = oldonedrag;
			bWaypointDrawmode = owdm;
			t.gridentitysurfacesnap = oldgridentitysurfacesnap;
			t.inputsys.xmouse = omx;
			t.inputsys.ymouse = omy;
			//Restore real input.
			input_calculatelocalcursor();
			if (t.inputsys.picksystemused == 1 || t.inputsys.localcurrentterrainheight_f < 100.0f)
			{

			}
//				PickScreen2D23D(vCenterPos.x, vCenterPos.y, 500);
//				placeatx_f = CameraPositionX() + GetPickVectorX();
//				placeatz_f = CameraPositionZ() + GetPickVectorZ();
			float terrain_height = BT_GetGroundHeight(t.terrain.TerrainID, placeatx_f, placeatz_f, 1);

			if (ObjectExist(g.editorwaypointoffset + 0) == 0)
			{
				MakeObjectSphere(g.editorwaypointoffset + 0, 25);
				SetObjectCollisionOff(g.editorwaypointoffset + 0);
				SetAlphaMappingOn(g.editorwaypointoffset + 0, 25);
				DisableObjectZRead(g.editorwaypointoffset + 0);
				//			DisableObjectZWrite(g.editorwaypointoffset + 0);
				HideObject(g.editorwaypointoffset + 0);
				SetObjectMask(g.editorwaypointoffset + 0, 1);
				SetObjectEffect(g.editorwaypointoffset + 0, g.guishadereffectindex);
				SetObjectEmissive(g.editorwaypointoffset + 0, Rgb(255, 255, 255));
				SetObjectMask(g.editorwaypointoffset + 0, 1);
			}
			//  Show where we draw waypoints
			if (ObjectExist(g.editorwaypointoffset + 0) == 1)
			{
				PositionObject(g.editorwaypointoffset + 0, placeatx_f, terrain_height + 5, placeatz_f);
				ShowObject(g.editorwaypointoffset + 0);
			}
			*/

			//extern int spot_lights_count;
			//extern int point_lights_count;
			//ImGui::Text("Shadow Lights: %d", WickedCall_Get2DShadowLights());
			//ImGui::Text("spot_lights_count: %d", spot_lights_count);
			//ImGui::Text("point_lights_count: %d", point_lights_count);

			if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
				//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				ImGui::Text("");
				ImGui::Text("");
				ImGui::Text("");
			}

			ImGui::EndChild();

			//Drag/Drop models.
//			if (ImGui::BeginDragDropTarget())
//			{
//				if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("DND_MODEL_DROP_TARGET", 0)) // ImGuiDragDropFlags_AcceptNoDrawDefaultRect
//				{
//					AddPayLoad((ImGuiPayload*)payload, false);
//				}
//			}

#ifdef NEWGAMEELEMENTGRID
			entity_icons = 12;

			int entity_images[] = { ENTITY_START, ENTITY_CHECKPOINT, ENTITY_FLAG, ENTITY_TRIGGERZONE, ENTITY_WIN, ENTITY_LIGHT,ENTITY_VIDEO,ENTITY_MUSIC,ENTITY_SOUND,ENTITY_PARTICLE,ENTITY_IMAGE, ENTITY_TEXT };
			cstr entity_scripts[] = {
				"_markers\\Player Start.fpe",
				"_markers\\Player Checkpoint.fpe",
				"_markers\\flag.fpe" ,
				"_markers\\Trigger Zone.fpe",
				"_markers\\Win Zone.fpe",
				"_markers\\White Light.fpe",
				"_markers\\Video Zone.fpe",
				"_markers\\Ambience Zone.fpe",
				"_markers\\Audio Zone.fpe",
				"_markers\\Particles.fpe",
				"_markers\\Image Zone.fpe",
				"_markers\\Text Zone.fpe"
			};
			cstr entity_tooltip[] = {
				"Add Player Start Position",
				"Add Player Checkpoint",
				"Add Flag",
				"Add Trigger Zone",
				"Add Win Zone",
				"Add Light",
				"Add Video Zone",
				"Add Music Zone",
				"Add Audio Zone",
				"Add Particle",
				"Add Image Zone",
				"Add Text Zone"
			};

			int offset = 0;
			if (bViewOptionsOpen)
				offset = 205;// 115;

			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, ImGui::GetContentRegionAvail().y - offset
				- ((entity_w / entity_icons_columns) * (entity_icons / entity_icons_columns)) - ImGui::GetFontSize() * 4.0f + 10.0f));
			ImGui::TextCenter("Game Elements");

			ImVec4 IconColor = ImVec4(1.0, 1.0, 1.0, 1.0);
			ImGui::Indent(4);
			for (int i = 0; i < entity_icons; i++)
			{
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fSpacer, 0.0f));

				if (ImGui::ImgBtn(entity_images[i], ImVec2(entity_image_size, entity_image_size), ImVec4(0.0, 0.0, 0.0, 0.0), IconColor, ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, false))
				{
					FreeTempImageList(); //PE: Whenever g.entidmaster can change we must make sure to free any "temp" objects loaded.

					t.addentityfile_s = entity_scripts[i];
					if (t.addentityfile_s != "")
					{
						entity_adduniqueentity(false);
						t.tasset = t.entid;
						if (t.talreadyloaded == 0)
						{
							editor_filllibrary();
						}
					}

					iExtractMode = 0; //PE: Always start in find floor mode.
					t.inputsys.constructselection = t.tasset;
					t.gridentity = t.entid;
					t.inputsys.constructselection = t.entid;
					t.inputsys.domodeentity = 1;
					t.grideditselect = 5;
					Entity_Tools_Window = true;
					//Make sure we use a fresh t.grideleprof
					entity_fillgrideleproffromprofile();
					editor_refresheditmarkers();

					// Show elements when placing a new one down, prevents half being hidden and half not.
					t.showeditorelements = 1;
					editor_toggle_element_vis(t.showeditorelements);

				}
				if (ImGui::IsItemHovered() && bToolTipActive) ImGui::SetTooltip(entity_tooltip[i].Get());
				BeginDragDropFPE(entity_scripts[i].Get(), entity_images[i], bToolTipActive, ImVec2(entity_image_size, entity_image_size));

				ImVec2 restore_cursorpos = ImGui::GetCursorPos();
				if ((i + 1) % entity_icons_columns != 0 && i != entity_icons - 1)
					ImGui::SameLine();
			}

			content_avail = ImGui::GetContentRegionAvail();
			content_avail.y -= 6.0;

			bViewOptionsOpen = false;

			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, 3.0f));
			ImGui::Indent(-4);

			if (ImGui::StyleCollapsingHeader("View Options##viewoptions"))
			{
				bViewOptionsOpen = true;
				// Control viewing of game elements and editable area boundaries.
				//ImGui::TextCenter("View Options");

				ImGui::Columns(3);

				ImGuiWindow* win = ImGui::GetCurrentWindow();
				win->DC.CurrentColumns->Flags |= ImGuiColumnsFlags_NoResize;

				ImGui::SetColumnWidth(0, content_avail.x * 0.625f);
				ImGui::TextCenter("");

				float fFontSize = ImGui::GetFontSize();

				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, fFontSize*0.25f));
				ImGui::Text("Game Elements");
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, fFontSize*0.5f));
				ImGui::Text("Editable Area 2D Edge");
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, fFontSize*0.5f));
				ImGui::Text("Editable Area 3D Edge");
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, fFontSize*0.5f));
				ImGui::Text("Trees");
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, fFontSize*0.5f));
				ImGui::Text("Vegetation");
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, fFontSize*0.5f));
				ImGui::Text("Water");
				ImGui::NextColumn();
			#if 0
				ImGui::SetColumnWidth(1, content_avail.x * 0.2f);
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(-1.0f, 0.0f));
				ImGui::Text("Editor");

				// Editor game elements.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(4.0f, 0.0f));
				bool bShow = t.showeditorelements;
				if (ImGui::Checkbox("##EditorElements", &bShow))
				{
					t.showeditorelements = bShow;
					editor_toggle_element_vis(bShow);
				}

				// Editor 2D boundary.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(4.0f, 0.0f));
				bShow = (ggterrain_global_render_params2.flags2 & GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE) ? 1 : 0;
				if (ImGui::Checkbox("##Editor2DBounds", &bShow))
				{
					if (bShow) ggterrain_global_render_params2.flags2 |= GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE;
					else ggterrain_global_render_params2.flags2 &= ~GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE;
				}

				// Editor 3D boundary.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(4.0f, 0.0f));
				bShow = (ggterrain_global_render_params2.flags2 & GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE_3D) != 0;
				if (ImGui::Checkbox("##Editor3DBounds", &bShow))
				{
					if (bShow) ggterrain_global_render_params2.flags2 |= GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE_3D;
					else ggterrain_global_render_params2.flags2 &= ~GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE_3D;
				}

				// Editor Trees.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(4.0f, 0.0f));
				if (ImGui::Checkbox("##EditorTrees", &t.visuals.bEndableTreeDrawing))
				{
					t.gamevisuals.bEndableTreeDrawing = t.visuals.bEndableTreeDrawing;
					ggtrees_global_params.draw_enabled = t.visuals.bEndableTreeDrawing;
				}

				// Editor Vegetation.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(4.0f, 0.0f));
				if (ImGui::Checkbox("##EditorVeg", &t.visuals.bEndableGrassDrawing))
				{
					t.gamevisuals.bEndableGrassDrawing = t.visuals.bEndableGrassDrawing;
					gggrass_global_params.draw_enabled = t.visuals.bEndableGrassDrawing;
				}

				// Editor Water.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(4.0f, 0.0f));
				if (ImGui::Checkbox("##EditorWater", &t.visuals.bWaterEnable))
				{
					t.gamevisuals.bWaterEnable = t.visuals.bWaterEnable;
					Wicked_Update_Visuals((void *)&t.visuals);
				}
				ImGui::NextColumn();


				ImGui::SetColumnWidth(2, content_avail.x * 0.18f);
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(1.0f, 0.0f));
				ImGui::Text("Level");

				// Test level game elements.
				bShow = t.showtestgameelements;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(5.0f, 0.0f));
				if (ImGui::Checkbox("##LevelElements", &bShow))
					t.showtestgameelements = bShow;

				// Test level 2D boundary.
				bShow = t.showtestgame2dbounds;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(5.0f, 0.0f));
				if (ImGui::Checkbox("##Level2DBounds", &bShow))
					t.showtestgame2dbounds = bShow;

				// Test level 3D boundary.
				bShow = t.showtestgame3dbounds;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(5.0f, 0.0f));
				if (ImGui::Checkbox("##Level3DBounds", &bShow))
					t.showtestgame3dbounds = bShow;

				// Test level Trees.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(5.0f, 0.0f));
				bShow = t.showtestgametrees;
				if (ImGui::Checkbox("##LevelTrees", &bShow))
				{
					t.showtestgametrees = bShow;
					//t.gamevisuals.bEndableTreeDrawing = bShow;
				}

				// Test level Vegetation.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(5.0f, 0.0f));
				bShow = t.showtestgameveg;
				if (ImGui::Checkbox("##LevelVeg", &bShow))
					t.showtestgameveg = bShow;

				// Test level Water.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(5.0f, 0.0f));
				bShow = t.showtestgamewater;
				if (ImGui::Checkbox("##LevelWater", &bShow))
					t.showtestgamewater = bShow;
				

				ImGui::Columns(1);
			#else
				ImGui::SetColumnWidth(1, content_avail.x * 0.2f);
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(-1.0f, 0.0f));
				ImGui::Text("Editor");
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Changes to the Editor View settings are temporary and will only effect visuals whilst editing your levels");
				
				// Editor game elements.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(4.0f, 0.0f));
				bool bShow = t.showeditorelements;
				if (ImGui::Checkbox("##EditorElements", &bShow))
				{
					t.showeditorelements = bShow;
					editor_toggle_element_vis(bShow);
				}
				
				// Editor 2D boundary.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(4.0f, 0.0f));
				bShow = (ggterrain_global_render_params2.flags2 & GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE) ? 1 : 0;
				if (ImGui::Checkbox("##Editor2DBounds", &bShow))
				{
					if (bShow) ggterrain_global_render_params2.flags2 |= GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE;
					else ggterrain_global_render_params2.flags2 &= ~GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE;
				}
				
				// Editor 3D boundary.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(4.0f, 0.0f));
				bShow = (ggterrain_global_render_params2.flags2 & GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE_3D) != 0;
				if (ImGui::Checkbox("##Editor3DBounds", &bShow))
				{
					if (bShow) ggterrain_global_render_params2.flags2 |= GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE_3D;
					else ggterrain_global_render_params2.flags2 &= ~GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE_3D;
				}
				
				// Editor Trees.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(4.0f, 0.0f));
				if (t.showeditortrees < 0)
					t.showeditortrees = t.visuals.bEndableTreeDrawing;
				bShow = t.showeditortrees;
				if (ImGui::Checkbox("##EditorTrees", &bShow))
				{
					//t.gamevisuals.bEndableTreeDrawing = t.visuals.bEndableTreeDrawing;
					//ggtrees_global_params.draw_enabled = t.visuals.bEndableTreeDrawing;
					ggtrees_global_params.draw_enabled = bShow;
					t.showeditortrees = bShow;
				}
				
				// Editor Vegetation.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(4.0f, 0.0f));
				if (t.showeditorveg < 0)
					t.showeditorveg = t.visuals.bEndableGrassDrawing;
				bShow = t.showeditorveg;
				if (ImGui::Checkbox("##EditorVeg", &bShow))
				{
					//t.gamevisuals.bEndableGrassDrawing = t.visuals.bEndableGrassDrawing;
					//gggrass_global_params.draw_enabled = t.visuals.bEndableGrassDrawing;
					gggrass_global_params.draw_enabled = bShow;
					t.showeditorveg = bShow;
				}
				
				// Editor Water.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(4.0f, 0.0f));
				// Should be done when loading level.
				if (t.showeditorwater < 0)
					t.showeditorwater = t.visuals.bWaterEnable;
				bShow = t.showeditorwater;
				if (ImGui::Checkbox("##EditorWater", &bShow))
				{
					//t.gamevisuals.bWaterEnable = t.visuals.bWaterEnable;
					t.showeditorwater = bShow;
					Wicked_Update_Visuals((void *)&t.visuals);
				
				}
				ImGui::NextColumn();
				
				
				ImGui::SetColumnWidth(2, content_avail.x * 0.18f);
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(1.0f, 0.0f));
				ImGui::Text("Level");
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Changes to the Level View settings will effect the visuals seen in-game");
				
				// Test level game elements.
				bShow = t.showtestgameelements;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(5.0f, 0.0f));
				if (ImGui::Checkbox("##LevelElements", &bShow))
				t.showtestgameelements = bShow;
				
				// Test level 2D boundary.
				bShow = t.showtestgame2dbounds;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(5.0f, 0.0f));
				if (ImGui::Checkbox("##Level2DBounds", &bShow))
				t.showtestgame2dbounds = bShow;
				
				// Test level 3D boundary.
				bShow = t.showtestgame3dbounds;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(5.0f, 0.0f));
				if (ImGui::Checkbox("##Level3DBounds", &bShow))
				t.showtestgame3dbounds = bShow;
				
				// Test level Trees.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(5.0f, 0.0f));
				if (ImGui::Checkbox("##LevelTrees", &t.visuals.bEndableTreeDrawing))
					t.gamevisuals.bEndableTreeDrawing = t.visuals.bEndableTreeDrawing;
				
				// Test level Vegetation.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(5.0f, 0.0f));
				if (ImGui::Checkbox("##LevelVeg", &t.visuals.bEndableGrassDrawing))
					t.gamevisuals.bEndableGrassDrawing = t.visuals.bEndableGrassDrawing;
				
				// Test level Water.
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(5.0f, 0.0f));
				if (ImGui::Checkbox("##LevelWater", &t.visuals.bWaterEnable))
					t.gamevisuals.bWaterEnable = t.visuals.bWaterEnable;
				
				ImGui::Columns(1);
			#endif
			}


			// Old way.
			//ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(4.0f, 4.0f));
			//ImGui::Text("Show:  ");
			//ImGui::SameLine();
			//ImGui::SetCursorPos(ImGui::GetCursorPos() - ImVec2(0.0f, 4.0f));
			//
			//bShow = t.showeditorelements;
			//if (ImGui::Checkbox("Editor", &bShow))
			//{
			//	t.showeditorelements = bShow;
			//	editor_toggle_element_vis(bShow);
			//}
			//bShow = t.showtestgameelements;
			//ImGui::SameLine();
			//if (ImGui::Checkbox("Test Level", &bShow))
			//	t.showtestgameelements = bShow;
			//ImGui::Indent(-4);

#else
						// used to hide game elements so UI not too cluttered when in SHOOTER/RPG/PUZZLE GAMEPLAY panel mode
			//PE: Changed in new design to display all 15 icons. so bHideGameElementsWhenInSpecialGameplayMode always false.
			bool bHideGameElementsWhenInSpecialGameplayMode = false;


#ifdef WICKEDENGINE
#ifdef INCLUDELEFTENTITYTOOLICONS
			if (bHideGameElementsWhenInSpecialGameplayMode == false)
			{
				entity_icons = 10;
				//entity_icons_columns = 5;
				int entity_images[] = { ENTITY_LIGHT,ENTITY_WIN,ENTITY_VIDEO,ENTITY_MUSIC,ENTITY_START,ENTITY_TEXT,ENTITY_SOUND,ENTITY_PARTICLE,ENTITY_IMAGE,ENTITY_CHECKPOINT };
				cstr entity_scripts[] = {
					"_markers\\White Light.fpe",
					"_markers\\Win Zone.fpe",
					"_markers\\Video Zone.fpe",
					"_markers\\Ambience Zone.fpe",
					"_markers\\Player Start.fpe",
					"_markers\\Text Zone.fpe",
					"_markers\\Audio Zone.fpe",
					"_markers\\Particles.fpe",
					"_markers\\Image Zone.fpe",
					"_markers\\Player Checkpoint.fpe" };
				cstr entity_tooltip[] = {
					"Add Light",
					"Add Win Zone",
					"Add Video Zone",
					"Add Music Zone",
					"Add Player Start Position and Settings",
					"Add Text Zone",
					"Add Audio Zone",
					"Add Particle",
					"Add Image Zone",
					"Add Player Checkpoint" };

				ImVec4 IconColor = ImVec4(1.0, 1.0, 1.0, 1.0);
				ImGui::Indent(4);
				for (int i = 0; i < entity_icons; i++)
				{
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fSpacer, 0.0f));

					if (ImGui::ImgBtn(entity_images[i], ImVec2(entity_image_size, entity_image_size), ImVec4(0.0, 0.0, 0.0, 0.0), IconColor, ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, false)) //no bBoostIconColors
					{
						FreeTempImageList(); //PE: Whenever g.entidmaster can change we must make sure to free any "temp" objects loaded.

						//Open light window.
						t.addentityfile_s = entity_scripts[i];
						if (t.addentityfile_s != "")
						{
							entity_adduniqueentity(false);
							t.tasset = t.entid;
							if (t.talreadyloaded == 0)
							{
								editor_filllibrary();
							}
						}

						iExtractMode = 0; //PE: Always start in find floor mode.
						t.inputsys.constructselection = t.tasset;
						t.gridentity = t.entid;
						t.inputsys.constructselection = t.entid;
						t.inputsys.domodeentity = 1;
						t.grideditselect = 5;
						Entity_Tools_Window = true;
						//Make sure we use a fresh t.grideleprof
						entity_fillgrideleproffromprofile();
						editor_refresheditmarkers();

					}
					if (ImGui::IsItemHovered() && bToolTipActive) ImGui::SetTooltip(entity_tooltip[i].Get());
					BeginDragDropFPE(entity_scripts[i].Get(), entity_images[i], bToolTipActive, ImVec2(entity_image_size, entity_image_size));

					ImVec2 restore_cursorpos = ImGui::GetCursorPos();
					if ((i + 1) % entity_icons_columns != 0 && i != entity_icons - 1)
						ImGui::SameLine();
				}
				ImGui::Indent(-4);

			}
#endif

#ifdef WICKEDENGINE
#ifdef SHOOTERGAMEBUTTON
			if (Shooter_Tools_Window)
			{
				int shooter_icons = 5, shooter_icons_columns = 5;
				int shooter_images[] = { ENTITY_FLAG,ENTITY_GUNS,ENTITY_AMMO,ENTITY_ENEMIES,ENTITY_ALLIES };
				cstr shooter_scripts[] = {
					"_markers\\flag.fpe",
					"guns",
					"ammo",
					"enemies",
					"allies" };
				cstr shooter_tooltip[] = {
					"Add Flag",
					"Add Guns",
					"Add Ammo",
					"Add Enemies",
					"Add Allies" };

				ImVec4 IconColor = ImVec4(1.0, 1.0, 1.0, 1.0);
				ImGui::Indent(4);
				for (int i = 0; i < shooter_icons; i++)
				{
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fSpacer, 0.0f));
					if (ImGui::ImgBtn(shooter_images[i], ImVec2(entity_image_size, entity_image_size), ImVec4(0.0, 0.0, 0.0, 0.0), IconColor, ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, false)) //no bBoostIconColors
					{
						FreeTempImageList();
						t.addentityfile_s = shooter_scripts[i];
						int iJumpToObjectSelection = 0;
						if (stricmp(t.addentityfile_s.Get(), "guns") == NULL || stricmp(t.addentityfile_s.Get(), "ammo") == NULL
							|| stricmp(t.addentityfile_s.Get(), "enemies") == NULL || stricmp(t.addentityfile_s.Get(), "allies") == NULL)
						{
							iJumpToObjectSelection = i;
						}
						if (iJumpToObjectSelection == 0)
						{
							// add flag element to scene
							if (t.addentityfile_s != "")
							{
								entity_adduniqueentity(false);
								t.tasset = t.entid;
								if (t.talreadyloaded == 0)
								{
									editor_filllibrary();
								}
							}
							iExtractMode = 0;
							t.inputsys.constructselection = t.tasset;
							t.gridentity = t.entid;
							t.inputsys.constructselection = t.entid;
							t.inputsys.domodeentity = 1;
							t.grideditselect = 5;
							//stay in shooter mode
							//Entity_Tools_Window = true;
							entity_fillgrideleproffromprofile();
							editor_refresheditmarkers();
						}
						else
						{
							// go to ADD object with specific type
							bExternal_Entities_Window = true;
							iDisplayLibraryType = 0;
							iDisplayLibrarySubType = 0;
							iLastDisplayLibraryType = -1;
							switch (iJumpToObjectSelection)
							{
							case 1: sStartLibrarySearchString = "weapon"; break;
							case 2: sStartLibrarySearchString = "ammo"; break;
							case 3: sStartLibrarySearchString = "characters"; break;
							case 4: sStartLibrarySearchString = "ally"; break;
							}
						}
					}
					if (ImGui::IsItemHovered() && bToolTipActive) ImGui::SetTooltip(shooter_tooltip[i].Get());
					BeginDragDropFPE(shooter_scripts[i].Get(), shooter_images[i], bToolTipActive, ImVec2(entity_image_size, entity_image_size));
					ImVec2 restore_cursorpos = ImGui::GetCursorPos();
					if ((i + 1) % shooter_icons_columns != 0 && i != shooter_icons - 1)
						ImGui::SameLine();
				}
				bHideGameElementsWhenInSpecialGameplayMode = true;
				ImGui::Indent(-4);
			}
#endif
#endif

			//PE: SECTION_LEVEL_ENTITIES
			content_avail = ImGui::GetContentRegionAvail();
			content_avail.y -= 6.0;

			//Child need to be same color as frame color.
			ImGui::PushStyleColor(ImGuiCol_ChildWindowBg, ImVec4(0, 0, 0, 0));

			ImGui::BeginChild("##MainEntitiesLeftPanelButton", content_avail, false, iGenralWindowsFlags | ImGuiWindowFlags_NoScrollbar); //, false, ImGuiWindowFlags_HorizontalScrollbar);

			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(4.0f, 3.0f));

			float but_gadget_size = content_avail.x - 17.0f;
			char* button_label = "Show Game Elements";
			if (t.showeditorelements) button_label = "Hide Game Elements";

			if (ImGui::StyleButton(button_label, ImVec2(but_gadget_size, 0)))
			{
				// Toggle the show editor elements flag, so the correct button label is displayed.
				t.showeditorelements = !t.showeditorelements;
				editor_toggle_element_vis(t.showeditorelements);

			}
			if (ImGui::IsItemHovered() && bToolTipActive) ImGui::SetTooltip("%s", "Toggle visibility of game elements");

			ImGui::EndChild();
			ImGui::PopStyleColor();
#endif

#endif

			//Drag/Drop to remove objects.
			ImRect bb = { ImGui::GetWindowContentRegionMin()+ImGui::GetWindowPos(),ImGui::GetWindowContentRegionMax() + ImGui::GetWindowPos() };

			#ifdef WICKEDENGINE
			if (bTrashcanIconActive)
				bTrashcanIconActive = false;
			DragDrop_CheckTrashcanDrop(bb);
			#endif

			if (ImGui::BeginDragDropTargetCustom(bb, 12345))
			{
				//ImGui::Text("BeginDragDropTargetCustom");
				//Hightlight Here!
				if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("DND_MODEL_DROP_TARGET", 0)) // ImGuiDragDropFlags_AcceptNoDrawDefaultRect
				{
					AddPayLoad((ImGuiPayload*)payload, false);
				}
			}

			ImGui::End();


			#ifdef WICKEDENGINE
			//#########################
			//#### Current objects ####
			//#########################
			
			
			//ImGuiWindowClass subWinClass;
			//subWinClass.DockingAlwaysTabBar = true;
			//subWinClass.DockingAllowUnclassed = false;
			//subWinClass.ClassId = ImGui::GetID((void*)("CUSTOM_SUB_WINDOW_CLASS_CURRENT_OBJECTS" ));
			//ImGui::SetNextWindowClass(&subWinClass);

			ImGui::Begin("Current Objects##AdditionalIconsWindow", &bAlwaysOpen, iGenralWindowsFlags | ImGuiWindowFlags_NoTitleBar);

			static ImVec2 vBelowContentSize = { 0.0,40.0 };
			bool bSelectionAvail = false;
			int control_image_size = 42; //32;

			//PE: Make room for tool icons.
			content_avail = ImGui::GetContentRegionAvail();
			if (vBelowContentSize.y != 40.0f) {
				if (vBelowContentSize.y > 84) //2 lines of icons max. otherwise scrollbar.
					vBelowContentSize.y = 84;
				content_avail.y -= (vBelowContentSize.y + 8.0f);
			}
			else
				content_avail.y -= fsy * 3.0;
			if (content_avail.y < fsy) content_avail.y = fsy;

			ImGui::BeginChild("##CurrentObjectsLeftPanel", content_avail, false, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoNavInputs);

			extern sObject* g_highlight_pobject;
			extern std::vector<sRubberBandType> entityselectionlist;
			g_highlight_pobject = NULL;
			entityselectionlist.clear();
			int iUniqueTreeId = 67671;

			#define GROUPV2


			int iInsideTab = 0;
			if (ImGui::BeginTabBar("currentandgrouptabbar"))
			{
				int tabflags = 0;
				if (i_switch_group_tab == 1)
				{
					i_switch_group_tab = 0;
					tabflags = ImGuiTabItemFlags_SetSelected;
				}
				if (ImGui::BeginTabItem(" Current Objects ", NULL, tabflags))
				{
					iInsideTab = 1;
					tabflags = 0;

					ImGui::SetWindowFontScale(fFontSize_leftpanel);
					//ImGui::Text("Current Objects");
					//PE: To stop flicker of icons in list. it can take some frames before t.widget.pickedObject is set.
					static int iPickedObject = 0;
					static int iLastWidgetPickedObject[4] = { -1,-1,-1,-1 };
					if (t.gridentity <= 0)
					{
						if (iLastWidgetPickedObject[0] == iLastWidgetPickedObject[1] && iLastWidgetPickedObject[1] == iLastWidgetPickedObject[2])
							iPickedObject = iLastWidgetPickedObject[0];
						iLastWidgetPickedObject[0] = iLastWidgetPickedObject[1];
						iLastWidgetPickedObject[1] = iLastWidgetPickedObject[2];
						iLastWidgetPickedObject[2] = t.widget.pickedObject;
					}

					int iFirstIcon = -1;
					int iFirstEntityId = -1;
					if (t.gridentity > 0)
					{
						//backup_pickedObject
						iFirstIcon = t.gridentity;
						if (t.gridentityobj > 0)
							iPickedObject = t.gridentityobj;
						iLastWidgetPickedObject[2] = -1;
					}
					else if (iPickedObject > 0 && t.widget.pickedEntityIndex > 0) // t.widget.pickedObject > 0 && 
					{
						//Ignore picked if rubberband.
						if (!g.entityrubberbandlist.size() > 0)
						{
							int bankindex = t.entityelement[t.widget.pickedEntityIndex].bankindex;
							iFirstIcon = bankindex;
							iFirstEntityId = t.widget.pickedEntityIndex;
						}
					}

					ImGui::Columns(iColumns_leftpanel, "CurrentObjectsAdditional", false);  //false no border

					if (iFirstIcon > 0 && t.gridentityinzoomview == 0)
					{

						bool bUseWideThumb = false;
						int iTextureID = t.entityprofile[iFirstIcon].iThumbnailSmall;
						#ifdef USEWIDEICONSEVERYWHERE
						if (t.entityprofile[iFirstIcon].iThumbnailLarge > 0)
						{
							bUseWideThumb = true;
							iTextureID = t.entityprofile[iFirstIcon].iThumbnailLarge;
						}
						#endif

						if (iTextureID > 0)
						{

							bSelectionAvail = true;
							bool isThumbHovered = false;
							ImGui::PushID(uniqueId++);
							float fCenterX = ImGui::GetContentRegionAvail().x * 0.5;
							ImVec2 vIconSize = { (float)media_icon_size_leftpanel , (float)media_icon_size_leftpanel };

							if (!bUseWideThumb)
							{
								ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + (fCenterX - (media_icon_size_leftpanel*0.5)), ImGui::GetCursorPosY()));
							}
							else
							{
								//512x288
								float fRatio = 288.0f / 512.0f;
								float fImageWidth = ImGui::GetContentRegionAvail().x - 4.0f;
								vIconSize = { fImageWidth ,fImageWidth*fRatio };
							}

							ImVec2 vToolsPos = ImGui::GetCursorPos();
							
							if (ImGui::ImgBtn(iTextureID, vIconSize, drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true))
							{
								//Add to cursor.
								if (t.widget.pickedObject > 0 && t.widget.pickedEntityIndex > 0)
								{
									AddEntityToCursor(t.widget.pickedEntityIndex);
									// AddEntityToCursor used to both pick up an object, but in this case
									// we are duplicating, so we do need to wipe out certain real-time per-instance data
									t.grideleprof.newparticle.emitterid = -1; //LB: Must always get a new emitter ID.
									entity_cleargrideleprofrelationshipdata();
									bDraggingActive = false;
								}
							}
							if (ImGui::IsItemHovered())
								isThumbHovered = true;

							#ifdef WICKEDENGINE
							if (bWaitOnMouseRelease)
							{
								if (!ImGui::IsMouseDown(0))
									bWaitOnMouseRelease = false;
							}

							if (pref.iEnableDragDropEntityMode && !bWaitOnMouseRelease && t.gridentity == 0 && t.gridentityobj == 0 && ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
							{
								if (t.widget.pickedObject > 0 && t.widget.pickedEntityIndex > 0)
								{
									StartDragDropFromEntityID(t.widget.pickedEntityIndex);
								}
							}
							#endif

							//#### Locked Objects ####
							bool isObjectInLocedList = false;
							int iObjectLockedIndix = -1;
							if (vEntityLockedList.size() > 0)
							{
								for (int i = 0; i < vEntityLockedList.size(); i++)
								{
									int e = vEntityLockedList[i].e;
									if (e == t.widget.pickedEntityIndex)
									{
										isObjectInLocedList = true;
										iObjectLockedIndix = i;
										break;
									}
								}
							}
							if (isObjectInLocedList) {
								int iImageSize = 20;
								ImVec2 opos = ImGui::GetCursorPos();
								#ifdef USEWIDEICONSEVERYWHERE
								ImGui::SetCursorPos(ImVec2(vToolsPos.x + vIconSize.x - 17.0f, vToolsPos.y - 19.0f + vIconSize.y));
								#else
								ImGui::SetCursorPos(ImVec2(vToolsPos.x + vIconSize.x - 16.0f, vToolsPos.y - 16.0f + vIconSize.y));
								#endif
								ImGui::SetItemAllowOverlap();
								if (ImGui::ImgBtn(TOOL_LOCK, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false,false,false,false,false, bBoostIconColors))
								{
								#ifdef WICKEDENGINE
									LockSelectedObject(false, iObjectLockedIndix);
								#else
									int e = t.widget.pickedEntityIndex;
									if (iObjectLockedIndix >= 0) {
										t.entityelement[e].editorlock = 0;
										sObject* pObject;
										if (t.entityelement[e].obj > 0) {
											pObject = g_ObjectList[t.entityelement[e].obj];
											if (pObject) {
												WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
											}
										}
										vEntityLockedList.erase(vEntityLockedList.begin() + iObjectLockedIndix);
									}
								#endif
								}
								ImGui::SetCursorPos(opos);
								if (ImGui::IsItemHovered() && bToolTipActive) {
									isThumbHovered = false;
									ImGui::SetTooltip("UnLock Object");
								}
							}
							else
							{
								int iImageSize = 20;
								ImVec2 opos = ImGui::GetCursorPos();
								#ifdef USEWIDEICONSEVERYWHERE
								ImGui::SetCursorPos(ImVec2(vToolsPos.x + vIconSize.x - 17.0f, vToolsPos.y - 19.0f + vIconSize.y));
								#else
								ImGui::SetCursorPos(ImVec2(vToolsPos.x + vIconSize.x - 16.0f, vToolsPos.y - 16.0f + vIconSize.y));
								#endif
								ImGui::SetItemAllowOverlap();
								if (ImGui::ImgBtn(TOOL_UNLOCK, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false,false,false,false,false, bBoostIconColors))
								{
								#ifdef WICKEDENGINE
									LockSelectedObject(true, iObjectLockedIndix);
								#else
									int e = t.widget.pickedEntityIndex;
									t.entityelement[e].editorlock = 1 - t.entityelement[e].editorlock;
									sObject* pObject;
									if (t.entityelement[e].obj > 0) {
										pObject = g_ObjectList[t.entityelement[e].obj];
										if (pObject) {
											if (t.entityelement[e].editorlock)
											{
												#ifndef ALLOWSELECTINGLOCKEDOBJECTS
												WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_CURSOROBJECT);
												#endif
												sRubberBandType vEntityLockedItem;
												vEntityLockedItem.e = e;
												vEntityLockedList.push_back(vEntityLockedItem);
											}
											else {
												//Delete from list.
												for (int i = 0; i < vEntityLockedList.size(); i++)
												{
													if (vEntityLockedList[i].e == e) {
														vEntityLockedList.erase(vEntityLockedList.begin() + i);
														break;
													}
												}
												WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
											}
										}
									}
								#endif
								}
								ImGui::SetCursorPos(opos);
								if (ImGui::IsItemHovered() && bToolTipActive) {
									isThumbHovered = false;
									ImGui::SetTooltip("Lock Object");
								}
							}

							if (!bToolTipActive)
								isThumbHovered = false;

							static int ContextSel = -1;
							if (isThumbHovered || ContextSel == iFirstIcon)
							{
								if (ImGui::BeginPopupContextWindow())
								{
									ContextSel = iFirstIcon;
									ListGroupContextMenu(true);
									ImGui::EndPopup();
								}
							}

							if (isThumbHovered) {
								ImGui::SetTooltip("%s", t.entityprofileheader[iFirstIcon].desc_s.Get());
								if (iFirstEntityId > 0 && t.entityelement[iFirstEntityId].obj > 0) {
									if (g_ObjectList[t.entityelement[iFirstEntityId].obj]) {
										g_highlight_pobject = g_ObjectList[t.entityelement[iFirstEntityId].obj];
									}
								}

							}

							if (bDisplayText_leftpanel) {
								#ifdef USEWIDEICONSEVERYWHERE
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, -5.0f));
								#endif
								if (iFirstEntityId > 0)
									ImGui::TextCenter("%s", t.entityelement[iFirstEntityId].eleprof.name_s.Get()); //no wrap.
								else
									ImGui::TextCenter("%s", t.entityprofileheader[iFirstIcon].desc_s.Get()); //no wrap.
							}
							ImGui::PopID();
							preview_count++;
							ImGui::NextColumn();
						}
					}

					if (g.entityrubberbandlist.size() > 0 && t.gridentityinzoomview == 0)
					{
						bSelectionAvail = true;
						for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
						{
							bool bValid = true;
							int e = g.entityrubberbandlist[i].e;
							int tobj = t.entityelement[e].obj;
							int bankindex = t.entityelement[e].bankindex;

							//PE: Make sure we dont display the one attached to the cursor, already displayed and is not valid.
							if (bankindex == 0) bValid = false;

							if (bValid)
							{
								bool bUseWideThumb = false;
								int iTextureID = t.entityprofile[bankindex].iThumbnailSmall;

#ifdef USEWIDEICONSEVERYWHERE
								if (t.entityprofile[bankindex].iThumbnailLarge > 0)
								{
									bUseWideThumb = true;
									iTextureID = t.entityprofile[bankindex].iThumbnailLarge;
								}
#endif

								if (iTextureID > 0)
								{
									bool isThumbHovered = false;
									ImGui::PushID(uniqueId++);
									float fCenterX = ImGui::GetContentRegionAvail().x * 0.5;
									ImVec2 vIconSize = { (float)media_icon_size_leftpanel , (float)media_icon_size_leftpanel };

									if (!bUseWideThumb)
									{
										ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + (fCenterX - (media_icon_size_leftpanel*0.5)), ImGui::GetCursorPosY()));
									}
									else
									{
										//512x288
										float fRatio = 288.0f / 512.0f;
										float fImageWidth = ImGui::GetContentRegionAvail().x - 4.0f;
										vIconSize = { fImageWidth ,fImageWidth*fRatio };
									}

									ImVec2 vToolsPos = ImGui::GetCursorPos();
									if (ImGui::ImgBtn(iTextureID, vIconSize, drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true))
									{
										//Copy to cursor.
										AddEntityToCursor(e);
										bDraggingActive = false;
									}
									if (ImGui::IsItemHovered())
										isThumbHovered = true;

									#ifdef WICKEDENGINE
									if (bWaitOnMouseRelease)
									{
										if (!ImGui::IsMouseDown(0))
											bWaitOnMouseRelease = false;
									}

									if (pref.iEnableDragDropEntityMode && !bWaitOnMouseRelease && t.gridentity == 0 && t.gridentityobj == 0 && ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
									{
										StartDragDropFromEntityID(e);
									}
									#endif

									//#### Locked Objects ####
									bool isObjectInLocedList = false;
									int iObjectLockedIndix = -1;
									if (vEntityLockedList.size() > 0)
									{
										for (int i = 0; i < vEntityLockedList.size(); i++)
										{
											if (e == vEntityLockedList[i].e)
											{
												isObjectInLocedList = true;
												iObjectLockedIndix = i;
												break;
											}
										}
									}
									if (isObjectInLocedList) {
										int iImageSize = 20;
										ImVec2 opos = ImGui::GetCursorPos();
#ifdef USEWIDEICONSEVERYWHERE
										ImGui::SetCursorPos(ImVec2(vToolsPos.x + vIconSize.x - 17.0f, vToolsPos.y - 19.0f + vIconSize.y));
#else
										ImGui::SetCursorPos(ImVec2(vToolsPos.x + vIconSize.x - 16.0f, vToolsPos.y - 16.0f + vIconSize.y));
#endif
										ImGui::SetItemAllowOverlap();
										if (ImGui::ImgBtn(TOOL_LOCK, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
										{
											if (iObjectLockedIndix >= 0) {
												t.entityelement[e].editorlock = 0;
												sObject* pObject;
												if (t.entityelement[e].obj > 0) {
													pObject = g_ObjectList[t.entityelement[e].obj];
													if (pObject) {
														WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
													}
												}
												vEntityLockedList.erase(vEntityLockedList.begin() + iObjectLockedIndix);
											}
										}
										ImGui::SetCursorPos(opos);
										if (ImGui::IsItemHovered() && bToolTipActive) {
											isThumbHovered = false;
											ImGui::SetTooltip("UnLock Object");
										}
									}
									else
									{
										int iImageSize = 20;
										ImVec2 opos = ImGui::GetCursorPos();
#ifdef USEWIDEICONSEVERYWHERE
										ImGui::SetCursorPos(ImVec2(vToolsPos.x + vIconSize.x - 17.0f, vToolsPos.y - 19.0f + vIconSize.y));
#else
										ImGui::SetCursorPos(ImVec2(vToolsPos.x + vIconSize.x - 16.0f, vToolsPos.y - 16.0f + vIconSize.y));
#endif
										ImGui::SetItemAllowOverlap();
										if (ImGui::ImgBtn(TOOL_UNLOCK, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
										{
											t.entityelement[e].editorlock = 1 - t.entityelement[e].editorlock;
											sObject* pObject;
											if (t.entityelement[e].obj > 0) {
												pObject = g_ObjectList[t.entityelement[e].obj];
												if (pObject) {
													if (t.entityelement[e].editorlock)
													{
#ifndef ALLOWSELECTINGLOCKEDOBJECTS
														WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_CURSOROBJECT);
#endif
														sRubberBandType vEntityLockedItem;
														vEntityLockedItem.e = e;
														vEntityLockedList.push_back(vEntityLockedItem);
													}
													else {
														//Delete from list.
														for (int i = 0; i < vEntityLockedList.size(); i++)
														{
															if (vEntityLockedList[i].e == e) {
																vEntityLockedList.erase(vEntityLockedList.begin() + i);
																break;
															}
														}
														WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
													}
												}
											}
										}
										ImGui::SetCursorPos(opos);
										if (ImGui::IsItemHovered() && bToolTipActive) {
											isThumbHovered = false;
											ImGui::SetTooltip("Lock Object");
										}
									}

									if (!bToolTipActive)
										isThumbHovered = false;

									static int ContextSel = -1;
									if (isThumbHovered || ContextSel == e)
									{
										if (ImGui::BeginPopupContextWindow())
										{
											ContextSel = e;
											ListGroupContextMenu(true, e);
											ImGui::EndPopup();
										}
									}

									if (isThumbHovered) {
										ImGui::SetTooltip("%s", t.entityprofileheader[bankindex].desc_s.Get());
										if (e > 0 && t.entityelement[e].obj > 0) {
											if (g_ObjectList[t.entityelement[e].obj]) {
												g_highlight_pobject = g_ObjectList[t.entityelement[e].obj];
											}
										}
									}

									if (bDisplayText_leftpanel) {
#ifdef USEWIDEICONSEVERYWHERE
										ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, -5.0f));
#endif
										if(e > 0)
											ImGui::TextCenter("%s", t.entityelement[e].eleprof.name_s.Get()); //no wrap.
										else
											ImGui::TextCenter("%s", t.entityprofileheader[bankindex].desc_s.Get()); //no wrap.
									}
									ImGui::PopID();
									preview_count++;
									ImGui::NextColumn();
								}
							} //BValid
						}
					}

					ImGui::Columns(1);
					ImGui::SetWindowFontScale(1.00);

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}

					ImGui::EndTabItem();
				}

				tabflags = 0;
				if (i_switch_group_tab == 2)
				{
					i_switch_group_tab = 0;
					tabflags = ImGuiTabItemFlags_SetSelected;
				}
				if (ImGui::BeginTabItem(" Groups ", NULL, tabflags))
				{
					if (ImGui::IsItemHovered() && bToolTipActive) ImGui::SetTooltip("Object Groups");

					//Use Columns and fixed size.
					ImGui::Columns(iColumns_leftpanel, "CurrentObjectsAdditional", false);  //false no border
					ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2.0f, 2.0f));
					iInsideTab = 2;
					
					//ImGui::Indent(10);
					//#### Group Lists ####
					for (int l = 0; l < MAXGROUPSLISTS; l++)
					{
						if (vEntityGroupList[l].size() > 0)
						{
							//LB: quickly reject groups that have no image (i.e are child groups)
							if (iEntityGroupListImage[l] == 0)
								continue;

							//LB: reject groups that have names (which means they are groups for Smart Objects, not user created)
							if (sEntityGroupListName[l].Len() > 0)
								continue;

							cstr sGroupString = cstr("Group") + cstr(l + 1) + cstr(":") + cstr("Objects (") + cstr((int)vEntityGroupList[l].size()) + cstr(")");
							#ifdef GROUPV2
							float w = ImGui::GetContentRegionAvailWidth();
							float fPreviewImgSize = w - 10.0f;
							if (fPreviewImgSize > 200.0f) fPreviewImgSize = 200.0f;
							float ImgY = ImGui::GetFontSize();
							bool isClicked = false;
							ImVec2 vToolsPos = ImGui::GetCursorPos();
							if (iEntityGroupListImage[l] > 0 && ImageExist(iEntityGroupListImage[l]))
							{
								float ImgX = ImageWidth(iEntityGroupListImage[l]);
								ImgY = ImageHeight(iEntityGroupListImage[l]);
								float Ratio = fPreviewImgSize / ImgX;
								ImgY *= Ratio;

								if (current_selected_group == l)
								{
									window = ImGui::GetCurrentWindow();
									ImVec2 padding = { 3.0, 3.0 };
									const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + ImVec2(fPreviewImgSize, ImgY));
									window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
								}
								isClicked = ImGui::ImgBtn(iEntityGroupListImage[l], ImVec2(fPreviewImgSize, ImgY), drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false,false,false,false);
							}
							else
								isClicked = ImGui::Selectable(sGroupString.Get()); //PE: Missing ?

							if (ImGui::IsItemHovered())
							{
								//Highlight group.
								entityselectionlist = vEntityGroupList[l];
								if (iEntityGroupListImage[l] > 0 && ImageExist(iEntityGroupListImage[l]))
								{
									ImGui::BeginTooltip();
									float fRatio = (float)ImageHeight(iEntityGroupListImage[l]) / (float)ImageWidth(iEntityGroupListImage[l]);
									float imagew = 400.0f;
									float imageh = imagew * fRatio;
									ImGui::ImgBtn(iEntityGroupListImage[l], ImVec2(imagew, imageh), drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false);
									ImGui::EndTooltip();
								}
							}

							if(isClicked)
							{
								current_selected_group = l;
								g.entityrubberbandlist = vEntityGroupList[l];
								//Set widget on first item in list.
								int e = g.entityrubberbandlist[0].e;
								if (e > 0)
								{
									if (t.entityelement[e].editorlock == 0)
									{
										t.widget.pickedEntityIndex = e;
										t.widget.pickedObject = t.entityelement[e].obj;
									}
								}
								//PE: Make sure next selection , delete rubberband if ctrl not used.
								iLastSelectedEntityGroup = -1;
								iLastSelectedEntity = -1;
							}

							if (bWaitOnMouseRelease)
							{
								if (!ImGui::IsMouseDown(0))
									bWaitOnMouseRelease = false;
							}

							if (pref.iEnableDragDropEntityMode && !bWaitOnMouseRelease && t.gridentity == 0 && t.gridentityobj == 0 && ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
							{
								//Just use first entry.
								int e = vEntityGroupList[l][0].e;
								if (iEntityGroupListImage[l] > 0 && ImageExist(iEntityGroupListImage[l]))
									StartDragDropFromEntityID(e, l , iEntityGroupListImage[l]);
								else
									StartDragDropFromEntityID(e,l);
							}

							//Check if any item in group is locked.
							bool isObjectInLocedList = false;
							int iObjectLockedIndix = -1;
							if (vEntityGroupList[l].size() > 0)
							{
								for (int i = 0; i < vEntityGroupList[l].size(); i++)
								{
									int e = vEntityGroupList[l][i].e;
									if (e > 0 && t.entityelement[e].editorlock)
									{
										isObjectInLocedList = true;
										iObjectLockedIndix = i;
										break;
									}
								}
							}

							int iImageSize = 20;
							ImVec2 opos = ImGui::GetCursorPos();
							ImGui::SetCursorPos(ImVec2(vToolsPos.x + fPreviewImgSize - 22.0f, vToolsPos.y - 22.0f + ImgY));
							ImGui::SetItemAllowOverlap();
							ImGui::PushID( 223344 + l); //Need unique ids.
							if (isObjectInLocedList)
							{
								if (ImGui::ImgBtn(TOOL_LOCK, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false,false,false,false,false, bBoostIconColors))
								{
									if (vEntityGroupList[l].size() > 0)
									{
										for (int i = 0; i < vEntityGroupList[l].size(); i++)
										{
											int e = vEntityGroupList[l][i].e;
											if (e > 0) {
												t.entityelement[e].editorlock = 0;
												sObject* pObject;
												if (t.entityelement[e].obj > 0) {
													pObject = g_ObjectList[t.entityelement[e].obj];
													if (pObject) {
														WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
													}
												}
												//Delete from list.
												for (int il = 0; il < vEntityLockedList.size(); il++)
												{
													if (vEntityLockedList[il].e == e) {
														vEntityLockedList.erase(vEntityLockedList.begin() + il);
														break;
													}
												}

											}
										}
									}

								}
								if (ImGui::IsItemHovered() && bToolTipActive) 
								{
									ImGui::SetTooltip("UnLock Group");
								}
							}
							else
							{
								if (ImGui::ImgBtn(TOOL_UNLOCK, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false,false,false,false,false, bBoostIconColors))
								{
									if (vEntityGroupList[l].size() > 0)
									{
										for (int i = 0; i < vEntityGroupList[l].size(); i++)
										{
											int e = vEntityGroupList[l][i].e;
											if (e > 0)
											{
												t.entityelement[e].editorlock = 1;
												sObject* pObject;
												if (t.entityelement[e].obj > 0)
												{
													pObject = g_ObjectList[t.entityelement[e].obj];
													if (pObject) 
													{
														#ifndef ALLOWSELECTINGLOCKEDOBJECTS
														WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_CURSOROBJECT);
														#endif
													}
												}
												sRubberBandType vEntityLockedItem;
												vEntityLockedItem.e = e;
												vEntityLockedList.push_back(vEntityLockedItem);
											}
										}
									}

								}
								if (ImGui::IsItemHovered() && bToolTipActive) {
									ImGui::SetTooltip("Lock Group");
								}
							}
							ImGui::SetCursorPos(opos);
							ImGui::PopID();
							#else
							//Process.
							ImVec2 vCurPos = ImGui::GetCursorPos();
							ImGui::PushItemWidth(-50);
							bool bTreeOpen = false;
							//					if (ImGui::TreeNode(sGroupString.Get()))
							if (ImGui::TreeNodeEx((void*)(intptr_t)&vEntityGroupList[l], 0, sGroupString.Get()))
							{
								bTreeOpen = true;
								if (ImGui::IsItemHovered()) {
									entityselectionlist = vEntityGroupList[l];
								}

								for (int i = 0; i < vEntityGroupList[l].size(); i++)
								{
									bool bHighlightObject = false;
									int e = vEntityGroupList[l][i].e;
									int bankindex = t.entityelement[e].bankindex;

									cstr sObjectString = cstr(" (") + cstr(e) + cstr(")");
									cstr sTreeName = t.entityprofileheader[bankindex].desc_s + sObjectString;
									cstr sUngroupName = cstr("Ungroup") + sObjectString;
									//ImGui::Text(sTreeName.Get());
									if (t.gridentityinzoomview == e)
									{
										sTreeName = "In Properties";
									}
									bool is_selected = false;
									ImVec2 vCurItemPos = ImGui::GetCursorPos();
									ImGui::Indent(-10);
									ImGui::TreeNodeEx((void*)(intptr_t)i, ImGuiTreeNodeFlags_Bullet | ImGuiTreeNodeFlags_NoTreePushOnOpen, sTreeName.Get());
									if (ImGui::IsItemClicked())
									{
										AddEntityToCursor(e);
									}
									if (ImGui::IsItemHovered()) {
										bHighlightObject = true;
									}
									ImGui::Indent(10);

									ImVec2 vOldItemPos = ImGui::GetCursorPos();
									ImGui::PushID(iUniqueTreeId++);
									ImGui::SetCursorPos(ImVec2(content_avail.x - 18.0f - ImGui::GetCurrentWindow()->ScrollbarSizes.x, vCurItemPos.y));
									ImGui::SetItemAllowOverlap();
									if (ImGui::ImgBtn(TOOL_UNGROUP, ImVec2(16, 16), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false))
									{
										vEntityGroupList[l].erase(vEntityGroupList[l].begin() + i);
										iEntityGroupListImage[l] = 0;
									}
									if (ImGui::IsItemHovered() && bToolTipActive) {
										ImGui::SetTooltip(sUngroupName.Get());
										bHighlightObject = true;
									}
									ImGui::PopID();
									ImGui::SetCursorPos(vOldItemPos);

									if (bHighlightObject)
									{
										//PE: Mark item in editor.
										sObject* pObject;
										if (t.entityelement[e].obj > 0) {
											pObject = g_ObjectList[t.entityelement[e].obj];
											if (pObject) {
												g_highlight_pobject = pObject;
											}
										}
									}
								}

								ImGui::TreePop();
							}
							if (!bTreeOpen && ImGui::IsItemHovered()) {
								entityselectionlist = vEntityGroupList[l];
							}

							ImGui::PopItemWidth();


							ImVec2 vOldPos = ImGui::GetCursorPos();

							ImGui::SameLine();
							ImGui::SetCursorPos(ImVec2(content_avail.x - 18.0f - ImGui::GetCurrentWindow()->ScrollbarSizes.x, vCurPos.y));
							ImGui::PushID(iUniqueTreeId++);
							ImGui::SetItemAllowOverlap();
							if (ImGui::ImgBtn(TOOL_TRASHCAN, ImVec2(16, 16), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false))
							{
								vEntityGroupList[l].clear();
								iEntityGroupListImage[l] = 0;
							}
							if (ImGui::IsItemHovered() && bToolTipActive) {
								ImGui::SetTooltip("Delete Group");
								entityselectionlist = vEntityGroupList[l];
							}
							ImGui::PopID();

							ImGui::SameLine();
							ImGui::SetCursorPos(ImVec2(content_avail.x - 18.0f - 18.0f - ImGui::GetCurrentWindow()->ScrollbarSizes.x, vCurPos.y));
							ImGui::PushID(iUniqueTreeId++);
							ImGui::SetItemAllowOverlap();
							if (ImGui::ImgBtn(TOOL_UNGROUP, ImVec2(16, 16), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false))
							{
								g.entityrubberbandlist = vEntityGroupList[l];
								//vEntityGroupList[l].clear();
								//Set widget on first item in list.
								int e = g.entityrubberbandlist[0].e;
								if (e > 0)
								{
									t.widget.pickedEntityIndex = e;
									t.widget.pickedObject = t.entityelement[e].obj;
								}

							}
							if (ImGui::IsItemHovered() && bToolTipActive) {
								ImGui::SetTooltip("UnGroup to Cursor");
								entityselectionlist = vEntityGroupList[l];
							}
							ImGui::PopID();

							ImGui::SameLine();
							ImGui::SetCursorPos(ImVec2(content_avail.x - 18.0f - 18.0f - 18.0f - ImGui::GetCurrentWindow()->ScrollbarSizes.x, vCurPos.y));
							ImGui::PushID(iUniqueTreeId++);
							ImGui::SetItemAllowOverlap();
							if (ImGui::ImgBtn(TOOL_ENT_DUPLICATE, ImVec2(16, 16), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false))
							{
								DuplicateFromList(vEntityGroupList[l]);
							}
							if (ImGui::IsItemHovered() && bToolTipActive) {
								ImGui::SetTooltip("Duplicate to Cursor");
								entityselectionlist = vEntityGroupList[l];
							}
							ImGui::PopID();


							ImGui::SetCursorPos(vOldPos);

#endif
							ImGui::NextColumn();

						}
					}
					//ImGui::Indent(-10);
					ImGui::PopStyleVar();

					ImGui::Columns(1);

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
					}

					ImGui::EndTabItem();
				}
				
				tabflags = 0;
				if (i_switch_group_tab == 3)
				{
					i_switch_group_tab = 0;
					tabflags = ImGuiTabItemFlags_SetSelected;
				}
				//PE: Not sure what TRASH is , some kind of undo/redo system ?
				/*
				if (ImGui::BeginTabItem(" Trash ", NULL, tabflags))
				{
					iInsideTab = 3;

					//Locked objects moved in new design.
					//#### Locked Objects ####
					if (vEntityLockedList.size() > 0)
					{
						//Tree view.
						cstr sLockedString = cstr("Locked Objects (") + cstr((int)vEntityLockedList.size()) + cstr(")");
						ImVec2 vCurPos = ImGui::GetCursorPos();
						bool bTreeOpen = false;
						ImGui::PushItemWidth(-50);
						//				if (ImGui::TreeNode(sLockedString.Get()))
						if (ImGui::TreeNodeEx((void*)(intptr_t)&vEntityLockedList, 0, sLockedString.Get()))
						{
							bTreeOpen = true;
							if (ImGui::IsItemHovered()) {
								entityselectionlist = vEntityLockedList;
							}

							for (int i = 0; i < vEntityLockedList.size(); i++)
							{
								bool bHighlightObject = false;
								int e = vEntityLockedList[i].e;
								int bankindex = t.entityelement[e].bankindex;

								cstr sObjectString = cstr(" (") + cstr(e) + cstr(")");
								cstr sTreeName = t.entityprofileheader[bankindex].desc_s + sObjectString;
								cstr sUnlockName = cstr("Unlock") + sObjectString;
								//ImGui::Text(sTreeName.Get());
								bool is_selected = false;
								ImVec2 vCurItemPos = ImGui::GetCursorPos();
								ImGui::Indent(-10);
								ImGui::TreeNodeEx((void*)(intptr_t)i, ImGuiTreeNodeFlags_Bullet | ImGuiTreeNodeFlags_NoTreePushOnOpen, sTreeName.Get());
								if (ImGui::IsItemHovered()) {
									bHighlightObject = true;
								}
								ImGui::Indent(10);

								ImVec2 vOldItemPos = ImGui::GetCursorPos();
								ImGui::PushID(iUniqueTreeId++);
								ImGui::SetCursorPos(ImVec2(content_avail.x - 18.0f - ImGui::GetCurrentWindow()->ScrollbarSizes.x, vCurItemPos.y));
								ImGui::SetItemAllowOverlap();
								if (ImGui::ImgBtn(TOOL_UNLOCK, ImVec2(16, 16), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false))
								{
									t.entityelement[e].editorlock = 0;
									sObject* pObject;
									if (t.entityelement[e].obj > 0) {
										pObject = g_ObjectList[t.entityelement[e].obj];
										if (pObject) {
											WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
										}
									}
									vEntityLockedList.erase(vEntityLockedList.begin() + i);
								}
								if (ImGui::IsItemHovered() && bToolTipActive) {
									ImGui::SetTooltip(sUnlockName.Get());
									bHighlightObject = true;
								}
								ImGui::PopID();
								ImGui::SetCursorPos(vOldItemPos);

								if (bHighlightObject)
								{
									//PE: Mark item in editor.
									sObject* pObject;
									if (t.entityelement[e].obj > 0) {
										pObject = g_ObjectList[t.entityelement[e].obj];
										if (pObject) {
											g_highlight_pobject = pObject;
										}
									}
								}
								//sObject* pObject;
								//if (t.entityelement[e].obj > 0) {
								//	pObject = g_ObjectList[t.entityelement[e].obj];
								//}
							}
							ImGui::TreePop();
						}
						if (!bTreeOpen && ImGui::IsItemHovered()) {
							entityselectionlist = vEntityLockedList;
						}

						ImGui::PopItemWidth();

						ImVec2 vOldPos = ImGui::GetCursorPos();
						ImGui::SameLine();

						ImGui::SetCursorPos(ImVec2(content_avail.x - 18.0f - ImGui::GetCurrentWindow()->ScrollbarSizes.x, vCurPos.y));
						ImGui::PushID(iUniqueTreeId++);
						ImGui::SetItemAllowOverlap();
						if (ImGui::ImgBtn(TOOL_UNLOCK, ImVec2(16, 16), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false))
						{
							for (int i = 0; i < vEntityLockedList.size(); i++)
							{
								int e = vEntityLockedList[i].e;
								t.entityelement[e].editorlock = 0;
								sObject* pObject;
								if (t.entityelement[e].obj > 0) {
									pObject = g_ObjectList[t.entityelement[e].obj];
									if (pObject) {
										WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
									}
								}
							}
							vEntityLockedList.clear();
						}
						if (ImGui::IsItemHovered() && bToolTipActive) ImGui::SetTooltip("Unlock All Objects");
						ImGui::PopID();

						ImGui::SetCursorPos(vOldPos);
					}

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
					}

					ImGui::EndTabItem();
				}
				*/		
				ImGui::EndTabBar(); //PE:Fix Assert error , stacksize.
			}

			ImGui::EndChild();

			vBelowContentSize = ImGui::GetCursorPos();

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));


			float w = ImGui::GetWindowContentRegionWidth();
			int iTotalIcons = 3;
			if (pref.iObjectEnableAdvanced) iTotalIcons = 4;
			int icon_spacer = 10;
			float control_width = (control_image_size + 4.0) * iTotalIcons + 12.0;
			control_width += (icon_spacer*(iTotalIcons - 1));
			int indent = (w*0.5) - (control_width*0.5);
			if (indent < 2) indent = 2;
			ImGui::Indent(indent);

			ImVec2 restore_cursorpos = ImGui::GetCursorPos();

			window = ImGui::GetCurrentWindow();

			// Can create smart object from a group, so ask here
			static bool bGetNewSmartObjectName = false;
			static char pSmartObjectName[256];
			if (bGetNewSmartObjectName == true)
			{
				ImGui::SetNextWindowSize(ImVec2(26 * ImGui::GetFontSize(), 11 * ImGui::GetFontSize()), ImGuiCond_Once);
				ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
				cstr sUniqueWinName = cstr("Enter A Name for your Smart Object##Smart Object Name Window");
				bool bSmartObjectNameWindow = true; //PE: The window should always be open here.
				ImGui::Begin(sUniqueWinName.Get(), &bSmartObjectNameWindow, 0);
				ImGui::Indent(10);
				cstr sUniqueInputName = cstr("##Smart Object Name") + cstr(1);
				ImGui::PushItemWidth(-10);
				ImGui::Text("");
				ImGui::Text("Type a name for your Smart Object and press ENTER:");
				if (ImGui::IsRootWindowOrAnyChildFocused() && !ImGui::IsAnyItemActive() && !ImGui::IsMouseClicked(0)) ImGui::SetKeyboardFocusHere(0);
				if (ImGui::InputText(sUniqueInputName.Get(), pSmartObjectName, 250, ImGuiInputTextFlags_EnterReturnsTrue))
				{
					// save the group
					char pObjectSavedFilename[MAX_PATH];
					strcpy(pObjectSavedFilename, pSmartObjectName);
					if (SaveGroup(current_selected_group, pObjectSavedFilename) == true)
					{
						// success, go to preview to set thumbnail
						g_LastGroupSaved_s = pObjectSavedFilename;

						//PE: If we already have the original image use that no need for large preview. just goto the folder where it was created.
						CreateBackBufferCacheName(g_LastGroupSaved_s.Get(), 512, 288);
						if (!FileExist(BackBufferCacheName.Get()))
						{
							extern cstr sGotoPreviewWithFile;
							extern int iGotoPreviewType;
							sGotoPreviewWithFile = pObjectSavedFilename;
							iGotoPreviewType = 2;
						}
						else
						{
							sStartLibrarySearchString = "user";
							iLastDisplayLibraryType = -1;
							bExternal_Entities_Window = true;
							iDisplayLibraryType = 0;
							iDisplayLibrarySubType = 0;
						}
					}

					// finished here
					bGetNewSmartObjectName = false;
				}
				if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

				ImGui::PopItemWidth();
				ImGui::Text("");
				int iCancelSize = 100;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetWindowContentRegionWidth()*0.5) - (iCancelSize*0.5), 0.0f));
				if ( !bSmartObjectNameWindow || ImGui::StyleButton("Cancel", ImVec2(iCancelSize, 0)))
				{
					//Window closed or cancel selected, just exit.
					bGetNewSmartObjectName = false;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Cancel");
				ImGui::Indent(-10);
				bImGuiGotFocus = true;
				ImGui::End();
			}
			for (int b = 0; b < iTotalIcons; b++)
			{
				//TOOL_UNLOCK
				ImVec4 IconActive = ImVec4(1.0, 1.0, 1.0, 1.0);
				ImVec4 IconInActive = ImVec4(0.7, 0.7, 0.7, 0.7);
				ImVec4 IconColor;
				bool bIconActive = false;
				int iIconID = 0;
				LPSTR pLabelToolTip = "";
				#ifdef GROUPINGFEATURE
				if (b == 0 ) { iIconID = TOOL_GROUP; pLabelToolTip = "Group Objects"; }
				if (b == 1 ) { iIconID = TOOL_UNGROUP; pLabelToolTip = "Ungroup Objects"; }
				if (b == 2) { iIconID = TOOL_GROUPEDIT; pLabelToolTip = "Edit Group"; }
				if (b == 3) { iIconID = TOOL_GROUPSAVE; pLabelToolTip = "Save Group"; }
				#else
				if (b == 0) { iIconID = TOOL_GROUP; pLabelToolTip = "Group Objects"; }
				if (b == 1) { iIconID = TOOL_UNGROUP; pLabelToolTip = "Ungroup Objects"; }
				if (b == 2) { iIconID = TOOL_GROUPEDIT; pLabelToolTip = "Edit Group"; }
				#endif
				//PE: && bSelectionAvail Always display looks better.
				bool bValidSelectionForGroup = false;
				// if selection a smart object
				bool bIsASmartObject = false;
				if (current_selected_group != -1)
				{
					int iParentGroupID = vEntityGroupList[current_selected_group][0].iParentGroupID;
					for (int i = 0; i < MAXGROUPSLISTS; i++)
					{
						if (vEntityGroupList[i].size() > 0)
						{
							if (vEntityGroupList[i][0].iGroupID == iParentGroupID)
							{
								if (sEntityGroupListName[i].Len() > 0)
								{
									// parent is a smart object
									bIsASmartObject = true;
								}
							}
						}
					}
				}
				if (bIsASmartObject == true )
				{
					// yes, so change labels to reflect Smart Object editing
					if (iInsideTab == 1)
					{
						// but only when in current object view
						if (b == 0) { pLabelToolTip = "This selection is a Smart Object"; }
						if (b == 1) { pLabelToolTip = "Ungroup Smart Object"; }
						if (b == 2) { pLabelToolTip = "Edit Smart Object"; }
						if (b == 3) { pLabelToolTip = "Save As Smart Object"; }
						if (iIconID == TOOL_UNGROUP || iIconID == TOOL_GROUPEDIT || iIconID == TOOL_GROUPSAVE)
						{
							IconColor = IconActive;
							bIconActive = true;
						}
						else
						{
							IconColor = IconInActive;
						}
					}
					else
					{
						// smart objects have no controls in the group tab
						IconColor = IconInActive;
					}
				}
				else
				{
					if (bSelectionAvail)
					{
						// regular group must not be a smart object - need at least two objects to make a NEW group
						if (g.entityrubberbandlist.size() > 1)
						{
							bValidSelectionForGroup = true;
						}
					}
					if (bValidSelectionForGroup == true && !(iIconID == TOOL_UNGROUP || iIconID == TOOL_GROUPEDIT || iIconID == TOOL_GROUPSAVE))
					{
						IconColor = IconActive;
						bIconActive = true;
					}
					else
					{
						IconColor = IconInActive;
					}
					if ((iIconID == TOOL_UNGROUP || iIconID == TOOL_GROUPEDIT || iIconID == TOOL_GROUPSAVE) && current_selected_group >= 0 && iInsideTab == 2)
					{
						IconColor = IconActive;
						bIconActive = true;
					}
				}

				if (iIconID > 0)
				{
					//Highlight icon.
					if (iIconID == TOOL_GROUPEDIT && bIconActive)
					{
						if (current_selected_group >= 0 && group_editing_on)
						{
							ImVec2 padding = { 3.0, 3.0 };
							const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + ImVec2(control_image_size, control_image_size));
							window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
						}
					}

					if (ImGui::ImgBtn(iIconID, ImVec2(control_image_size, control_image_size), ImVec4(0.0, 0.0, 0.0, 0.0), IconColor, ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false,false, bBoostIconColors))
					{
						#ifdef GROUPINGFEATURE
						if ( 1 )
						{
							// clicked mode button
							if (iIconID == TOOL_GROUP)
							{
								CreateNewGroup(-1);
							}
							if (iIconID == TOOL_UNGROUP && bIconActive)
							{
								// show all game elements when editing a group
								gridedit_setsmartobjectvisibilityinrubberband(true);

								// then ungroup them so visible and ready to manage
								UnGroupSelected();
							}
							if (iIconID == TOOL_GROUPEDIT && bIconActive)
							{
								if (group_editing_on && current_selected_group >= 0)
								{
									//Turning off , refresh group thumb.
									g.entityrubberbandlist = vEntityGroupList[current_selected_group];
									GetRubberbandLowHighValues();
									//PE: Generate new thumbnail of group.
									BackBufferIsGroup = false;
									BackBufferEntityID = 0;
									BackBufferObjectID = 0;
									BackBufferImageID = iEntityGroupListImage[current_selected_group];
									BackBufferSizeX = 512 * 2.0f;
									BackBufferSizeY = 288 * 2.0f;
									BackBufferZoom = 1.0f;
									BackBufferCamLeft = 0.0f;
									BackBufferCamUp = 0.0f;
									bRotateBackBuffer = false;
									bBackBufferAnimated = false;
									bLoopBackBuffer = false;
									RevertBackbufferCubemap();
									BackBufferSnapShotMode = true;

									//PE: Fullscreen
									if (BitmapExist(99))
									{
										DeleteBitmapEx(99);
									}
									bFullScreenBackbuffer = true;
									bStopBackbufferGrab = 1;

									//if BackBufferSnapShotMode
									if (t.widget.pickedEntityIndex > 0 && t.widget.activeObject > 0)
									{
										widget_hide();
									}

									// smart object game elements hide their game elements when not editing them
									gridedit_setsmartobjectvisibilityinrubberband(false);
								}
								else
								{
									// show all game elements when editing a group
									gridedit_setsmartobjectvisibilityinrubberband(true);
								}
								group_editing_on = 1 - group_editing_on; //toggle

							}
							if (iIconID == TOOL_GROUPSAVE)
							{
								// save group as object
								if (current_selected_group >= 0)
								{
									bGetNewSmartObjectName = true;
									strcpy(pSmartObjectName, "");
								}
							}
						}
						#endif
					}
					if (ImGui::IsItemHovered() && bToolTipActive) ImGui::SetTooltip(pLabelToolTip);

					if (iIconID == TOOL_GROUP)
					{
						if (ImGui::BeginPopupContextWindow())
						{
							ListGroupContextMenu();
							ImGui::EndPopup();
						}
					}


					restore_cursorpos = ImGui::GetCursorPos();
					if (b < iTotalIcons)
					{
						ImGui::SameLine();
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(icon_spacer, 0));
					}
					//PE: Support wrapping of icons.
					float caw = (ImGui::GetContentRegionAvailWidth() + (control_image_size*0.5));
					if (caw < control_image_size) {
						ImGui::SetCursorPos(restore_cursorpos);
					}
				}
			}
			ImGui::Indent(-indent);
			ImGui::SetCursorPos(restore_cursorpos); //Restore cursor.

			vBelowContentSize = ImGui::GetCursorPos() - vBelowContentSize;

			//Support DragDrop to remove objects.
			bb = { ImGui::GetWindowContentRegionMin() + ImGui::GetWindowPos(),ImGui::GetWindowContentRegionMax() + ImGui::GetWindowPos() };

			if (bTrashcanIconActive2)
				bTrashcanIconActive2 = false;
			bool bTmp = bTrashcanIconActive;
			DragDrop_CheckTrashcanDrop(bb);
			bTrashcanIconActive2 = bTrashcanIconActive;
			bTrashcanIconActive = bTmp;

			ImGui::End();
			#endif

		}

		//################################
		//#### EBE BUILDER LEFT PANEL ####
		//################################

#ifdef USELEFTPANELSTRUCTUREEDITOR
		if (refresh_gui_docking == 0) {
			//Need to be here while first time docking.
			ImGui::Begin("Structure Editor##LeftPanel", &bBuilder_Left_Window, 0);
			ImGui::End();
		}
		if (bBuilder_Left_Window) {

			ImGui::Begin("Structure Editor##LeftPanel", &bBuilder_Left_Window);

			extern char ActiveEBEFilename[260];
			int preview_count = 0;
			float contentarea = ImGui::GetWindowSize().x * ImGui::GetWindowSize().y;
			int media_icon_size = 64;
			int iColumnsWidth = 110;
			bool bNoText = false;
			if (contentarea > 90000) {
				media_icon_size = 64;
				iColumnsWidth = 110;
			}
			else if (contentarea > 80000) {
				media_icon_size = 48;
				iColumnsWidth = 110 - 16;
			}
			else if (contentarea > 40000) {
				media_icon_size = 32;
				iColumnsWidth = 110 - 16 - 16;
			}
			else {
				media_icon_size = 16;
				iColumnsWidth = 110 - 16 - 16 - 16 - 16;
				bNoText = true;
			}

			bool bDisplayText = true;
			ImGui::SetWindowFontScale(SMALLFONTSIZE);
			float fWinWidth = ImGui::GetWindowSize().x - 10.0; // Flicker - ImGui::GetCurrentWindow()->ScrollbarSizes.x;
			if (iColumnsWidth >= fWinWidth && fWinWidth > media_icon_size) {
				iColumnsWidth = fWinWidth;
				ImGui::SetWindowFontScale(SMALLESTFONTSIZE);
			}
			if (fWinWidth <= media_icon_size + 10) {
				iColumnsWidth = media_icon_size;
				ImGui::SetWindowFontScale(SMALLESTFONTSIZE);
			}
			if (fWinWidth <= 42) {
				//				media_icon_size = 32;
				iColumnsWidth = media_icon_size + 16;
				bDisplayText = false;
			}

			int iColumns = (int)(ImGui::GetWindowSize().x / (iColumnsWidth));
			if (iColumns <= 1)
				iColumns = 1;

			ImGui::Columns(iColumns, "mycolumns4entities", false);  //false no border

			float fFramePadding = (iColumnsWidth - media_icon_size)*0.5;
			float fCenterX = iColumnsWidth * 0.5;
			ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(fFramePadding, 2.0f));

			for (int il = 0; il < t.ebebankmax; il++) {
				int icon = TOOL_BUILDER;
				char tmp[MAX_PATH];
				strcpy(tmp, t.ebebank_s[il].Get());
				int pos = strlen(tmp);
				while (pos > 0 && tmp[pos] != '\\') pos--;
				if (pos > 0) {
					cstr Text;
					strcpy(&tmp[0], &tmp[pos + 1]);
					if (pestrcasestr(tmp, "new site.")) { icon = EBE_NEW; Text = "Add New Site"; }
					else if (pestrcasestr(tmp, "cube.")) { icon = EBE_CUBE; Text = "Cube"; }
					else if (pestrcasestr(tmp, "floor.")) { icon = EBE_FLOOR; Text = "Floor"; }
					else if (pestrcasestr(tmp, "wall.")) { icon = EBE_WALL; Text = "Wall"; }
					else if (pestrcasestr(tmp, "column.")) { icon = EBE_COLUMN; Text = "Column"; }
					else if (pestrcasestr(tmp, "row.")) { icon = EBE_ROW; Text = "Row"; }
					else if (pestrcasestr(tmp, "stairs.")) { icon = EBE_STAIRS; Text = "Stairs"; }
					else if (pestrcasestr(tmp, "block.")) { icon = EBE_BLOCK; Text = "Block"; }
					else {
						icon = TOOL_BUILDER;
						int pos2 = 0;
						while (tmp[pos2] != '.' && pos2 < strlen(tmp)) pos2++;
						if (pos2 > 0)
							tmp[pos2] = 0;
						Text = tmp;
					}

					if (strlen(ActiveEBEFilename) > 0 && pestrcasestr(t.ebebank_s[il].Get(), ActiveEBEFilename)) {
						ImVec4 bg_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram]; // { 0.0, 0.0, 0.0, 1.0 };
						ImVec2 padding = { 4.0, 4.0 };
						ImGuiWindow* window = ImGui::GetCurrentWindow();
						const ImRect image_bb((window->DC.CursorPos - padding) + ImVec2(fFramePadding, 2.0f), window->DC.CursorPos + padding + ImVec2(fFramePadding, 2.0f) + ImVec2(media_icon_size, media_icon_size));
						window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(bg_col), 0.0f, 15, 3.0f);
					}

					if (ImGui::ImgBtn(icon, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true))
					{
						if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
						if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
						if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;

						DeleteWaypointsAddedToCurrentCursor();
						//CheckTooltipObjectDelete();
						CloseDownEditorProperties();
						#ifdef WICKEDENGINE
						iLastEntityOnCursor = 0;
						#endif

						t.addentityfile_s = t.ebebank_s[il].Get();
						if (t.addentityfile_s != "")
						{
							entity_adduniqueentity(false);
							t.tasset = t.entid;
							if (t.talreadyloaded == 0)
							{
								editor_filllibrary();
							}
						}
						t.inputsys.constructselection = t.tasset;

						t.gridentity = t.entid;
						t.inputsys.constructselection = t.entid;
						t.inputsys.domodeentity = 1;
						t.grideditselect = 5;
#ifdef WICKEDENGINE
						//Make sure we use a fresh t.grideleprof
						entity_fillgrideleproffromprofile();
#endif
						editor_refresheditmarkers();

						if (icon != EBE_NEW) {
							LPSTR pPBFEBEFile = t.ebebank_s[il].Get();
							ebe_loadpattern(pPBFEBEFile);
							t.inputsys.constructselection = 0;
						}
						else {
							//NewSite, make sure we are in entity mode.
							bForceKey = true;
							csForceKey = "e";
						}

					}
					if (ImGui::IsItemHovered() && Text != "") ImGui::SetTooltip("%s", Text.Get());

					if (!bNoText) {
						int iTextWidth = ImGui::CalcTextSize(Text.Get()).x;
						if (iTextWidth < iColumnsWidth)
							ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + (fCenterX - (iTextWidth*0.5)), ImGui::GetCursorPosY()));
						ImGui::TextWrapped(Text.Get());
					}
					ImGui::NextColumn();


				}
			}


			ImGui::PopStyleVar();
			ImGui::SetWindowFontScale(1.00);
			ImGui::Columns(1);

			CheckMinimumDockSpaceSize(200.0f);

			ImGui::End();
		}
#endif

		//##############################
		//#### Bug Reporting system ####
		//##############################

		#ifdef WICKEDENGINE
		ProcessBugReporting();
		#endif


		//####################
		//#### Storyboard ####
		//####################

		#ifdef STORYBOARD
		//PE: Delayed startup moved to process_storeboard so we can hide 3D editor.
		static bool bInitStoryboardStartup = true;
		if (bInitStoryboardStartup)
		{
			extern bool bSpecialEditorFromStandalone;
			extern bool bReturnToWelcome;
			if (bSpecialEditorFromStandalone && !bReturnToWelcome)
			{
				bStoryboardWindow = true;
				GGTerrain_CancelRamp();
			}
			else if (!pref.iDisplayWelcomeScreen)
			{
				if (pref.iLastInStoryboard)
				{
					bStoryboardWindow = true;
					GGTerrain_CancelRamp();
				}
			}
			bInitStoryboardStartup = false;
		}

		process_storeboard();
		#endif

		//###################
		//#### RPG GAMES ####
		//###################
		#ifdef RPG_GAMES
		ProcessRPGSetupWindow();
		#endif


		//######################################
		//#### Handle Change to Hand cursor ####
		//######################################

		//if (refresh_gui_docking >= 4)
		//{
		//	//PE: Set hand if we can pick and move a object.
		//	if (iReusePickEntityID > 0 && t.entityelement[iReusePickEntityID].editorlock == 0)
		//	{
		//		if(ImGui::GetMouseCursor() == 0) //Only if arrow cursor.
		//			ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
		//	}
		//}


		//###########################
		//#### VISULS LEFT PANEL ####
		//###########################

		#ifdef WICKEDENGINE
		if (refresh_gui_docking == 0 && !Visuals_Tools_Window)
		{
			//Make sure window is setup in docking space.
			ImGui::Begin("Environment Effects##VisualsToolsWindow", &Visuals_Tools_Window, iGenralWindowsFlags);
			ImGui::End();
		}
		else 
		{
			tab_tab_visuals(1, 0);
		}
		#endif

		bImGuiReadyToRender = true;

		if (refresh_gui_docking < 4) 
		{
			refresh_gui_docking++;
		}
		else 
		{
			if (!bImGuiInitDone)
			{
				#ifdef WICKEDENGINE
				WickedCall_EnableCameraLight(bEditorLight);
				#endif
			}
			bImGuiInitDone = true;
			static bool bLeftPanelSelectedAsDefault = false;
			if (!bLeftPanelSelectedAsDefault) {
				//ImGui::SetWindowFocus(TABENTITYNAME);
				//PE: Start in terrain tools.
				#ifdef WICKEDENGINE
				#ifdef GGTERRAIN_USE_NEW_TERRAIN
				if(pref.iTerrainDebugMode)
					ImGui::SetWindowFocus("Paint Terrain##TerrainToolsWindow");
				else
					ImGui::SetWindowFocus("Terrain Tools##Paint Terrain##TerrainToolsWindow");
				#else
				ImGui::SetWindowFocus("Paint Terrain##TerrainToolsWindow");
				#endif
				#else
				ImGui::SetWindowFocus("Terrain Tools##TerrainToolsWindow");
				#endif

				bLeftPanelSelectedAsDefault = true;
			}

		}

		//Some need launch after we have bImGuiReadyToRender , so prompt will work.
		if (iSkibFramesBeforeLaunch == 0) 
		{
			switch (iLaunchAfterSync)
			{
				#ifndef WICKEDENGINE
				case 2: //Open
					iLaunchAfterSync = 0;
					int iRet;
					iRet = AskSaveBeforeNewAction();
					if (iRet != 2)
					{
						//t.returnstring_s must have full path to .fpm.

						//PE: filedialogs change dir so.
						cStr tOldDir = GetDir();
						char * cFileSelected;
						#ifdef WICKEDENGINE
						cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "fpm\0*.fpm\0", g.mysystem.mapbankAbs_s.Get() , NULL);
						#else
						cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "fpm\0*.fpm\0", g.mysystem.mapbankAbs_s.Get() , NULL, true);
						#endif
						SetDir(tOldDir.Get());
						if (cFileSelected && strlen(cFileSelected) > 0) 
						{
							t.returnstring_s = cFileSelected;
							if (t.returnstring_s != "")
							{
								if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) == ".fpm")
								{
									t.gridentity = 0;
									t.inputsys.constructselection = 0;
									t.inputsys.domodeentity = 1;
									t.grideditselect = 5;
									editor_refresheditmarkers();

									g.projectfilename_s = t.returnstring_s;
									gridedit_load_map();

									iLaunchAfterSync = 80; //Update env
									iSkibFramesBeforeLaunch = 5;

									int firstempty = -1;
									int i = 0;
									for (; i < REMEMBERLASTFILES; i++) {
										if (firstempty == -1 && strlen(pref.last_open_files[i]) <= 0)
											firstempty = i;

										if (strlen(pref.last_open_files[i]) > 0 && pestrcasestr(g.projectfilename_s.Get(), pref.last_open_files[i])) { //already there
											break;
										}
									}
									if (i >= REMEMBERLASTFILES) {
										if (firstempty == -1) {
											//No empty slots , rotate.
											for (int ii = 0; ii < REMEMBERLASTFILES-1; ii++) {
												strcpy(pref.last_open_files[ii], pref.last_open_files[ii + 1]);
											}
											strcpy(pref.last_open_files[REMEMBERLASTFILES-1], g.projectfilename_s.Get());
										}
										else
											strcpy(pref.last_open_files[firstempty], g.projectfilename_s.Get());
									}


									//Locate player start marker.
									for (t.e = 1; t.e <= g.entityelementlist; t.e++)
									{
										if (t.entityelement[t.e].bankindex > 0)
										{
											if (t.entityprofile[t.entityelement[t.e].bankindex].ismarker == 1 && t.entityprofile[t.entityelement[t.e].bankindex].lives != -1)
											{
												//Point camera.
												t.obj = t.entityelement[t.e].obj;
												if (t.obj > 0) {
													float offsetx = ((float)GetDesktopWidth() - renderTargetAreaSize.x) * 0.25f;
													t.cx_f = ObjectPositionX(t.obj) + offsetx; //t.editorfreeflight.c.x_f;
													t.cy_f = ObjectPositionZ(t.obj); //t.editorfreeflight.c.z_f;
												}
												break;
											}
										}
									}

									#ifdef WICKEDENGINE
									strcpy(cTriggerMessage, "Level loaded");
									bTriggerMessage = true;
									#endif
								}
							}
						}
					}
					iLastUpdateVeg = 0;
					bUpdateVeg = true;
					break;
				#endif
				case 503: //Save the actual map here!
				{
					iLaunchAfterSync = 0;
					#ifdef WICKEDENGINE
					//PE: Just let the old "saving level..." fade away.
					//strcpy(cTriggerMessage, "Level saved");
					//bTriggerMessage = true;
					if (iLaunchAfterSyncAction == 11)
					{
						strcpy(cTriggerMessage, "A start marker has been added to your new level. This is where you will start in this level when you press Test Level.");
						bTriggerMessage = true;
						iTriggerMessageDelay = 30;
						iTriggerMessageY = 1;
						iMessageTimer = 0;
						iLaunchAfterSyncAction = 0;

						//MD: Ensures the saved camera position is close to the player start marker. Otherwise, terrain generator camera position would be saved.
						t.editorfreeflight.c.x_f = t.gridentityposx_f + 10.0f;
						t.editorfreeflight.c.y_f = t.gridentityposy_f + 200.0f;
						t.editorfreeflight.c.z_f = t.gridentityposz_f + 10.0f;
						t.editorfreeflight.c.angx_f = 70.0f;
						t.editorfreeflight.c.angy_f = -70.0f;
					}
					#endif
					gridedit_save_map();
					g.projectmodified = 0; gridedit_changemodifiedflag();
					g.projectmodifiedstatic = 0;

					break;
				}
				case 504: //Save the actual map here!
				{
					iLaunchAfterSync = 0;
					gridedit_save_map();
					g.projectmodified = 0; gridedit_changemodifiedflag();
					g.projectmodifiedstatic = 0;
					if (iLaunchAfterSyncAction == 1)
					{
						#ifdef WICKEDENGINE						
						bStoryboardWindow = true;
						GGTerrain_CancelRamp();
						#endif
					}
					if (iLaunchAfterSyncAction == 2)
					{
						iLaunchAfterSync = 2;
						iSkibFramesBeforeLaunch = 5;
					}

					if (iLaunchAfterSyncAction == 3)
					{
						//PE: Default to terrain tools , like when we launch Max.
						bForceKey = true;
						csForceKey = "t";
						bForceKey2 = true;
						csForceKey2 = "6";
						t.inputsys.domodeterrain = 1; t.inputsys.dowaypointview = 0;
						t.gridentitymarkersmodeonly = 0; t.grideditselect = 0;
						t.terrain.terrainpaintermode = 6;
						bTerrain_Tools_Window = true;
						// must reset any manual editing
						#ifdef WICKEDENGINE
						GGTerrain_ResetSculpting();
						void reset_terrain_paint_date(void);
						reset_terrain_paint_date();
						#endif
						iLaunchAfterSync = 5;
						iSkibFramesBeforeLaunch = 5;
					}

					iLaunchAfterSyncAction = 0;
					break;
				}
				case 3: //Save
					#ifdef WICKEDENGINE
					GGTerrain_CancelRamp();
					#endif

					iLaunchAfterSync = 0;
					if (g.projectmodified == 1)
					{
						if (t.ebe.on == 1)
							ebe_hide(); //Make sure we have last ebe changes.

						//  yes save first
						if (g.projectfilename_s == "")
						{
							t.returnstring_s = "";
							cStr tOldDir = GetDir();
							char * cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_SAVE, "fpm\0*.fpm\0", g.mysystem.mapbankAbs_s.Get(), NULL,true);
							SetDir(tOldDir.Get());
							if (cFileSelected && strlen(cFileSelected) > 0) {
								t.returnstring_s = cFileSelected;
							}
							if (t.returnstring_s != "")
							{
								if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) != ".fpm")  t.returnstring_s = t.returnstring_s + ".fpm";
								g.projectfilename_s = t.returnstring_s;
								bool oksave = true;
								if (FileExist(g.projectfilename_s.Get())) {
									oksave = overWriteFileBox(g.projectfilename_s.Get());
								}
								if (oksave) 
								{

									iLaunchAfterSync = 503; //Do the actualy save here.
									iSkibFramesBeforeLaunch = 3;

									//gridedit_save_map();

									//Add newly saved fpm level to recent list.
									int firstempty = -1;
									int i = 0;
									for (; i < REMEMBERLASTFILES; i++) {
										if (firstempty == -1 && strlen(pref.last_open_files[i]) <= 0)
											firstempty = i;

										if (strlen(pref.last_open_files[i]) > 0 && pestrcasestr(g.projectfilename_s.Get(), pref.last_open_files[i])) { //already there
											break;
										}
									}
									if (i >= REMEMBERLASTFILES) {
										if (firstempty == -1) {
											//No empty slots , rotate.
											for (int ii = 0; ii < REMEMBERLASTFILES - 1; ii++) {
												strcpy(pref.last_open_files[ii], pref.last_open_files[ii + 1]);
											}
											strcpy(pref.last_open_files[REMEMBERLASTFILES - 1], g.projectfilename_s.Get());
										}
										else
											strcpy(pref.last_open_files[firstempty], g.projectfilename_s.Get());
									}

									#ifdef WICKEDENGINE
									strcpy(cTriggerMessage, "Saving Level ...");
									bTriggerMessage = true;
									#endif
								}
							}
						}
						else
						{
							iLaunchAfterSync = 503; //Do the actualy save here.
							iSkibFramesBeforeLaunch = 3;
							//gridedit_save_map();
							#ifdef WICKEDENGINE
							strcpy(cTriggerMessage, "Saving Level ...");
							bTriggerMessage = true;
							#endif
						}

						//g.projectmodified = 0; gridedit_changemodifiedflag();
						//g.projectmodifiedstatic = 0;
					}
					break;

				case 4: //Save As
				{
					#ifdef WICKEDENGINE
					GGTerrain_CancelRamp();
					#endif

					cstr oldprojectfilename_s = g.projectfilename_s;
					iLaunchAfterSync = 0;
					if (t.ebe.on == 1)
						ebe_hide(); //Make sure we have last ebe changes.

					t.returnstring_s = "";
					cStr tOldDir = GetDir();
					char * cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_SAVE, "fpm\0*.fpm\0", g.mysystem.mapbankAbs_s.Get(), NULL,true);
					SetDir(tOldDir.Get());
					if (cFileSelected && strlen(cFileSelected) > 0) {
						t.returnstring_s = cFileSelected;
					}
					if (t.returnstring_s != "")
					{
						if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) != ".fpm")  t.returnstring_s = t.returnstring_s + ".fpm";
						g.projectfilename_s = t.returnstring_s;

						bool oksave = true;
						if (FileExist(g.projectfilename_s.Get())) {
							oksave = overWriteFileBox(g.projectfilename_s.Get());
						}
						if (oksave) 
						{
							//Add newly saved fpm level to recent list.
							int firstempty = -1;
							int i = 0;
							for (; i < REMEMBERLASTFILES; i++) {
								if (firstempty == -1 && strlen(pref.last_open_files[i]) <= 0)
									firstempty = i;
								if (strlen(pref.last_open_files[i]) > 0 && pestrcasestr(g.projectfilename_s.Get(), pref.last_open_files[i])) { //already there
									break;
								}
							}
							if (i >= REMEMBERLASTFILES) {
								if (firstempty == -1) {
									//No empty slots , rotate.
									for (int ii = 0; ii < REMEMBERLASTFILES - 1; ii++) {
										strcpy(pref.last_open_files[ii], pref.last_open_files[ii + 1]);
									}
									strcpy(pref.last_open_files[REMEMBERLASTFILES - 1], g.projectfilename_s.Get());
								}
								else
									strcpy(pref.last_open_files[firstempty], g.projectfilename_s.Get());
							}

							iLaunchAfterSync = 503; //Do the actualy save here.
							iSkibFramesBeforeLaunch = 3;

							//PE: Change storyboard node to new save as project name.
							if (iLevelEditorFromStoryboardID >= 0)
							{
								//Validate we have the correct one.
								if (iLevelEditorFromStoryboardID < STORYBOARD_MAXNODES)
								{
									if (stricmp(Storyboard.Nodes[iLevelEditorFromStoryboardID].level_name, oldprojectfilename_s.Get()) == NULL)
									{
										//Valid , Update node.

										//Only relative.
										char tmp[MAX_PATH];
										strcpy(tmp, t.returnstring_s.Get());
										char *find = (char *)pestrcasestr(tmp, "mapbank\\");
										if (find && find != &tmp[0]) strcpy(&tmp[0], find);

										std::string sLevelPath = &tmp[0];

										int iPos;
										for (iPos = strlen(tmp); iPos >= 0; iPos--)
											if (tmp[iPos] == '\\') break;
										if (iPos > 0) iPos++;
										std::string sLevelTitle = &tmp[iPos];
										replaceAll(sLevelTitle, ".fpm", "");

										strcpy(Storyboard.Nodes[iLevelEditorFromStoryboardID].level_name, sLevelPath.c_str());
										strcpy(Storyboard.Nodes[iLevelEditorFromStoryboardID].title, sLevelTitle.c_str());
									}
								}
							}

//							gridedit_save_map();

							#ifdef WICKEDENGINE
							strcpy(cTriggerMessage, "Saving Level ...");
							bTriggerMessage = true;
							#endif
						}
					}

					//g.projectmodified = 0; gridedit_changemodifiedflag();
					//g.projectmodifiedstatic = 0;

					break;
				}

				case 5: // New flatten level
				{
					#ifdef WICKEDENGINE
					GGTerrain_CancelRamp();
					#endif

					iLaunchAfterSync = 0;
					int iRet = 0;
					#ifdef WICKEDENGINE
					if (!bNoSecondAsk)
					{
					#endif
						iRet = AskSaveBeforeNewAction();
					#ifdef WICKEDENGINE
					}
					else
					{
						bNoSecondAsk = false;
						iRet = 0;
					}
					#endif
					if (iRet != 2)
					{
						#ifdef PROCEDURALTERRAINWINDOW
						// need to trigger the new level code
						t.inputsys.donewflat = 1;
						t.inputsys.donew == 1;//?
						gridedit_new_map();
						t.inputsys.donewflat = 0;
						t.inputsys.donew = 0;
						iLaunchAfterSync = 80;
						iSkibFramesBeforeLaunch = 5;
						//strcpy(cTriggerMessage, "New level created");
						//bTriggerMessage = true;
						// go to procedural terrain generator
						bProceduralLevel = true;
						bProceduralLevelStartup = true; // will trigger a random theme to be selected (overriding EMPTY init above)
						GGTerrain_RemoveHeightMap();
						iLevelEditorFromStoryboardID = -1; //We cant update storyboard.

						#else
						#ifdef WICKEDENGINE
						extern bool g_bTerrainGeneratorChooseRealTerrain;
						g_bTerrainGeneratorChooseRealTerrain = false;
						HWND hThisWnd = GetForegroundWindow();
						if (MessageBoxA(hThisWnd, "Do you want the terrain textured with grass?", "Terrain Generator (This feature is incomplete)", MB_YESNO) == IDYES)
						{
							// select grass instead of grey grid for the terrain
							g_bTerrainGeneratorChooseRealTerrain = true;
						}
						#endif
						t.inputsys.donewflat = 1;
						t.inputsys.donew == 1;
						gridedit_new_map();
						t.inputsys.donewflat = 0;
						t.inputsys.donew = 0;

						iLaunchAfterSync = 80; //Update env
						iSkibFramesBeforeLaunch = 5;

						#ifdef WICKEDENGINE
						strcpy(cTriggerMessage, "New level created");
						bTriggerMessage = true;
						#endif
						#endif // else PROCEDURALTERRAINWINDOW
					}
					#ifndef PROCEDURALTERRAINWINDOW
					iLastUpdateVeg = 0;
					bUpdateVeg = true;
					#endif

					break;
				}

				case 6: // New level
				{
					#ifdef WICKEDENGINE
					GGTerrain_CancelRamp();
					#endif

					iLaunchAfterSync = 0;
					int iRet = AskSaveBeforeNewAction();
					if (iRet != 2)
					{
						t.inputsys.donewflat = 0;
						t.inputsys.donew == 1;
						gridedit_new_map();
						t.inputsys.donewflat = 0;
						t.inputsys.donew = 0;

						iLaunchAfterSync = 80; //Update env
						iSkibFramesBeforeLaunch = 5;

						#ifdef WICKEDENGINE
						strcpy(cTriggerMessage, "New level created");
						bTriggerMessage = true;
						#endif
					}
					iLastUpdateVeg = 0;
					bUpdateVeg = true;
					break;
				}

				#ifndef WICKEDENGINE
				case 7: // Direct Open
				{
					iLaunchAfterSync = 0;
					int iRet;
					iRet = AskSaveBeforeNewAction();
					if (iRet != 2)
					{
						if (strlen(cDirectOpen) > 0) {

							t.returnstring_s = cDirectOpen;
							if (t.returnstring_s != "")
							{
								if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) == ".fpm")
								{
									t.gridentity = 0;
									t.inputsys.constructselection = 0;
									t.inputsys.domodeentity = 1;
									t.grideditselect = 5;
									editor_refresheditmarkers();

									g.projectfilename_s = t.returnstring_s;
									gridedit_load_map();

									iLaunchAfterSync = 80; //Update env
									iSkibFramesBeforeLaunch = 5;

									//Locate player start marker.
									for (t.e = 1; t.e <= g.entityelementlist; t.e++)
									{
										if (t.entityelement[t.e].bankindex > 0)
										{
											if (t.entityprofile[t.entityelement[t.e].bankindex].ismarker == 1 && t.entityprofile[t.entityelement[t.e].bankindex].lives != -1)
											{
												//Point camera.
												t.obj = t.entityelement[t.e].obj;
												if (t.obj > 0) {
													float offsetx = ((float)GetDesktopWidth() - renderTargetAreaSize.x) * 0.25f;
													t.cx_f = ObjectPositionX(t.obj) + offsetx; //t.editorfreeflight.c.x_f;
													t.cy_f = ObjectPositionZ(t.obj); //t.editorfreeflight.c.z_f;
												}
												break;
											}
										}
									}

								}
							}
						}
					}
					iLastUpdateVeg = 0;
					bUpdateVeg = true;
					break;
				}
				#endif

				case 8: //Import model.
				{
					iLaunchAfterSync = 0;

					// if free trial, no import
					if (g_bFreeTrialVersion == true)
					{
						bFreeTrial_Window = true;
						break;
					}

					#ifdef WICKEDENGINE
					GGTerrain_CancelRamp();
					#endif

					#ifdef WICKEDENGINE
					if (sDefaultImportPath == "")
						sDefaultImportPath = g.fpscrootdir_s;
					#endif
					cStr tOldDir = GetDir();
					char * cFileSelected;
					#ifdef WICKEDENGINE
					if (strlen(pLaunchAfterSyncPreSelectModel) > 0)
					{
						// can trigger the importer with a preselected model filename (used by scaling mode changes)
						cFileSelected = pLaunchAfterSyncPreSelectModel;
					}
					else
					{
						// otherwise by default it requests a model file
						cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "All\0*.*\0X\0*.x\0DBO\0*.dbo\0OBJ\0*.obj\0FBX\0*.fbx\0GLTF\0*.gltf\0GLB\0*.glb\0\0\0", sDefaultImportPath.Get(), NULL, true, "Import Model");

						// store last manually selected model file (for reload for scaling mode)
						if ( cFileSelected ) 
							strcpy (pLaunchAfterSyncLastImportedModel, cFileSelected);
						else
							strcpy (pLaunchAfterSyncLastImportedModel, "");
					}
					#else
					cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "All\0*.*\0X\0*.x\0DBO\0*.dbo\0OBJ\0*.obj\0FBX\0*.fbx\0GLTF\0*.gltf\0GLB\0*.glb\0\0\0", NULL, NULL , true );
					#endif
					SetDir(tOldDir.Get());
					if (cFileSelected && strlen(cFileSelected) > 0) 
					{
						char szModelPath[ MAX_PATH ];
						strcpy( szModelPath, cFileSelected );
						const char* pExtension = strrchr( szModelPath, '.' );
						if ( !pExtension )
						{
							strcpy(cTriggerMessage, "File extension not found");
							bTriggerMessage = true;
						}
						else
						{
							#ifdef WICKEDENGINE
							bool bFoundModel = true;
							// extract zip file and set szModelPath to first model found
							if ( _stricmp(pExtension, ".zip") == 0 )
							{
								char szSubZipPath[ MAX_PATH ];
								bool bFoundSubZip = false;

								bFoundModel = false;
								char rootFolder[ MAX_PATH ];
								strcpy( rootFolder, GG_GetWritePath() );
								strcat( rootFolder, "imported_models\\" );

								// add zip file name as a folder to extract to
								char* pSlash = strrchr( szModelPath, '/' );
								char* pBSlash = strrchr( szModelPath, '\\' );
								if ( pBSlash > pSlash ) pSlash = pBSlash;
								if ( pSlash ) strcat( rootFolder, pSlash+1 );
								
								// remove extension
								pSlash = strrchr( rootFolder, '.' );
								if ( pSlash ) *pSlash = 0;
								strcat( rootFolder, "\\" );

								char finalPath[ MAX_PATH ];
								
								// extract zip file
								mz_zip_archive zip_archive;
								memset(&zip_archive, 0, sizeof(zip_archive));
								if ( !mz_zip_reader_init_file( &zip_archive, szModelPath, 0 ) )
								{
									mz_zip_reader_end( &zip_archive );
									strcpy(cTriggerMessage, "Failed to open zip file for reading");
									bTriggerMessage = true;
								}
								int numFiles = mz_zip_reader_get_num_files( &zip_archive );
								char filename[ 1024 ];
								for( int i = 0; i < numFiles; i++ )
								{
									mz_zip_reader_get_filename( &zip_archive, i, filename, 1024 );

									if ( mz_zip_reader_is_file_a_directory( &zip_archive, i ) ) 
									{
										// skip empty folders
										continue;
									}
            
									if ( strlen(rootFolder) + strlen(filename) + 3 > MAX_PATH ) continue;

									strcpy( finalPath, rootFolder );
									strcat( finalPath, filename );
                        
									// look for model file
									if ( !bFoundModel )
									{
										pExtension = strrchr( filename, '.' );
										if ( pExtension )
										{
											if ( !stricmp(pExtension, ".x") 
											  || !stricmp(pExtension, ".dbo")
											  || !stricmp(pExtension, ".obj")
											  || !stricmp(pExtension, ".fbx")
											  || !stricmp(pExtension, ".gltf")
											  || !stricmp(pExtension, ".glb") )
											{
												bFoundModel = true;
												strcpy( szModelPath, finalPath );
											}
											if ( !stricmp(pExtension, ".zip") )
											{
												bFoundSubZip = true;
												strcpy( szSubZipPath, finalPath );
											}
										}
									}
            
									GG_CreatePath( finalPath );
            
									mz_zip_reader_extract_to_file( &zip_archive, i, finalPath, 0 );
								}
        
								mz_zip_reader_end( &zip_archive );

								if ( !bFoundModel && bFoundSubZip )
								{
									char* pSlash = strrchr( szSubZipPath, '/' );
									char* pBSlash = strrchr( szSubZipPath, '\\' );
									if ( pBSlash > pSlash ) pSlash = pBSlash;
									if ( pSlash ) strcat( rootFolder, pSlash+1 );
								
									// remove extension
									pSlash = strrchr( rootFolder, '.' );
									if ( pSlash ) *pSlash = 0;
									strcat( rootFolder, "\\" );

									char finalPath[ MAX_PATH ];
								
									// extract zip file
									mz_zip_archive zip_archive;
									memset(&zip_archive, 0, sizeof(zip_archive));
									if ( !mz_zip_reader_init_file( &zip_archive, szSubZipPath, 0 ) )
									{
										mz_zip_reader_end( &zip_archive );
										strcpy(cTriggerMessage, "Failed to open zip file for reading");
										bTriggerMessage = true;
									}
									int numFiles = mz_zip_reader_get_num_files( &zip_archive );
									char filename[ 1024 ];
									for( int i = 0; i < numFiles; i++ )
									{
										mz_zip_reader_get_filename( &zip_archive, i, filename, 1024 );

										if ( mz_zip_reader_is_file_a_directory( &zip_archive, i ) ) 
										{
											// skip empty folders
											continue;
										}
            
										if ( strlen(rootFolder) + strlen(filename) + 3 > MAX_PATH ) continue;

										strcpy( finalPath, rootFolder );
										strcat( finalPath, filename );
                        
										// look for model file
										if ( !bFoundModel )
										{
											pExtension = strrchr( filename, '.' );
											if ( pExtension )
											{
												if ( !stricmp(pExtension, ".x") 
												  || !stricmp(pExtension, ".dbo")
												  || !stricmp(pExtension, ".obj")
												  || !stricmp(pExtension, ".fbx")
												  || !stricmp(pExtension, ".gltf")
												  || !stricmp(pExtension, ".glb") )
												{
													bFoundModel = true;
													strcpy( szModelPath, finalPath );
												}
											}
										}
            
										GG_CreatePath( finalPath );
            
										mz_zip_reader_extract_to_file( &zip_archive, i, finalPath, 0 );
									}
        
									mz_zip_reader_end( &zip_archive );
								}
							}

							if ( !bFoundModel )
							{
								strcpy(cTriggerMessage, "Zip file does not contain a recognised model format");
								bTriggerMessage = true;
							}
							else
							{
								t.returnstring_s = szModelPath;
								const char* pExtension = strrchr( szModelPath, '.' );
								bool bPermittedFormat = false;
								if (stricmp(pExtension, ".x") == NULL) bPermittedFormat = true;
								if (stricmp(pExtension, ".dbo") == NULL) bPermittedFormat = true;
								if (stricmp(pExtension, ".obj") == NULL) bPermittedFormat = true;
								if (stricmp(pExtension, ".fbx") == NULL) bPermittedFormat = true;
								if (stricmp(pExtension, ".gltf") == NULL) bPermittedFormat = true;
								if (stricmp(pExtension, ".glb") == NULL) bPermittedFormat = true;
								//if (stricmp(pExtension, ".dae") == NULL) bPermittedFormat = true;
								//if (stricmp(pExtension, ".3ds") == NULL) bPermittedFormat = true;
								if ( bPermittedFormat == true )
								{
									// load the model
									#ifdef WICKEDENGINE
									sDefaultImportPath = t.returnstring_s; //Remember last import path.
									#endif
									t.timporterfile_s = t.returnstring_s;
									importer_loadmodel();
								}
								else 
								{
									strcpy(cTriggerMessage, "This is not a supported model file.");
									bTriggerMessage = true;
								}
							}
							#else
							t.returnstring_s = szModelPath;
							bool bPermittedFormat = false;
							if (stricmp(pExtension, ".x") == NULL) bPermittedFormat = true;
							if (stricmp(pExtension, ".dbo") == NULL) bPermittedFormat = true;
							if (stricmp(pExtension, ".obj") == NULL) bPermittedFormat = true;
							if (stricmp(pExtension, ".fbx") == NULL) bPermittedFormat = true;
							if (bPermittedFormat == true)
							{
								// load the model
								t.timporterfile_s = t.returnstring_s;
								importer_loadmodel();
							}
							else
							{
								strcpy(cTriggerMessage, "This is not a supported model file.");
								bTriggerMessage = true;
							}
							#endif
						}
					}
					if (bDelayedTutorialCheckAction == TOOL_IMPORT) 
					{
						bDelayedTutorialCheckAction = -1;
						TutorialNextAction();
					}
					// clear 'pLaunchAfterSyncPreSelectModel' as this is a one time use until set again
					#ifdef WICKEDENGINE
					if (strlen(pLaunchAfterSyncPreSelectModel) > 0)
					{
						strcpy (pLaunchAfterSyncPreSelectModel, "");
					}
					#endif
					break;
				}

				case 80: //Update envmap
				{
					iLaunchAfterSync = 0;
					//Make sure we have envmap.
					visuals_justshaderupdate();
					t.visuals.refreshskysettingsfromlua = true;
					cubemap_generateglobalenvmap();
					t.visuals.refreshskysettingsfromlua = false;
					//extern bool bFullVegUpdate;
					//bFullVegUpdate = true;
					bUpdateVeg = true;

					#ifdef WICKEDENGINE
					//PE: We need to recreate probes after all objects is placed, so we can find the probe boundingbox.
					for (int te = 1; te <= g.entityelementlist; te++)
					{
						int entid = t.entityelement[te].bankindex;
						if (entid > 0)
						{
							if (t.entityprofile[entid].ismarker == 2)
							{
								float fLightProbeScale = t.entityelement[te].eleprof.light.fLightHasProbe;
								if ( fLightProbeScale > 0 )
									entity_placeprobe(t.entityelement[te].obj, fLightProbeScale);
								else
									entity_deleteprobe(t.entityelement[te].obj);
							}
						}

						//MD: Also make sure autoflatten areas are applied
						entity_autoFlattenWhenAdded(te);
					}


					if (bLaunchTestGameAfterLoad)
					{
						bLaunchTestGameAfterLoad = false;
						iLaunchAfterSync = 1;
					}
					if (bLaunchSaveStandalonefterLoad)
					{
						bExport_Standalone_Window = true;
						bLaunchSaveStandalonefterLoad = false;
					}
					if (bCloseStoryboardAfterLoad)
					{
						bStoryboardWindow = false;
						bCloseStoryboardAfterLoad = false;
					}
					#endif

					break;
				}

				case 81: //Delayed window focus.
				{
					iLaunchAfterSync = 0;
					#ifdef WICKEDENGINE
					//Make sure we have envmap.
					ImGui::SetWindowFocus(cNextWindowFocus);
					strcpy(cNextWindowFocus, "");
					#endif
					break;
				}

				case 82: //Delayed window focus.
				{
					iLaunchAfterSync = 0;
					#ifdef WICKEDENGINE
					g_bCharacterCreatorPlusActivated = true;
					#endif
					break;
				}

				default:
					break;
			}
		}
		else
		{
			iSkibFramesBeforeLaunch--;
		}

		//###########################
		//#### Trigger A Message ####
		//###########################
		bool bForceMessageNoFade = false;
		gridedit_triggermessagehandler(bForceMessageNoFade);

		//PE: Hide transition from storyboard to terrain generator.
		if (iBlackoutForFrames > 0)
		{
			if (iBlackoutForFrames != 5)
			{
				//PE: newlevel: bBlockImGuiUntilNewFrame = true; Triggered , what to do ?
				if (bBlockImGuiUntilNewFrame)
					g_bNoSwapchainPresent = true;

				//PE: Hide everything in the background (wicked 3D stuff).
				ImGuiViewport* mainviewport = ImGui::GetMainViewport();
				if (0) //PE: Switched to normal message.
				{
					if (mainviewport)
					{
						ImDrawList* drawlist = ImGui::GetForegroundDrawList(mainviewport);
						if (drawlist)
						{
							ImVec4 monitor_col = ImVec4(0, 0, 0, 1.0); //Black for now.
							drawlist->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(40, 40), ImGui::GetColorU32(monitor_col));

							ImGuiContext& g = *GImGui;
							ImGui::SetWindowFontScale(2.0);
							ImVec2 tsize = ImGui::CalcTextSize("Preparing the Terrain Generator.Please wait...");
							ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;
							ImVec2 tpos = (viewPortSize * 0.5) - (tsize * 0.5);
							drawlist->AddText(g.Font, g.FontSize, tpos, ImGui::GetColorU32(ImGuiCol_Text), "Preparing the Terrain Generator.Please wait...");
							ImGui::SetWindowFontScale(1.0);

						}
					}
				}
			}
			iBlackoutForFrames--;
			if(iBlackoutForFrames == 0)
				g_bNoSwapchainPresent = false;
				
		}
	}
	#endif

	// 191015 - Trigger quick start dialog when editor flowing
	if ( iCountDownToShowQuickStartDialog > 0 )
	{
		iCountDownToShowQuickStartDialog--;
		if ( iCountDownToShowQuickStartDialog == 0 )
		{
			// insert parental control prompt if not used before
			if ( g.quickparentalcontrolmode == 0 )
			{
				// 050416 - ensure once time entrance to parental control from boot-up
				g.quickparentalcontrolmode = 1;
				editor_showparentalcontrolpage ();
			}
		}
	}
	#ifdef VRTECH
	#else
	else
	{
		#ifdef FREETRIALVERSION
			if ( g.iFreeVersionModeActive == 2 && dwStartOfEditingSession > 0 && timeGetTime() > dwStartOfEditingSession )
			{
			welcome_init(1);
			welcome_init(0);
			welcome_init(2);
			g.iFreeVersionModeActiveDuringEditor = 1;
			welcome_show(WELCOME_FREETRIALINTROAPP);
			g.iFreeVersionModeActiveDuringEditor = 0;
			welcome_free();
			if (dwSecondReminder == 0)
			{
				dwSecondReminder = 1;
				dwStartOfEditingSession = timeGetTime() + (1000*60*60);
			}
			else
				dwStartOfEditingSession = 0;
			}
		#endif
	}
	#endif

	//  Do not get start memory until processed one loop (below)
	if (  t.gamememactuallyusedstarttriggercount>0 ) 
	{
		--t.gamememactuallyusedstarttriggercount;
		if (  t.gamememactuallyusedstarttriggercount == 0 ) 
		{
			g.gamememactuallyusedstart=SMEMAvailable(1);
		}
	}

	//  Machine Independent Speed
	game_timeelapsed ( );
	t.ts_f=(Timer()-t.tsl_f)/50.0 ; t.tsl_f=Timer();

	//  Send SteamID to the editor if needed
	mp_sendSteamIDToEditor ( );

	//  User input calls
	#ifdef ENABLEIMGUI
	static bool imgui_onetime_init = false;
	if (g.globals.ideinputmode == 1) {

		#ifndef USEOLDIDE
		imgui_input_getcontrols();
		#else
		input_getcontrols();
		#endif
	}
	else 
	{
		input_getcontrols();
	}

	if (!imgui_onetime_init) 
	{
		imgui_onetime_init = true;
	}
	#else
	//  User input calls
	input_getcontrols();
	#endif

	bool bTitleSystemActive = true;
	#ifdef WICKEDENGINE
	if ((bTriggerWhatsNewInStoryboard && g_iWelcomeLoopPage == WELCOME_ANNOUNCEMENTS))
		bTitleSystemActive = false;
	#endif
	#ifdef VRTECH
	if (bTitleSystemActive)
	{
		// could not launch Welcome system before IMGUI inits, so flagged to happen here
		if (iTriggerWelcomeSystemStuff > 0 && iTriggerWelcomeSystemStuff < 6) iTriggerWelcomeSystemStuff++;
		if (iTriggerWelcomeSystemStuff > 5)
		{
			// Init or Cycle
			if (iTriggerWelcomeSystemStuff == 6)
			{
				// only show front dialogs if not resuming from previous session
				if (g.grestoreeditorsettings == 0)
				{
					// Welcome quick start page
					g.quickstartmenumode = 0;
					if (g.iFreeVersionModeActive != 0)
					{
						editor_showquickstart(0);
						iTriggerWelcomeSystemStuff = 99;
					}
					else
					{
						if (g.gshowonstartup == 1 || g.iTriggerSoftwareToQuit != 0)
						{
							#ifdef WICKEDENGINE
							if(!bAddWhatNewToMenu) //Already in menu.
							#endif
								editor_showquickstart(0);
							iTriggerWelcomeSystemStuff = 99;
						}
						else
						{
							welcome_free();
							iTriggerWelcomeSystemStuff = 7;
						}
					}
				}
				else
				{
					// always need to close down loading splash
					welcome_free();
					iTriggerWelcomeSystemStuff = 7;
				}
			}
			else if (iTriggerWelcomeSystemStuff == 7)
			{
				//Exit wait for mouse release before closing welcome screen.
				if (t.inputsys.mclick == 0)
					iTriggerWelcomeSystemStuff = 0;
			}
			else
			{
				// Cycle - handle welcome loop
				if (welcome_cycle() == true)
				{
					welcome_free();
					iTriggerWelcomeSystemStuff = 7;
				}
			}

			//Make sure we dont sent input to rendertarget when in welcome.
			t.inputsys.xmouse = 500000;
			t.inputsys.ymouse = 0;
			t.inputsys.xmousemove = 0;
			t.inputsys.ymousemove = 0;
			set_inputsys_mclick(0);// t.inputsys.mclick = 0;
			t.inputsys.zmouse = 0;
			t.inputsys.wheelmousemove = 0;
			t.inputsys.activemouse = 0;
			t.syncthreetimes = 1;
			t.inputsys.k_s = "";
			t.inputsys.keyreturn = 0;
			t.inputsys.keyshift = 0;
			t.inputsys.keytab = 0;
			t.inputsys.keyleft = 0;
			t.inputsys.keyright = 0;
			t.inputsys.keyup = 0;
			t.inputsys.keydown = 0;
			t.inputsys.keycontrol = 0;
			t.inputsys.keyspace = 0;
			t.inputsys.kscancode = 0;

		}
	}
	#endif

	// calc local cursor
	bool bPickActive = true;
	#ifdef WICKEDENGINE
	iReusePickObjectID = -1;
	pReusePickObject = 0;
	
	if (pref.iDragCameraMovement && t.ebe.on == 0 && bDragCameraActive)
		bPickActive = false;
	#endif
	if(bPickActive)
		input_calculatelocalcursor ( );

	// Character Creator Plus
	#ifdef VRTECH
	if ( g_bCharacterCreatorPlusActivated == true )
	{
		// character creator plus character edited in situ
		charactercreatorplus_loop();
	}
	#endif

	#ifdef BUILDINGEDITOR
	BuildingEditor::loop();
	#endif

	//  Importer or Main Editor
	if ( t.importer.loaded != 0 || (t.interactive.active == 1 && (t.interactive.pageindex<21 || t.interactive.pageindex>90)) )
	{
		//  Importer control or Interactive Mode
		if (  t.importer.loaded != 0 ) 
		{
			importer_loop ( );
			importer_draw ( );
		}
	}
	else
	{
		//  Character Kit Active
		#ifdef VRTECH
		//if(0) // t.characterkit.loaded !=  0 ) 
		//{
			// bye bye character creator, welcome plus!
			//characterkit_loop ( );
			//characterkit_draw ( );
		//}
		//else
		#else
		if ( t.characterkit.loaded !=  0 ) 
		{
			characterkit_loop ( );
			characterkit_draw ( );
		}
		else
		#endif
		{
			// give editor a chance to init, then switch to EBE for quick coding!
			// Editor Controls
			terrain_terraintexturesystempainterentry();
			editor_constructionselection();

			#ifdef WICKEDENGINE
			if (t.grideditselect != 0)
			{
				//PE: Make sure to hide "cubes" when not editing.
				WickedCall_DisplayCubes(false);
			}
			#endif

			if ( t.grideditselect == 3 || t.grideditselect == 4 ) 
			{
				// Entity controls
				editor_viewfunctionality ( );
			}
			else
			{
				editor_mainfunctionality ( );
				if ( t.grideditselect == 0 ) 
				{
					// Terrain controls
					t.terrain.camx_f=t.cx_f ; t.terrain.camz_f=t.cy_f;
					t.terrain.zoom_f=t.gridzoom_f*0.12;
					terrain_editcontrol ( );
					#ifdef WICKEDENGINE
					if (BackBufferImageID <= 0)
					{
						WickedCall_DisplayCubes(true);
					}
					grass_editcontrol();

					//PE: Make sure clicks inside terrain tools also record a change, so level is saved.
					if (bImGuiRenderTargetFocus)
					{
						//  Any click inside 3D area constitues some sort of edit
						if (t.inputsys.mclick != 0)
						{
							g.projectmodified = 1;
							gridedit_changemodifiedflag();
							// effect on g.projectmodifiedstatic
						}
					}
					#endif
				}
				else
				{
					if ( t.ebe.on == 1 )
					{
						// Easy Building Editor
						ebe_loop();
					}
					else
					{
						//  Non-terrain controls
						gridedit_mapediting ( );
						terrain_editcontrol_auxiliary ( );
					}
				}
			}

			editor_overallfunctionality ( );
			terrain_detectendofterraintexturesystempainter ( );

			//  Handle visual components
			editor_detect_invalid_screen ( );
			editor_visuals ( );
			editor_undergroundscan ( );

			//  Ensure entity animations speeds are controlled
			if(!bExport_Standalone_Window)
				entity_loopanim ( );

			//  Widget control
			widget_loop ( );

			//  Character creator loop
			///characterkit_updateAllCharacterCreatorEntitiesInMap ( );

			//  Ensure lighting is updated as lighting is edited and moved
			lighting_loop ( );

			//  Only show terrain cursor if in terrain edit mode
			if (  t.grideditselect == 0 && t.inputsys.mclick != 2 && t.inputsys.mclick != 4 && t.interactive.insidepanel == 0 ) 
			{
				terrain_cursor ( );
			}
			else
			{
				terrain_cursor_off ( );
			}

			//  Render terrain elements (shadowupdatepacer as shadow calc is expensive, time slice it)
			t.terrain.gameplaycamera=0;
			if ( Timer() > (int)t.editor.shadowupdatepacer ) 
			{
				t.editor.shadowupdatepacer=Timer()+20;
				terrain_shadowupdate ( );
			}
			terrain_update ( );
			terrain_waterineditor ( );

			#ifndef WICKEDENGINE
			//  IDE Communications (only when mouse not in 3D view)
			if (  t.inputsys.xmouse == 500000  )  t.inputsys.residualidecount = 10;
			if (  t.inputsys.residualidecount>0  )  t.inputsys.residualidecount = t.inputsys.residualidecount-1;
			if (  t.inputsys.residualidecount>0 ) 
			{
				//  Interface code
				interface_handlepropertywindow ( );

				//  Handle save standalone (cannot wait after 758 as straight into domodal)
				#ifdef FPSEXCHANGE
				OpenFileMap(3, "FPSEXCHANGE");
				for (t.idechecks = 1; t.idechecks <= 3; t.idechecks++)
				{
					if (t.idechecks == 1) { t.virtualfileindex = 758; t.tvaluetocheck = 1; }
					if (t.idechecks == 2) { t.virtualfileindex = 762; t.tvaluetocheck = 1; }
					if (t.idechecks == 3) { t.virtualfileindex = 762; t.tvaluetocheck = 2; }
					t.tokay = GetFileMapDWORD(3, t.virtualfileindex);
					if (t.tokay == t.tvaluetocheck)
					{
						SetEventAndWait(3);
						//CloseFileMap (  3 );
						if (t.idechecks == 1)
						{
							// Save Standalone
							gridedit_intercept_savefirst();
							OpenFileMap(3, "FPSEXCHANGE");
							if (t.editorcanceltask == 0)
							{
								popup_text(t.strarr_s[82].Get());
								gridedit_load_map(); // 190417 - ensures levelbank contents SAME as level 1 FPM!

								// new dialog to handle save standalone
								popup_text_close();
								//mapfile_savestandalone ( );
								//suggest new init code to load just what the save standalone dialog needs
								welcome_init(1);
								welcome_init(2);
								welcome_init(0);
								welcome_show(WELCOME_SAVESTANDALONE);
								welcome_free();
								SetFileMapDWORD(3, t.virtualfileindex, 3);
							}
							else
							{
								SetFileMapDWORD(3, t.virtualfileindex, 0);
							}
						}
						if (t.idechecks == 2)
						{
							// (dave) Skip terrain rendering - it causes a crash in debug
							g_bSkipTerrainRender = true;

							//  Import Model
							gridedit_import_ask();
							SetFileMapDWORD(3, t.virtualfileindex, 0);
						}
						if (t.idechecks == 3)
						{
							// Character Creator Plus
							//this is now old code, and will be removed during clean-up after first functionality draft complete
							//g_bCharacterCreatorPlusActivated = true; //if (t.characterkit.loaded == 0)  t.characterkit.loaded = 1;
							#ifndef VRTECH
							if (t.characterkit.loaded == 0)  t.characterkit.loaded = 1;
							#endif
							SetFileMapDWORD(3, t.virtualfileindex, 0);
						}
						SetEventAndWait(3);
					}
				}
				#endif

				// Handle auto trigger stock level loader
				#ifdef FPSEXCHANGE
				OpenFileMap (  3, "FPSEXCHANGE" );
				t.tleveltoautoload=GetFileMapDWORD( 3, 754 );
				if (  t.tleveltoautoload>0 ) 
				{
					// clear flag on performing this action
					SetFileMapDWORD (  3, 754, 0 );
					SetEventAndWait (  3 );

					// trigger event or load a map
					if ( t.tleveltoautoload>=1001 )
					{
						// trigger events
						if ( t.tleveltoautoload==1001 ) 
						{
							g.quickstartmenumode = 0;
							editor_showquickstart ( 1 );
						}
						if ( t.tleveltoautoload==1002 ) 
						{
							editor_showparentalcontrolpage();
						}
					}
					else
					{
						// load a map
						t.tlevelautoload_s="";
						switch (  t.tleveltoautoload ) 
						{
							case 1 : t.tlevelautoload_s = "The Big Escape.fpm" ; break ;
							case 2 : t.tlevelautoload_s = "Cartoon Antics.fpm" ; break ;
							case 3 : t.tlevelautoload_s = "Get To The River.fpm" ; break ;
							case 4 : t.tlevelautoload_s = "The Heirs Revenge.fpm" ; break ;
							case 5 : t.tlevelautoload_s = "Morning Mountain Stroll.fpm" ; break ;
							case 6 : t.tlevelautoload_s = "The Asylum.fpm" ; break ;
							case 7 : t.tlevelautoload_s = "Gem World.fpm" ; break ;
							case 21 : t.tlevelautoload_s = "Bridge Battle (MP).fpm" ; break ;
							case 22 : t.tlevelautoload_s = "Camp Oasis (MP).fpm" ; break ;
							case 23 : t.tlevelautoload_s = "Devils Hill (MP).fpm" ; break ;
							case 24 : t.tlevelautoload_s = "Sunset Island (MP).fpm" ; break ;
							case 25 : t.tlevelautoload_s = "The Beach (MP).fpm" ; break ;
						}
						t.tlevelautoload_s=g.mysystem.mapbankAbs_s+t.tlevelautoload_s;//g.fpscrootdir_s+"\\Files\\mapbank\\"+t.tlevelautoload_s;

						//  ask to save first if modified project open
						t.editorcanceltask=0;
						if (  g.projectmodified == 1 ) 
						{
							//  If project modified, ask if want to save first
							gridedit_intercept_savefirst ( );
						}
						if (  t.editorcanceltask == 0 ) 
						{
							if (  t.tlevelautoload_s != "" ) 
							{
								if (  cstr(Lower(Right(t.tlevelautoload_s.Get(),4))) == ".fpm" ) 
								{
									g.projectfilename_s=t.tlevelautoload_s;
									gridedit_load_map ( );
#ifdef WICKEDENGINE
									grass_init();
									bUpdateVeg = true;
#endif

								}
							}
						}
					}
				}
				#endif
			}
			#endif
			// 111115 - keep track of memory between sessions with simpler SYSMEM minus STARTMEM calculation
			g.gamememactuallyused = SMEMAvailable(1) - g.gamememactuallyusedstart;

			// 111115 - and introduce sliding effect to hide flicker due to reading direct system memory value
			t.tmempercdest_f = (g.gamememactuallyused+0.0f) / (g.gamememactualmaxrightnow+0.0f);
			if ( t.tmemperc_f < t.tmempercdest_f-0.01f )
			{
				t.tmemperc_f = t.tmemperc_f + 0.01f;
			}
			else
			{
				if ( t.tmemperc_f > t.tmempercdest_f+0.01f )
				{
					t.tmemperc_f = t.tmemperc_f - 0.01f;
				}
			}

			if (  t.tmemperc_f > 1.0f  )  t.tmemperc_f = 1.0;
			if (  g.ghidememorygauge == 0 ) 
			{
				// (Dave) - check the image exists
				if ( ImageExist ( g.editorimagesoffset+2 ) == 1 )
				{
					Ink (  Rgb(0,0,0),0  ); Box (  2,2,102,18 );
					Ink (  Rgb(0,255,0),0  ); Box (  2,2,3+(99*t.tmemperc_f),18 );
					PasteImage (  g.editorimagesoffset+2,2,2,1 );
				}
			}
			//  End of Character Creator branch
		}
		//  Import/Editor branch
	}

	//  Constantly checking if VIDMEM invalidated
	editor_detect_invalid_screen ( );

	// 191015 - test level click prompt
	if ( g.showtestlevelclickprompt > 0 )
	{
		if ( timeGetTime() > g.showtestlevelclickprompt )
		{
			g.showtestlevelclickprompt = 0;
		}
		int iXPos = 630;
		int iYPos = abs ( cos( timeGetTime()/500.0f )*35.0f );
		PasteImage ( g.editorimagesoffset+61, iXPos - (ImageWidth(g.editorimagesoffset+61)/2), 50+iYPos );
	}

	//  Update screen (if mouse in 3D are)
	if (  t.recoverdonotuseany3dreferences == 0 ) 
	{
		//  editor super chuggy
		if (  t.inputsys.activemouse == 1 ) 
		{
			//  constant update
			//if ( gbWelcomeSystemActive == false )
			//{
			SyncRate ( 0 ); SyncMask ( 1 ); Sync ( ); SleepNow ( 5 );
			//}
		}
		else
		{
			//  check for PAINT message
			#ifdef FPSEXCHANGE
			OpenFileMap (  3, "FPSEXCHANGE" );
			SetEventAndWait (  3 );
			if (  GetFileMapDWORD( 3, 60 ) == 1 ) 
			{
				SetFileMapDWORD (  3,60,0  ); t.syncthreetimes=3;
				SetEventAndWait (  3 );
			}
			#endif
			SyncRate (  0 );
			if (  t.syncthreetimes>0 ) {  --t.syncthreetimes; Sync ( ); }
			SleepNow ( 10 );
		}

		//  Detect if resolution changed (windows)
		editor_detect_invalid_screen ( );
	}

	#ifdef VRTECH
	if (g_bCascadeQuitFlag) 
	{
		int iRet = AskSaveBeforeNewAction();
		if (iRet == 2)
		{
			g_bCascadeQuitFlag = false;
		}
		else 
		{
			PostQuitMessage(0);
		}
	}
	#endif
}

void mapeditorexecutable_finish(void)
{
	// End map editor program (moved above chdir and pref writes)
	common_justbeforeend();

	// Come out of Files folder
	SetCurrentDirectoryA(g.fpscrootdir_s.Get());

#ifdef ENABLEIMGUI
	if (t.game.set.ismapeditormode == 1) {

		// seems this command no longer detecting if user maximised the window? Rely on settings set elsewhere (avoids always setting to minimized)
		//if (IsZoomed(g_pGlob->hWnd)) {
		//	pref.iMaximized = 1;
		//}
		//else {
		//	pref.iMaximized = 0;
		//}

		cstr prefile = defaultWriteFolder;
#ifdef WICKEDENGINE
		prefile += "gamegurumax.pref";
#else
		prefile += "gameguru.pref";
#endif

		FILE* preffile = GG_fopen(prefile.Get(), "wb+");
		if (preffile) {
			fwrite(&pref, 1, sizeof(pref), preffile);
			fclose(preffile);
		}

		if (pref.save_layout) {
			char cmLayoutFile[MAX_PATH];
#ifdef WICKEDENGINE
			sprintf(cmLayoutFile, "%suimax.layout", defaultWriteFolder);
#else
			sprintf(cmLayoutFile, "%suiv3.layout", defaultWriteFolder);
#endif
			ImGui::SaveIniSettingsToDisk(cmLayoutFile);
		}
	}
#endif

	#ifdef VRTECH
	// ensure this gets called when leave software too
	//extern HMODULE hGGWMRDLL;
	//PE: GGVR_DeleteHolographicSpace identifier not found.
	//	if( hGGWMRDLL) //PE: Only if dll is loaded.
	//		GGVR_DeleteHolographicSpace;
	#endif

	#ifdef WICKEDENGINE
	// Ends naturally after this - runs through to end of WinMain
	#else
	// final exit
	ExitProcess ( 0 );
	#endif
}

void mapeditorexecutable(void)
{
	mapeditorexecutable_init();

	// main loop
	#ifdef ENABLEIMGUI
	while (!g_bCascadeQuitFlag)
	#else
	#ifdef VRTECH
	// start thread loader for Character Creator texture files (multi-threaded loading) (saves 2s if started CCP)
	timestampactivity(0, "preload CCP textures early");
	charactercreatorplus_preloadinitialcharacter();
	#endif
	while ( 1 )
	#endif
	{
		mapeditorexecutable_loop();
	}
	mapeditorexecutable_finish();
}

#ifdef VRTECH
int AskSaveBeforeNewAction(void)
{
	int iAction = 0;
	if (g.projectmodified == 1)
	{
		#ifdef WICKEDENGINE
		#ifdef ENABLEAUTOLEVELSAVE
		if (!pref.iDisableLevelAutoSave && g.projectfilename_s != "")
		{
			//PE: We can do any messages when called from WM_CLOSE
			//PE: Change different functions instead.
			//Auto save. no message
			gridedit_save_map();
			bTriggerMessage = false;

			g.projectmodified = 0; gridedit_changemodifiedflag();
			g.projectmodifiedstatic = 0;
			return(1); //Return saved.
		}
		#endif
		#endif
		iAction = askBoxCancel("Do you wish to save first?", "Confirmation"); //1==Yes 2=Cancel 0=No

		if (iAction == 1)
		{
			//  yes save first
			if (g.projectfilename_s == "")
			{
				t.returnstring_s = "";
				cStr tOldDir = GetDir();
				char * cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_SAVE, "fpm\0*.fpm\0", g.mysystem.mapbankAbs_s.Get(), NULL, true);
				SetDir(tOldDir.Get());
				if (cFileSelected && strlen(cFileSelected) > 0) {
					t.returnstring_s = cFileSelected;
				}
				if (t.returnstring_s != "")
				{
					if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) != ".fpm")  t.returnstring_s = t.returnstring_s + ".fpm";
					g.projectfilename_s = t.returnstring_s;
					bool oksave = true;
					if (FileExist(g.projectfilename_s.Get())) {
						oksave = overWriteFileBox(g.projectfilename_s.Get());
					}
					if (oksave) {
						gridedit_save_map();
					}
				}
			}
			else
			{
				gridedit_save_map();
			}

			g.projectmodified = 0; gridedit_changemodifiedflag();
			g.projectmodifiedstatic = 0;
		}
	}
	return iAction;

}
#endif

void editor_detect_invalid_screen ( void )
{
	if (  GetDisplayInvalid() != 0 || MatrixExist(g.m4_projection) == 0 ) 
	{
		if (  1 ) 
		{
			#ifdef FPSEXCHANGE
			OpenFileMap (  1, "FPSEXCHANGE" );
			SetFileMapDWORD (  1, 900, 1 );
			SetFileMapString (  1, 1256, t.strarr_s[622].Get() );
			SetFileMapString (  1, 1000, t.strarr_s[623].Get() );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD(1, 900) == 1 ) 
			{
				SetEventAndWait (  1 );
			}
			t.tokay=GetFileMapDWORD(1, 904);
			if (  t.tokay == 1 ) 
			{
				//  no references to 3D objects (all gone now)
				t.recoverdonotuseany3dreferences=1;
				//  save now
				gridedit_save_map_ask ( );
			}
			//  call a new map editor
			OpenFileMap (  2, "FPSEXCHANGE" );
			SetFileMapString (  2, 1000, "Guru-MapEditor.exe" );
			SetFileMapString (  2, 1256, "-r" );
			SetFileMapDWORD (  2, 994, 0 );
			SetFileMapDWORD (  2, 924, 1 );
			SetEventAndWait (  2 );
			#endif
			//  free steam to unload the module in effect
			mp_free ( );
			//  end this old mapeditor
			common_justbeforeend();
			ExitProcess ( 0 );
		}
	}
}

void editor_showhelppage ( int iHelpType )
{
#if defined(ENABLEIMGUI) && !defined(USEOLDIDE) 
	return;
#else

	// image to use
	int iEditorHelpImage = 1;
	int iDivideBy = 1;
	#ifdef VRTECH
	 switch ( iHelpType )
	 {
		case 1 : iEditorHelpImage = 1; break;
		case 2 : iEditorHelpImage = 27; iDivideBy = 2; break;
		case 3 : iEditorHelpImage = 28; iDivideBy = 2; break;
	 }
	#endif
	#ifdef FPSEXCHANGE
	 OpenFileMap (  1, "FPSEXCHANGE" );
	 SetEventAndWait (  1 );
	#endif
	do
	{
		t.inputsys.mclick=MouseClick();
		FastSync (  );
	} while ( !(  t.inputsys.mclick == 0 ) );
	t.inputsys.kscancode=0;
	t.asx_f=1.0;
	t.asy_f=1.0;
	t.imgx_f=ImageWidth(g.editorimagesoffset+iEditorHelpImage)/iDivideBy*t.asx_f;
	t.imgy_f=ImageHeight(g.editorimagesoffset+iEditorHelpImage)/iDivideBy*t.asy_f;
	Sprite (  123,-10000,-10000,g.editorimagesoffset+iEditorHelpImage );
	SizeSprite (  123,t.imgx_f,t.imgy_f );
	t.lastmousex=MouseX() ; t.lastmousey=MouseY();
	t.tpressf1toleave=0;
	while (  t.inputsys.kscancode == 0 && EscapeKey() == 0 ) 
	{
		#ifdef FPSEXCHANGE
		 t.inputsys.kscancode=GetFileMapDWORD( 1, 100 );
		#else
		 t.inputsys.kscancode = ScanCode();
		#endif
		if (  t.inputsys.kscancode == 0 ) 
		{
			if (  t.tpressf1toleave == 1  )  t.tpressf1toleave = 2;
		}
		if (  t.inputsys.kscancode == 112 ) 
		{
			if (  t.tpressf1toleave == 0  )  t.tpressf1toleave = 1;
			if (  t.tpressf1toleave == 2 ) 
			{
				//  allow the F1 press through to exit
			}
			else
			{
				t.inputsys.kscancode=0;
			}
		}
		#ifdef FPSEXCHANGE
		 if (  GetFileMapDWORD( 1, 908 ) == 1  )  break;
		 if (  GetFileMapDWORD( 1, 20 ) != 0  )  break;
		 if (  GetFileMapDWORD( 1, 516 )>0  )  break;
		#endif
		t.terrain.gameplaycamera=0;
		terrain_shadowupdate ( );
		terrain_update ( );
		PasteSprite (  123,(GetChildWindowWidth(0)-t.imgx_f)/2,(GetChildWindowHeight(0)-t.imgy_f)/2 );
		Sync (  );
	}
	//  once we are in the help page, can use filemap to detect key (so F1 on/off issue does not occur)
	do
	{
		#ifdef FPSEXCHANGE
		 t.inputsys.kscancode = GetFileMapDWORD(1, 100);
		#else
		 t.inputsys.kscancode = ScanCode();
		#endif
		FastSync (  );
	} while ( !(  t.inputsys.kscancode == 0 ) );
	//PE: Make sure we dont sent mouse input to whatever is below page.
	do
	{
		t.inputsys.mclick = MouseClick();
		FastSync();
	} while (!(t.inputsys.mclick == 0));
#endif
}

void editor_showparentalcontrolpage ( void )
{
	// allow parental control to be activated and deactivated
	#ifdef FPSEXCHANGE
	 OpenFileMap (  1, "FPSEXCHANGE" );
	 SetEventAndWait (  1 );
	#endif
	do
	{
		set_inputsys_mclick(MouseClick());// t.inputsys.mclick = MouseClick();
		FastSync (  );
	} 
	while ( !(  t.inputsys.mclick == 0 ) );
	t.inputsys.kscancode=0;
	t.asx_f=1.0;
	t.asy_f=1.0;
	t.imgx_f=ImageWidth(g.editorimagesoffset+8)*t.asx_f;
	t.imgy_f=ImageHeight(g.editorimagesoffset+8)*t.asy_f;
	Sprite (  123,-10000,-10000,g.editorimagesoffset+8 );
	SizeSprite (  123,t.imgx_f,t.imgy_f );
	t.lastmousex=MouseX() ; t.lastmousey=MouseY();
	t.tpressf1toleave=0;
	int iStayInParentalControlDialog = 1;
	cstr ParentFourDigitCode = "";
	int digitcode[5];
	digitcode[0] = 0;
	digitcode[1] = 0;
	digitcode[2] = 0;
	digitcode[3] = 0;
	int digitcodeindex = 0;
	int tpressedbefore = 0;
	bool bParentalToggleForcesQuit = false;
	while ( iStayInParentalControlDialog == 1 && t.inputsys.kscancode != 27 ) 
	{
		#ifdef FPSEXCHANGE
		 t.inputsys.kscancode=GetFileMapDWORD( 1, 100 );
		 if (  GetFileMapDWORD( 1, 908 ) == 1  )  break;
		 if (  GetFileMapDWORD( 1, 516 )>0  )  break;
		#else
		 t.inputsys.kscancode = ScanCode();
		#endif
		int tnewkeycode = 0; // numpad detection
		if ( t.inputsys.kscancode == 45 ) tnewkeycode = 48;
		if ( t.inputsys.kscancode == 35 ) tnewkeycode = 49;
		if ( t.inputsys.kscancode == 40 ) tnewkeycode = 50;
		if ( t.inputsys.kscancode == 34 ) tnewkeycode = 51;
		if ( t.inputsys.kscancode == 37 ) tnewkeycode = 52;
		if ( t.inputsys.kscancode == 12 ) tnewkeycode = 53;
		if ( t.inputsys.kscancode == 39 ) tnewkeycode = 54;
		if ( t.inputsys.kscancode == 36 ) tnewkeycode = 55;
		if ( t.inputsys.kscancode == 38 ) tnewkeycode = 56;
		if ( t.inputsys.kscancode == 33 ) tnewkeycode = 57;
		if ( tnewkeycode > 0 )
		{
			t.inputsys.kscancode = tnewkeycode;
		}
		if ( t.inputsys.kscancode >= 48 && t.inputsys.kscancode <= 57 )
		{
			if ( tpressedbefore == 0 && digitcodeindex < 4 )
			{
				if ( g.quickparentalcontrolmode == 1 )
				{
					// enable lock - entering password
					digitcode[digitcodeindex] = t.inputsys.kscancode;
					digitcodeindex++;
					ParentFourDigitCode = ParentFourDigitCode + "*";
					tpressedbefore = 1;
					if ( digitcodeindex == 4 )
					{
						g.quickparentalcontrolmode = 2;
						g.quickparentalcontrolmodepassword[0] = digitcode[0];
						g.quickparentalcontrolmodepassword[1] = digitcode[1];
						g.quickparentalcontrolmodepassword[2] = digitcode[2];
						g.quickparentalcontrolmodepassword[3] = digitcode[3];
						iStayInParentalControlDialog = 0;
						bParentalToggleForcesQuit = true;
						break;
					}
				}
				if ( g.quickparentalcontrolmode == 2 )
				{
					// disable lock - confirming password
					digitcode[digitcodeindex] = t.inputsys.kscancode;
					digitcodeindex++;
					ParentFourDigitCode = ParentFourDigitCode + "*";
					tpressedbefore = 1;
					if ( digitcodeindex == 4 )
					{
						// real password or secret backdoor
						bool bPasswordOkay = false;
						if (digitcode[0]==g.quickparentalcontrolmodepassword[0]
						&&	digitcode[1]==g.quickparentalcontrolmodepassword[1]
						&&	digitcode[2]==g.quickparentalcontrolmodepassword[2]
						&&	digitcode[3]==g.quickparentalcontrolmodepassword[3] ) bPasswordOkay = true;
						if (digitcode[0]==57 // 9119
						&&	digitcode[1]==49
						&&	digitcode[2]==49
						&&	digitcode[3]==57 ) bPasswordOkay = true;
						if ( bPasswordOkay == true )
						{
							g.quickparentalcontrolmode = 1;
							iStayInParentalControlDialog = 0;
							bParentalToggleForcesQuit = true;
							break;
						}
						else
						{
							// try again
							ParentFourDigitCode = "";
							digitcodeindex = 0;
						}
					}
				}

			}
		}
		else
		{
			tpressedbefore = 0;
		}

		t.terrain.gameplaycamera=0;
		terrain_shadowupdate ( );
		terrain_update ( );
		int iDialogTop = (GetChildWindowHeight(0)-t.imgy_f)/2;
		PasteSprite ( 123, (GetChildWindowWidth(0)-t.imgx_f)/2, iDialogTop );
		LPSTR pRCMTitle = "RESTRICTED CONTENT MODE : OFF";
		if ( g.quickparentalcontrolmode == 2 ) pRCMTitle = "RESTRICTED CONTENT MODE : ON";
		pastebitmapfontcenter ( pRCMTitle, GetChildWindowWidth(0)/2, iDialogTop + 20, 3, 255 );
		pastebitmapfontcenter ( "This feature will control visibility of restricted content such as", GetChildWindowWidth(0)/2, iDialogTop + 70, 1, 255 );
		pastebitmapfontcenter ( "blood, violence and gore which may be offensive to some users.", GetChildWindowWidth(0)/2, iDialogTop + 95, 1, 255 );
		pastebitmapfontcenter ( "If you do not want this, press escape now.", GetChildWindowWidth(0)/2, iDialogTop + 120, 1, 255 );
		pastebitmapfontcenter ( ParentFourDigitCode.Get(), GetChildWindowWidth(0)/2, iDialogTop + (t.imgy_f/2), 4, 255 );
		if ( g.quickparentalcontrolmode == 2 )
		{
			pastebitmapfontcenter ( "ENTER YOUR FOUR DIGIT PASSWORD TO DEACTIVATE CONTENT LOCK", GetChildWindowWidth(0)/2, iDialogTop + t.imgy_f - 70, 2, 255 );
			pastebitmapfontcenter ( "OR PRESS [ESCAPE] TO CANCEL", GetChildWindowWidth(0)/2, iDialogTop + t.imgy_f - 50, 2, 255 );
		}
		else
		{
			pastebitmapfontcenter ( "ENTER FOUR DIGIT PASSWORD TO ACTIVATE CONTENT LOCK", GetChildWindowWidth(0)/2, iDialogTop + t.imgy_f - 70, 2, 255 );
			pastebitmapfontcenter ( "OR PRESS [ESCAPE] TO ENTER REGULAR MODE", GetChildWindowWidth(0)/2, iDialogTop + t.imgy_f - 50, 2, 255 );
		}
		pastebitmapfontcenter ( "YOU CAN ACCESS THIS OPTION AGAIN FROM THE HELP MENU", GetChildWindowWidth(0)/2, iDialogTop + t.imgy_f - 30, 2, 255 );
		Sync ( );
	}
	do
	{
		t.inputsys.kscancode=GetFileMapDWORD( 1, 100 );
		FastSync (  );
	} 
	while ( (  t.inputsys.kscancode > 3 ) ); //PE: We can keep getting virtual keys <= 3.
	//PE: Make sure we dont sent mouse input to whatever is below page.
	do
	{
		set_inputsys_mclick(MouseClick());// t.inputsys.mclick = MouseClick();
		FastSync();
	} while (!(t.inputsys.mclick == 0));

	// only a mode of 2 carries the digit code for activated
	if ( g.quickparentalcontrolmode != 2 )
	{
		digitcode[0] = 0;
		digitcode[1] = 0;
		digitcode[2] = 0;
		digitcode[3] = 0;
	}

	// 050416 - flag file to control parental control mode
	t.tfile_s=g.fpscrootdir_s+"\\parentalcontrolmode.ini";
	DeleteAFile (  t.tfile_s.Get() );
	if (  FileOpen(1)  ==  1  )  CloseFile (  1 );
	OpenToWrite (  1,t.tfile_s.Get() );
	WriteString (  1, cstr(g.quickparentalcontrolmode).Get() );
	WriteByte (  1, digitcode[0] );
	WriteByte (  1, digitcode[1] );
	WriteByte (  1, digitcode[2] );
	WriteByte (  1, digitcode[3] );
	CloseFile (  1 );
	t.tfile_s = g.fpscrootdir_s+"\\parentalcontrolactive.ini";
	if ( g.quickparentalcontrolmode == 2 )
	{
		// ensure file exists for IDE benefit
		OpenToWrite ( 1,t.tfile_s.Get() );
		WriteString ( 1, "123" );
		CloseFile ( 1 );
	}
	else
	{
		// delete this file to show IDE no parental control in effect
		DeleteAFile (  t.tfile_s.Get() );
	}

	// force the product to quit if change parental control setting
	if ( bParentalToggleForcesQuit == true )
	{
		MessageBoxA ( GetForegroundWindow(), "In order for the restricted content mode chosen to take effect, you must exit GameGuru and restart", "GameGuru Restart", MB_OK | MB_ICONEXCLAMATION | MB_TOPMOST );
	}
}

void editor_freezeanimations ( void )
{
	// go through all objects and freeze their animations
	if ( t.fStoreObjAnimSpeeds==NULL )
	{
		t.fStoreObjAnimSpeeds = new float[210000];
		for ( int iObj = 1; iObj < 210000; iObj++ )
		{
			if ( ObjectExist ( iObj )==1 )
			{
				sObject* pObject = GetObjectData ( iObj );
				t.fStoreObjAnimSpeeds [ iObj ] = pObject->fAnimSpeed;
				pObject->fAnimSpeed = 0.0f;
			}
		}
	}
}

void editor_unfreezeanimations ( void )
{
	// go through all objects and restore all animation speeds from freeze step above
	if ( t.fStoreObjAnimSpeeds )
	{
		for ( int iObj = 1; iObj < 210000; iObj++ )
		{
			if ( ObjectExist ( iObj )==1 )
			{
				sObject* pObject = GetObjectData ( iObj );
				pObject->fAnimSpeed = t.fStoreObjAnimSpeeds [ iObj ];
			}
		}
		delete t.fStoreObjAnimSpeeds;
		t.fStoreObjAnimSpeeds = NULL;
	}
}

void editor_showquickstart ( int iForceMainOpen )
{
	// open welcome system
	editor_freezeanimations();
	if ( gbWelcomeSystemActive == false )
	{
		welcome_init(1);
		welcome_staticbackdrop();
		welcome_init(2);
	}
	welcome_init(0);

	// if first time run for VRQ
	if ( g.vrqTriggerSerialCodeEntrySystem == 1 )
	{
		#ifdef ALPHAEXPIRESYSTEM
		 PostQuitMessage(0);
		#else
		 welcome_show(WELCOME_SERIALCODE);
		#endif
	}
	else
	{
		// Welcome system not syncronous any more
		//if (g.iTriggerSoftwareToQuit != 0)
		//{
		//	welcome_show(WELCOME_EXITAPP);
		//}
		//else
		{
			if (g.iFreeVersionModeActive == 1)
			{
				welcome_show(WELCOME_FREEINTROAPP);
			}
			if (g.iFreeVersionModeActive == 2)
			{
				welcome_show(WELCOME_FREETRIALINTROAPP);
			}
		}

		// if welcome not deactivated
		if (g.gshowonstartup != 0 || iForceMainOpen == 1)
		{
			// if no announcement wanting to share news
			if (g_iWelcomeLoopPage != WELCOME_ANNOUNCEMENTS)
			{
				#ifdef WICKEDENGINE
				// MAX only uses old welcome system for announcements right now
				welcome_show(WELCOME_ANNOUNCEMENTS);
				if (g_iWelcomeLoopPage != WELCOME_ANNOUNCEMENTS)
					bTriggerWhatsNewInStoryboard = false; //PE: No need to trigger nothing to show.
				#else
				// start welcome page
				if (g.vrqcontrolmode == 0)
					welcome_show(WELCOME_MAIN);
				else
					welcome_show(WELCOME_MAINVR);
				#endif
			}
			if (strlen(t.tlevelautoload_s.Get()) > 0)
			{
				//Trigger load level.
				welcome_free();
				t.tlevelautoload_s = "";
			}
		}
	}

	//  reset before leave
	t.inputsys.kscancode=0;
	set_inputsys_mclick(0);// t.inputsys.mclick = 0;
	t.inputsys.xmouse=0;
	t.inputsys.ymouse=0;
}

void editor_previewmapormultiplayer_initcode ( int iUseVRTest )
{
	//  store if project modified
	t.storeprojectmodified=g.projectmodified;
	g_tstoreprojectmodifiedstatic = g.projectmodifiedstatic; 

	//  flag that we clicked TEST GAME
	t.interactive.testgameused=1;

	g.tabmodehidehuds = 0; //Enable HUD if lua disabled it in prev session.

	//  Before launch test game, check if enough contiguous
	checkmemoryforgracefulexit();

#ifdef ENABLEIMGUI
#ifndef USEOLDIDE
	//PE: Test game mode.
//	extern DWORD gWindowSizeX;
//	extern DWORD gWindowSizeY;
	extern DWORD gWindowVisible;

	gWindowSizeXOld = GetChildWindowWidth(-1);
	gWindowSizeYOld = GetChildWindowHeight(-1);

	RECT rect = { NULL };
	GetWindowRect(g_pGlob->hWnd, &rect);

	gWindowPosXOld = rect.left;
	gWindowPosYOld = rect.top;

	gWindowVisibleOld = gWindowVisible; //SW_MAXIMIZE
	if (IsZoomed(g_pGlob->hWnd))
		gWindowMaximized = 1;
	else
		gWindowMaximized = 0;
#endif
#endif

	HMONITOR monitor = MonitorFromWindow(g_pGlob->hWnd, MONITOR_DEFAULTTONEAREST);
	MONITORINFO info;
	info.cbSize = sizeof(MONITORINFO);
	GetMonitorInfo(monitor, &info);
	int monitor_width = info.rcMonitor.right - info.rcMonitor.left;
	int monitor_height = info.rcMonitor.bottom - info.rcMonitor.top;
	g_pGlob->dwWindowX = info.rcMonitor.left;
	g_pGlob->dwWindowY = info.rcMonitor.top;

	//  First call will toggle keyboard/mouse back to BACKGROUND (to capture all direct data)
	SetWindowModeOn (  );

#ifdef ENABLEIMGUI
#ifndef USEOLDIDE
	//PE: Test game mode.
	SetWindowSettings(0, 0, 0);
	SetWindowPos(g_pGlob->hWnd, HWND_TOP, g_pGlob->dwWindowX, g_pGlob->dwWindowY, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
	SetForegroundWindow(g_pGlob->hWnd);
	SetWindowSize(monitor_width, monitor_height);
	ShowWindow(); MaximiseWindow();

	//Hide any windows outside main viewport.
	ImGui::HideAllViewPortWindows();
	LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	//SetWindowLong(g_pGlob->hWnd, GWL_WNDPROC, (LONG)WindowProc);

#endif
#endif

	//  center mouse pointer in editor (and hide it)
	game_hidemouse ( );

	//  hide widget if was highlighted when tested game
	widget_hide ( );

	// hide EBE if active when click test game button
	ebe_hide();

	// hide texture terrain painter panels
	terrain_paintselector_hide();

	//  switch off any IDE entity highlighting
	#ifdef WICKEDENGINE
	t.geditorhighlightingtentityID = 0;
	#endif

	editor_restoreentityhighlightobj ( );

	// switch off any rubber band entity highlighting
	gridedit_clearentityrubberbandlist();

	// View Options menu changed so Level now alters both test level and standalone, so no need for these toggles.
	#if 0
	#ifdef WICKEDENGINE
	// Can optionally toggle trees, vegetation and water in test level.
	// Store what the values were before the change, so they can be restored when going back to editor.
	int prevWater = t.gamevisuals.bWaterEnable;
	int prevTree = t.gamevisuals.bEndableTreeDrawing;
	int prevGrass = t.gamevisuals.bEndableGrassDrawing;
	TestLevel_ToggleTreeVegWater(t.showtestgametrees, t.showtestgameveg, t.showtestgamewater);
	t.showtestgametrees = prevTree;
	t.showtestgamewater = prevWater;
	t.showtestgameveg = prevGrass;
	#endif
	#endif

	// 210917 - refresh HLSL shaders (flagged as doing shader work)
	if ( g.gforceloadtestgameshaders == 1 )
	{
		// go through all loaded effects and reload them
		for ( t.t = -5 ; t.t <= g.effectbankmax; t.t++ )
		{
			char pEffectFilename[1024];
			strcpy ( pEffectFilename, "effectbank\\reloaded\\" );
			if ( t.t == -5 ) 
			{ 
				t.tteffectid = t.terrain.effectstartindex+0; 
				if ( g.gpbroverride == 1 )
					strcat ( pEffectFilename, "apbr_terrain.fx"); 
				else
					strcat ( pEffectFilename, "terrain_basic.fx"); 
			}
			if ( t.t == -4 ) 
			{ 
				t.tteffectid = t.terrain.effectstartindex+2; 
				if ( g.gpbroverride == 1 )
					strcat ( pEffectFilename, "apbr_veg.fx"); 
				else
					strcat ( pEffectFilename, "vegetation_basic.fx"); 
			}
			if ( t.t == -3 ) 
			{ 
				t.tteffectid = g.thirdpersonentityeffect; 
				if ( g.gpbroverride == 1 )
					strcat ( pEffectFilename, "apbr_basic.fx"); 
				else
					strcat ( pEffectFilename, "entity_basic.fx"); 
			}
			if ( t.t == -2 ) 
			{ 
				t.tteffectid = g.thirdpersoncharactereffect; 
				if ( g.gpbroverride == 1 )
					strcat ( pEffectFilename, "apbr_animwithtran.fx"); 
				else
					strcat ( pEffectFilename, "character_basic.fx"); 
			}
			if ( t.t == -1 ) { t.tteffectid = g.staticlightmapeffectoffset; strcat ( pEffectFilename, "static_basic.fx"); }
			if ( t.t == 0 ) { t.tteffectid = g.staticshadowlightmapeffectoffset; strcat ( pEffectFilename, "shadow_basic.fx"); }
			if ( t.t > 0 ) { t.tteffectid = g.effectbankoffset+t.t; strcpy ( pEffectFilename, t.effectbank_s[t.t].Get()); }
			if ( GetEffectExist ( t.tteffectid ) == 1 ) 
			{
				// gather all objects that use this effect
				int iObjListMax = 0;
				DWORD** pObjList = new DWORD* [ g_iObjectListCount ];
				memset ( pObjList, 0, sizeof(DWORD*)*g_iObjectListCount );
				for ( DWORD dwObject = 0; dwObject < (DWORD)g_iObjectListCount; dwObject++ )
				{
					sObject* pObject = g_ObjectList [ dwObject ];
					if ( pObject )
					{ 
						bool bAnyMeshUsingEffect = false;
						for ( DWORD dwMesh = 0; dwMesh < (DWORD)pObject->iMeshCount; dwMesh++ )
						{
							if ( pObject->ppMeshList [ dwMesh ]->pVertexShaderEffect == m_EffectList [ t.tteffectid ]->pEffectObj )
							{
								bAnyMeshUsingEffect = true;
							}
						}
						if ( bAnyMeshUsingEffect == true )
						{
							DWORD* pPerObjData = new DWORD[1+pObject->iMeshCount];
							memset ( pPerObjData, 0, sizeof(DWORD)*(1+pObject->iMeshCount) );
							pObjList[iObjListMax] = pPerObjData;
							*(pPerObjData+0) = dwObject;
							DWORD dwObjDataIndex = 1;
							for ( DWORD dwFrameIndex = 0; dwFrameIndex < (DWORD)pObject->iFrameCount; dwFrameIndex++ )
							{
								if ( pObject->ppFrameList [ dwFrameIndex ]->pMesh )
								{
									if ( pObject->ppFrameList [ dwFrameIndex ]->pMesh->pVertexShaderEffect == m_EffectList [ t.tteffectid ]->pEffectObj )
									{
										*(pPerObjData+dwObjDataIndex) = 1+dwFrameIndex;
										dwObjDataIndex++;
									}
								}
							}
							iObjListMax++;
						}
					}
				}

				// delete the old effect and load a new one
				DeleteEffect ( t.tteffectid );
				LoadEffect ( pEffectFilename, t.tteffectid, 0 );
				filleffectparamarray ( t.tteffectid );

				// set the new effects to each object in the list
				if ( iObjListMax > 0 )
				{
					for ( int iObjListIndex = 0; iObjListIndex < iObjListMax; iObjListIndex++ )
					{
						DWORD* pPerObjData = pObjList[iObjListIndex];
						DWORD dwObject = *(pPerObjData+0);
						sObject* pObject = g_ObjectList [ dwObject ];
						if ( pObject )
						{
							for ( DWORD dwObjDataIndex = 0; dwObjDataIndex < (DWORD)pObject->iMeshCount; dwObjDataIndex++ )
							{
								DWORD dwFrameIndex = *(pPerObjData+1+dwObjDataIndex);
								if ( dwFrameIndex > 0 )
								{
									dwFrameIndex--;
									SetLimbEffect ( dwObject, dwFrameIndex, t.tteffectid );
								}
							}
						}
						SAFE_DELETE(pPerObjData);
					}
				}
				SAFE_DELETE(pObjList);

				// by default, set to first technique
				SetEffectTechnique ( t.tteffectid, NULL );
			}
		}

		// also reestablish links with constant vars for terrain and veh shaders
		//t.terrain.iForceTerrainVegShaderUpdate = 1;
		// re-assign params for reloaded terrain and veg
		terrain_applyshader();
		grass_applyshader();
	}
	
	//  set-up test game screen prompt assets
	if ( t.game.runasmultiplayer == 1 ) 
	{
		loadscreenpromptassets(2);
		#ifdef PRODUCTV3
		 printscreenprompt("ENTERING SOCIAL VR");
		#else
		 printscreenprompt("ENTERING MULTIPLAYER MODE");
		#endif
	}
	else
	{
		loadscreenpromptassets(iUseVRTest);
		printscreenprompt("LAUNCHING TEST LEVEL");
	}

	//  Save editor configuration
	timestampactivity(0,"PREVIEWMAP: Save config");
	editor_savecfg ( );

	#ifdef WICKEDENGINE
	// level saving takes 25% of overall 'click test level on large level'
	// removed for now in favour of user choosing when they should save/backup their creations
	// can restore this if we can get save to sub-3 seconds.
	#else
	// And save the level to levelbank\testmap before launch preview
	// so we can restore to this level if it crashes
	g.gpretestsavemode=1;
	gridedit_save_test_map ( );
	#endif
	g.gpretestsavemode = 0;

	// Now saves all part-files into temp FPM file (which multiplayer can pick up later)
	if ( t.game.runasmultiplayer == 1 ) 
	{
		//  save temp copy of current level
		g.projectfilename_s=g.mysystem.editorsGrideditAbs_s+"worklevel.fpm";//g.fpscrootdir_s+"\\Files\\editors\\gridedit\\worklevel.fpm";
		editor_savecfg ( );
		mapfile_saveproject_fpm ( );
	}

	// GCStore could have assed assets since the last 'test game' so refresh internal lists
	sky_init ( );
	terrain_initstyles ( );
	grass_initstyles();

	// Re-acquire indices now the lists have changed
	// takes visuals.sky$ visuals.terrain$ visuals.vegetation$
	visuals_updateskyterrainvegindex ( );

	// Ensure game visuals settings used
	t.gamevisuals.skyindex=t.visuals.skyindex;
	t.gamevisuals.sky_s=t.visuals.sky_s;
	t.gamevisuals.terrainindex=t.visuals.terrainindex;
	t.gamevisuals.terrain_s=t.visuals.terrain_s;
	t.gamevisuals.vegetationindex=t.visuals.vegetationindex;
	t.gamevisuals.vegetation_s=t.visuals.vegetation_s;
	t.gamevisuals.iEnvironmentWeather = t.visuals.iEnvironmentWeather;

	#ifdef WICKEDENGINE
	// the visuals vs gamevisuals could do with some work, I noticed our ambience is being overwritten
	// when it really needed to be transferred to the gamevisuals
	// is this done elsewhere??
	t.gamevisuals.AmbienceRed_f = t.visuals.AmbienceRed_f;
	t.gamevisuals.AmbienceGreen_f = t.visuals.AmbienceGreen_f;
	t.gamevisuals.AmbienceBlue_f = t.visuals.AmbienceBlue_f;
	t.gamevisuals.SunAngleX = t.visuals.SunAngleX;
	t.gamevisuals.SunAngleY = t.visuals.SunAngleY;
	t.gamevisuals.SunAngleZ = t.visuals.SunAngleZ;

	//PE: Backup SetGlobalGraphicsSettings
	t.gamevisuals.bSSREnabled = t.visuals.bSSREnabled;
	t.gamevisuals.bFXAAEnabled = t.visuals.bFXAAEnabled;
	t.gamevisuals.bLightShafts = t.visuals.bLightShafts;
	t.gamevisuals.bLensFlare = t.visuals.bLensFlare;
	t.gamevisuals.bReflectionsEnabled = t.visuals.bReflectionsEnabled;
	t.gamevisuals.iShadowSpotCascadeResolution = t.visuals.iShadowSpotCascadeResolution;
	t.gamevisuals.iShadowPointMax = t.visuals.iShadowPointMax;
	t.gamevisuals.iShadowPointResolution = t.visuals.iShadowPointResolution;
	t.gamevisuals.iShadowSpotMax = t.visuals.iShadowSpotMax;
	t.gamevisuals.iShadowSpotResolution = t.visuals.iShadowSpotResolution;

	#endif

	// copy game visuals to visuals for use in level play
	t.visuals=t.gamevisuals;

	#ifdef WICKEDENGINE
	//PE: SetGlobalGraphicsSettings 2 = highest , this is the users current settings, user knows best dont change there settings.
	if(pref.iTestGameGraphicsQuality != 2)
		SetGlobalGraphicsSettings( pref.iTestGameGraphicsQuality );
	#endif

	t.visuals.refreshshaders=1;
	t.visuals.refreshvegtexture=1;

	// Hide camera while prepare test map
	t.storecx_f=CameraPositionX();
	t.storecy_f=CameraPositionY();
	t.storecz_f=CameraPositionZ();

	// default start position is edit-camera XZ
	t.terrain.playerx_f = CameraPositionX(0);
	t.terrain.playerz_f = CameraPositionZ(0);
	#ifdef GGTERRAIN_USE_NEW_TERRAIN
	t.terrain.playery_f = BT_GetGroundHeight(t.terrain.TerrainID, t.terrain.playerx_f, t.terrain.playerz_f) + 150.0;
	#else
	if (t.terrain.TerrainID > 0)
	{
		t.terrain.playery_f = BT_GetGroundHeight(t.terrain.TerrainID, t.terrain.playerx_f, t.terrain.playerz_f) + 150.0;
	}
	else
	{
		t.terrain.playery_f = g.gdefaultterrainheight + 150.0;
	}
	#endif
	t.terrain.playerax_f = 0.0;
	t.terrain.playeray_f = 0.0;
	t.terrain.playeraz_f = 0.0;

	// store all editor entity positions and rotations
	t.storedentityelementlist=g.entityelementlist;
	t.storedentityviewcurrentobj=g.entityviewcurrentobj;
	Dim (  t.storedentityelement,g.entityelementlist );
	for ( t.e = 1 ; t.e<=  g.entityelementlist; t.e++ )
	{
		t.storedentityelement[t.e]=t.entityelement[t.e];
	}

	// hide all markers
	for (t.e = 1; t.e <= g.entityelementlist; t.e++)
	{
		t.entid = t.entityelement[t.e].bankindex;
		t.obj = t.entityelement[t.e].obj;
		if (t.obj > 0)
		{
			if (ObjectExist(t.obj) == 1)
			{
				if (t.entityprofile[t.entid].ismarker != 0)
				{
					//  all markers must be hidden
					HideObject(t.obj);
				}
				if (t.entityprofile[t.entid].addhandlelimb > 0)
				{
					//  hide decal handles
					HideLimb(t.obj, t.entityprofile[t.entid].addhandlelimb);
				}
			}
		}
	}
	
	// ensure all locked entity transparency resolves
	for ( t.tte = 1 ; t.tte<=  g.entityelementlist; t.tte++ )
	{
		if ( t.entityelement[t.tte].editorlock == 1 || t.entityelement[t.tte].underground == 1 ) 
		{
			t.tobj=t.entityelement[t.tte].obj;
			if ( t.tobj>0 ) 
			{
				if ( ObjectExist(t.tobj) == 1 ) 
				{
					if ( t.entityelement[t.tte].underground == 1  )  t.entityelement[t.tte].isclone = 1;
					entity_converttoinstance ( );
				}
			}
		}
	}

	//PE: start any animations that are not in editor mode.
	for (t.tte = 1; t.tte <= g.entityelementlist; t.tte++)
	{
		// hide EBE markers
		int iIndex = t.entityelement[t.tte].bankindex;
		if (t.entityprofile[iIndex].isebe != 0)
		{
			t.tobj = t.entityelement[t.tte].obj;
			if (t.tobj > 0)
			{
				if (ObjectExist(t.tobj) == 1)
				{
					HideLimb(t.tobj, 0);
				}
			}
		}

		t.entid = t.entityelement[t.tte].bankindex;
		t.tttsourceobj = g.entitybankoffset + t.entityelement[t.tte].bankindex;
		t.tobj = t.entityelement[t.tte].obj;
		if (t.tobj > 0)
		{
			if (ObjectExist(t.tobj) == 1)
			{
				//PE: Possible fix for issues:
				//PE: https://github.com/TheGameCreators/GameGuruRepo/issues/206
				//PE: https://github.com/TheGameCreators/GameGuruRepo/issues/273
				//PE: need testing.
				if (t.entityprofile[t.entid].ischaracter == 1) {
					//Char should always have z depth , but somehow its removed somewhere.
					EnableObjectZDepth(t.tobj);
				}

				#ifdef WICKEDENGINE
				//PE: Make sure we reset all animations. mainly for lua controlled objects like doors
				if (t.entityprofile[t.entid].animmax > 0)
				{
					SetObjectFrame(t.tttsourceobj, 0);
					StopObject(t.tttsourceobj);
					SetObjectFrame(t.tobj, 0);
					StopObject(t.tobj);
				}
				#endif

				//FULLBOUNDS
				if (t.entityprofile[t.entid].startanimingame > 0) 
				{
					if (t.entityprofile[t.entid].animmax > 0) 
					{
						t.q = t.entityprofile[t.entid].startanimingame - 1;
						SetObjectFrame(t.tttsourceobj, 0);
						LoopObject(t.tttsourceobj, t.entityanim[t.entid][t.q].start, t.entityanim[t.entid][t.q].finish);
						SetObjectFrame(t.tobj, 0);
						LoopObject(t.tobj, t.entityanim[t.entid][t.q].start, t.entityanim[t.entid][t.q].finish);
					}
				}
				else 
				{
					#ifdef WICKEDENGINE
					//PE: Restore any non char animations.
					if (t.tobj > 0 && t.entityprofile[t.entid].ischaracter == 0 && GetNumberOfFrames(t.tobj) > 0)
					{
						SetObjectFrame(t.tobj, 0);
						if (t.entityprofile[t.entid].animmax > 0 && t.entityprofile[t.entid].playanimineditor > 0 && t.entityprofile[t.entid].ischaractercreator == 0)
						{
							t.q = t.entityprofile[t.entid].playanimineditor - 1;
							LoopObject(t.tobj, t.entityanim[t.entid][t.q].start, t.entityanim[t.entid][t.q].finish);
						}
						else if (t.entityprofile[t.entid].playanimineditor < 0)
						{
							// uses name instead of index, the negative is the ordinal into the animset
							extern void entity_loop_using_negative_playanimineditor(int e, int obj, cstr animname);
							entity_loop_using_negative_playanimineditor(t.tte, t.tobj, t.entityprofile[t.entid].playanimineditor_name);
						}
						else
						{
							LoopObject(t.tobj); StopObject(t.tobj);
						}
					}
					#endif

				}
			}
		}
	}

#ifdef WICKEDENGINE
	//TestLevel_ToggleTreeVegWater(false, false, false);
	editor_toggle_element_vis(t.showtestgameelements);
	//TestLevel_ToggleBoundary(t.showtestgame2dbounds, t.showtestgame3dbounds);
#else
	// hide all waypoints and zones
	waypoint_hideall ( );
#endif

	// hide editor objects too
	for ( t.obj = t.editor.objectstartindex+1; t.obj <= t.editor.objectstartindex+1+10 ;  t.obj++ ) //?//t.editor.objectstartindex+10;
	{
		if ( ObjectExist(t.obj) == 1 ) 
		{
			HideObject (  t.obj );
		}
	}

	// hide any EBE site markers (limb zeros)
	for ( t.tte = 1; t.tte <= g.entityelementlist; t.tte++ )
	{
		int iIndex = t.entityelement[t.tte].bankindex;
		if ( t.entityprofile[iIndex].isebe != 0 ) 
		{
			t.tobj = t.entityelement[t.tte].obj;
			if ( t.tobj>0 ) 
			{
				if ( ObjectExist(t.tobj) == 1 ) 
				{
					#ifdef WICKEDENGINE
					// when EBE entity is loaded first time, no editing, the handle object at limb zero is not used
					sObject* pObject = GetObjectData(t.tobj);
					if ( pObject->iFrameCount > 1 )
						HideLimb ( t.tobj, 0 );
					#else
					HideLimb ( t.tobj, 0 );
					#endif
				}
			}
		}
	}

	// ensure no collision from legacy engine
	AutomaticCameraCollision (  0,0,0 );
	SetGlobalCollisionOff (  );

	// Setup game view camera
	SetCameraFOV ( 75 );
	g.grav_f=-5.0;

	// store original terrain heights
	if ( t.terrain.TerrainID>0 ) 
	{
		for ( t.z = 0 ; t.z<=  1024; t.z++ )
		{
			for ( t.x = 0 ; t.x<=  1024; t.x++ )
			{
				t.h_f=BT_GetGroundHeight(t.terrain.TerrainID,t.x*50.0,t.z*50.0,1);
				t.terrainmatrix[t.x][t.z]=t.h_f;
			}
		}
	}

	// Create heightmap from this terrain (for quad reduction)
	if ( t.terrain.TerrainID>0 ) 
	{
		t.terrain.terrainregionupdate=0;
		terrain_refreshterrainmatrix ( );
		t.theightfile_s=g.mysystem.levelBankTestMap_s+"heightmap.dds"; //"levelbank\\testmap\\heightmap.dds";
		terrain_createheightmapfromheightdata ( );
	}

	// full speed
	SyncRate ( 0 );

	// Work out the amount of memory used for the TEST GAME session
	t.tmemorybeforetestgame=SMEMAvailable(1);

	#ifdef VRTECH
	// in VR, if controller powered down, need to jog it back to life
	if ( g.vrglobals.GGVREnabled == 2 )
	{
		//PE: GGVR_ReconnectWithHolographicSpaceControllers(); identifier not found.
//		GGVR_ReconnectWithHolographicSpaceControllers();
	}
	#endif

	//
	// launch game root with IDE 'test at cursor position' settings
	//
	//t.game.gameisexe=0; only set right at start!
	t.game.set.resolution=0;
	t.game.set.initialsplashscreen=0;
	t.game.set.ismapeditormode=0;
	extern int tgamesetismapeditormode;
	tgamesetismapeditormode = 0;
	#ifdef WICKEDENGINE
	WickedCall_SetEditorCameraLight(false);
	#endif

	#ifdef WICKEDENGINE
	// can now edit behavior logic 'live'
	extern void gridedit_restartanybehaviorediting(void);
	gridedit_restartanybehaviorediting();
	#endif

	// game loop init code
	game_masterroot_initcode ( iUseVRTest );
}

bool editor_previewmapormultiplayer_loopcode ( int iUseVRTest )
{
	bool bEndThisLoop = false;
	#ifdef VRTECH
	g_bDisableQuitFlag = true;
	bEndThisLoop = game_masterroot_loopcode ( iUseVRTest );
	g_bDisableQuitFlag = false;
	#else
	game_masterroot ( 0 );
	bEndThisLoop = true;
	#endif
	return bEndThisLoop;
}

void editor_previewmapormultiplayer_afterloopcode ( int iUseVRTest )
{
	// game after loop code
	game_masterroot_afterloopcode ( iUseVRTest );

	t.terrain.skysundirectionx_f = t.terrain.sundirectionx_f;
	t.terrain.skysundirectiony_f = t.terrain.sundirectiony_f;
	t.terrain.skysundirectionz_f = t.terrain.sundirectionz_f;

	t.game.set.ismapeditormode=1;
	extern int tgamesetismapeditormode;
	tgamesetismapeditormode = 1;
	#ifdef WICKEDENGINE
	WickedCall_SetEditorCameraLight(true);
	#endif

	// Restore entities (remove light map objects for return to IDE editor)
	lm_restoreall ( );

	//PE: Hide any hit decals.
	decal_hide();

	// restore any EBE site markers (limb zeros)
	for ( t.tte = 1; t.tte <= g.entityelementlist; t.tte++ )
	{
		int iIndex = t.entityelement[t.tte].bankindex;
		if ( t.entityprofile[iIndex].isebe != 0 ) 
		{
			t.tobj = t.entityelement[t.tte].obj;
			if ( t.tobj>0 ) 
			{
				if ( ObjectExist(t.tobj) == 1 ) 
				{
					ShowLimb ( t.tobj, 0 );
				}
			}
		}
	}

	// Revert mode to only render NEAR technique
	visuals_restoreterrainshaderforeditor ( );
	BT_ForceTerrainTechnique ( 1 );

	// editor speed max
	SyncMask ( 1 );
	SyncRate ( 0 );

	//PE: release mouse so all monitors can be used.
	ClipCursor(NULL);

	// restore mouse pos and visbility
	game_showmouse ( );

	// prompt informing user we are saving the level changes
	if ( t.conkit.modified == 1 ) 
	{
		popup_text("Saving level changes");
	}

	//  show all waypoints and zones
	waypoint_restore ( );

	// 101115 - restore all characters to use regular character shader
	game_setup_character_shader_entities ( false );

	// if additional entities added, remove and restore orig count
	if ( g.entityelementlist>t.storedentityelementlist ) 
	{
		for ( t.e = t.storedentityelementlist+1 ; t.e<= g.entityelementlist ; t.e++ )
		{
			t.obj=t.entityelement[t.e].obj;
			if ( t.obj>0 ) 
			{
				if ( ObjectExist(t.obj) == 1 ) 
				{
					DeleteObject ( t.obj );
				}
			}
			t.entityelement[t.e].obj=0;
			t.entityelement[t.e].bankindex=0;
		}
		g.entityelementlist=t.storedentityelementlist;
		g.entityviewcurrentobj=t.storedentityviewcurrentobj;
	}

	// restore all editor entity positions and rotations
	for ( t.e = 1 ; t.e <= g.entityelementlist; t.e++ )
	{
		t.obj=t.entityelement[t.e].obj;
		if ( t.obj>0 ) 
		{
			if ( ObjectExist(t.obj) == 1 ) 
			{
				// only if still exists - could have been deleted
				t.entityelement[t.e]=t.storedentityelement[t.e];
			}
		}
	}
	UnDim ( t.storedentityelement );

	// restore entity positions and rotations
	for ( t.e = 1 ; t.e <= g.entityelementlist; t.e++ )
	{
		t.entid=t.entityelement[t.e].bankindex;
		t.obj=t.entityelement[t.e].obj;
		if ( t.obj>0 ) 
		{
			if ( ObjectExist(t.obj) == 1 ) 
			{
				if ( t.entityprofile[t.entid].ismarker == 0 ) 
				{
					// reset entity
					PositionObject (  t.obj,t.entityelement[t.e].x,t.entityelement[t.e].y,t.entityelement[t.e].z );
					RotateObject (  t.obj,t.entityelement[t.e].rx,t.entityelement[t.e].ry,t.entityelement[t.e].rz );
					ScaleObject(t.obj, 100 + t.entityelement[t.e].scalex, 100 + t.entityelement[t.e].scaley, 100 + t.entityelement[t.e].scalez);
					ShowObject (  t.obj );

					// restore zdepth mode of this entity
					entity_preparedepth(t.entid, t.obj);
				}
				if ( t.entityprofile[t.entid].addhandlelimb>0 ) 
				{
					ShowLimb ( t.obj,t.entityprofile[t.entid].addhandlelimb );
				}
			}
		}
	}

	#ifdef WICKEDENGINE
	// restore new particles that may have been deleted
	for (t.e = 1; t.e <= g.entityelementlist; t.e++)
	{
		int iParticleEmitter = t.entityelement[t.e].eleprof.newparticle.emitterid;
		if (iParticleEmitter != -1)
		{
			if (t.entityelement[t.e].eleprof.newparticle.bParticle_Preview == true)
				gpup_emitterActive(iParticleEmitter, 1);
			else
				gpup_emitterActive(iParticleEmitter, 0);
		}
	}
	#endif

	// show all markers
	t.gridentityhidemarkers=0;
	editor_updatemarkervisibility ( );

	// ensure all locked entity transparency resolves
	for ( t.tte = 1 ; t.tte<=  g.entityelementlist; t.tte++ )
	{
		if ( t.entityelement[t.tte].editorlock == 1 || t.entityelement[t.tte].underground == 1 ) 
		{
			t.tobj=t.entityelement[t.tte].obj;
			if ( t.tobj>0 ) 
			{
				if ( ObjectExist(t.tobj) == 1 ) 
				{
					//PE: Re-enable transparent on locked entities.
					if(t.entityelement[t.tte].editorlock == 1)
					{
							t.entityelement[t.tte].isclone = 0;
							entity_converttoclonetransparent();
					}
					else 
					{
						if (t.entityelement[t.tte].underground == 1) t.entityelement[t.tte].isclone = 1;
						entity_converttoinstance();
					}
				}
			}
		}
	}

	//PE: disable any animations that should not be in editor.
	for (t.tte = 1; t.tte <= g.entityelementlist; t.tte++)
	{
		// hide EBE markers
		int iIndex = t.entityelement[t.tte].bankindex;
		if (t.entityprofile[iIndex].isebe != 0)
		{
			t.tobj = t.entityelement[t.tte].obj;
			if (t.tobj > 0)
			{
				if (ObjectExist(t.tobj) == 1)
				{
					ShowLimb(t.tobj, 0);
				}
			}
		}

		t.entid = t.entityelement[t.tte].bankindex;
		t.tttsourceobj = g.entitybankoffset + t.entityelement[t.tte].bankindex;
		t.tobj = t.entityelement[t.tte].obj;
		if (t.tobj > 0)
		{
			if (ObjectExist(t.tobj) == 1)
			{
				#ifdef WICKEDENGINE
				//PE: Make sure we reset all animations. mainly for lua controlled objects like doors
				if (t.entityprofile[t.entid].animmax > 0)
				{
					SetObjectFrame(t.tttsourceobj, 0);
					StopObject(t.tttsourceobj);
					SetObjectFrame(t.tobj, 0);
					StopObject(t.tobj);

					//LB: also need to trigger Wicked to update the frame at least once
					sObject* pParentObj = GetObjectData(t.tttsourceobj);
					sObject* pInstanceObj = GetObjectData(t.tobj);
					WickedCall_SetObjectFrame(pParentObj, 0);
					WickedCall_SetObjectFrame(pInstanceObj, 0);
				}
				#endif
				if (t.entityprofile[t.entid].startanimingame > 0) 
				{
					if (t.entityprofile[t.entid].animmax > 0) 
					{
						t.q = 0;
						SetObjectFrame(t.tttsourceobj, 0);
						StopObject(t.tttsourceobj);
						SetObjectFrame(t.tobj, 0);
						StopObject(t.tobj);
					}
				}
			}
		}

		//PE: pframe is lost on clone objects, recreate.
		if (t.entityprofile[t.entid].ismarker == 0 && t.entityprofile[t.entid].isebe == 0)
		{
			if (t.entityelement[t.tte].isclone == 1 && t.entityelement[t.tte].underground == 0)
			{
				if (t.entityelement[t.tte].editorlock == 0)
				{
					//t.tobj = t.tentityobj; t.tte = t.tentitytoselect;
					entity_converttoinstance();
				}
			}
		}

		if (t.tobj > 0 && t.entityprofile[t.entid].ischaracter == 1) 
		{
			//Restore any character animations for editor.
			if (GetNumberOfFrames(t.tobj) > 0)
			{
				SetObjectFrame(t.tobj, 0);
				if (t.entityprofile[t.entid].animmax > 0 && t.entityprofile[t.entid].playanimineditor > 0 && t.entityprofile[t.entid].ischaractercreator == 0)
				{
					t.q = t.entityprofile[t.entid].playanimineditor - 1;
					LoopObject(t.tobj, t.entityanim[t.entid][t.q].start, t.entityanim[t.entid][t.q].finish);
				}
				else if (t.entityprofile[t.entid].playanimineditor < 0)
				{
					// uses name instead of index, the negative is the ordinal into the animset
					extern void entity_loop_using_negative_playanimineditor(int e, int obj, cstr animname);
					entity_loop_using_negative_playanimineditor(t.tte, t.tobj, t.entityprofile[t.entid].playanimineditor_name);
				}
				else
				{
					LoopObject(t.tobj); StopObject(t.tobj);
				}
			}

		}
		else 
		{
			#ifdef WICKEDENGINE
			//PE: Restore any non char animations.
			if (t.tobj > 0 && GetNumberOfFrames(t.tobj) > 0)
			{
				SetObjectFrame(t.tobj, 0);
				if (t.entityprofile[t.entid].animmax > 0 && t.entityprofile[t.entid].playanimineditor > 0 && t.entityprofile[t.entid].ischaractercreator == 0)
				{
					t.q = t.entityprofile[t.entid].playanimineditor - 1;
					LoopObject(t.tobj, t.entityanim[t.entid][t.q].start, t.entityanim[t.entid][t.q].finish);
				}
				else if (t.entityprofile[t.entid].playanimineditor < 0)
				{
					// uses name instead of index, the negative is the ordinal into the animset
					extern void entity_loop_using_negative_playanimineditor(int e, int obj, cstr animname);
					entity_loop_using_negative_playanimineditor(t.tte, t.tobj, t.entityprofile[t.entid].playanimineditor_name);
				}
				else
				{
					LoopObject(t.tobj); StopObject(t.tobj);
				}
			}
			#endif
		}
	}

	// signal that we have finished Test Level, restore mapeditor windows
	#ifdef FPSEXCHANGE
	 OpenFileMap (  1, "FPSEXCHANGE" );
	 SetFileMapDWORD (  1, 970, 1 );
	 SetEventAndWait (  1 );
	#endif

	// LB101019 - this can cause a freeze due to DirectInput bug when screensaver/hybernate kicks in
	// as the key pressed when waking up the boot screen remains in the key buffer even though key not pressed
	// though does get cleared later somehow (replace DX Input at some point to avoid this issue)
	// wait until all mouse activity over and escape key released
	//while ( MouseClick() != 0 ) {}
	//while ( ScanCode() != 0 ) {}

	// Restore camera
	editor_restoreeditcamera ( );
	t.updatezoom=1;

	// restore object visibilities
	editor_refresheditmarkers ( );

	// 130320 - ensure water height change is not saved out to root (messes up when reload software; underwater)
	float fStoreWaterLevel = g.gdefaultwaterheight;
	#ifdef WICKEDENGINE
	g.gdefaultwaterheight = -500.0f; //GGORIGIN_Y;
	#else
	g.gdefaultwaterheight = GGORIGIN_Y;
	#endif

	// remember game states for next time
	visuals_save ( );

	//PE: Before doing this, we should make sure that t.visuals LUA changes is not part of t.visuals.
#ifdef PRODUCTCLASSIC
	//PE: Restore settings from sliders. so .lua changes is not included.
	t.slidersmenuindex = t.slidersmenunames.visuals;
	sliders_write(true);
	t.slidersmenuindex = t.slidersmenunames.water;
	sliders_write(true);
	t.slidersmenuindex = t.slidersmenunames.camera;
	sliders_write(true);
	t.slidersmenuindex = t.slidersmenunames.posteffects;
	sliders_write(true);
	t.slidersmenuindex = t.slidersmenunames.qualitypanel;
	sliders_write(true);
	t.slidersmenuindex = t.slidersmenunames.worldpanel;
	sliders_write(true);
	t.slidersmenuindex = t.slidersmenunames.graphicoptions;
	sliders_write(true);
	t.slidersmenuindex = t.slidersmenunames.shaderoptions;
	sliders_write(true);

#endif

#ifdef WICKEDENGINE
	//PE: t.visuals LUA changes Problem:
	//PE: Max: Just dont copy gamevisuals = visuals ( all changes already goes to gamevisuals).
	//PE: TODO validate that all "test game" settings is also changed in gamevisuals.
	//PE: TODO after then removed line below on MAX only t.gamevisuals=t.visuals;
#endif

#ifndef WICKEDENGINE
	t.gamevisuals=t.visuals;
#endif

	// and restore as would otherwise interfere with ?
	g.gdefaultwaterheight = fStoreWaterLevel;

	// restore shader constants with editor visuals (and bring back some settings we want to retain)
	t.visuals=t.editorvisuals;
	t.visuals.skyindex=t.gamevisuals.skyindex;
	t.visuals.sky_s=t.gamevisuals.sky_s;
	t.visuals.terrainindex=t.gamevisuals.terrainindex;
	t.visuals.terrain_s=t.gamevisuals.terrain_s;
	t.visuals.vegetationindex=t.gamevisuals.vegetationindex;
	t.visuals.vegetation_s=t.gamevisuals.vegetation_s;
	t.visuals.iEnvironmentWeather = t.gamevisuals.iEnvironmentWeather;

	#ifdef WICKEDENGINE
	//t.visuals.AmbienceIntensity_f = 89.25f;
	t.visuals.AmbienceRed_f = t.gamevisuals.AmbienceRed_f;
	t.visuals.AmbienceGreen_f = t.gamevisuals.AmbienceGreen_f;
	t.visuals.AmbienceBlue_f = t.gamevisuals.AmbienceBlue_f;

	//PE: Comment out to always use editor camera and fov
//	t.visuals.CameraNEAR_f = t.gamevisuals.CameraNEAR_f;
//	t.visuals.CameraFAR_f = t.gamevisuals.CameraFAR_f;
//	t.visuals.CameraFOV_f = t.gamevisuals.CameraFOV_f;

	t.visuals.FogR_f = t.gamevisuals.FogR_f;
	t.visuals.FogG_f = t.gamevisuals.FogG_f;
	t.visuals.FogB_f = t.gamevisuals.FogB_f;
	t.visuals.FogA_f = t.gamevisuals.FogA_f;
	t.visuals.FogNearest_f = t.gamevisuals.FogNearest_f;
	t.visuals.FogDistance_f = t.gamevisuals.FogDistance_f;

	t.visuals.SkyIntensity_f = t.gamevisuals.SkyIntensity_f;
	t.visuals.SunIntensity_f = t.gamevisuals.SunIntensity_f;
	t.visuals.SunRed_f = t.gamevisuals.SunRed_f;
	t.visuals.SunGreen_f = t.gamevisuals.SunGreen_f;
	t.visuals.SunBlue_f = t.gamevisuals.SunBlue_f;
	t.visuals.ZenithRed_f = t.gamevisuals.ZenithRed_f;
	t.visuals.ZenithGreen_f = t.gamevisuals.ZenithGreen_f;
	t.visuals.ZenithBlue_f = t.gamevisuals.ZenithBlue_f;
	t.visuals.fSunShadowBias = t.gamevisuals.fSunShadowBias;
	t.visuals.bColorGrading = t.gamevisuals.bColorGrading;
	t.visuals.ColorGradingLUT = t.gamevisuals.ColorGradingLUT;
	t.visuals.bBloomEnabled = t.gamevisuals.bBloomEnabled;
	t.visuals.fsetBloomThreshold = t.gamevisuals.fsetBloomThreshold;
	t.visuals.bSSREnabled = t.gamevisuals.bSSREnabled;
	t.visuals.bReflectionsEnabled = t.gamevisuals.bReflectionsEnabled;
	t.visuals.bFXAAEnabled = t.gamevisuals.bFXAAEnabled;
	t.visuals.bTessellation = t.gamevisuals.bTessellation;
	t.visuals.bLightShafts = t.gamevisuals.bLightShafts;
	t.visuals.bLensFlare = t.gamevisuals.bLensFlare;
	t.visuals.bAutoExposure = t.gamevisuals.bAutoExposure;
	t.visuals.fAutoExposureRate = t.gamevisuals.fAutoExposureRate;
	t.visuals.fAutoExposureKey = t.gamevisuals.fAutoExposureKey;
	t.visuals.fExposure = t.gamevisuals.fExposure;
	t.visuals.fGamma = t.gamevisuals.fGamma;

	t.visuals.SkyCloudiness = t.gamevisuals.SkyCloudiness;
	t.visuals.SkyCloudCoverage = t.gamevisuals.SkyCloudCoverage;
	t.visuals.SkyCloudHeight = t.gamevisuals.SkyCloudHeight;
	t.visuals.SkyCloudThickness = t.gamevisuals.SkyCloudThickness;
	t.visuals.SkyCloudSpeed = t.gamevisuals.SkyCloudSpeed;

	t.visuals.iMSAASampleCount = t.gamevisuals.iMSAASampleCount;

	t.visuals.iMSAO = t.gamevisuals.iMSAO;
	t.visuals.fMSAOPower = t.gamevisuals.fMSAOPower;

	//PE: restore SetGlobalGraphicsSettings here. unless changed with tab tab, then they are changed in gamevisuals
	//PE: Postprocess already restored.
	t.visuals.iShadowSpotCascadeResolution = t.gamevisuals.iShadowSpotCascadeResolution;
	t.visuals.iShadowSpotResolution = t.gamevisuals.iShadowSpotResolution;
	t.visuals.iShadowPointResolution = t.gamevisuals.iShadowPointResolution;
	t.visuals.iShadowPointMax = t.gamevisuals.iShadowPointMax;
	t.visuals.iShadowSpotMax = t.gamevisuals.iShadowSpotMax;
	t.visuals.bTransparentShadows = t.gamevisuals.bTransparentShadows;

	t.visuals.fShadowFarPlane = t.gamevisuals.fShadowFarPlane;

	#if 0
	#ifdef WICKEDENGINE
	TestLevel_ToggleTreeVegWater(t.showtestgametrees, t.showtestgameveg, t.showtestgamewater);
	#endif
	#endif

	t.visuals.bWaterEnable = t.gamevisuals.bWaterEnable;
	t.visuals.fWaterWaveAmplitude = t.gamevisuals.fWaterWaveAmplitude;
	t.visuals.fWaterPatchLength = t.gamevisuals.fWaterPatchLength;
	t.visuals.fWaterChoppyScale = t.gamevisuals.fWaterChoppyScale;
	t.visuals.fWaterWindDependency = t.gamevisuals.fWaterWindDependency;

	t.visuals.WaterFogMinDist = t.gamevisuals.WaterFogMinDist;
	t.visuals.WaterFogMaxDist = t.gamevisuals.WaterFogMaxDist;
	t.visuals.WaterFogMinAmount = t.gamevisuals.WaterFogMinAmount;
	
	//PE: Water color was missing.
	t.visuals.WaterRed_f = t.gamevisuals.WaterRed_f;
	t.visuals.WaterGreen_f = t.gamevisuals.WaterGreen_f;
	t.visuals.WaterBlue_f = t.gamevisuals.WaterBlue_f;
	t.visuals.WaterAlpha_f = t.gamevisuals.WaterAlpha_f;

	t.visuals.iTimeOfday = t.gamevisuals.iTimeOfday;
	t.visuals.SunAngleX = t.gamevisuals.SunAngleX;
	t.visuals.SunAngleY = t.gamevisuals.SunAngleY;
	t.visuals.SunAngleZ = t.gamevisuals.SunAngleZ;

	t.visuals.bSimulate24Hours = t.gamevisuals.bSimulate24Hours;
	t.visuals.fTimeSpeed = t.gamevisuals.fTimeSpeed;

	t.visuals.fWeatherIntensity = t.gamevisuals.fWeatherIntensity;
	t.visuals.fWeatherLighting = t.gamevisuals.fWeatherLighting;
	t.visuals.fWeatherThunder = t.gamevisuals.fWeatherThunder;
	t.visuals.fWeatherWind = t.gamevisuals.fWeatherWind;
	
	t.visuals.fLevelDifficulty = t.gamevisuals.fLevelDifficulty;
	

	for (int iL = 0; iL < 32; iL++) {
		t.visuals.sTerrainTextures[iL] = t.gamevisuals.sTerrainTextures[iL];
		t.visuals.sTerrainTexturesName[iL] = t.gamevisuals.sTerrainTexturesName[iL];
	}
	

	for (int iL = 0; iL < 128; iL++) {
		t.visuals.sGrassTextures[iL] = t.gamevisuals.sGrassTextures[iL];
		t.visuals.sGrassTexturesName[iL] = t.gamevisuals.sGrassTexturesName[iL];

		t.visuals.sFactionName[iL] = t.gamevisuals.sFactionName[iL];
	}

	t.visuals.bEndableAmbientMusicTrack = t.gamevisuals.bEndableAmbientMusicTrack;
	t.visuals.sAmbientMusicTrack = t.gamevisuals.sAmbientMusicTrack;
	t.visuals.iAmbientMusicTrackVolume = t.gamevisuals.iAmbientMusicTrackVolume;
	t.visuals.bEnableCombatMusicTrack = t.gamevisuals.bEnableCombatMusicTrack;
	t.visuals.sCombatMusicTrack = t.gamevisuals.sCombatMusicTrack;
	t.visuals.iCombatMusicTrackVolume = t.gamevisuals.iCombatMusicTrackVolume;

	t.visuals.bEndableTreeDrawing = t.gamevisuals.bEndableTreeDrawing;

	t.visuals.bEndableGrassDrawing = t.gamevisuals.bEndableGrassDrawing;

	t.visuals.iHeightmapWidth = t.gamevisuals.iHeightmapWidth;
	t.visuals.iHeightmapHeight = t.gamevisuals.iHeightmapHeight;

	t.visuals.bDisableSkybox = t.gamevisuals.bDisableSkybox;

	t.visuals.bRainEnabled = t.gamevisuals.bRainEnabled;
	t.visuals.fRainSpeedX = t.gamevisuals.fRainSpeedX;
	t.visuals.fRainSpeedY = t.gamevisuals.fRainSpeedY;
	t.visuals.fRainOpacity = t.gamevisuals.fRainOpacity;
	t.visuals.fRainScaleX = t.gamevisuals.fRainScaleX;
	t.visuals.fRainScaleY = t.gamevisuals.fRainScaleY;
	t.visuals.fRainRefreactionScale = t.gamevisuals.fRainRefreactionScale;


	t.visuals.bSnowEnabled = t.gamevisuals.bSnowEnabled;
	t.visuals.fSnowLayers = t.gamevisuals.fSnowLayers;
	t.visuals.fSnowDepth = t.gamevisuals.fSnowDepth;
	t.visuals.fSnowWind = t.gamevisuals.fSnowWind;
	t.visuals.fSnowSpeed = t.gamevisuals.fSnowSpeed;
	t.visuals.fSnowOpacity = t.gamevisuals.fSnowOpacity;
	t.visuals.fSnowOffset = t.gamevisuals.fSnowOffset;

	#endif

	// and refresh assets based on restore
	t.visuals.refreshshaders=1;
	visuals_loop ( );
	visuals_shaderlevels_update ( );

	// use infinilights to show dynamic lighting in editor
	lighting_init ( );

	// Second call will toggle keyboard/mouse back to FOREGROUND
	SetWindowModeOn ( );

	#ifdef ENABLEIMGUI
	#ifndef USEOLDIDE
	//PE: Need to restore original settings.
	//PE: Setup the window here. pos size. Docking ?
	SetWindowSettings(5, 1, 1);
	SetForegroundWindow(g_pGlob->hWnd);
	SetWindowSize(gWindowSizeXOld+ gWindowSizeAddX, gWindowSizeYOld+ gWindowSizeAddY); //PE: test
	SetWindowPosition(gWindowPosXOld, gWindowPosYOld);
	ShowWindow();
	if (gWindowMaximized == 1 )
		MaximiseWindow();
	else
		RestoreWindow();

	//PE: enable outside windows again.
	ImGui::ShowAllViewPortWindows();
	#ifndef WICKEDENGINE
	LRESULT CALLBACK ImguiWindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	#endif
	#ifdef USERENDERTARGET
	//PE: keep it at current resolution for now.
	//SetCameraToImage(0, 21, OldrenderTargetSize.x, OldrenderTargetSize.y, 2);
	#endif
	#endif
	#endif

	// Close popup message
	if ( t.conkit.modified == 1 ) 
	{
		SleepNow ( 1000 );
		popup_text_close();
		t.conkit.modified=0;
	}

	// Ensure no terrain/entity editing carried back
	t.terrain.terrainpainteroneshot=0;

	// Set editor to use a true 1;1 pixel mapping for Text ( , Steam GUI and other overlay images )
	SetChildWindowTruePixel ( 1 );
	//common_refreshDisplaySize ( );

	// restore if project modified
	t.tignoreinvalidateobstacles=1;
	#ifndef WICKEDENGINE
	//PE: In Wickede we use the flags directly.
	g.projectmodified = t.storeprojectmodified; if ( g.projectmodified == 1 ) gridedit_changemodifiedflag ( );
	g.projectmodifiedstatic = g_tstoreprojectmodifiedstatic; 
	#else
	//PE: Ups - g.projectmodified Still used for save.
	g.projectmodified = t.storeprojectmodified;
	#endif
	t.tignoreinvalidateobstacles=0;

	// Something is clipping objects when returning to editor
	editor_loadcfg();
	editor_refreshcamerarange();
}

void editor_previewmapormultiplayer(int iUseVRTest)
{
	// for non-MAX scenarios (single function call)
	bool bRunLoop = true;
	editor_previewmapormultiplayer_initcode(iUseVRTest);
	while ( bRunLoop == true)
	{
		if (editor_previewmapormultiplayer_loopcode(iUseVRTest) == true) bRunLoop = false;
	}
	editor_previewmapormultiplayer_afterloopcode(iUseVRTest);
	t.postprocessings.fadeinvalue_f = 1.0f;
}

void editor_multiplayermode ( void )
{
	// check we are not in the importer or character creator
	editor_checkIfInSubApp ( );

	//  Record last edited project
	t.storeprojectfilename_s=g.projectfilename_s;

	//  Set multiplayer flags here
	t.game.runasmultiplayer=1;
	#ifdef VRTECH
	editor_previewmapormultiplayer ( 1 );
	#else
	editor_previewmapormultiplayer ( 0 );
	#endif

	// PE: I cant restore editor after multiplayer mode ? SO:
	// call a new map editor
	#ifdef FPSEXCHANGE
	#ifdef PRODUCTV3
	// not for VRQ - allow it to return normally
	#else
	OpenFileMap(2, "FPSEXCHANGE");
	SetFileMapString(2, 1000, "Guru-MapEditor.exe");
	SetFileMapString(2, 1256, "-r");
	SetFileMapDWORD(2, 994, 0);
	SetFileMapDWORD(2, 924, 1);
	SetEventAndWait(2);
	// Terminate fragmented EXE
	common_justbeforeend();
	ExitProcess(0);
	#endif
	#endif

	// As multiplayer can load OTHER things, restore level to state before we clicked MM button
	t.tfile_s=g.mysystem.editorsGridedit_s+"cfg.cfg";//"editors\\gridedit\\cfg.cfg";
	if (  FileExist(t.tfile_s.Get()) == 1 ) 
	{
		timestampactivity(0,"reloading your level after MM button");
		t.skipfpmloading=0;
		g.projectfilename_s=g.mysystem.editorsGrideditAbs_s+"worklevel.fpm";//g.fpscrootdir_s+"\\Files\\editors\\gridedit\\worklevel.fpm";
		editor_loadcfg ( );
		gridedit_load_map ( );
		#ifdef WICKEDENGINE
		grass_init();
		bUpdateVeg = true;
		#endif

		//  added to solve fog issue when go in and out of MP menu
		visuals_editordefaults ( );
		t.visuals.refreshshaders=1;
	}

	//  restore last edited project
	g.projectfilename_s=t.storeprojectfilename_s;
	gridedit_updateprojectname ( );

	//editor_restoreeditcamera();
	//SyncMaskOverride(0xFFFFFFFF);

}

void editor_previewmap ( int iUseVRTest )
{
	//  check if we are in the importer or character creator, if we are, don't test ma
	editor_checkIfInSubApp ( );
	//  Set single player test game flags here
	t.game.runasmultiplayer=0;
	#ifdef VRTECH
	editor_previewmapormultiplayer ( iUseVRTest );
	#else
	editor_previewmapormultiplayer ( 0 );
	#endif
}

void editor_previewmap_initcode(int iUseVRTest)
{
	editor_previewmapormultiplayer_initcode ( iUseVRTest );
}

bool editor_previewmap_loopcode(int iUseVRTest)
{
	// loop ended
	return editor_previewmapormultiplayer_loopcode ( iUseVRTest );
}

void editor_previewmap_afterloopcode(int iUseVRTest)
{
	editor_previewmapormultiplayer_afterloopcode ( iUseVRTest );
}

void input_getfilemapcontrols ( void )
{
	//  Update triggers and issue actions through filemapping system
	#ifdef FPSEXCHANGE
	OpenFileMap (  1, "FPSEXCHANGE" );
	SetEventAndWait (  1 );
	#endif

	#ifdef FPSEXCHANGE
	 // only if the IDE has foreground focus
	 DWORD dwForegroundFocusForIDE = GetFileMapDWORD( 1, 596 );
	 if ( dwForegroundFocusForIDE == 10 )
	 {
		t.inputsys.xmouse=GetFileMapDWORD( 1, 0 );
		t.inputsys.ymouse=GetFileMapDWORD( 1, 4 );
		t.inputsys.xmousemove=GetFileMapDWORD( 1, 8 );
		t.inputsys.ymousemove=GetFileMapDWORD( 1, 12 );
		SetFileMapDWORD (  1, 8, 0 );
		SetFileMapDWORD (  1, 12, 0 );
		t.inputsys.wheelmousemove=GetFileMapDWORD( 1, 16 );
		set_inputsys_mclick(GetFileMapDWORD(1, 20));// t.inputsys.mclick = GetFileMapDWORD(1, 20);
		if (GetFileMapDWORD(1, 28) == 1)  set_inputsys_mclick(2);// t.inputsys.mclick = 2;
		if (MouseClick() == 4)  set_inputsys_mclick(4);// t.inputsys.mclick = 4;
		if (t.interactive.insidepanel == 1)  set_inputsys_mclick(0);// t.inputsys.mclick = 0;
		t.inputsys.kscancode=GetFileMapDWORD( 1, 100 );
	 }
	#else
	 t.inputsys.xmouse = MouseX();
	 t.inputsys.ymouse = MouseY();
	 t.inputsys.xmousemove = MouseMoveX();
	 t.inputsys.ymousemove = MouseMoveY();
	 t.inputsys.wheelmousemove = MouseMoveZ();
	 t.inputsys.mclick = MouseClick();
	 if (t.interactive.insidepanel == 1) t.inputsys.mclick = 0;
	 t.inputsys.kscancode = ScanCode();
	#endif

	//  extra mappings
	input_extramappings ( );

	//  Control keys direct from keyboard
	#ifdef FPSEXCHANGE
	 t.inputsys.keyreturn=GetFileMapDWORD( 1, 108 );
	 t.inputsys.keyshift=GetFileMapDWORD( 1, 112 );
	 t.inputsys.keytab = 0;
	 t.inputsys.keyup=GetFileMapDWORD( 1, 120 );
	 t.inputsys.keydown=GetFileMapDWORD( 1, 124 );
	 t.inputsys.keyleft=GetFileMapDWORD( 1, 128 );
	 t.inputsys.keyright=GetFileMapDWORD( 1, 132 );
	 t.inputsys.keycontrol=GetFileMapDWORD( 1, 116 );
	 t.inputsys.keyalt=GetFileMapDWORD( 1, 136 );
	#else
	t.inputsys.keyreturn = ReturnKey();
	t.inputsys.keyshift = ShiftKey();
	t.inputsys.keytab = 0;
	t.inputsys.keyup = UpKey();
	t.inputsys.keydown = DownKey();
	t.inputsys.keyleft = LeftKey();
	t.inputsys.keyright = RightKey();
	t.inputsys.keycontrol = ControlKey();
	t.inputsys.keyalt = 0;
	#endif
	if (  t.inputsys.kscancode == 32  )  t.inputsys.keyspace = 1; else t.inputsys.keyspace = 0;

	// will release keypress flag if no key AND no SHIFT!!
	if (t.inputsys.kscancode == 0 && t.inputsys.keyshift == 0) t.inputsys.keypressallowshift = 0;

	//  W,A,S,D in editor for scrolling about (easier for user)
	if (  t.inputsys.kscancode == 87  )
		t.inputsys.keyup = 1;
	if (  t.inputsys.kscancode == 65  )  t.inputsys.keyleft = 1;
	if (  t.inputsys.kscancode == 83  )  t.inputsys.keydown = 1;
	if (  t.inputsys.kscancode == 68  )  t.inputsys.keyright = 1;

	//  fake mousemove values for low-response systems (when in zoomed in mode)
	if (  t.grideditselect == 4 ) 
	{
		if (  t.inputsys.keyshift == 1 ) 
		{
			if (  t.inputsys.keyleft == 1  )  t.inputsys.xmousemove = -10;
			if (  t.inputsys.keyright == 1  )  t.inputsys.xmousemove = 10;
			if (  t.inputsys.keyup == 1  )  t.inputsys.ymousemove = -10;
			if (  t.inputsys.keydown == 1  )  t.inputsys.ymousemove = 10;
			set_inputsys_mclick(2);// t.inputsys.mclick = 2;
			t.inputsys.keyleft=0;
			t.inputsys.keyright=0;
			t.inputsys.keyup=0;
			t.inputsys.keydown=0;
		}
	}

	//  special trigger when click LIBRARY TAB, force into respective mode
	#ifdef FPSEXCHANGE
	if (  GetFileMapDWORD( 1, 546 ) == 1 ) 
	{
		t.ttabindex=GetFileMapDWORD( 1, 520 );
		if (  t.ttabindex == 0  )  t.inputsys.domodeentity = 1;
		if (  t.ttabindex == 1  )  t.inputsys.domodeentity = 1;
		if (  t.ttabindex == 2  )
		{
			if ( t.ebe.active == 0 )
			{
				// need to select a site (using entity creation and placement first)
			}
			else
			{
				// reset for tool work
				ebe_reset();
			}
		}
		else
		{
			// When click non-Builder tab, should leave builder mode
			ebe_hide();

			//PE: If first entity, shader have not yet had constant set , so update shaders.
			//PE: Prevent new created ebe from disappering when clicking away from "builder".
			visuals_justshaderupdate();
		}
		SetFileMapDWORD (  1, 546, 0 );
	}
	#endif

	//  recent file list
	#ifdef FPSEXCHANGE
	t.trecentfilechoice=GetFileMapDWORD( 1, 442 );
	if (  t.trecentfilechoice>0 ) 
	{
		//  retain choice for action at end of subroutine
		t.trecentfilechoice_s=GetFileMapString( 1, 1000 );
		SetFileMapDWORD (  1, 442, 0 );
	}
	#endif

	//  termination trigger
	#ifdef FPSEXCHANGE
	if (  GetFileMapDWORD( 1, 908 ) == 1 ) 
	{
		// show outtro message if free version mode
		if ( g.iFreeVersionModeActive == 1 || ( g.iFreeVersionModeActive == 2 && g_trialStampDaysLeft > 0 ) )
		{
			t.inputsys.ignoreeditorintermination = 1;
			welcome_init(1);
			welcome_init(0);
			if ( g.iFreeVersionModeActive == 1 ) welcome_show(WELCOME_FREEINTROAPP);
			if ( g.iFreeVersionModeActive == 2 ) welcome_show(WELCOME_FREETRIALINTROAPP);
			t.inputsys.ignoreeditorintermination = 0;
		}

		// Here we ask if changes should be saved, etc
		gridedit_intercept_savefirst_noreload ( );
		OpenFileMap (  1,"FPSEXCHANGE" );
		if (  t.editorcanceltask == 0 ) 
		{
			//  go ahead, confirmed, end interface program
			SetFileMapDWORD (  1, 912, 1 );
			SetEventAndWait (  1 );
			//  close down Steam hook
			mp_free ( );
			//  end editor program
			timestampactivity(0,"Terminated because 908=1");
			common_justbeforeend();
			ExitProcess ( 0 );
		}
		else
		{
			//  carry on with interface
			SetFileMapDWORD (  1, 908, 0 );
			SetEventAndWait (  1 );
			//CloseFileMap (  1 );
		}
	}
	#endif

	//  EDIT MENU
	#ifdef FPSEXCHANGE
	if (  GetFileMapDWORD( 1, 446 ) == 1 ) 
	{  
		t.inputsys.doundo = 1; 
		SetFileMapDWORD (  1, 446, 0 ); 
	}
	if (  GetFileMapDWORD( 1, 450 ) == 1 ) { t.inputsys.doredo = 1  ; SetFileMapDWORD (  1, 450, 0 ); }
	if (  GetFileMapDWORD( 1, 454 ) == 1 ) { t.inputsys.tselcontrol = 1  ; t.inputsys.tselcut = 1 ; t.inputsys.tselcopy = 1 ; SetFileMapDWORD (  1, 454, 0 ); }
	if (  GetFileMapDWORD( 1, 458 ) == 1 ) { t.inputsys.tselcontrol = 1  ; t.inputsys.tselcopy = 1 ; SetFileMapDWORD (  1, 458, 0 ); }
	#endif

	//  Get toolbar triggers
	#ifdef FPSEXCHANGE
	t.inputsys.doartresize=0;
	t.toolbarset=GetFileMapDWORD( 1, 200 );
	t.toolbarindex=GetFileMapDWORD( 1, 204 );
	if (  t.toolbarindex>0 ) 
	{
		if (  t.toolbarset == 2 ) 
		{
			//  ZOOM IN and ZOOM OUT
			switch (  t.toolbarindex ) 
			{
			case 1 : t.inputsys.kscancode = 188 ; break ;
			case 2 : t.inputsys.kscancode = 190 ; break ;
			}		//~   endif
		}
		if (  t.toolbarset == 4 ) 
		{
			//  EDIT MODE SELECTOR (entity/terrain)
			switch (  t.toolbarindex ) 
			{
			case 7 : t.inputsys.kscancode = Asc("E") ; break ;
			case 8 : t.inputsys.kscancode = Asc("M") ; break ;
			case 9 : t.inputsys.kscancode = Asc("T") ; break ;
			}		//~   endif
		}
		if (  t.toolbarset == 6 ) 
		{
			//  TERRAIN TOOLS (sculpt,flatten,paint)
			t.inputsys.domodeterrain=1;
			switch (  t.toolbarindex ) 
			{
			case 1 : t.inputsys.kscancode = Asc("1") ; break ;
			case 2 : t.inputsys.kscancode = Asc("2") ; break ;
			case 3 : t.inputsys.kscancode = Asc("3") ; break ;
			case 4 : t.inputsys.kscancode = Asc("4") ; break ;
			case 5 : t.inputsys.kscancode = Asc("5") ; break ;
			case 6 : t.inputsys.kscancode = Asc("6") ; break ;
			case 7 : t.inputsys.kscancode = Asc("7") ; break ;
			case 8 : t.inputsys.kscancode = Asc("8") ; break ;
			case 9 : t.inputsys.kscancode = Asc("9") ; break ;
			case 10 : t.inputsys.kscancode = Asc("0") ; break ;
			}
		}
		if (  t.toolbarset == 8 ) 
		{
			//  wayppoint
			t.inputsys.domodewaypoint=1;
			switch (  t.toolbarindex ) 
			{
				case 1 :
					t.inputsys.domodewaypointcreate=1;
				break;
			}		//~   endif
		}
		if (  t.toolbarset == 9 ) 
		{
			//  rem LAUNCH TEST GAME
			switch (  t.toolbarindex ) 
			{
				case 1 :
					editor_previewmap ( 0 );
				break;
				case 2 :
					editor_multiplayermode ( );
				break;
				#ifdef VRTECH
				case 3 :
					if ( g.gvrmode == 0 )
					{
						HWND hThisWnd = GetForegroundWindow();
						MessageBoxA ( hThisWnd, "You are not in VR mode. You need to exit the software. When you restart, select VR MODE ON to enable VR.", "Not in VR Mode", MB_OK );
						OpenFileMap (  1, "FPSEXCHANGE" );
						SetFileMapDWORD (  1, 970, 1 );
						SetEventAndWait (  1 );
					}
					else
					{
						editor_previewmap ( 1 );
					}
				break;
				#endif
			}
		}
		if ( t.toolbarset == 21 ) 
		{
			// HELP MENU Actions
			#ifdef VRTECH
			switch ( t.toolbarindex ) 
			{
				#ifndef WICKEDENGINE
				case 1 : editor_showhelppage ( 1 );  break;
				#endif
				case 2 : editor_showhelppage ( 2 );  break;
				case 3 : editor_showhelppage ( 3 );  break;
			}
			#else
			switch (  t.toolbarindex ) 
			{
				case 1 : editor_showhelppage ( 0 ); break;
				case 2 : 
					if (  t.interactive.active == 0  )  
						t.interactive.active = 2;
					break;
			}
			#endif
		}
	}
	#endif

	// Clear toolbar index and deltas
	#ifdef FPSEXCHANGE
	SetFileMapDWORD (  1, 200, 0 );
	SetFileMapDWORD (  1, 204, 0 );
	SetFileMapDWORD (  1, 8, 0 );
	SetFileMapDWORD (  1, 12, 0 );
	SetFileMapDWORD (  1, 16, 0 );
	#endif

	// Deactivate mouse if leave 3d area
	if ( t.inputsys.xmouse == -1 && t.inputsys.ymouse == -1 ) 
	{
		t.inputsys.xmouse=500000;
		t.inputsys.ymouse=0;
		t.inputsys.xmousemove=0;
		t.inputsys.ymousemove=0;
		t.inputsys.activemouse=0;
		set_inputsys_mclick(0);// t.inputsys.mclick = 0;
		t.syncthreetimes=2;
	}
	else
	{
		if (  t.inputsys.activemouse == 0 ) 
		{
			//  was out, now back in
			editor_refresheditmarkers ( );
		}
	}
	t.inputsys.activemouse=1;

	// Convert FILE MAP COMM VALUES to DX INPUT CODES
	t.t_s="" ; t.tt=0;
	switch ( t.inputsys.kscancode ) 
	{
		case 9 : t.tt = 15 ; break ;
		case 32 : t.tt = 57 ; break ;
		case 33 : t.tt = 201 ; break ;
		case 34 : t.tt = 209 ; break ;
		case 37 : t.tt = 203 ; break ;
		case 38 : t.tt = 200 ; break ;
		case 39 : t.tt = 205 ; break ;
		case 40 : t.tt = 208 ; break ;
		case 42 : t.tt = 16 ; break ;
		case 46 : t.tt = 211 ; break ;
		case 54 : t.tt = 16 ; break ;
		case 112 : t.tt = 59 ; break ;
		case 113 : t.tt = 60 ; break ;
		case 114 : t.tt = 61 ; break ;
		case 115 : t.tt = 62 ; break ;
		case 123 : t.tt = 88 ; break ;
		case 187 : t.tt = 13 ; break ;
		case 188 : t.tt = 51 ; break ;
		case 189 : t.tt = 12 ; break ;
		case 190 : t.tt = 52 ; break ;
		case 192 : t.tt = 40 ; break ;
		case 219 : t.tt = 26 ; break ;
		case 220 : t.tt = 86 ; break ;
		case 221 : t.tt = 27 ; break ;
		case 222 : t.tt = 43 ; break ;
		case 1001 : t.tt = 13 ; break ;
		case 1002 : t.tt = 12 ; break ;
	}

	// 031215 - then remap to new scancodes (from keymap)
	t.tt = g.keymap[t.tt];

	// and temp back into IDE key values (for last bit)
	int ttt = 0;
	switch ( t.tt )
	{
		case 15 : ttt = 9 ; break ;
		case 57 : ttt = 32 ; break ;
		case 201 : ttt = 33 ; break ;
		case 209 : ttt = 34 ; break ;
		case 203 : ttt = 37 ; break ;
		case 200 : ttt = 38 ; break ;
		case 205 : ttt = 39 ; break ;
		case 208 : ttt = 40 ; break ;
		case 16 : ttt = 42 ; break ;
		case 211 : ttt = 46 ; break ;
		case 59 : ttt = 112 ; break ;
		case 60 : ttt = 113 ; break ;
		case 61 : ttt = 114 ; break ;
		case 62 : ttt = 115 ; break ;
		case 88 : ttt = 123 ; break ;
		case 13 : ttt = 187 ; break ;
		case 51 : ttt = 188 ; break ;
		case 12 : ttt = 189 ; break ;
		case 52 : ttt = 190 ; break ;
		case 40 : ttt = 192 ; break ;
		case 26 : ttt = 219 ; break ;
		case 86 : ttt = 220 ; break ;
		case 27 : ttt = 221 ; break ;
		case 43 : ttt = 222 ; break ;
	}
	// then create proper inkey chars from revised (if any) scancodes
	switch ( ttt )
	{
		case 16 : t.t_s = "q"; break;
		case 57 : t.t_s = " "; break;
		case 107 : t.t_s = "="; break;
		case 109 : t.t_s = "-"; break;
		case 187 : t.t_s = "="; break;
		case 188 : t.t_s = ","; break;
		case 189 : t.t_s = "-"; break;
		case 190 : t.t_s = "."; break;
		case 192 : t.t_s = "'"; break;
		case 219 : t.t_s = "["; break;
		case 220 : t.t_s = "\\"; break;
		case 221 : t.t_s = "]"; break;
		case 222 : t.t_s = "#"; break;
	}
	if (  t.inputsys.kscancode >= Asc("A") && t.inputsys.kscancode <= Asc("Z")  )  t.t_s = Lower(Chr(t.inputsys.kscancode));
	if (  t.inputsys.kscancode >= Asc("0") && t.inputsys.kscancode <= Asc("9")  )  t.t_s = Lower(Chr(t.inputsys.kscancode));
	if (  t.t_s != ""  )  t.tt = 1;

	//  Get menu triggers
	t.inputsys.dosave=0 ; t.inputsys.doopen=0 ; t.inputsys.donew=0 ; t.inputsys.donewflat=0 ; t.inputsys.dosaveas=0;
	#ifdef FPSEXCHANGE
	if (  GetFileMapDWORD( 1, 404 ) == 1 ) { t.inputsys.dosave = 1  ; SetFileMapDWORD (  1, 404, 0 ); }
	if (  GetFileMapDWORD( 1, 408 ) == 1 ) { t.inputsys.donew = 1  ; SetFileMapDWORD (  1, 408, 0 ); }
	if (  GetFileMapDWORD( 1, 408 ) == 2 ) 
	{ 
		if ( t.bIgnoreFirstCallToNewLevel == true )
		{
			// 280317 - editor calls to create new map, but can load in default.fpm at start (when welcome screen active)
			t.bIgnoreFirstCallToNewLevel = false;
		}
		else
		{
			t.inputsys.donewflat = 1; 
		}
		SetFileMapDWORD (  1, 408, 0 ); 
	}
	if (  GetFileMapDWORD( 1, 434 ) == 1 ) { t.inputsys.dosaveas = 1  ; SetFileMapDWORD (  1, 434, 0 ); }
	if (  GetFileMapDWORD( 1, 400 ) == 1 ) { t.inputsys.doopen = 1  ; t.inputsys.donew = 0 ; t.inputsys.donewflat = 0 ; SetFileMapDWORD (  1, 400, 0 ); }
	#else
	if (t.bTriggerNewMapAtStart == true)
	{
		t.bTriggerNewMapAtStart = false;
		t.inputsys.donew = 1;
	}
	#endif

	// select items from editing to see values
	#ifdef FPSEXCHANGE
	SetEventAndWait (  1 );
	t.tindex1=GetFileMapDWORD( 1, 712 );
	if (  t.tindex1>0 ) 
	{
		t.tt=1 ; t.t_s="";
		t.tindex2=GetFileMapDWORD( 1, 716 );
		if (  t.tindex1 == 2 ) 
		{
			t.inputsys.domodeterrain=1;
			switch (  t.tindex2 ) 
			{
				case 1 : t.t_s = "1" ; break ;
				case 2 : t.t_s = "2" ; break ;
				case 3 : t.t_s = "3" ; break ;
				case 4 : t.t_s = "6" ; break ;
				case 5 : t.t_s = "9" ; break ;
				case 6 : t.t_s = "0" ; break ;
			}
		}
		if (  t.tindex1 == 1 ) 
		{
			switch (  t.tindex2 ) 
			{
				case 1 : t.t_s = "t" ; break ;
				case 2 : t.t_s = "e" ; break ;
			}
		}
		SetFileMapDWORD (  1, 712, 0 );
		SetFileMapDWORD (  1, 716, 0 );
		SetEventAndWait (  1 );
	}
	#endif

	//  Record final translated key values
	t.inputsys.k_s=t.t_s ; t.inputsys.kscancode=t.tt;

	//  Determine if Library Selection Made
	#ifdef FPSEXCHANGE
	if ( GetFileMapDWORD( 1, 516 ) > 0 )
	{
		SetFileMapDWORD ( 1, 516, 0 );
		t.clickedonworkspace = GetFileMapDWORD( 1, 520 );
		t.clickeditemonworkspace = GetFileMapDWORD( 1, 524 );
		if ( t.clickeditemonworkspace != -1 ) 
		{
			// if in EBE tool, and switch to Entity/Marker tab, reactivate EBE
			if ( t.clickedonworkspace == 2 ) 
			{
				if ( t.ebe.active != 0 )
				{
					// switch on EBE tool visuals
					ebe_reset();
				}
				else
				{
					// not active, but need to be in entity mode for placement of site
					t.inputsys.domodeentity = 1; 
					t.grideditselect = 5; 
				}
			}
			else
			{
				ebe_hide();
			}

			// check if Entity/Marker/Builder tab selected
			if ( t.clickedonworkspace == 1 || t.clickedonworkspace == 2 ) 
			{
				if ( t.clickedonworkspace == 1 || (t.clickedonworkspace == 2 && t.clickeditemonworkspace == 0) )
				{
					if ( t.clickedonworkspace == 1 )
					{
						// Selected Marker (playerstart,light,trigger,emission)
						t.addentityfile_s = t.markerentitybank_s[1+t.clickeditemonworkspace];
					}
					else
					{
						// Or Builder 'Add New Site' which produces an entity we can use
						t.addentityfile_s = t.ebebank_s[1+t.clickeditemonworkspace];
						t.inputsys.domodeentity = 1; // ensure can position entity when select site
					}
					if ( t.addentityfile_s != "" ) 
					{
						#ifdef ENABLEIMGUI
						DeleteWaypointsAddedToCurrentCursor();
						//CheckTooltipObjectDelete();
						CloseDownEditorProperties();
						#endif
						#ifdef WICKEDENGINE
						iLastEntityOnCursor = 0;
						#endif
						entity_adduniqueentity ( false );
						t.tasset=t.entid;
						if ( t.talreadyloaded == 0 ) 
						{
							editor_filllibrary ( );
						}
					}
					t.inputsys.constructselection = t.tasset;
				}
				if ( t.clickedonworkspace == 2 && t.clickeditemonworkspace > 0 )
				{
					#ifdef ENABLEIMGUI
					CloseDownEditorProperties();
					#endif
					// selected builder tool icon - load in pattern for cube-insertion
					LPSTR pPBFEBEFile = t.ebebank_s[1+t.clickeditemonworkspace].Get();
					// loads painting pattern
					ebe_loadpattern ( pPBFEBEFile );
					t.inputsys.constructselection = 0;
				}
			}
			if ( t.clickedonworkspace == 0 ) 
			{
				if (  t.clickeditemonworkspace == 0 ) 
				{
					t.tnewadd=0;
					if (  t.clickedonworkspace == 0 ) 
					{
						#ifdef ENABLEIMGUI
						DeleteWaypointsAddedToCurrentCursor();
						//CheckTooltipObjectDelete();
						CloseDownEditorProperties();
						#endif

						//  [new entity]
						entity_addtoselection ( );
						t.tnewadd=t.entnewloaded;
						t.tasset=t.entid;
					}
					//  add asset to library
					if ( t.tnewadd == 1 ) editor_filllibrary ( );
					//  use as current asset
					t.inputsys.constructselection=t.tasset;
				}
				else
				{
					//  select existing asset
					if (  t.clickedonworkspace == 0 ) 
					{
						//  entity uses array to indicate the real entity index (to exclude markers - see above)
						if (  t.clickeditemonworkspace >= 0 && t.clickeditemonworkspace <= ArrayCount(t.locallibraryent) ) 
						{
							t.inputsys.constructselection=t.locallibraryent[t.clickeditemonworkspace];
						}
						else
						{
							t.inputsys.constructselection=0;
						}
					}
					else
					{
						//  direct relationship between list index and choice
						t.inputsys.constructselection=t.clickeditemonworkspace;
					}
				}
			}

			//  Workspace index determines editing mode
			if (  t.clickedonworkspace  == 0 ) { t.inputsys.domodeentity = 1 ; t.grideditselect  =  5; }
			if (  t.clickedonworkspace  == 1 ) { t.inputsys.domodeentity = 1 ; t.grideditselect  =  5; }
			editor_refresheditmarkers ( );
		}
	}
	#endif

	// Ensure status bar is constantly updated
	#ifdef FPSEXCHANGE
	++t.interfacestatusbarupdate;
	if ( t.interfacestatusbarupdate>30 ) 
	{
		// cursor position
		if ( g.gridlayershowsingle == 1 ) 
		{
			t.t_s = "" ; t.t_s=t.t_s +"CLIP="+Str(int(t.clipheight_f));
		}
		else
		{
			t.t_s="CLIP OFF";//"ALL" ; t.t_s=t.strarr_s[80]+":"+t.t_s;
		}
		SetFileMapString (  1, 4256, t.t_s.Get() );
		 t.strwork = "" ; t.strwork = t.strwork + "X:"+Str(t.inputsys.mmx)+"  "+"Z:"+Str(t.inputsys.mmy);
		SetFileMapString (  1, 4512, t.strwork.Get() );
		if (  t.gridentitygridlock == 0  )  t.tpre_s = "NORMAL";
		if (  t.gridentitygridlock == 1  )  t.tpre_s = "SNAP";
		if (  t.gridentitygridlock == 2  )  t.tpre_s = "GRID";
		SetFileMapString (  1, 4768, t.tpre_s.Get() );
		SetEventAndWait (  1 );
		//  editing mode
		if (  t.grideditselect == 0 ) 
		{
			t.statusbar_s=t.strarr_s[332];
			terrain_getpaintmode ( );
			t.statusbar_s=t.statusbar_s+" "+t.mode_s;
		}
		if (  t.grideditselect  ==  1  )  t.statusbar_s = t.strarr_s[336];
		if (  t.grideditselect == 2 ) 
		{
			//  art tools not used any more
		}
		if (  t.grideditselect == 3 ) 
		{
			//  map view mode not used any more
		}
		if (  t.grideditselect == 4 )  t.statusbar_s = t.strarr_s[343];
		if (  t.grideditselect == 5 ) 
		{
			t.statusbar_s=t.strarr_s[344];
			t.statusbar_s=t.statusbar_s+"  Entity : "+t.relaytostatusbar_s;
		}
		if (  t.grideditselect == 6 ) 
		{
			//  add waypoint status
			t.statusbar_s="Waypoint Mode (LMB=Drag Point  SHIFT+LMB=Clone Point  SHIFT+RMB=Remove Point)";
		}
		//  only update infrequently
		t.interfacestatusbarupdate=0;
	}
	#endif

	//  Update status bar out of action subroutines
	gridedit_updatestatusbar ( );

	// Action after filemap activity
	if ( t.trecentfilechoice>0 ) 
	{
		// save first
		gridedit_intercept_savefirst ( );
		if ( t.editorcanceltask == 0 ) 
		{
			// go ahead, load direct (skip the open dialog)
			g.projectfilename_s=t.trecentfilechoice_s;
			gridedit_load_map ( );
#ifdef WICKEDENGINE
			grass_init();
			bUpdateVeg = true;
#endif

		}
		t.trecentfilechoice=0;
	}
}

void editor_handlepguppgdn ( void )
{
	// changes and returns 't.tupdownstepvalue_f'
	bool bWidgetMove = false;
	if (t.inputsys.kscancode == 201 || t.inputsys.kscancode == 209)
	{
		float fEntityStepSize = 5.0f;
		if (t.gridentity > 0 && t.gridentityobj > 0)
		{
			if (ObjectExist(t.gridentityobj) == 1)
				fEntityStepSize = ObjectSizeY(t.gridentityobj, 1);
		}
		else
		{
			if (t.widget.pickedEntityIndex > 0)
			{
				int wobj = t.entityelement[t.widget.pickedEntityIndex].obj;
				if (t.widget.activeObject > 0)
					wobj = t.widget.activeObject;

				if (ObjectExist(wobj) == 1)
					fEntityStepSize = ObjectSizeY(wobj, 1);

				//Make sure to highlight all objects the object belong to.
				#ifdef WICKEDENGINE
				if (t.widget.pickedEntityIndex > 0)
					CheckGroupListForRubberbandSelections(t.widget.pickedEntityIndex);
				bWidgetMove = true;
				//				if (g.entityrubberbandlist.size() > 0) //Cancel it
				//					return;
				#endif
			}
		}
		if (t.gridentitygridlock >= 1)
			t.tupdownstepvalue_f = 0.0;
		else
			t.tupdownstepvalue_f = 1.0;
		if (t.gridentitygridlock > 0)
		{
			if (t.inputsys.keypressallowshift == 0 && (t.inputsys.kscancode == 201 || t.inputsys.kscancode == 209))
			{
				if (t.gridentitygridlock == 1)
					t.tupdownstepvalue_f = fEntityStepSize;
#ifdef WICKEDENGINE
				if (t.gridentitygridlock == 2)
					t.tupdownstepvalue_f = fEditorGridSizeY;
#else
				if (t.gridentitygridlock == 2)  t.tupdownstepvalue_f = 100.0;
#endif
				t.inputsys.keypressallowshift = 1;
			}
			else
			{
				t.tupdownstepvalue_f = 0;
			}
		}
		#ifdef WICKEDENGINE
		if (bWidgetMove)
		{
			if (t.tupdownstepvalue_f != 0.0f && t.widget.pickedEntityIndex > 0 && t.entityelement[t.widget.pickedEntityIndex].editorlock == 0)
			{
				bool bDisableRubberBandMoving = false;
				if (current_selected_group >= 0 && group_editing_on)
				{
					bDisableRubberBandMoving = true;
				}
				if (!bDisableRubberBandMoving)
				{
					if (t.inputsys.kscancode == 201)  t.entityelement[t.widget.pickedEntityIndex].y += t.tupdownstepvalue_f;
					if (t.inputsys.kscancode == 209)  t.entityelement[t.widget.pickedEntityIndex].y -= t.tupdownstepvalue_f;
					int wobj = t.entityelement[t.widget.pickedEntityIndex].obj;
					if (t.widget.activeObject > 0)
						wobj = t.widget.activeObject;

					PositionObject(wobj, t.entityelement[t.widget.pickedEntityIndex].x, t.entityelement[t.widget.pickedEntityIndex].y, t.entityelement[t.widget.pickedEntityIndex].z);
					//widget_movezonesandlights(t.widget.pickedEntityIndex);

					// if we need to also move rubber band highlighted objects, do so now
					if (g.entityrubberbandlist.size() > 0)
					{
						for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
						{
							int e = g.entityrubberbandlist[i].e;
							int tobj = t.entityelement[e].obj;
							if (e != t.widget.pickedEntityIndex && tobj > 0 && t.entityelement[e].editorlock == 0)
							{
								if (ObjectExist(tobj) == 1)
								{
									if (tobj != wobj)
									{
										if (t.inputsys.kscancode == 201)  t.entityelement[e].y += t.tupdownstepvalue_f;
										if (t.inputsys.kscancode == 209)  t.entityelement[e].y -= t.tupdownstepvalue_f;
										if (t.inputsys.kscancode == 201) g.entityrubberbandlist[i].x += t.tupdownstepvalue_f;
										if (t.inputsys.kscancode == 209) g.entityrubberbandlist[i].x -= t.tupdownstepvalue_f;

										PositionObject(tobj, t.entityelement[e].x, t.entityelement[e].y, t.entityelement[e].z);

										//widget_movezonesandlights(e);
									}
								}
							}
						}
					}
				}

				//for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
				//{
				//	if (t.inputsys.kscancode == 201) g.entityrubberbandlist[i].x += t.tupdownstepvalue_f;
				//	if (t.inputsys.kscancode == 209) g.entityrubberbandlist[i].x -= t.tupdownstepvalue_f;
				//}
			}
		}
		else
		{
		#else
			if (t.inputsys.kscancode == 201)  t.gridentityposy_f += t.tupdownstepvalue_f;
			if (t.inputsys.kscancode == 209)  t.gridentityposy_f -= t.tupdownstepvalue_f;
		#endif
		#ifdef WICKEDENGINE
		}
		#endif
	}
}

#ifdef ENABLEIMGUI
int last_xmousemove = 0, last_ymousemove = 0;
void imgui_input_getcontrols(void)
{
	//  Some actions are directly triggered by input subroutine
	t.inputsys.doload = 0;
	t.inputsys.domodeterrain = 0;
	t.inputsys.domodeentity = 0;
	t.inputsys.domodemarker = 0;
	t.inputsys.domodewaypoint = 0;
	t.inputsys.doundo = 0;
	t.inputsys.doredo = 0;
	t.inputsys.tselcontrol = 0;
	t.inputsys.tselcut = 0;
	t.inputsys.tselcopy = 0;
	t.inputsys.tseldelete = 0;

	ImGuiIO& io = ImGui::GetIO(); (void)io;
	#ifdef USERENDERTARGET
	//PE: Take everything from imgui.

	float itmpmousex = ImGui::GetMousePos().x;
	float itmpmousey = ImGui::GetMousePos().y;
	int iSecureZone = 4;
	RECT winpos = { 0,0,0,0 };

	if (pref.bDisableMultipleViewport) {
		//PE: Mouse coords is different when using non Multiple Viewport.
		//PE: TODO we need to match the Multiple Viewport mouse coord system here:
		//POINT p;
		//GetCursorPos(&p);
		//itmpmousex = p.x;
		//itmpmousey = p.y;
	}

	//PE: Must be relative to windows pos, or nothing work if you have a window placed at the rigth of the screen.
	GetWindowRect(g_pGlob->hWnd, &winpos);

	#ifdef WICKEDENGINE
	bool bCanGetInput = bImGuiRenderTargetFocus;
	if (pref.iEnableDragDropEntityMode && bDraggingActive)
	{
		bCanGetInput = true;
	}

	if (bCanGetInput && (itmpmousex + winpos.left) >= (renderTargetAreaPos.x+iSecureZone) && (itmpmousey+winpos.top) >= (renderTargetAreaPos.y + iSecureZone) &&
		(itmpmousex - winpos.left) <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && (itmpmousey-winpos.top) <= renderTargetAreaPos.y + 30 + (renderTargetAreaSize.y - iSecureZone ))
	#else
	if (bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x+iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
		itmpmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmpmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone ))
	#endif
	{
		#ifdef WICKEDENGINE
		//PE: @Lee This system dont work, try making the window smaller and moving it to the right, then display welcome screen.
		//PE: @Lee i think we need to use the system from V3 that adjust the mouse coords to the window pos/size. and somehow match it to the new 1:1 backdrop.

		// commented this out as I want coordinates to be for the WHOLE SCREEN, not the renderable view
		// as I have allowed wicked to render to the whole surface in the backdrop with UI overlayed
		// and a single universal understanding of this helps with coordinates, rubber banding, 3D to 2D, etc
		#else
		// Figure out mouse scale values.
		itmpmousex -= renderTargetAreaPos.x;
		itmpmousey -= renderTargetAreaPos.y;
		float RatioX = ((float) GetDisplayWidth() / (float) renderTargetAreaSize.x) * ((float)GetDisplayWidth() / (float)GetChildWindowWidth(-1) );
		float RatioY = ((float) GetDisplayHeight() / (float) renderTargetAreaSize.y) * ((float)GetDisplayHeight() / (float)GetChildWindowHeight(-1) );
		itmpmousex *= RatioX;
		itmpmousey *= RatioY;
		#endif 

		t.inputsys.activemouse = 1;
		t.inputsys.xmouse = (int)itmpmousex;
		t.inputsys.ymouse = (int)itmpmousey;
		t.inputsys.zmouse = io.MouseWheel; // MouseZ();
		t.inputsys.xmousemove = t.inputsys.xmouse - xmouseold;
		t.inputsys.ymousemove = t.inputsys.ymouse - ymouseold;

		last_xmousemove = t.inputsys.xmousemove;
		last_ymousemove = t.inputsys.ymousemove;

		xmouseold = t.inputsys.xmouse;
		ymouseold = t.inputsys.ymouse;

		t.inputsys.wheelmousemove = io.MouseWheel; //MouseMoveZ();
		#ifdef WICKEDENGINE
		if (ImGui::IsMouseDown(2)) t.inputsys.wheelmousemove = 0;
		#endif
		set_inputsys_mclick(io.MouseDown[0] + (io.MouseDown[1] * 2.0) + (io.MouseDown[2] * 3.0) + (io.MouseDown[3] * 4.0));// t.inputsys.mclick = io.MouseDown[0] + (io.MouseDown[1] * 2.0) + (io.MouseDown[2] * 3.0) + (io.MouseDown[3] * 4.0); //  MouseClick();
		t.inputsys.k_s = Lower(Inkey());

		//  Control keys direct from keyboard
		t.inputsys.keyreturn = io.KeysDown[13]; // ReturnKey();
		t.inputsys.keyshift = io.KeyShift;
		t.inputsys.keytab = io.KeysDown[0x09]; //TAB!
		t.inputsys.keyleft = io.KeysDown[37]; // LeftKey();
		t.inputsys.keyright = io.KeysDown[39]; //RightKey();
		t.inputsys.keyup = io.KeysDown[38]; //UpKey();
		t.inputsys.keydown = io.KeysDown[40]; // DownKey();
		t.inputsys.keycontrol = io.KeyCtrl; //ControlKey();
		t.inputsys.keyspace = io.KeysDown[32]; //SpaceKey();

		//PE: We need raw scancodes. just take it from imgui.
		t.inputsys.kscancode = 0;
		for (int iTemp = 0; iTemp < 256; iTemp++)
		{
			if (iTemp != 16 && iTemp != 17 && iTemp != 18) 
			{ 
				//shift,control (added 18, not sure what it is)
				if (io.KeysDown[iTemp] > 0)
				{
					t.inputsys.kscancode = iTemp;
					break;
				}
			}
		}

	}
	else 
	{
		//No input to DX11.
		t.inputsys.activemouse = 1;
		t.inputsys.zmouse = 0;

		#ifdef WICKEDENGINE
		float fMouseDeltaX, fMouseDeltaZ;
		WickedCall_GetMouseDeltas ( &fMouseDeltaX, &fMouseDeltaZ);
		t.inputsys.xmousemove = fMouseDeltaX;
		t.inputsys.ymousemove = fMouseDeltaZ;
		#else
		t.inputsys.xmousemove = 0;
		t.inputsys.ymousemove = 0;
		#endif

		xmouseold = t.inputsys.xmouse;
		ymouseold = t.inputsys.ymouse;

		t.inputsys.wheelmousemove = 0;

		set_inputsys_mclick(0);// t.inputsys.mclick = 0;

		t.inputsys.k_s = "";
		//t.inputsys.kscancode = ScanCode();

		//  Control keys direct from keyboard
		t.inputsys.keyreturn = 0;
		t.inputsys.keyshift = 0;
		t.inputsys.keytab = 0;
		t.inputsys.keyleft = 0;
		t.inputsys.keyright = 0;
		t.inputsys.keyup = 0;
		t.inputsys.keydown = 0;
		t.inputsys.keycontrol = 0;
		t.inputsys.keyspace = 0;
		t.inputsys.kscancode = 0;
	}

	int mcursor = ImGui::GetMouseCursor();

	if (bBuilder_Properties_Window) 
	{
		//Disable some keys.
	}

	if (g_bCharacterCreatorPlusActivated) 
	{
		//Disable some keys.
		if( t.inputsys.kscancode == Asc("t") || t.inputsys.kscancode == Asc("T") )
			t.inputsys.kscancode = 0;
		if( t.inputsys.k_s == "t" || t.inputsys.k_s == "T" ) 
			t.inputsys.k_s = "";
		if (t.inputsys.kscancode == Asc("p") || t.inputsys.kscancode == Asc("P"))
			t.inputsys.kscancode = 0;
		if (t.inputsys.k_s == "p" || t.inputsys.k_s == "P")
			t.inputsys.k_s = "";

	}
	if (bEntity_Properties_Window) 
	{
		//Disable all key input when in Properties.
		t.inputsys.keyleft = 0;
		t.inputsys.keyright = 0;
		t.inputsys.keyup = 0;
		t.inputsys.keydown = 0;
		t.inputsys.kscancode = 0;
		t.inputsys.k_s = "";
		t.inputsys.keyshift = 0;
		t.inputsys.keytab = 0;
	}

	if (ImGui::IsAnyItemActive() && t.inputsys.mclick != 1 ) 
	{
		//A widget got focus, like textinput , disable all keys.
		t.inputsys.keyleft = 0;
		t.inputsys.keyright = 0;
		t.inputsys.keyup = 0;
		t.inputsys.keydown = 0;
		t.inputsys.kscancode = 0;
		t.inputsys.k_s = "";
		t.inputsys.keyshift = 0;
		t.inputsys.keytab = 0;
	}

	// 060320 - somehow, some laptops set 'bImGuiGotFocus' to true (or mcursor>0), 
	// wiping out click detection in Welcome screen, so added condition to prevent this erasure!
	if ( bImGuiGotFocus || ( mcursor > 0 && mcursor != ImGuiMouseCursor_Hand) )
	{
		//No GG input when using imgui.
		t.inputsys.xmouse = 500000;
		t.inputsys.ymouse = 0;
		t.inputsys.xmousemove = 0;
		t.inputsys.ymousemove = 0;
		set_inputsys_mclick(0);// t.inputsys.mclick = 0;
		t.inputsys.zmouse = 0;
		t.inputsys.wheelmousemove = 0;
		t.inputsys.activemouse = 0;
		t.syncthreetimes = 1;
		t.inputsys.k_s = "";
		//  Control keys direct from keyboard
		t.inputsys.keyreturn = 0;
		t.inputsys.keyshift = 0;
		t.inputsys.keytab = 0;
		t.inputsys.keyleft = 0;
		t.inputsys.keyright = 0;
		t.inputsys.keyup = 0;
		t.inputsys.keydown = 0;
		t.inputsys.keycontrol = 0;
		t.inputsys.keyspace = 0;
		t.inputsys.kscancode = 0;

	}
	#else
	input_getdirectcontrols();
	#endif

	input_extramappings();

	//  Flag reset
	t.inputsys.dorotation = 0;
	t.inputsys.domirror = 0;
	t.inputsys.doflip = 0;
	t.inputsys.doentityrotate = 0;
	t.inputsys.dozoomin = 0;
	t.inputsys.dozoomout = 0;
	t.inputsys.doscrollleft = 0;
	t.inputsys.doscrollright = 0;
	t.inputsys.doscrollup = 0;
	t.inputsys.doscrolldown = 0;
	t.inputsys.domapresize = 0;
	t.inputsys.dogroundmode = -1;
	t.inputsys.dozoomview = 0;
	t.inputsys.dozoomviewmovex = 0;
	t.inputsys.dozoomviewmovey = 0;
	t.inputsys.dozoomviewmovez = 0;
	t.inputsys.dozoomviewrotatex = 0;
	t.inputsys.dozoomviewrotatey = 0;
	t.inputsys.dozoomviewrotatez = 0;
	t.inputsys.dosinglelayer = 0;
	t.inputsys.tselfloor = 0;
	t.inputsys.tselpaste = 0;
	t.inputsys.tselwipe = 0;
	t.inputsys.dosaveandrun = 0;

	//PE: Map additional keys.
	if (t.inputsys.kscancode == 32)  t.inputsys.keyspace = 1; else t.inputsys.keyspace = 0;
	if (t.inputsys.kscancode == 0 && t.inputsys.keyshift == 0) t.inputsys.keypressallowshift = 0;

	//  W,A,S,D in editor for scrolling about (easier for user)
	if (t.inputsys.kscancode == 87)
		t.inputsys.keyup = 1;
	if (t.inputsys.kscancode == 65)  t.inputsys.keyleft = 1;
	if (t.inputsys.kscancode == 83)  t.inputsys.keydown = 1;
	if (t.inputsys.kscancode == 68)  t.inputsys.keyright = 1;

	if (t.inputsys.keycontrol == 1)
	{
		#ifndef WICKEDENGINE
		if (t.inputsys.k_s == "")  t.inputsys.undokeypress = 0;
		#endif
		if (t.inputsys.k_s == "z" && t.inputsys.undokeypress == 0) 
		{
			bForceUndo = true;
			//t.inputsys.doundo = 1; 
			//t.inputsys.undokeypress = 1;
		}
		else if (t.inputsys.k_s == "y" && t.inputsys.undokeypress == 0) 
		{
			t.inputsys.doredo = 1; 
			t.inputsys.undokeypress = 1;
		}
	}

	//  Convert to DX INPUT CODES
//###
	t.t_s = ""; t.tt = 0;
	switch (t.inputsys.kscancode)
	{
	case 9: t.tt = 15; break;
	case 32: t.tt = 57; break;
	case 33: t.tt = 201; break;
	case 34: t.tt = 209; break;
	case 37: t.tt = 203; break;
	case 38: t.tt = 200; break;
	case 39: t.tt = 205; break;
	case 40: t.tt = 208; break;
	case 42: t.tt = 16; break;
	case 46: t.tt = 211; break;
	case 54: t.tt = 16; break;
	case 112: t.tt = 59; break;
	case 113: t.tt = 60; break;
	case 114: t.tt = 61; break;
	case 115: t.tt = 62; break;
	case 123: t.tt = 88; break;
	case 187: t.tt = 13; break;
	case 188: t.tt = 51; break;
	case 189: t.tt = 12; break;
	case 190: t.tt = 52; break;
	case 192: t.tt = 40; break;
	case 219: t.tt = 26; break;
	case 220: t.tt = 86; break;
	case 221: t.tt = 27; break;
	case 222: t.tt = 43; break;
	case 1001: t.tt = 13; break;
	case 1002: t.tt = 12; break;
	}
	// 031215 - then remap to new scancodes (from keymap)
	t.tt = g.keymap[t.tt];
	// and temp back into IDE key values (for last bit)
	int ttt = 0;
	switch (t.tt)
	{
	case 15: ttt = 9; break;
	case 57: ttt = 32; break;
	case 201: ttt = 33; break;
	case 209: ttt = 34; break;
	case 203: ttt = 37; break;
	case 200: ttt = 38; break;
	case 205: ttt = 39; break;
	case 208: ttt = 40; break;
	case 16: ttt = 42; break;
	case 211: ttt = 46; break;
	case 59: ttt = 112; break;
	case 60: ttt = 113; break;
	case 61: ttt = 114; break;
	case 62: ttt = 115; break;
	case 88: ttt = 123; break;
	case 13: ttt = 187; break;
	case 51: ttt = 188; break;
	case 12: ttt = 189; break;
	case 52: ttt = 190; break;
	case 40: ttt = 192; break;
	case 26: ttt = 219; break;
	case 86: ttt = 220; break;
	case 27: ttt = 221; break;
	case 43: ttt = 222; break;
	}
	// then create proper inkey chars from revised (if any) scancodes
	switch (ttt)
	{
	case 16: t.t_s = "q"; break;
	case 57: t.t_s = " "; break;
	case 107: t.t_s = "="; break;
	case 109: t.t_s = "-"; break;
	case 187: t.t_s = "="; break;
	case 188: t.t_s = ","; break;
	case 189: t.t_s = "-"; break;
	case 190: t.t_s = "."; break;
	case 192: t.t_s = "'"; break;
	case 219: t.t_s = "["; break;
	case 220: t.t_s = "\\"; break;
	case 221: t.t_s = "]"; break;
	case 222: t.t_s = "#"; break;
	}

	if (t.inputsys.kscancode >= Asc("A") && t.inputsys.kscancode <= Asc("Z"))  t.t_s = Lower(Chr(t.inputsys.kscancode));
	if (t.inputsys.kscancode >= Asc("0") && t.inputsys.kscancode <= Asc("9"))  t.t_s = Lower(Chr(t.inputsys.kscancode));
	if (t.t_s != "")  t.tt = 1;

	t.inputsys.k_s = t.t_s; t.inputsys.kscancode = t.tt;
//####

//  Input conditional flags
	if (t.inputsys.kscancode == 0) {
		t.inputsys.keypress = 0;
		if (iForceScancode > 0) {
			if (iForceScancode == 13)
				t.inputsys.keyreturn = 1;
			t.inputsys.kscancode = iForceScancode;
			iForceScancode = -1;
		}
		else if (bForceKey) {
			bForceKey = false;
			t.inputsys.k_s = csForceKey;
			t.inputsys.keycontrol = 0;
			t.inputsys.keyshift = 0;
			t.inputsys.keytab = 0;
			t.inputsys.kscancode = Asc(csForceKey.Get());
		}
		else if (bForceKey2) {
			bForceKey2 = false;
			t.inputsys.k_s = csForceKey2;
			t.inputsys.keycontrol = 0;
			t.inputsys.keyshift = 0;
			t.inputsys.keytab = 0;
			t.inputsys.kscancode = Asc(csForceKey2.Get());
		}

	}
	if (bForceUndo) 
	{
		t.inputsys.doundo = 1;
		t.inputsys.undokeypress = 1;
		bForceUndo = false;
	}
	if (bForceRedo) 
	{
		t.inputsys.doredo = 1;
		t.inputsys.undokeypress = 1;
		bForceRedo = false;
	}

	#ifdef PRODUCTV3
	// When old in welcome system, do not allow regular edit keys to work!
	if (iTriggerWelcomeSystemStuff != 0)
		return;
	#endif

	//  Construction Keys
	if (t.inputsys.keycontrol == 0)
	{
		// can get marker mode from anywhere
		if ((t.inputsys.kscancode == Asc("M") || t.inputsys.k_s == "m") && t.inputsys.keypress == 0)
		{
			t.inputsys.domodemarker = 1;
			t.inputsys.keypress = 1;
		}

		if ((t.grideditselect == 4 && t.gridentityinzoomview>0) || t.grideditselect == 5)
		{
			#ifdef WICKEDENGINE
			if (t.inputsys.k_s == "g" && t.inputsys.keypress == 0)
			#else
			if (t.inputsys.k_s == "b" && t.inputsys.keypress == 0)
			#endif
			{
				t.inputsys.keypress = 1; 
				t.gridentitygridlock = t.gridentitygridlock + 1;
				if (t.gridentitygridlock>2)  
					t.gridentitygridlock = 0;
			}
			if (t.inputsys.k_s == "y" && t.inputsys.keypress == 0 && g.gentitytogglingoff == 0)
			{
				// only if not EBE
				if (t.entityprofile[t.gridentity].isebe == 0)
				{
					//PE: This dont work, t.gridentity = 0 ?
					t.ttrygridentitystaticmode = 1 - t.gridentitystaticmode;
					t.ttrygridentity = t.gridentity; editor_validatestaticmode();
				}
				t.inputsys.keypress = 1;
			}
			if (t.inputsys.k_s == "u" && t.inputsys.keypress == 0)
			{
				//  control auto-flatten
				t.inputsys.keypress = 1;
				t.gridedit.autoflatten = 1 - t.gridedit.autoflatten;
			}
			if (t.inputsys.k_s == "i" && t.inputsys.keypress == 0)
			{
				//  control entity spray mode
				t.inputsys.keypress = 1;
				t.gridedit.entityspraymode = 1 - t.gridedit.entityspraymode;
			}
			// except when in EBE mode which handles - and + keys for material changing
			if (t.ebe.on == 0)
			{
				if (t.inputsys.k_s == "-" && t.inputsys.keypress == 0) { t.gridentitymodifyelement = 1; t.inputsys.keypress = 1; }
				if (t.inputsys.k_s == "=" && t.inputsys.keypress == 0) { t.gridentitymodifyelement = 2; t.inputsys.keypress = 1; }
			}
		}

		//  editing mode
		if (t.inputsys.k_s == "t")
		{
			#ifdef WICKEDENGINE
			if (!pref.iEnableSingleRightPanelAdvanced)
			{
				Weather_Tools_Window = false;
				Visuals_Tools_Window = false;
				//LB: shooter now a filter mode Shooter_Tools_Window = false;
				Entity_Tools_Window = false;
				bWaypoint_Window = false;
				iRestoreLastWindow = 0;
			}
			bTerrain_Tools_Window = true;
			#endif
			t.inputsys.domodeterrain = 1; t.inputsys.dowaypointview = 0;
			bTerrain_Tools_Window = true;
			#ifdef WICKEDENGINE
			t.terrain.terrainpaintermode = 1;
			#endif
		}
		if (t.inputsys.k_s == "v")
		{
			/*
			#ifdef WICKEDENGINE
			if (!pref.iEnableSingleRightPanelAdvanced)
			{
				Weather_Tools_Window = false;
				Visuals_Tools_Window = false;
				//LB: shooter now a filter mode Shooter_Tools_Window = false;
				Entity_Tools_Window = false;
				bWaypoint_Window = false;
				iRestoreLastWindow = 0;
			}
			bTerrain_Tools_Window = true;
			t.inputsys.domodeterrain = 1; t.inputsys.dowaypointview = 0;
			t.terrain.terrainpaintermode = 10;
			#endif
			*/
		}
			#ifdef WICKEDENGINE
			if (t.inputsys.k_s == "o")
			#else
			if (t.inputsys.k_s == "e" || t.inputsys.k_s == "o")
			#endif
			{
			#ifdef WICKEDENGINE
			if (!pref.iEnableSingleRightPanelAdvanced)
			{
				Weather_Tools_Window = false;
				Visuals_Tools_Window = false;
				//LB: shooter now a filter mode Shooter_Tools_Window = false;
				bTerrain_Tools_Window = false;
				bWaypoint_Window = false;
				iRestoreLastWindow = 0;
			}
			Entity_Tools_Window = true;
			#endif
			t.inputsys.domodeentity = 1; t.inputsys.dowaypointview = 0;
		}
		#ifdef WICKEDENGINE
		// no waypoint painting in MAX
		#else
		if (t.inputsys.k_s == "p")
		{
			#ifdef WICKEDENGINE
			if (!pref.iEnableSingleRightPanelAdvanced)
			{
				Weather_Tools_Window = false;
				Visuals_Tools_Window = false;
				//LB: shooter now a filter mode Shooter_Tools_Window = false;
				bTerrain_Tools_Window = false;
				Entity_Tools_Window = false;
				iRestoreLastWindow = 0;
			}
			#endif
			bWaypoint_Window = true;
			t.inputsys.domodewaypoint = 1;
			t.inputsys.dowaypointview = 0;
		}
		#endif
		if (t.inputsys.keyspace == 1 && t.inputsys.keypress == 0) { t.inputsys.dowaypointview = 1 - t.inputsys.dowaypointview; t.inputsys.keypress = 1; t.lastgrideditselect = -1; editor_refresheditmarkers(); }

		//  NUM-ROTATE CONTROLS
		if (t.inputsys.k_s == "r" && t.inputsys.keypress == 0 && t.ebe.on == 0 )
		{
			t.inputsys.dorotation = 1; t.inputsys.keypress = 1;
		}
		if (t.grideditselect != 4 && t.grideditselect != 0)
		{
			#ifdef WICKEDENGINE
			if (pref.iEnableAxisRotationShortcuts == 1)
			#endif
			{
				if (t.inputsys.k_s == "1" && t.inputsys.keypress == 0) { t.inputsys.doentityrotate = 1; t.inputsys.keypress = 1; }
				if (t.inputsys.k_s == "2" && t.inputsys.keypress == 0) { t.inputsys.doentityrotate = 2; t.inputsys.keypress = 1; }
				if (t.inputsys.k_s == "3" && t.inputsys.keypress == 0) { t.inputsys.doentityrotate = 3; t.inputsys.keypress = 1; }
				if (t.inputsys.k_s == "4" && t.inputsys.keypress == 0) { t.inputsys.doentityrotate = 4; t.inputsys.keypress = 1; }
				if (t.inputsys.k_s == "5" && t.inputsys.keypress == 0) { t.inputsys.doentityrotate = 5; t.inputsys.keypress = 1; }
				if (t.inputsys.k_s == "6" && t.inputsys.keypress == 0) { t.inputsys.doentityrotate = 6; t.inputsys.keypress = 1; }
				if (t.inputsys.keyshift == 0)
				{
					if (t.inputsys.k_s == "0" && t.inputsys.keypress == 0) { t.inputsys.doentityrotate = 98; t.inputsys.keypress = 1; }
				}
				else
				{
					if (t.inputsys.k_s == "0" && t.inputsys.keypress == 0) { t.inputsys.doentityrotate = 99; t.inputsys.keypress = 1; }
				}
			}
		}

		//  Editing of Map
		if (t.inputsys.k_s == ",")  t.inputsys.dozoomin = 1;
		if (t.inputsys.k_s == ".")  t.inputsys.dozoomout = 1;

		//  TAB Key causes layer edit view control
		if (t.inputsys.kscancode == 15 && t.inputsys.keypress == 0) { t.inputsys.dosinglelayer = 1; t.inputsys.keypress = 1; }

		#ifdef WICKEDENGINE
		static bool bF1Released = false;
		if (t.inputsys.kscancode != 59)
			bF1Released = true;

		// F1 to toggle widget mode or smart positioning mode.
		if (t.inputsys.kscancode == 59 && bF1Released)
		{
			bF1Released = false;
			pref.iEnableDragDropWidgetSelect = !pref.iEnableDragDropWidgetSelect;
			if (pref.iEnableDragDropWidgetSelect)
				widget_show_widget();
			else
				widget_hide();
		}
		#else
		//  F1 for help page
		if (t.inputsys.kscancode == 59) editor_showhelppage(0);
		#endif

		// F2-F4 in editor to control widget mode or smart positioning mode.
		if (t.inputsys.kscancode >= 60 && t.inputsys.kscancode <= 62)
		{
			t.toldmode = t.widget.mode;
			#ifdef WICKEDENGINE
			bool bWidgetEnabled = pref.iEnableDragDropWidgetSelect;
			if (t.inputsys.kscancode == 60) 
			{
				if (bWidgetEnabled)
					t.widget.mode = 0;
				else
					iObjectMoveMode = 2;

			}
			if (t.inputsys.kscancode == 61) 
			{
				if (bWidgetEnabled)
					t.widget.mode = 1;
				else
					iObjectMoveMode = 0;
			}
			if (t.inputsys.kscancode == 62) 
			{
				if (bWidgetEnabled)
				{
					// Don't allow characters and markers to be scaled with the widget
					if (t.entityprofile[t.widget.pickedEntityIndex].ischaracter == 0 && t.entityprofile[t.widget.pickedEntityIndex].ismarker == 0)
					{
						t.widget.mode = 2;
					}
				}
				else
				{
					iObjectMoveMode = 1;
				}
			}
			#else
			if (t.inputsys.kscancode == 60) t.widget.mode = 0;
			if (t.inputsys.kscancode == 61) t.widget.mode = 1;
			if (t.inputsys.kscancode == 62) t.widget.mode = 2;
			#endif
			
			if ( t.toldmode != t.widget.mode ) widget_show_widget ( );
		}
	}
	else
	{
		if (t.inputsys.k_s == "r" && t.ebe.on == 0)  t.inputsys.dorotation = 1;
	}

	//  Key Map Scroll and Resize
	if (t.inputsys.keyshift == 0)
	{
		if (t.inputsys.keyleft == 1)  t.inputsys.doscrollleft = 3;
		if (t.inputsys.keyright == 1)  t.inputsys.doscrollright = 3;
		if (t.inputsys.keyup == 1) 
			t.inputsys.doscrollup = 3;
		if (t.inputsys.keydown == 1)  t.inputsys.doscrolldown = 3;
	}
	else
	{
		if (t.inputsys.keyleft == 1)  t.inputsys.doscrollleft = 20;
		if (t.inputsys.keyright == 1)  t.inputsys.doscrollright = 20;
		if (t.inputsys.keyup == 1)
			t.inputsys.doscrollup = 20;
		if (t.inputsys.keydown == 1)  t.inputsys.doscrolldown = 20;
	}

	//  Mouse Wheel control (170616 - but not when in EBE mode as its used for grid layer control)
	if (t.ebe.on == 0)
	{
		if (t.grideditselect == 4)
		{
			//  Zoomed in View
			t.zoomviewcamerarange_f -= (t.inputsys.wheelmousemove / 10.0);
		}
		else
		{
			//  Non-Zoomed in View
			if (t.inputsys.keycontrol == 0)
			{
				if (t.inputsys.wheelmousemove<0)
					t.inputsys.dozoomout = 1;
				if (t.inputsys.wheelmousemove>0)
					t.inputsys.dozoomin = 1;
			}
		}
	}

	//  UndoRedo Keys
	if (t.inputsys.keycontrol == 1)
	{
		#ifndef WICKEDENGINE
		if (t.inputsys.k_s == "")  t.inputsys.undokeypress = 0;
		#endif
		if (t.inputsys.k_s == "z" && t.inputsys.undokeypress == 0) 
		{ 
			t.inputsys.doundo = 1; t.inputsys.undokeypress = 1; 
		}
		if (t.inputsys.k_s == "y" && t.inputsys.undokeypress == 0) { t.inputsys.doredo = 1; t.inputsys.undokeypress = 1; }
	}

	//  Controls only when in zoomview
	if (t.grideditselect == 4)
	{
		//  orient arrowkey movement to camera angle
		t.tca_f = WrapValue(CameraAngleY());
		if (t.tca_f >= 360 - 45 || t.tca_f <= 45)
		{
			t.txa = 1; t.txb = 2; t.txc = 0; t.txd = 0;
			t.tza = 0; t.tzb = 0; t.tzc = 2; t.tzd = 1;
		}
		else
		{
			if (t.tca_f >= 180 - 45 && t.tca_f <= 180 + 45)
			{
				t.txa = 2; t.txb = 1; t.txc = 0; t.txd = 0;
				t.tza = 0; t.tzb = 0; t.tzc = 1; t.tzd = 2;
			}
			else
			{
				if (t.tca_f <= 180)
				{
					t.txa = 0; t.txb = 0; t.txc = 2; t.txd = 1;
					t.tza = 2; t.tzb = 1; t.tzc = 0; t.tzd = 0;
				}
				else
				{
					t.txa = 0; t.txb = 0; t.txc = 1; t.txd = 2;
					t.tza = 1; t.tzb = 2; t.tzc = 0; t.tzd = 0;
				}
			}
		}
		t.inputsys.dozoomviewmovex = 0; t.inputsys.dozoomviewmovez = 0;
		if (t.inputsys.keyleft == 1) { t.inputsys.dozoomviewmovex += t.txa; t.inputsys.dozoomviewmovez += t.tza; }
		if (t.inputsys.keyright == 1) { t.inputsys.dozoomviewmovex += t.txb; t.inputsys.dozoomviewmovez += t.tzb; }
		if (t.inputsys.keyup == 1)
		{
			t.inputsys.dozoomviewmovex += t.txc;
			t.inputsys.dozoomviewmovez += t.tzc;
		}
		if (t.inputsys.keydown == 1) { t.inputsys.dozoomviewmovex += t.txd; t.inputsys.dozoomviewmovez += t.tzd; }
		//  control rotation
		if (t.inputsys.k_s == "1" && t.inputsys.keypress == 0) { t.inputsys.dozoomviewrotatex = 1; t.inputsys.keypress = 1; }
		if (t.inputsys.k_s == "2" && t.inputsys.keypress == 0) { t.inputsys.dozoomviewrotatex = 2; t.inputsys.keypress = 1; }
		if (t.inputsys.k_s == "3" && t.inputsys.keypress == 0) { t.inputsys.dozoomviewrotatey = 1; t.inputsys.keypress = 1; }
		if (t.inputsys.k_s == "4" && t.inputsys.keypress == 0) { t.inputsys.dozoomviewrotatey = 2; t.inputsys.keypress = 1; }
		if (t.inputsys.k_s == "5" && t.inputsys.keypress == 0) { t.inputsys.dozoomviewrotatez = 1; t.inputsys.keypress = 1; }
		if (t.inputsys.k_s == "6" && t.inputsys.keypress == 0) { t.inputsys.dozoomviewrotatez = 2; t.inputsys.keypress = 1; }
		if (t.inputsys.keyshift == 0)
		{
			if (t.inputsys.k_s == "0" && t.inputsys.keypress == 0) { t.inputsys.dozoomviewrotatex = 98; t.inputsys.keypress = 1; }
		}
		else
		{
			if (t.inputsys.k_s == "0" && t.inputsys.keypress == 0) { t.inputsys.dozoomviewrotatex = 99; t.inputsys.keypress = 1; }
		}
	}
	if (t.grideditselect == 4 || t.grideditselect == 5)
	{
		//  control finder (toggled using gridentityautofind value)
		#ifdef WICKEDENGINE
		// Simpler RETURN system
		t.gridentitydroptoground = 0;
		if (t.inputsys.keyreturn == 1)
		{
			t.gridentityautofind = 0;
			t.gridentityusingsoftauto = 0;
			t.gridentitysurfacesnap = 0;
			if (iObjectMoveModeDropSystemUsing == 1 && g_bHoldGridEntityPosWhenManaged == false)
			{
				if (t.gridentity > 0)
				{
					t.gridentitydroptoground = 1 + t.entityprofile[t.gridentity].forwardfacing;
				}
			}
		}
		#else
		if (t.inputsys.keyreturn == 1)
		{
			if (t.gridentityautofind == 0) { t.gridentityautofind = 3; }
			if (t.gridentityautofind == 1) { t.gridentityautofind = 2; }
		}
		else
		{
			if (t.gridentityautofind == 3) { t.gridentityautofind = 1; t.gridentityusingsoftauto = 0; t.gridentitysurfacesnap = 0; }
			if (t.gridentityautofind == 2) { t.gridentityautofind = 0; t.gridentityposoffground = 0; t.gridentityusingsoftauto = 1; t.gridentitysurfacesnap = 0; }
		}
		if (t.gridentityautofind == 1 && t.gridentity>0)
		{
			t.gridentitydroptoground = 1 + t.entityprofile[t.gridentity].forwardfacing;
		}
		else
		{
			t.gridentitydroptoground = 0;
		}
		#endif
		//  control height
		if (t.grideditselect == 4)
		{
			//  move entity through zoomview system
			if (t.inputsys.kscancode == 201) { t.inputsys.dozoomviewmovey = 2; t.gridentityposoffground = 1; t.gridentityautofind = 0; t.gridentityusingsoftauto = 0; }
			if (t.inputsys.kscancode == 209) { t.inputsys.dozoomviewmovey = 1; t.gridentityposoffground = 1; t.gridentityautofind = 0; t.gridentityusingsoftauto = 0; }
		}
		else
		{
			//  directly move entity (and detatch from terrain) PGUP and PGDN
			if (t.inputsys.kscancode == 201 || t.inputsys.kscancode == 209)
			{
				#ifndef WICKEDENGINE
				if (t.widget.activeObject == 0)
				{
				#endif
					editor_handlepguppgdn();
					t.gridentityposoffground = 1; t.gridentityautofind = 0; t.gridentityusingsoftauto = 0; t.gridentitysurfacesnap = 0;
				#ifndef WICKEDENGINE
				}
				#endif
			}
		}
	}

	//  Create a waypoint when instructed to
	if (t.inputsys.domodewaypointcreate == 1 && t.inputsys.keypress == 0)
	{
		//In freeflight mode t.cx_f,t.cy_f is NOT the same as CameraPositionX() , CameraPositionZ().
		//Search for "Debug c_xy" and enable those lines to see the difference.

		//Changed to this:

		float placeatx_f, placeatz_f;
		placeatx_f = CameraPositionX();
		placeatz_f = CameraPositionZ();

		t.inputsys.domodewaypointcreate = 0;
		t.inputsys.keypress = 1; t.inputsys.domodewaypoint = 1; t.grideditselect = 6;
		if (t.terrain.TerrainID>0)
		{
			g.waypointeditheight_f = BT_GetGroundHeight(t.terrain.TerrainID, placeatx_f, placeatz_f); //
		}
		else
		{
			g.waypointeditheight_f = g.gdefaultterrainheight;
		}
		t.waypointeditstyle = 1; t.waypointeditstylecolor = 0; t.waypointeditentity = 0;
		//t.mx_f = t.cx_f; t.mz_f = t.cy_f;
		t.mx_f = placeatx_f;
		t.mz_f = placeatz_f;
		waypoint_createnew();

		PointCamera(t.mx_f, g.waypointeditheight_f, t.mz_f);
		t.editorfreeflight.c.angx_f = CameraAngleX();
		t.editorfreeflight.c.angy_f = CameraAngleY();
	}


	
	//  fake mousemove values for low-response systems (when in zoomed in mode)
	if (t.grideditselect == 4)
	{
		if (t.inputsys.keyshift == 1)
		{
			if (t.inputsys.keyleft == 1)  t.inputsys.xmousemove = -10;
			if (t.inputsys.keyright == 1)  t.inputsys.xmousemove = 10;
			if (t.inputsys.keyup == 1)
				t.inputsys.ymousemove = -10;
			if (t.inputsys.keydown == 1)  t.inputsys.ymousemove = 10;
			set_inputsys_mclick(2);// t.inputsys.mclick = 2;
			t.inputsys.keyleft = 0;
			t.inputsys.keyright = 0;
			t.inputsys.keyup = 0;
			t.inputsys.keydown = 0;
		}
	}


	//Update statusbar
	//Update statusbar
	++t.interfacestatusbarupdate;
	if (t.interfacestatusbarupdate > 30)
	{
		#ifdef WICKEDENGINE
		//PE: No clipping in wicked yet.
		t.statusbar_s = "";
		#else
		//  cursor position
		if (g.gridlayershowsingle == 1)
		{
			t.statusbar_s = ""; t.statusbar_s = t.statusbar_s + "CLIP=" + Str(int(t.clipheight_f));
		}
		else
		{
			t.statusbar_s = "CLIP OFF";//"ALL" ; t.t_s=t.strarr_s[80]+":"+t.t_s;
		}

		t.statusbar_s = t.statusbar_s + " | ";
		#endif
		if (t.inputsys.xmouse == 500000)
		{
			t.strwork = ""; t.statusbar_s = t.statusbar_s + "X: 0 Z: 0";
		}
		else {
			t.strwork = ""; t.statusbar_s = t.statusbar_s + "X:" + Str(t.inputsys.mmx) + " " + "Z:" + Str(t.inputsys.mmy);
		}

		//PE: 17/08/21 reactivated.
		t.statusbar_s = t.statusbar_s + " | ";
		if (t.gridentitygridlock == 0)  t.statusbar_s = t.statusbar_s + "NORMAL";
		if (t.gridentitygridlock == 1)  t.statusbar_s = t.statusbar_s + "SNAP";
		if (t.gridentitygridlock == 2)  t.statusbar_s = t.statusbar_s + "GRID";

		//  editing mode

		//336 = Clipboard Selection Mode (CTRL+C=Copy DELETE=Clear)
		//332 = Terrain Painting Mode:
		//343 = Zoomed In Mode (Right click and drag to view, Left to Exit)
		//344 = Entity Editing Mode (R=Rotate Entity  ENTER=Find Floor/Wall)

		if (t.grideditselect == 0)
		{
#ifdef WICKEDENGINE
			if (t.terrain.terrainpaintermode >= 6) {
				if (t.terrain.terrainpaintermode == 11) {
					t.laststatusbar_s = "Terrain Tree Editing Mode";
				}
				else if (t.terrain.terrainpaintermode == 12) {
					t.laststatusbar_s = "Terrain Bush Editing Mode";
				}
				else if (t.terrain.terrainpaintermode == 10) {
					t.laststatusbar_s = "Terrain Vegetation Editing Mode";
				}
				else {
					t.laststatusbar_s = "Terrain Painting Mode";
				}
			}
			else {

				t.laststatusbar_s = "Terrain Sculpt Mode ";

				//if (t.terrain.terrainpaintermode == 1)
				//	t.laststatusbar_s = t.laststatusbar_s + "- Shape Mode";
				//if (t.terrain.terrainpaintermode == 2)
				//	t.laststatusbar_s = t.laststatusbar_s + "- Level Mode";
				//if (t.terrain.terrainpaintermode == 3)
				//	t.laststatusbar_s = t.laststatusbar_s + "- Copy Mode";
				//if (t.terrain.terrainpaintermode == 4)
				//	t.laststatusbar_s = t.laststatusbar_s + "- Blend Mode";
				//if (t.terrain.terrainpaintermode == 5)
				//	t.laststatusbar_s = t.laststatusbar_s + "- Ramp Mode";

				if (ggterrain_extra_params.sculpt_mode == GGTERRAIN_SCULPT_RAISE || ggterrain_extra_params.sculpt_mode == GGTERRAIN_SCULPT_LOWER)
					t.laststatusbar_s = t.laststatusbar_s + "- Shape Mode";
				else if (ggterrain_extra_params.sculpt_mode == GGTERRAIN_SCULPT_LEVEL)
					t.laststatusbar_s = t.laststatusbar_s + "- Level Mode";
				else if (ggterrain_extra_params.sculpt_mode == GGTERRAIN_SCULPT_BLEND)
					t.laststatusbar_s = t.laststatusbar_s + "- Blend Mode";
				else if (ggterrain_extra_params.sculpt_mode == GGTERRAIN_SCULPT_RAMP)
					t.laststatusbar_s = t.laststatusbar_s + "- Ramp Mode";
				else if (ggterrain_extra_params.sculpt_mode == GGTERRAIN_SCULPT_PICK)
					t.laststatusbar_s = t.laststatusbar_s + "- Pick Height Mode";
				else if (ggterrain_extra_params.sculpt_mode == GGTERRAIN_SCULPT_WRITE)
					t.laststatusbar_s = t.laststatusbar_s + "- Use Picked Height Mode";
				else if (ggterrain_extra_params.sculpt_mode == GGTERRAIN_SCULPT_RANDOM)
					t.laststatusbar_s = t.laststatusbar_s + "- Random Mode";
				else if (ggterrain_extra_params.sculpt_mode == GGTERRAIN_SCULPT_RESTORE)
					t.laststatusbar_s = t.laststatusbar_s + "- Restore Mode";

			}
#else
			t.laststatusbar_s = t.strarr_s[332];
			terrain_getpaintmode();
			t.laststatusbar_s = t.laststatusbar_s + " " + t.mode_s;
#endif
		}
#ifndef WICKEDENGINE
		if (t.grideditselect == 1)  t.laststatusbar_s = t.strarr_s[336];
		if (t.grideditselect == 2)
		{
			//  art tools not used any more
		}
		if (t.grideditselect == 3)
		{
			//  map view mode not used any more
		}

		if (t.grideditselect == 4)  t.laststatusbar_s = t.strarr_s[343];
#endif

		if (t.grideditselect == 5)
		{
#ifdef WICKEDENGINE
			t.laststatusbar_s = "Object Editing Mode - ";
			t.laststatusbar_s = t.laststatusbar_s + " Object: " + t.relaytostatusbar_s;
#else
			t.laststatusbar_s = t.strarr_s[344];
			t.laststatusbar_s = t.laststatusbar_s + " Entity: " + t.relaytostatusbar_s;
#endif
		}
		if (t.grideditselect == 6)
		{
			//  add waypoint sta2tus
#ifdef WICKEDENGINE
			t.laststatusbar_s = "Waypoint Editing Mode";
#else
			t.laststatusbar_s = "Waypoint Mode (LMB=Drag Point  SHIFT+LMB=Clone Point  SHIFT+RMB=Remove Point)";
#endif
		}

#ifdef WICKEDENGINE
		if (g_bCharacterCreatorPlusActivated)
			t.laststatusbar_s = "Character Creator Mode";
		if ( (bBuilder_Properties_Window || t.ebe.on == 1) || (t.gridentity > 0 && t.entityprofile[t.gridentity].isebe != 0) )
			t.laststatusbar_s = "Structure Editor Mode";
		if (bImporter_Window && t.importer.importerActive == 1)
			t.laststatusbar_s = "Importer Mode";
#endif

		//  only update infrequently
		t.interfacestatusbarupdate = 0;

		//t.laststatusbar_s = t.statusbar_s;
	}

	cstr WinTitle = "";

	if (strcmp(Lower(Left(g.projectfilename_s.Get(), Len(g.rootdir_s.Get()))), Lower(g.rootdir_s.Get())) == 0)
	{
		WinTitle = Right(g.projectfilename_s.Get(), Len(g.projectfilename_s.Get()) - Len(g.rootdir_s.Get()));
	}
	else
	{
		WinTitle = g.projectfilename_s;
	}
	if (g.projectmodified != 0)  WinTitle = WinTitle + "*";

#ifdef STORYBOARD
	if (bStoryboardWindow)
	{
		WinTitle = Storyboard.gamename;
		if (Storyboard.project_readonly == 1)
		{
			WinTitle = WinTitle + " (read only)";
		}
		else
		{
			if (Storyboard.iChanged) WinTitle = WinTitle + "*";
		}
	}
#endif

	if (WinTitle != CurrentWinTitle) {
		//Change windows title
		CurrentWinTitle = WinTitle;
		#ifdef VRTECH
		#ifdef PRODUCTV3
		cstr NewTitle = "VR Quest - ";
		#else
		cstr NewTitle = "GameGuru MAX - ";
		#endif
		if (strnicmp(WinTitle.Get(), "mapbank\\", 8) == 0)
			WinTitle = WinTitle.Get() + 8;
		NewTitle = NewTitle + WinTitle;
		SetWindowTitle(NewTitle.Get());
		#else
		cstr NewTitle = "GameGuru - ";
		if (strnicmp(WinTitle.Get(), "mapbank\\", 8) == 0)
			WinTitle = WinTitle.Get() + 8;
		NewTitle = NewTitle + WinTitle;
		SetWindowTitle(NewTitle.Get());
#endif
	}

	//  Update status bar out of action subroutines
	//gridedit_updatestatusbar();


}
#endif

void input_getcontrols ( void )
{
	//  Some actions are directly triggered by input subroutine
	t.inputsys.doload=0;
	t.inputsys.domodeterrain=0;
	t.inputsys.domodeentity=0;
	t.inputsys.domodemarker=0;
	t.inputsys.domodewaypoint=0;
	t.inputsys.doundo=0;
	t.inputsys.doredo=0;
	t.inputsys.tselcontrol=0;
	t.inputsys.tselcut=0;
	t.inputsys.tselcopy=0;
	t.inputsys.tseldelete=0;

	//  Obtain input data
	if (  g.globals.ideinputmode == 1 ) 
	{
		input_getfilemapcontrols ( );
	}
	else
	{
		input_getdirectcontrols ( );
	}

	//  Flag reset
	t.inputsys.dorotation=0;
	t.inputsys.domirror=0;
	t.inputsys.doflip=0;
	t.inputsys.doentityrotate=0;
	t.inputsys.dozoomin=0;
	t.inputsys.dozoomout=0;
	t.inputsys.doscrollleft=0;
	t.inputsys.doscrollright=0;
	t.inputsys.doscrollup=0;
	t.inputsys.doscrolldown=0;
	t.inputsys.domapresize=0;
	t.inputsys.dogroundmode=-1;
	t.inputsys.dozoomview=0;
	t.inputsys.dozoomviewmovex=0;
	t.inputsys.dozoomviewmovey=0;
	t.inputsys.dozoomviewmovez=0;
	t.inputsys.dozoomviewrotatex=0;
	t.inputsys.dozoomviewrotatey=0;
	t.inputsys.dozoomviewrotatez=0;
	t.inputsys.dosinglelayer=0;
	t.inputsys.tselfloor=0;
	t.inputsys.tselpaste=0;
	t.inputsys.tselwipe=0;
	t.inputsys.dosaveandrun=0;

	//  Input conditional flags
	if (t.inputsys.kscancode == 0) 
	{
		t.inputsys.keypress = 0;
		#ifdef VRTECH
		if (iForceScancode > 0 ) 
		{
			t.inputsys.kscancode = iForceScancode;
			iForceScancode = -1;
		}
		else if (bForceKey) 
		{
			bForceKey = false;
			t.inputsys.k_s = csForceKey;
		}
		#endif
	}


	//  Construction Keys
	if (  t.inputsys.keycontrol == 0 ) 
	{
		// can get marker mode from anywhere
		if ( (t.inputsys.kscancode == Asc("M") || t.inputsys.k_s == "m") && t.inputsys.keypress == 0 ) 
		{
			t.inputsys.domodemarker = 1;
			t.inputsys.keypress = 1; 
		}

		if ( (t.grideditselect == 4 && t.gridentityinzoomview>0) || t.grideditselect == 5 ) 
		{
			#ifdef WICKEDENGINE
			if (  t.inputsys.k_s == "g" && t.inputsys.keypress == 0 )
			#else
			if (t.inputsys.k_s == "b" && t.inputsys.keypress == 0)
			#endif
			{
				t.inputsys.keypress=1; 
				t.gridentitygridlock=t.gridentitygridlock+1;
				if ( t.gridentitygridlock>2 )  
					t.gridentitygridlock = 0;
			}
			if (  t.inputsys.k_s == "y" && t.inputsys.keypress == 0 && g.gentitytogglingoff == 0 ) 
			{
				// only if not EBE
				if ( t.entityprofile[t.gridentity].isebe == 0 )
				{
					t.ttrygridentitystaticmode=1-t.gridentitystaticmode;
					t.ttrygridentity=t.gridentity ; editor_validatestaticmode ( );
				}
				t.inputsys.keypress=1; 
			}
			if (  t.inputsys.k_s == "u" && t.inputsys.keypress == 0 ) 
			{
				//  control auto-flatten
				t.inputsys.keypress=1;
				t.gridedit.autoflatten=1-t.gridedit.autoflatten;
			}
			if (  t.inputsys.k_s == "i" && t.inputsys.keypress == 0 ) 
			{
				//  control entity spray mode
				t.inputsys.keypress=1;
				t.gridedit.entityspraymode=1-t.gridedit.entityspraymode;
			}
			// except when in EBE mode which handles - and + keys for material changing
			if ( t.ebe.on == 0 )
			{
				if (  t.inputsys.k_s == "-" && t.inputsys.keypress == 0 ) { t.gridentitymodifyelement = 1  ; t.inputsys.keypress = 1; }
				if (  t.inputsys.k_s == "=" && t.inputsys.keypress == 0 ) { t.gridentitymodifyelement = 2 ; t.inputsys.keypress = 1; }
			}
		}

		//  editing mode
		if (  t.inputsys.k_s == "t" ) { t.inputsys.domodeterrain = 1  ; t.inputsys.dowaypointview = 0; }
		#ifdef WICKEDENGINE
		if (  t.inputsys.k_s == "o" ) { t.inputsys.domodeentity = 1  ; t.inputsys.dowaypointview = 0; }
		#else
		if (t.inputsys.k_s == "e") { t.inputsys.domodeentity = 1; t.inputsys.dowaypointview = 0; }
		#endif
		if (  t.inputsys.k_s == "p" ) { t.inputsys.domodewaypoint = 1  ; t.inputsys.dowaypointview = 0; }
		if ( t.inputsys.keyspace == 1 && t.inputsys.keypress == 0 ) { t.inputsys.dowaypointview=1-t.inputsys.dowaypointview ; t.inputsys.keypress=1 ; t.lastgrideditselect=-1  ; editor_refresheditmarkers ( ); }

		//  NUM-ROTATE CONTROLS
		if (  t.inputsys.k_s == "r" && t.inputsys.keypress == 0 && t.ebe.on == 0) { t.inputsys.dorotation = 1 ; t.inputsys.keypress = 1; }
		if (  t.grideditselect != 4 && t.grideditselect != 0 ) 
		{
			if (  t.inputsys.k_s == "1" && t.inputsys.keypress == 0 ) { t.inputsys.doentityrotate = 1  ; t.inputsys.keypress = 1; }
			if (  t.inputsys.k_s == "2" && t.inputsys.keypress == 0 ) { t.inputsys.doentityrotate = 2  ; t.inputsys.keypress = 1; }
			if (  t.inputsys.k_s == "3" && t.inputsys.keypress == 0 ) { t.inputsys.doentityrotate = 3  ; t.inputsys.keypress = 1; }
			if (  t.inputsys.k_s == "4" && t.inputsys.keypress == 0 ) { t.inputsys.doentityrotate = 4  ; t.inputsys.keypress = 1; }
			if (  t.inputsys.k_s == "5" && t.inputsys.keypress == 0 ) { t.inputsys.doentityrotate = 5  ; t.inputsys.keypress = 1; }
			if (  t.inputsys.k_s == "6" && t.inputsys.keypress == 0 ) { t.inputsys.doentityrotate = 6  ; t.inputsys.keypress = 1; }
			if (  t.inputsys.keyshift == 0 ) 
			{
				if (  t.inputsys.k_s == "0" && t.inputsys.keypress == 0 ) { t.inputsys.doentityrotate = 98  ; t.inputsys.keypress = 1; }
			}
			else
			{
				if (  t.inputsys.k_s == "0" && t.inputsys.keypress == 0 ) { t.inputsys.doentityrotate = 99 ; t.inputsys.keypress = 1; }
			}
		}

		// Editing of Map
		if ( t.inputsys.k_s == ","  )  t.inputsys.dozoomin = 1;
		if ( t.inputsys.k_s == "."  )  t.inputsys.dozoomout = 1;

		// TAB Key causes layer edit view control
		if ( t.inputsys.kscancode == 15 && t.inputsys.keypress == 0 ) { t.inputsys.dosinglelayer = 1  ; t.inputsys.keypress = 1; }

		// F1 for help page
		#ifndef WICKEDENGINE
		if ( t.inputsys.kscancode == 59 ) editor_showhelppage ( 1 );
		#endif

		// this is the non-IDE input function (need to consolidate at some point - yucky repeat code!)
	}
	else
	{
		if (  t.inputsys.k_s == "r" && t.ebe.on == 0)  t.inputsys.dorotation = 1;
	}

	//  Key Map Scroll and Resize
	if (  t.inputsys.keyshift == 0 ) 
	{
		if (  t.inputsys.keyleft == 1  )  t.inputsys.doscrollleft = 3;
		if (  t.inputsys.keyright == 1  )  t.inputsys.doscrollright = 3;
		if (  t.inputsys.keyup == 1  )  t.inputsys.doscrollup = 3;
		if (  t.inputsys.keydown == 1  )  t.inputsys.doscrolldown = 3;
	}
	else
	{
		if (  t.inputsys.keyleft == 1  )  t.inputsys.doscrollleft = 20;
		if (  t.inputsys.keyright == 1  )  t.inputsys.doscrollright = 20;
		if (  t.inputsys.keyup == 1  )  t.inputsys.doscrollup = 20;
		if (  t.inputsys.keydown == 1  )  t.inputsys.doscrolldown = 20;
	}

	//  Mouse Wheel control (170616 - but not when in EBE mode as its used for grid layer control)
	if ( t.ebe.on == 0 )
	{
		if (  t.grideditselect == 4 ) 
		{
			//  Zoomed in View
			t.zoomviewcamerarange_f -= (t.inputsys.wheelmousemove / 10.0);
		}
		else
		{
			//  Non-Zoomed in View
			if (  t.inputsys.keycontrol == 0 ) 
			{
				if (  t.inputsys.wheelmousemove<0  )
					t.inputsys.dozoomout = 1;
				if (  t.inputsys.wheelmousemove>0  )
					t.inputsys.dozoomin = 1;
			}
		}
	}

	//  UndoRedo Keys
	if (  t.inputsys.keycontrol == 1 ) 
	{
		#ifndef WICKEDENGINE
		if (  t.inputsys.k_s == ""  )  t.inputsys.undokeypress = 0;
		#endif
		if (  t.inputsys.k_s == "z" && t.inputsys.undokeypress == 0 ) { t.inputsys.doundo = 1  ; t.inputsys.undokeypress = 1; }
		if (  t.inputsys.k_s == "y" && t.inputsys.undokeypress == 0 ) { t.inputsys.doredo = 1  ; t.inputsys.undokeypress = 1; }
	}

	//  Controls only when in zoomview
	if (  t.grideditselect == 4 ) 
	{
		//  orient arrowkey movement to camera angle
		t.tca_f=WrapValue(CameraAngleY());
		if (  t.tca_f >= 360-45 || t.tca_f <= 45 ) 
		{
			t.txa=1 ; t.txb=2 ; t.txc=0 ; t.txd=0;
			t.tza=0 ; t.tzb=0 ; t.tzc=2 ; t.tzd=1;
		}
		else
		{
			if (  t.tca_f >= 180-45 && t.tca_f <= 180+45 ) 
			{
				t.txa=2 ; t.txb=1 ; t.txc=0 ; t.txd=0;
				t.tza=0 ; t.tzb=0 ; t.tzc=1 ; t.tzd=2;
			}
			else
			{
				if (  t.tca_f <= 180 ) 
				{
					t.txa=0 ; t.txb=0 ; t.txc=2 ; t.txd=1;
					t.tza=2 ; t.tzb=1 ; t.tzc=0 ; t.tzd=0;
				}
				else
				{
					t.txa=0 ; t.txb=0 ; t.txc=1 ; t.txd=2;
					t.tza=1 ; t.tzb=2 ; t.tzc=0 ; t.tzd=0;
				}
			}
		}
		t.inputsys.dozoomviewmovex=0 ; t.inputsys.dozoomviewmovez=0;
		if (  t.inputsys.keyleft == 1 ) { t.inputsys.dozoomviewmovex += t.txa  ; t.inputsys.dozoomviewmovez +=t.tza; }
		if (  t.inputsys.keyright == 1 ) { t.inputsys.dozoomviewmovex += t.txb  ; t.inputsys.dozoomviewmovez += t.tzb; }
		if (  t.inputsys.keyup == 1 ) { t.inputsys.dozoomviewmovex += t.txc  ; t.inputsys.dozoomviewmovez += t.tzc; }
		if (  t.inputsys.keydown == 1 ) { t.inputsys.dozoomviewmovex +=t.txd  ; t.inputsys.dozoomviewmovez += t.tzd; }
		//  control rotation
		if (  t.inputsys.k_s == "1" && t.inputsys.keypress == 0 ) { t.inputsys.dozoomviewrotatex = 1  ; t.inputsys.keypress = 1; }
		if (  t.inputsys.k_s == "2" && t.inputsys.keypress == 0 ) { t.inputsys.dozoomviewrotatex = 2  ; t.inputsys.keypress = 1; }
		if (  t.inputsys.k_s == "3" && t.inputsys.keypress == 0 ) { t.inputsys.dozoomviewrotatey = 1  ; t.inputsys.keypress = 1; }
		if (  t.inputsys.k_s == "4" && t.inputsys.keypress == 0 ) { t.inputsys.dozoomviewrotatey = 2  ; t.inputsys.keypress = 1; }
		if (  t.inputsys.k_s == "5" && t.inputsys.keypress == 0 ) { t.inputsys.dozoomviewrotatez = 1  ; t.inputsys.keypress = 1; }
		if (  t.inputsys.k_s == "6" && t.inputsys.keypress == 0 ) { t.inputsys.dozoomviewrotatez = 2  ; t.inputsys.keypress = 1; }
		if (  t.inputsys.keyshift == 0 ) 
		{
			if (  t.inputsys.k_s == "0" && t.inputsys.keypress == 0 ) { t.inputsys.dozoomviewrotatex = 98  ; t.inputsys.keypress = 1; }
		}
		else
		{
			if (  t.inputsys.k_s == "0" && t.inputsys.keypress == 0 ) { t.inputsys.dozoomviewrotatex = 99  ; t.inputsys.keypress = 1; }
		}
	}
	if (  t.grideditselect == 4 || t.grideditselect == 5 ) 
	{
		//  control finder (toggled using gridentityautofind value)
		if (  t.inputsys.keyreturn == 1 ) 
		{
			if (  t.gridentityautofind == 0  ) { t.gridentityautofind = 3; }
			if (  t.gridentityautofind == 1  ) { t.gridentityautofind = 2; }
		}
		else
		{
			if (  t.gridentityautofind == 3 ) { t.gridentityautofind = 1  ; t.gridentityusingsoftauto = 0; t.gridentitysurfacesnap = 0; }
			if (  t.gridentityautofind == 2 ) { t.gridentityautofind = 0  ; t.gridentityposoffground = 0 ; t.gridentityusingsoftauto = 1; t.gridentitysurfacesnap = 0; }
		}
		if ( t.gridentityautofind == 1 && t.gridentity>0 ) 
		{
			t.gridentitydroptoground = 1 + t.entityprofile[t.gridentity].forwardfacing;
		}
		else
		{
			t.gridentitydroptoground=0;
		}
		//  control height
		if (  t.grideditselect == 4 ) 
		{
			//  move entity through zoomview system
			if (  t.inputsys.kscancode == 201 ) { t.inputsys.dozoomviewmovey = 2  ; t.gridentityposoffground = 1 ; t.gridentityautofind = 0 ; t.gridentityusingsoftauto = 0; }
			if (  t.inputsys.kscancode == 209 ) { t.inputsys.dozoomviewmovey = 1  ; t.gridentityposoffground = 1 ; t.gridentityautofind = 0 ; t.gridentityusingsoftauto = 0; }
		}
		else
		{
			//  directly move entity (and detatch from terrain) PGUP and PGDN
			if ( t.inputsys.kscancode == 201 || t.inputsys.kscancode == 209 ) 
			{
				if ( t.widget.activeObject == 0 ) 
				{
					editor_handlepguppgdn();
					t.gridentityposoffground=1 ; t.gridentityautofind=0 ; t.gridentityusingsoftauto=0; t.gridentitysurfacesnap=0;
				}
			}
		}
	}

	//  Create a waypoint when instructed to
	if (  t.inputsys.domodewaypointcreate == 1 && t.inputsys.keypress == 0 ) 
	{
		t.inputsys.domodewaypointcreate=0;
		t.inputsys.keypress=1 ; t.inputsys.domodewaypoint=1 ; t.grideditselect=6;
		if (  t.terrain.TerrainID>0 ) 
		{
			g.waypointeditheight_f=BT_GetGroundHeight(t.terrain.TerrainID,t.cx_f,t.cy_f);
		}
		else
		{
			g.waypointeditheight_f=g.gdefaultterrainheight;
		}
		t.waypointeditstyle=1 ; t.waypointeditstylecolor=0 ; t.waypointeditentity=0;
		t.mx_f=t.cx_f ; t.mz_f=t.cy_f  ; waypoint_createnew ( );
	}
}

bool CameraInsideObject (sObject* pObject)
{
	GGVECTOR3 vecLocalCamPos = GGVECTOR3(CameraPositionX(0), CameraPositionY(0), CameraPositionZ(0));
	vecLocalCamPos -= pObject->position.vecPosition;
	GGMATRIX inverseMatrix = pObject->position.matObjectNoTran;
	float fDet;
	GGMatrixInverse (&inverseMatrix, &fDet, &inverseMatrix);
	GGVec3TransformCoord(&vecLocalCamPos, &vecLocalCamPos, &inverseMatrix);
	float fMinX = pObject->collision.vecMin.x;
	float fMinY = pObject->collision.vecMin.y;
	float fMinZ = pObject->collision.vecMin.z;
	float fMaxX = pObject->collision.vecMax.x;
	float fMaxY = pObject->collision.vecMax.y;
	float fMaxZ = pObject->collision.vecMax.z;
	if (vecLocalCamPos.x >= fMinX && vecLocalCamPos.x <= fMaxX && vecLocalCamPos.y >= fMinY && vecLocalCamPos.y <= fMaxY && vecLocalCamPos.z >= fMinZ && vecLocalCamPos.z <= fMaxZ)
		return true;
	else
		return false;
}

#ifdef WICKEDENGINE
uint32_t g_iGridEntityFlattener = -1;
#endif

void input_calculatelocalcursor ( void )
{
	#ifdef WICKEDENGINE

	//PE: Dont change anything when right mouse down.
	if (ImGui::IsMouseDown(1)) return;

	// once object management begun, only allow ray tests once user has clicked and 'moved' the cursor
	static int iRecordedMouseAtStartOfManagement = 0;
	if (t.gridentityobj>0)
	{
		static XMFLOAT4 lastManagedMouse;
		XMFLOAT4 currentMouse = wiInput::GetPointer();
		if (iRecordedMouseAtStartOfManagement == 0)
		{
			iRecordedMouseAtStartOfManagement = 1;
			lastManagedMouse = currentMouse;
		}
		else
		{
			if (currentMouse.x != lastManagedMouse.x || currentMouse.y != lastManagedMouse.y)
			{
				iRecordedMouseAtStartOfManagement = 2;
				g_bHoldGridEntityPosWhenManaged = false;
			}
		}
		if (iRecordedMouseAtStartOfManagement != 2)
		{
			// until we move the mouse after starting an object management, just leave
			return;
		}
	}
	else
	{
		// when no more object to manage, can reset this system
		iRecordedMouseAtStartOfManagement = 0;
		g_bHoldGridEntityPosWhenManaged = false;
	}

	// use Wicked Pick System
	t.tx_f=0; t.tz_f=0;
	float fPickedYAxis = 0.0f;
	t.inputsys.localselectedrayhit = false;

	std::vector<sRubberBandType> entityvisible;
	bool bDisableRubberBandMoving = false;
	if (current_selected_group >= 0 && group_editing_on)
	{
		bDisableRubberBandMoving = true;
	}
	if (!bDisableRubberBandMoving && pref.iEnableDragDropEntityMode && bDraggingActive)
	{
		//PE: MUST disable collision on ALL rubberband objects.
		entityvisible = g.entityrubberbandlist;
		if (g.entityrubberbandlist.size() > 0)
		{
			for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
			{
				int e = g.entityrubberbandlist[i].e;
				int obj = t.entityelement[e].obj;
				if (obj > 0 && GetVisible(obj))
				{
					entityvisible[i].x = 1;
					HideObject(obj);
				}
				else
				{
					entityvisible[i].x = 0;
				}
			}
		}
	}

	if (!pref.iEnableDragDropEntityMode)
	{
		int iLayerMaskForPick = GGRENDERLAYERS_NORMAL;
		if (bDraggingActive || t.gridentityobj > 0) iLayerMaskForPick = GGRENDERLAYERS_TERRAIN;
		if (WickedCall_GetPick(&t.tx_f, &fPickedYAxis, &t.tz_f, NULL, NULL, NULL, NULL, iLayerMaskForPick) == true)
			t.inputsys.localselectedrayhit = true;

		// special treatment of point lights
		if (t.gridentity > 0 && t.gridentityobj > 0 && t.entityprofile[t.gridentity].ismarker == 2)
		{
			if (t.grideleprof.usespotlighting == 0)
			{
				t.gridentityrotatex_f = 90;
				t.gridentityrotatey_f = 0;
				t.gridentityrotatez_f = 0;
				t.gridentityrotatequatmode = 0;
				t.gridentityrotatequatx_f = 0;
				t.gridentityrotatequaty_f = 0;
				t.gridentityrotatequatz_f = 0;
				t.gridentityrotatequatw_f = 1;
			}
			fPickedYAxis += 10.0f;
		}
	}
	else
	{
		// LB: allow finding of other object surfaces when not dragging (initial placement of object)
		int iLayerMaskForPick = GGRENDERLAYERS_NORMAL | GGRENDERLAYERS_TERRAIN;

		uint64_t hitentity = 0;
		if (pref.iEnableDragDropEntityMode && bDraggingActive && t.gridentityobj > 0) HideObject(t.gridentityobj);

		// orient to surface mode keyboard shurtcut
		if (t.inputsys.keyspace == 1 && g_iOrientToSurfaceMode == 0) g_iOrientToSurfaceMode = 2;
		if (t.inputsys.keyspace == 0 && g_iOrientToSurfaceMode == 2) g_iOrientToSurfaceMode = 1;
		if (t.inputsys.keyspace == 1 && g_iOrientToSurfaceMode == 1) g_iOrientToSurfaceMode = 3;
		if (t.inputsys.keyspace == 0 && g_iOrientToSurfaceMode == 3) g_iOrientToSurfaceMode = 0;

		bool bApplyHitOffset = false;
		bool bRayResult = false;
		float fPickX, fPickZ;
		bool bMustFaceUpOrDown = false;
		float fUpDownAngle = WrapValue(CameraAngleX(0));
		if (fUpDownAngle > 10.0f && fUpDownAngle < 350.0f)
		{
			// a horizontal plane for down views
			bMustFaceUpOrDown = true;
		}
		// special method of detecting when should eliminate hitoffsets to helo with accurate positioning
		static float fLastPickedY = 0.0f;
		static float fLastDiff = 0.0f;
		if (!ImGui::IsMouseDown(0))
		{
			fLastPickedY = 0.0f;
			fLastDiff = 0.0f;
		}
		// pick
		float fNormalX = 0.0f;
		float fNormalY = 1.0f;
		float fNormalZ = 0.0f;
		int iForwardFacing = 0;
		if (t.gridentity > 0) iForwardFacing = t.entityprofile[t.gridentity].forwardfacing;
		if (iObjectMoveMode == 2 && t.gridentityobj > 0 && bMustFaceUpOrDown == true && t.gridentity > 0 && t.entityprofile[t.gridentity].ismarker != 2 && iForwardFacing != 2)
		{
			// convert base obj pos to 2D
			//float fBlockedBaseX = t.gridentityposx_f;
			//float fBlockedBaseY = t.gridentityposy_f;
			//float fBlockedBaseZ = t.gridentityposz_f;
			//ImVec2 v2DPos;
			//v2DPos = Convert3DTo2D(fBlockedBaseX, fBlockedBaseY, fBlockedBaseZ);
			//GGVECTOR2 vecBase = GGVECTOR2(v2DPos.x, v2DPos.y);
			// convert clicked pos to 2D
			//v2DPos = Convert3DTo2D(fBlockedBaseX + fHitOffsetX, fBlockedBaseY + fHitOffsetY, fBlockedBaseZ + fHitOffsetZ);
			//GGVECTOR2 vecClickPos = GGVECTOR2(v2DPos.x, v2DPos.y);
			// work out difference to move virtual mouse pointer to base of object no matter the orientation
			GGVECTOR2 vecVirtMouseOffset = GGVECTOR2(0, 0); //vecBase - vecClickPos; too clever by half!
			XMFLOAT4 currentMouse = wiInput::GetPointer();
			bRayResult = WickedCall_GetPick2(currentMouse.x + vecVirtMouseOffset.x, currentMouse.y + vecVirtMouseOffset.y, &fPickX, &fPickedYAxis, &fPickZ, &fNormalX, &fNormalY, &fNormalZ, &hitentity, iLayerMaskForPick);
			// and finally put hitoffset back to restore object relative position
			bApplyHitOffset = true;
			// simpler system easier to use - shift mouse to object true base coord, no need for mouse 3D->2D adjustment and accurate for placement!
			if (fLastPickedY == 0.0f) fLastPickedY = fPickedYAxis;
			float fDiff = fabs(fPickedYAxis - fLastPickedY) - 5.0f;
			if (fDiff < 0.0f) fDiff = 0.0f;
			if (fDiff > fLastDiff)
			{
				fLastDiff = fDiff;
				fHitOffsetX *= 0.95f;
				fHitOffsetY *= 0.95f;
				fHitOffsetZ *= 0.95f;
			}
		}
		else
		{
			bRayResult = WickedCall_GetPick(&fPickX, &fPickedYAxis, &fPickZ, &fNormalX, &fNormalY, &fNormalZ, &hitentity, iLayerMaskForPick);
		}
		//LB: to help perfect plane positioning of EMPTY LEVEL scenes, clamp to zero Y if within threshold
		if (fPickedYAxis > -1.0f && fPickedYAxis < 1.0f) 
		{
			fPickedYAxis = 0.0f;
		}
		if (bRayResult == true && t.gridentityobj > 0 && t.gridentity > 0 && t.entityprofile[t.gridentity].ismarker == 0 && iForwardFacing == 0)
		{
			/* LB: this causes the judder when smart placing, caused when VERY minor XZ changes happen causing spiral to detect new heights
			// that when acted on change XZ again causing the same height not to be found, thus vicious cycle!!
			// if hit an object, such as a corrogated roof or pallet with holes in
			float fBestY = fPickedYAxis;
			sObject* pHitObject = NULL;
			if (hitentity > 0) pHitObject = m_ObjectManager.FindObjectFromWickedObjectEntityID(hitentity);

			// object attached to cursor
			sObject* pCursorObj = GetObjectData(t.gridentityobj);

			// cast four rays and pick highest Y position as the true coordinate
			float fSpiralRadiusMax = (ObjectSizeX(t.gridentityobj, 1) + ObjectSizeZ(t.gridentityobj,1)) / 2.0f / 2.0f;
			float fSpiralRadius = 0.0f;
			float fSpiralAngle = 0.0f;
			for (int iFour = 0; iFour < 20; iFour++)
			{
				GGVECTOR3 vecPos = pCursorObj->position.vecPosition;
				vecPos.x += NewXValue(0, fSpiralAngle, fSpiralRadius);
				vecPos.z += NewZValue(0, fSpiralAngle, fSpiralRadius);
				fSpiralRadius += (fSpiralRadiusMax / 20.0f);
				fSpiralAngle += (720.0f / 20.0f);
				if (pHitObject == NULL)
				{
					float fNewPickX = 0;
					float fNewPickY = 0;
					float fNewPickZ = 0;
					WickedCall_SentRay2 (vecPos.x, vecPos.y+10.0f, vecPos.z, 0, -1, 0, &fNewPickX, &fNewPickY, &fNewPickZ, &fNormalX, &fNormalY, &fNormalZ, &hitentity, iLayerMaskForPick);
					if (hitentity > 0)
					{
						// acquired an object at location, use this for further checks
						pHitObject = m_ObjectManager.FindObjectFromWickedObjectEntityID(hitentity);
					}
				}
				float fDistance = 0.0f;
				if (pHitObject) fDistance = IntersectObject(pHitObject->dwObjectNumber, vecPos.x, vecPos.y + 10.0f, vecPos.z, vecPos.x, vecPos.y - 10.0f, vecPos.z);
				if (fDistance > 0.0f)
				{
					GGVECTOR3 vecHit = GGVECTOR3(g_pGlob->checklist[5].fvaluea, g_pGlob->checklist[5].fvalueb, g_pGlob->checklist[5].fvaluec);
					GGVECTOR3 vecHitNormal = GGVECTOR3(g_pGlob->checklist[6].fvaluea, g_pGlob->checklist[6].fvalueb, g_pGlob->checklist[6].fvaluec);
					if (vecHit.y > fBestY)
					{
						fBestY = vecHit.y;
					}
				}
			}
			// new highest Y position
			fPickedYAxis = fBestY;
			*/
		}
		if (bApplyHitOffset == true)
		{
			fPickX += fHitOffsetX;
			fPickedYAxis += fHitOffsetY;
			fPickZ += fHitOffsetZ;
		}
		if (bRayResult == true )
		{
			// if initial selection or in ghost mode
			bool bJustForInitialDragIn = false;
			if (bDraggingActive == false && fHitOffsetX == 0 && fHitOffsetY == 0 && fHitOffsetZ == 0) bJustForInitialDragIn = true;
			if (bDraggingActive == true && t.gridentityposx_f == 0 && t.gridentityposz_f == 0) bJustForInitialDragIn = true;
			if (bDraggingActiveInitial == true)	bJustForInitialDragIn = true;
			if (bJustForInitialDragIn==true || (iObjectMoveModeDropSystemUsing == 1 && g_bHoldGridEntityPosWhenManaged == false) || iForwardFacing == 1 || (t.entityprofile[t.gridentity].ismarker == 2))
			{
				// modify the rotation of the object in smart mode when object is forward facing
				if (t.gridentityobj > 0 && t.gridentity > 0 && t.entityprofile[t.gridentity].ischaracter == 0)
				{
					if (iObjectMoveMode == 2)
					{
						bool bAdjustAndTilt = false;
						if (t.entityprofile[t.gridentity].ismarker == 0)
						{
							if (iForwardFacing == 0 && g_iStackToSurfaceMode == 1 && g_iOrientToSurfaceMode == 1)
							{
								// ground objects can find orientation if mode selected
								bAdjustAndTilt = true;
							}
							if (iForwardFacing == 1)
							{
								// wall objects can find ANY surface
								bAdjustAndTilt = true;
							}
						}
						else
						{
							// lights ALWAYS orient to surface
							if (t.entityprofile[t.gridentity].ismarker == 2)
							{
								bAdjustAndTilt = true;
							}
						}
						if (bAdjustAndTilt == true)
						{
							fNormalX *= 100.0f;
							fNormalY *= 100.0f;
							fNormalZ *= 100.0f;
							int iObj = t.gridentityobj;
							float fStoreAngX = ObjectAngleX(iObj);
							float fStoreAngY = ObjectAngleY(iObj);
							float fStoreAngZ = ObjectAngleZ(iObj);
							PointObject(t.gridentityobj, ObjectPositionX(iObj) - fNormalX, ObjectPositionY(iObj) - fNormalY, ObjectPositionZ(iObj) - fNormalZ);
							if (iForwardFacing == 0)
							{
								PitchObjectUp(iObj, 90);
								TurnObjectRight(iObj, g_fLocalTurnRotationForSmartMode);
							}
							float fStoreEntAngX = t.gridentityrotatex_f;
							float fStoreEntAngY = t.gridentityrotatey_f;
							float fStoreEntAngZ = t.gridentityrotatez_f;
							if (t.entityprofile[t.gridentity].ismarker == 2 && t.grideleprof.usespotlighting == 1)
							{
								// spotlights need to retain their rotation!
							}
							else
							{
								t.gridentityrotatex_f = ObjectAngleX(iObj);
								t.gridentityrotatey_f = ObjectAngleY(iObj);
								t.gridentityrotatez_f = ObjectAngleZ(iObj);
								t.gridentityrotatequatmode = 0;
								t.gridentityrotatequatx_f = 0;
								t.gridentityrotatequaty_f = 0;
								t.gridentityrotatequatz_f = 0;
								t.gridentityrotatequatw_f = 1;
							}
							if (fStoreEntAngX != t.gridentityrotatex_f || fStoreEntAngY != t.gridentityrotatey_f || fStoreEntAngZ != t.gridentityrotatez_f)
							{
								// rotation resets hitoffset as it does not translate when orientation changes
								if (bJustForInitialDragIn == false)
								{
									// but only when dragging, not initial placement
									fHitOffsetX = 0.001f;
									fHitOffsetY = 0.001f;
									fHitOffsetZ = 0.001f;
								}
							}
							if (t.entityprofile[t.gridentity].ismarker == 2)
							{
								fHitOffsetX = -fNormalX / 10.0f;
								fHitOffsetY = -fNormalY / 10.0f;
								fHitOffsetZ = -fNormalZ / 10.0f;
							}
							RotateObject(iObj, fStoreAngX, fStoreAngY, fStoreAngZ);
						}
					}
					else
					{
						// all non-smart modes should keep lights hanging down
						if (t.entityprofile[t.gridentity].ismarker == 2 && t.grideleprof.usespotlighting == 0)
						{
							t.gridentityrotatex_f = 270;
							t.gridentityrotatey_f = 0;
							t.gridentityrotatez_f = 0;
							t.gridentityrotatequatmode = 0;
							t.gridentityrotatequatx_f = 0;
							t.gridentityrotatequaty_f = 0;
							t.gridentityrotatequatz_f = 0;
							t.gridentityrotatequatw_f = 1;
							fPickedYAxis += 10.0f;
						}
					}
				}
			}

			// for ceiling objects, hang down from top of object
			if (iForwardFacing == 2 && t.entityprofile[t.gridentity].ismarker == 0)
			{
				fHitOffsetX = 0.001f;
				fHitOffsetY = ObjectSizeY(t.gridentityobj, 1) * 0.95f; // allow a small margin so can see if try to place on ground
				fHitOffsetZ = 0.001f;
			}

			// register the ray hit
			t.inputsys.localselectedrayhit = true;

			// confirm pick
			t.tx_f = fPickX;
			t.tz_f = fPickZ;
		}
		g_bAdjustPlaneXZUsingSurfaceXZ = true;
		if (hitentity > 0)
		{
			// if ray test on object, need to adjust plane to follow surface
			iLastHitObjectID = 0;
			iReusePickObjectID = 0;
			pReusePickObject = 0;
			iReusePickEntityID = 0;
			// found object under hovering cursor, match to entity index
			sObject* pHitObject = m_ObjectManager.FindObjectFromWickedObjectEntityID(hitentity);
			if (pref.iEnableDragDropStopSelectFromInside == 1)
			{
				// control whether can select an object from the inside
				if (pHitObject && CameraInsideObject(pHitObject) == true) pHitObject = NULL;
			}
			if (pHitObject)
			{
				pReusePickObject = pHitObject;
				for (int e = 1; e <= g.entityelementlist; e++)
				{
					if (t.entityelement[e].obj == pHitObject->dwObjectNumber)
					{
						iLastHitObjectID = pHitObject->dwObjectNumber;
						iReusePickObjectID = iLastHitObjectID;
						iReusePickEntityID = e;
						fReusePickHitX = t.tx_f;
						fReusePickHitY = fPickedYAxis;
						fReusePickHitZ = t.tz_f;
						break;
					}
				}
			}
		}
		else
		{
			// if not touching object surface, must be terrain, so restore plane in case plane was moved with 'g_bAdjustPlaneXZUsingSurfaceXZ'
			if (iObjectMoveMode == 2 && t.inputsys.mclick == 0 )
			{
				g_bResetPlaneAfterXZAdjust = true;
			}
		}
		if (pref.iEnableDragDropEntityMode && bDraggingActive && t.gridentityobj > 0) ShowObject(t.gridentityobj);
	}
	t.inputsys.picksystemused=2;

	if (!bDisableRubberBandMoving && pref.iEnableDragDropEntityMode && bDraggingActive)
	{
		//PE: Enable rubberband collision again.
		if (entityvisible.size() > 0)
		{
			for (int i = 0; i < (int)entityvisible.size(); i++)
			{
				int e = entityvisible[i].e;
				int obj = t.entityelement[e].obj;
				if (entityvisible[i].x == 1)
				{
					ShowObject(obj);
				}
			}
		}
	}

	t.tilex_f=t.tx_f;
	t.tiley_f=t.tz_f;
	#else
	// Early warning of resource VIDMEM loss, if matrix gone
	if ( MatrixExist(g.m4_projection) == 0 ) 
	{
		editor_detect_invalid_screen ( );
	}
	// Local cursor calculation
	t.inputsys.picksystemused=0;
	if (  t.grideditselect != 4 ) 
	{
		//  do not change these values if in zoom mode
		SetCurrentCamera (  0 );
		SetCameraRange (  DEFAULT_NEAR_PLANE, DEFAULT_FAR_PLANE );
		t.screenwidth_f=800.0;
		t.screenheight_f=600.0;
		GetProjectionMatrix (  g.m4_projection );
		GetViewMatrix (  g.m4_view );
		t.blank=InverseMatrix(g.m4_projection,g.m4_projection);
		t.blank=InverseMatrix(g.m4_view,g.m4_view);

		#if defined(ENABLEIMGUI) && !defined(USEOLDIDE) 
		//PE: Do not use (800.0x600.0) Just convert , we need any resolution to work.
		t.tadjustedtoareax_f = ((float) t.inputsys.xmouse / (float)GetDisplayWidth()) / ((float)GetDisplayWidth() / (float)GetChildWindowWidth(-1));
		t.tadjustedtoareay_f = ((float) t.inputsys.ymouse / (float)GetDisplayHeight()) / ((float)GetDisplayHeight() / (float)GetChildWindowHeight(-1));
		#else
		//  work out visible part of full backbuffer (i.e. 1212 of 1360)
		t.tadjustedtoareax_f=(GetDisplayWidth()+0.0)/(GetChildWindowWidth()+0.0);
		t.tadjustedtoareay_f=(GetDisplayHeight()+0.0)/(GetChildWindowHeight()+0.0);
		//  scale full mouse to fit in visible area
		t.tadjustedtoareax_f = ((t.inputsys.xmouse + 0.0) / 800.0) / t.tadjustedtoareax_f;
		t.tadjustedtoareay_f = ((t.inputsys.ymouse + 0.0) / 600.0) / t.tadjustedtoareay_f;
		#endif

		//  stretch scaled-mouse to projected -1 to +1
		SetVector4 (  g.v4_far,(t.tadjustedtoareax_f*2)-1,-((t.tadjustedtoareay_f*2)-1),0,1 );
		t.tx_f=GetXVector4(g.v4_far);
		t.ty_f=GetYVector4(g.v4_far);
		t.tz_f=GetZVector4(g.v4_far);
		TransformVector4 (  g.v4_far,g.v4_far,g.m4_projection );
		t.tx_f=GetXVector4(g.v4_far);
		t.ty_f=GetYVector4(g.v4_far);
		t.tz_f=GetZVector4(g.v4_far);
		SetVector3 ( g.v3_far, t.tx_f, t.ty_f, t.tz_f );
		TransformVectorCoordinates3 ( g.v3_far, g.v3_far, g.m4_view );
		t.tx_f=GetXVector3(g.v3_far);
		t.ty_f=GetYVector3(g.v3_far);
		t.tz_f=GetZVector3(g.v3_far);
		t.fx_f=CameraPositionX(0);
		t.fy_f=CameraPositionY(0);
		t.fz_f=CameraPositionZ(0);
		t.tx_f=t.tx_f-t.fx_f;
		t.ty_f=t.ty_f-t.fy_f;
		t.tz_f=t.tz_f-t.fz_f;
		t.tt_f=abs(t.tx_f)+abs(t.ty_f)+abs(t.tz_f);
		t.tx_f=t.tx_f/t.tt_f;
		t.ty_f=t.ty_f/t.tt_f;
		t.tz_f=t.tz_f/t.tt_f;
		t.tstep=10000;
		t.tdiststep_f=t.gridzoom_f;
		while ( t.tstep>0 ) 
		{
			t.fx_f=t.fx_f+(t.tx_f*t.tdiststep_f);
			t.fy_f=t.fy_f+(t.ty_f*t.tdiststep_f);
			t.fz_f=t.fz_f+(t.tz_f*t.tdiststep_f);
			// hit ground at
			if ( t.terrain.TerrainID>0 ) 
			{
				if ( BT_GetGroundHeight(t.terrain.TerrainID,t.fx_f,t.fz_f) > t.fy_f )  break;
			}
			else
			{
				if ( 1000.0 > t.fy_f )  break;
			}
			--t.tstep;
		}
		if ( t.tstep == 0 ) 
		{
			// no floor to target, have to get coordinate from pick system
			PickScreen2D23D ( t.inputsys.xmouse, t.inputsys.ymouse, 500 );
			t.fx_f=GetPickVectorX();
			t.fy_f=GetPickVectorY();
			t.fz_f=GetPickVectorZ();
			t.inputsys.picksystemused=1;
		}
		t.tx_f=t.fx_f;
		t.tz_f=t.fz_f;
		t.tilex_f=t.tx_f;
		t.tiley_f=t.tz_f;

		//  restore camera range
		editor_refreshcamerarange ( );
	}
	else
	{
		t.tx_f=t.tilex_f;
		t.tz_f=t.tiley_f;
	}
	#endif

	//  World cursor position
	t.inputsys.localx_f=t.tx_f;
	t.inputsys.localy_f=t.tz_f;
	t.tx=t.inputsys.localx_f/100.0;
	t.ty=t.inputsys.localy_f/100.0;
	if (  t.tx<0  )  t.tx = 0;
	if (  t.ty<0  )  t.ty = 0;
	if (  t.tx>t.maxx-1  )  t.tx = t.maxx-1;
	if (  t.ty>t.maxy-1  )  t.ty = t.maxy-1;
	t.inputsys.mmx=t.tx ; t.inputsys.mmy=t.ty;

	//  layer height is terrain Floor height
	#ifdef GGTERRAIN_USE_NEW_TERRAIN
	t.inputsys.localcurrentterrainheight_f = BT_GetGroundHeight(t.terrain.TerrainID,t.tx_f,t.tz_f);
	#else
	if (  t.terrain.TerrainID>0 ) 
	{
		t.inputsys.localcurrentterrainheight_f=BT_GetGroundHeight(t.terrain.TerrainID,t.tx_f,t.tz_f);
	}
	else
	{
		t.inputsys.localcurrentterrainheight_f=g.gdefaultterrainheight;
	}
	#endif

	// when placing waypoints, include entities as 'ground' to check
	t.inputsys.originallocalx_f = t.inputsys.localx_f;
	t.inputsys.originallocaly_f = t.inputsys.localy_f;

	#ifdef VRTECH
	extern bool bWaypointDrawmode;
	if ( t.gridentitysurfacesnap == 1 || t.onedrag > 0 || bWaypointDrawmode)
	{
		// only when finding place to place entity
		if ( t.gridentity > 0 || t.onedrag > 0 || bWaypointDrawmode)
		{
	#else
	if ( t.gridentitysurfacesnap == 1 || t.onedrag > 0)
	{
		// only when finding place to place entity
		if ( t.gridentity > 0 || t.onedrag > 0)
		{
	#endif
			// get distance of current terrain hit
			float fTDX = t.inputsys.localx_f - CameraPositionX();
			float fTDY = t.inputsys.localcurrentterrainheight_f - CameraPositionY();
			float fTDZ = t.inputsys.localy_f - CameraPositionZ();
			float fTerrDist = sqrt ( fabs(fTDX*fTDX) + fabs(fTDY*fTDY) * fabs(fTDZ*fTDZ) );

			// scan for surface point
			int iEntityOver = findentitycursorobj ( -1 );
			if ( iEntityOver != 0 )
			{
				// get distance of new surface point
				if (t.gridnearcameraclip > 0) 
				{
					fTDX = g.glastpickedx_f - GetFromVectorX();
					fTDY = g.glastpickedy_f - GetFromVectorY();
					fTDZ = g.glastpickedz_f - GetFromVectorZ();
				}
				else 
				{
					fTDX = g.glastpickedx_f - CameraPositionX();
					fTDY = g.glastpickedy_f - CameraPositionY();
					fTDZ = g.glastpickedz_f - CameraPositionZ();
				}
				float fSurfaceDist = sqrt ( fabs(fTDX*fTDX) + fabs(fTDY*fTDY) * fabs(fTDZ*fTDZ) );

				// if surface closer, use that
				if ( fSurfaceDist < fTerrDist )
				{
					t.inputsys.localx_f = g.glastpickedx_f;
					t.inputsys.localcurrentterrainheight_f = g.glastpickedy_f;
					t.inputsys.localy_f = g.glastpickedz_f;
				}
			}
		}
	}

	#ifdef WICKEDENGINE
	if (t.inputsys.picksystemused == 2)
	{
		// wicked pick system provides Y coordinate via terrainheight value
		t.inputsys.localcurrentterrainheight_f = fPickedYAxis;
		
		// LB: when clicking and dragging, we need to know ray hit Y so we can position
		// the widget plane at that height for correct movement of the object (otherwise it is at terrain height and goes wrong!)
		if (pref.iEnableDragDropEntityMode)
		{
			// monitor when not dragging, and use last height just before the click as the plane height
			if (bDraggingActive == false)
			{
				t.inputsys.localselectedplaneheight_f = fPickedYAxis;
			}
		}
	}
	#endif

	//  height at which zoom editing happens
	t.layerheight_f=t.zoomviewtargety_f+100.0;

	// wicked can dynamically flatten terrain if flagged
	#ifdef WICKEDENGINE
	/* cannot guarentee same XYZ from ray cast! Makes building jump about
	if ( t.gridentity > 0 && t.gridentityobj > 0 && t.gridedit.autoflatten == 1)
	{
		float x = ObjectPositionX(t.gridentityobj);
		float z = ObjectPositionZ(t.gridentityobj);
		float ang = ObjectAngleY(t.gridentityobj);
		if (g_iGridEntityFlattener == -1)
		{
			float sx = ObjectSizeX(t.gridentityobj, 1) * 1.2f;
			float sz = ObjectSizeZ(t.gridentityobj, 1) * 1.2f;
			g_iGridEntityFlattener = GGTerrain_AddFlatRect(x, z, sx, sz, ang);
		}
		else
		{
			GGTerrain_UpdateFlatArea(g_iGridEntityFlattener, x, z, ang);
		}
	}
	else
	{
		if (g_iGridEntityFlattener != -1)
		{
			GGTerrain_RemoveFlatArea(g_iGridEntityFlattener);
			g_iGridEntityFlattener = -1;
		}
	}
	*/
	#endif
}

void editor_updatemarkervisibility ( void )
{
	for ( t.e = 1 ; t.e<=  g.entityelementlist; t.e++ )
	{
		t.entid=t.entityelement[t.e].bankindex;
		if (  t.entityprofile[t.entid].ismarker != 0 ) 
		{
			t.obj=t.entityelement[t.e].obj;
			if (  t.obj>0 ) 
			{
				if (  ObjectExist(t.obj) == 1 ) 
				{
					if (  t.gridentityhidemarkers == 0 ) 
					{
						ShowObject (  t.obj );
					}
					else
					{
						HideObject (  t.obj );
					}
				}
			}
		}
	}
	if (  t.gridentityhidemarkers == 0 ) 
	{
		waypoint_showall ( );
	}
	else
	{
		waypoint_hideall ( );
	}
}

void editor_disableforzoom ( void )
{
	#ifdef FPSEXCHANGE
	OpenFileMap (  2, "FPSEXCHANGE" );
	SetFileMapDWORD (  2, 850, 1 );
	SetEventAndWait (  2 );
	#endif
}

void editor_enableafterzoom ( void )
{
	#ifdef FPSEXCHANGE
	OpenFileMap (  2, "FPSEXCHANGE" );
	SetFileMapDWORD (  2, 850, 0 );
	SetEventAndWait (  2 );
	editor_cutcopyclearstate ( );
	#endif
}

void editor_init ( void )
{
	image_setlegacyimageloading(true);
	//  Load editor images
	SetMipmapNum(1); //PE: mipmaps not needed.
	t.strwork = ""; t.strwork = t.strwork + "languagebank\\"+g.language_s+"\\artwork\\quick-help.png";
	LoadImage (  t.strwork.Get(), g.editorimagesoffset+1 );
	LoadImage (  "editors\\gfx\\memorymeter.png",g.editorimagesoffset+2 );
	#ifdef WICKEDENGINE
	LoadImage (  "editors\\gfx\\4.png",g.editorimagesoffset+3 );
	LoadImage (  "editors\\gfx\\5.png",g.editorimagesoffset+4 );
	#else
	LoadImage (  "editors\\gfx\\4.bmp",g.editorimagesoffset+3 );
	LoadImage (  "editors\\gfx\\5.bmp",g.editorimagesoffset+4 );
	#endif
	t.strwork = ""; t.strwork = t.strwork + "languagebank\\"+g.language_s+"\\artwork\\gurumeditation.png";
	LoadImage (  t.strwork.Get() ,g.editorimagesoffset+5 );
	t.strwork = ""; t.strwork = t.strwork + "languagebank\\"+g.language_s+"\\artwork\\gurumeditationoff.png";
	LoadImage ( t.strwork.Get() ,g.editorimagesoffset+6 );

	// +7 reserved (below)

	// Test Game prompt
	t.strwork = ""; t.strwork = t.strwork + "languagebank\\"+g.language_s+"\\artwork\\quick-start-testlevel-prompt.png";
	LoadImage ( t.strwork.Get(), g.editorimagesoffset+61 );

	// Cursor for entity highlighting
	LoadImage ( "editors\\gfx\\9.png",g.editorimagesoffset+7 );
	#ifdef WICKEDENGINE
	LoadImage ( "editors\\gfx\\13.png",g.editorimagesoffset+13 );
	#else
	LoadImage ( "editors\\gfx\\13.bmp",g.editorimagesoffset+13 );
	#endif

	#ifdef VRTECH
	LoadImage ( "editors\\gfx\\14-white.png",g.editorimagesoffset+14 );
	if (!GetImageExistEx(g.editorimagesoffset + 14))
		LoadImage("editors\\gfx\\14.png", g.editorimagesoffset + 14);
	LoadImage ( "editors\\gfx\\14-red.png",g.editorimagesoffset+16 );
	LoadImage ( "editors\\gfx\\14-green.png",g.editorimagesoffset+17 );
	#else
	LoadImage("editors\\gfx\\14.png", g.editorimagesoffset + 14);
	#endif

	#ifdef WICKEDENGINE
	LoadImage (  "editors\\gfx\\26.png",g.editorimagesoffset+26 );
	#else
	LoadImage ( "editors\\gfx\\18.png",g.editorimagesoffset+18 );	
	LoadImage (  "editors\\gfx\\26.bmp",g.editorimagesoffset+26 );
	#endif
	LoadImage ( "editors\\gfx\\cursor.dds",g.editorimagesoffset+10 );

	//  F9 Edit Mode Graphical Prompts
	t.strwork = ""; t.strwork = t.strwork + "languagebank\\"+g.language_s+"\\artwork\\f9-help-terrain.png";
	LoadImage ( t.strwork.Get() ,g.editorimagesoffset+21 );
	t.strwork = ""; t.strwork = t.strwork + "languagebank\\"+g.language_s+"\\artwork\\f9-help-entity.png";
	LoadImage ( t.strwork.Get() ,g.editorimagesoffset+22 );
	t.strwork = ""; t.strwork = t.strwork + "languagebank\\"+g.language_s+"\\artwork\\f9-help-conkit.png";
	LoadImage ( t.strwork.Get() ,g.editorimagesoffset+23 );

	// new images for editor extra help
	image_setlegacyimageloading(true);
	#ifdef VRTECH
	t.strwork = ""; t.strwork = t.strwork + "languagebank\\"+g.language_s+"\\artwork\\testgamelayout-noweapons.png";
 	LoadImage (  t.strwork.Get(), g.editorimagesoffset+27 );
	t.strwork = ""; t.strwork = t.strwork + "languagebank\\"+g.language_s+"\\artwork\\testgamelayout-vr.png";
 	LoadImage (  t.strwork.Get(), g.editorimagesoffset+28 );
	#endif
	image_setlegacyimageloading(false);

	//  Also loaded by interactive mode when active
	#ifdef VRTECH
	///LoadImage (  "languagebank\\neutral\\gamecore\\huds\\interactive\\close-highlight.png",g.interactiveimageoffset+15 );
	#else
	LoadImage (  "languagebank\\neutral\\gamecore\\huds\\interactive\\close-highlight.png",g.interactiveimageoffset+15 );
	#endif

	//  for overlays on map editor view
	if (  FileExist("editors\\gfx\\resources.png") == 1 ) 
	{
		LoadImage (  "editors\\gfx\\resources.png",g.editordrawlastimagesoffset+1 );
	}
	if (  FileExist("editors\\gfx\\resourceslow.png") == 1 ) 
	{
		LoadImage (  "editors\\gfx\\resourceslow.png",g.editordrawlastimagesoffset+2 );
	}
	if (  FileExist("editors\\gfx\\resourcesgone.png") == 1 ) 
	{
		LoadImage (  "editors\\gfx\\resourcesgone.png",g.editordrawlastimagesoffset+3 );
	}
	if (  FileExist("editors\\gfx\\resourcesworking.png") == 1 ) 
	{
		LoadImage (  "editors\\gfx\\resourcesworking.png",g.editordrawlastimagesoffset+4 );
	}
	SetMipmapNum(-1);
	image_setlegacyimageloading(false);

	//  Work area entity cursor (placeholder for instance of target expanded by 1.05 to make shell highligher)
	#ifdef WICKEDENGINE
	WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_CURSOROBJECT);
	#endif

	MakeObjectPlane (  t.editor.objectstartindex+5,150,150  ); 
	XRotateObject (  t.editor.objectstartindex+5,90 );
	TextureObject (  t.editor.objectstartindex+5,g.editorimagesoffset+7 );
	SetObjectMask (  t.editor.objectstartindex+5, 1 );
	SetObjectTransparency (  t.editor.objectstartindex+5,2 );
	modifyplaneimagestrip(5,8,1);
	SetObjectCollisionOff (  t.editor.objectstartindex+5 );
	//DisableObjectZDepth (  t.editor.objectstartindex+5 ); //PE: UpdateLayerInner layer 4 do not render bNewZLayerObject in pass 0 so is clipped.
	SetObjectLight (  t.editor.objectstartindex+5,0 );
	HideObject (  t.editor.objectstartindex+5 );
	OffsetLimb (  t.editor.objectstartindex+5,0,0,0,-1 );
	SetObjectEffect ( t.editor.objectstartindex+5, g.guishadereffectindex );

	//  cylinder to indicate resources in editor used (and warning)
	MakeObjectCylinder (  t.editor.objectstartindex+7,50 );
	SetObjectCollisionOff (  t.editor.objectstartindex+7 );
	SetObjectLight (  t.editor.objectstartindex+7,0 );
	DisableObjectZDepth (  t.editor.objectstartindex+7 );
	DisableObjectZRead (  t.editor.objectstartindex+7 );
	TextureObject (  t.editor.objectstartindex+7,g.editordrawlastimagesoffset+1 );
	LockObjectOn (  t.editor.objectstartindex+7 );
	ScaleObject (  t.editor.objectstartindex+7,2,0,2 );
	RotateObject (  t.editor.objectstartindex+7,0,0,90 );
	PositionObject (  t.editor.objectstartindex+7,0,-117.5,200 );
	SetObjectMask (  t.editor.objectstartindex+7, 1 );

	#ifdef WICKEDENGINE
	WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_NORMAL);
	#endif

	//  Setup camera
	BackdropColor (  Rgb(0,0,0) );
	// `set camera range 10,10000 now set in _editor_overallfunctionality

	SetLightRange (  0,10000 );
	SetAmbientLight (  75 );
	#ifdef WICKEDENGINE
	SetCameraFOV(45); //PE: default 45 in wicked.
	#else
	SetCameraFOV (  90 );
	#endif
	SetAutoCamOff (  );

	//  PositionCamera (  )
	t.gridscale_f=((800/2)/8)/t.gridzoom_f;
	t.workareax=800 ; t.workareay=600;
	#ifdef GGTERRAIN_USE_NEW_TERRAIN
	t.borderx_f=1024.0*50.0 ; t.cx_f=GGORIGIN_X;
	t.bordery_f=1024.0*50.0 ; t.cy_f=GGORIGIN_Z;
	#else
	t.borderx_f=1024.0*50.0 ; t.cx_f=t.borderx_f/2;
	t.bordery_f=1024.0*50.0 ; t.cy_f=t.bordery_f/2;
	#endif
	editor_restoreeditcamera ( );

	//  Reset statu bar Text (  )
	t.statusbar_s="" ; t.laststatusbar_s="";
}

void editor_makeundergroundobj ( void )
{
	//  takes tobj,tobjx#,tobjy#,tobjz#
	t.tobjoffx_f=GetObjectCollisionCenterX(t.tobj);
	t.tobjoffy_f=GetObjectCollisionCenterY(t.tobj);
	t.tobjoffz_f=GetObjectCollisionCenterZ(t.tobj);
	t.tobjsizex_f=ObjectSizeX(t.tobj,1);
	t.tobjsizey_f=ObjectSizeY(t.tobj,1);
	t.tobjsizez_f=ObjectSizeZ(t.tobj,1);
	DeleteObject ( t.tobj );
	MakeObjectBox ( t.tobj,t.tobjsizex_f,t.tobjsizey_f,t.tobjsizez_f );
	//ColorObject ( t.tobj,Rgb(255,255,0) );
	PositionObject ( t.tobj,t.tobjx_f,t.tobjy_f,t.tobjz_f );
	OffsetLimb ( t.tobj,0,t.tobjoffx_f,t.tobjoffy_f,t.tobjoffz_f );
	DisableObjectZRead ( t.tobj );
	SetObjectWireframe ( t.tobj,1 );
	SetObjectMask ( t.tobj, 1 );
	SetObjectEffect ( t.tobj, g.guiwireframeshadereffectindex );
	SetObjectEmissive ( t.tobj, Rgb(255,255,0) );
}

void editor_undergroundscan ( void )
{
	#ifdef WICKEDENGINE
	// going to use col shader eventually for seeing objects 'under the terrain' (eventualeeee)
	#else
	//  will detect entities under the ground and convert them to place holders
	if (  Timer()>t.gundergroundscantime ) 
	{
		t.gundergroundscantime=Timer()+100;
		for ( t.e = 1; t.e <= g.entityelementlist; t.e++ )
		{
			t.tentid=t.entityelement[t.e].bankindex;
			if ( t.entityprofile[t.tentid].ismarker == 0 && t.entityprofile[t.tentid].isebe == 0 ) 
			{
				if ( t.entityelement[t.e].beenmoved == 1 ) 
				{
					t.entityelement[t.e].beenmoved=0;
					t.tobj=t.entityelement[t.e].obj;
					if (  t.tobj>0 ) 
					{
						if (  ObjectExist(t.tobj) == 1 ) 
						{
							// get original vector, transform it and check against terrain floor
							bool bUnderground = true;
							sObject* pObj = GetObjectData(t.tobj);
							for ( int iCorner = 0; iCorner < 8; iCorner++ )
							{
								GGVECTOR3 vec = pObj->collision.vecMin;
								if ( iCorner==1 ) { vec.x = pObj->collision.vecMax.x; }
								if ( iCorner==2 ) { vec.y = pObj->collision.vecMax.y; }
								if ( iCorner==3 ) { vec.x = pObj->collision.vecMax.x; vec.y = pObj->collision.vecMax.y; }
								if ( iCorner==4 ) {                                   vec.z = pObj->collision.vecMax.z; }
								if ( iCorner==5 ) { vec.x = pObj->collision.vecMax.x; vec.z = pObj->collision.vecMax.z; }
								if ( iCorner==6 ) { vec.y = pObj->collision.vecMax.y; vec.z = pObj->collision.vecMax.z; }
								if ( iCorner==7 ) { vec.x = pObj->collision.vecMax.x; vec.y = pObj->collision.vecMax.y; vec.z = pObj->collision.vecMax.z; }
								GGVec3TransformCoord ( &vec, &vec, &pObj->position.matWorld );
								if (  t.terrain.TerrainID>0 ) 
									t.tgrnd_f=BT_GetGroundHeight(t.terrain.TerrainID,vec.x,vec.z);
								else
									t.tgrnd_f=1000.0;
								if ( vec.y > t.tgrnd_f ) 
									bUnderground = false;
							}
							// act if underground status changed (make wireframe)
							if (  t.entityelement[t.e].underground == 0 ) 
							{
								if ( bUnderground == true ) 
								{
									//  entity underground
									t.entityelement[t.e].underground=1;
									t.tobjy_f=ObjectPositionY(t.tobj);
									t.tobjx_f=ObjectPositionX(t.tobj);
									t.tobjz_f=ObjectPositionZ(t.tobj);
									editor_makeundergroundobj ( );
									t.entityelement[t.e].isclone=1;
								}
							}
							else
							{
								if ( bUnderground == false ) 
								{
									//  entity above ground
									t.entityelement[t.e].underground=0;
									t.tte = t.e ; entity_converttoinstance ( );
								}
							}
						}
					}
				}
			}
		}
	}

	//  also detect same for gridentity
	if ( t.gridentity>0 && t.gridentityobj>0 ) 
	{
		if ( t.entityprofile[t.gridentity].isebe == 0 )
		{
			t.tobj=t.gridentityobj;
			if (  ObjectExist(t.tobj) == 1 ) 
			{
				t.tobjx_f=ObjectPositionX(t.tobj);
				t.tobjy_f=ObjectPositionY(t.tobj)+GetObjectCollisionCenterY(t.tobj)+(ObjectSizeY(t.tobj,1)/2)+LimbOffsetY(t.tobj,0);
				t.tobjz_f=ObjectPositionZ(t.tobj);
				if (  t.terrain.TerrainID>0 ) 
				{
					t.tgrnd_f=BT_GetGroundHeight(t.terrain.TerrainID,t.tobjx_f,t.tobjz_f);
				}
				else
				{
					t.tgrnd_f=1000.0;
				}
				if (  t.gridentityunderground == 0 ) 
				{
					if (  t.tobjy_f<t.tgrnd_f ) 
					{
						//  grid entity underground
						t.gridentityunderground=1;
						t.tobj=t.gridentityobj;
						editor_makeundergroundobj ( );
					}
				}
				else
				{
					if (  t.tobjy_f >= t.tgrnd_f ) 
					{
						//  grid entity above ground
						t.gridentityunderground=0;
						gridedit_recreateentitycursor ( );
					}
				}
			}
		}
	}
	#endif
}

void editor_restoreobjhighlightifnotrubberbanded ( int highlightingtentityobj )
{
	if ( highlightingtentityobj>0 ) 
	{
		if ( ObjectExist(highlightingtentityobj) == 1 ) 
		{
			bool bHighlightedFromRubberBandSelection = false;
			if ( g.entityrubberbandlist.size() > 0 )
			{
				for ( int i = 0; i < (int)g.entityrubberbandlist.size(); i++ )
				{
					int e = g.entityrubberbandlist[i].e;
					int tobj = t.entityelement[e].obj;
					if ( highlightingtentityobj == tobj )
						bHighlightedFromRubberBandSelection = true;
				}
			}
			if ( bHighlightedFromRubberBandSelection == false )
			{
				// dehighlight primary highlighted entity
#ifdef WICKEDENGINE
				bool bValid = true;
				if (t.geditorhighlightingtentityID > 0)
				{
					int mi = t.entityelement[t.geditorhighlightingtentityID].bankindex;
					if (mi > 0 && t.entityprofile[mi].bIsDecal) bValid = false;
				}
				if(bValid)
#endif
					SetAlphaMappingOn ( highlightingtentityobj, 100 );

				// and also dehighlight any children that may have been highlighted as well
				if ( t.tstoreentityindexofprimaryhightlighted > 0 )
				{
					gridedit_clearentityrubberbandlist();
					t.tstoreentityindexofprimaryhightlighted = 0;
				}
				#ifdef WICKEDENGINE
				//PE: SetAlphaMappingOn will overwrite basecolor.w
				//PE: Restore org colors.
				sObject* pObject = g_ObjectList[highlightingtentityobj];
				if (pObject)
				{
					for (int iMesh = 0; iMesh < pObject->iMeshCount; iMesh++)
						WickedCall_SetMeshMaterial(pObject->ppMeshList[iMesh]);
				}
				if (!bValid)
				{
					//Setup decal.
					SetupDecalObject(highlightingtentityobj, t.geditorhighlightingtentityID);
				}
				#endif

			}
		}
	}
}

void editor_restoreentityhighlightobj ( void )
{
	if ( t.geditorhighlightingtentityobj>0 ) 
	{
		editor_restoreobjhighlightifnotrubberbanded ( t.geditorhighlightingtentityobj );
		t.geditorhighlightingtentityobj=0;
	}
}

void editor_rec_checkifindexinparentchain ( int entityindex, bool* pbPartOfParentChildGroup )
{
	for ( int te = 1; te <= g.entityelementlist; te++ )
	{
		if ( t.entityelement[te].iHasParentIndex == entityindex && t.entityelement[te].obj > 0 )
		{
			*pbPartOfParentChildGroup = true;
			editor_rec_checkifindexinparentchain ( te, pbPartOfParentChildGroup );
		}
	}
}

void editor_rec_addchildrentorubberband ( int entityindex )
{
	for ( int te = 1; te <= g.entityelementlist; te++ )
	{
		if ( t.entityelement[te].iHasParentIndex == entityindex && t.entityelement[te].obj > 0 )
		{
			gridedit_addEntityToRubberBandHighlights ( te );
			editor_rec_addchildrentorubberband ( te );
		}
	}
}

void editor_refreshentitycursor ( void )
{
	//  new highligher for selected entities
	t.tentityobj=0 ; t.tentstaticmode=0;
	if ( t.gridentityobj>0 ) 
	{
		t.tentityobj=t.gridentityobj;
		t.tentstaticmode=t.gridentitystaticmode;
	}
	else
	{
		if ( t.tentitytoselect>0 ) 
		{
			if ( t.tentitytoselect <= ArrayCount(t.entityelement) ) 
			{
				t.tentityobj=t.entityelement[t.tentitytoselect].obj;
				t.tentstaticmode=t.entityelement[t.tentitytoselect].staticflag;
				t.ttentid=t.entityelement[t.tentitytoselect].bankindex;
				if ( t.entityprofile[t.ttentid].ismarker == 0 && t.entityprofile[t.ttentid].isebe == 0 ) 
				{
					if ( t.entityelement[t.tentitytoselect].isclone == 1 && t.entityelement[t.tentitytoselect].underground == 0 ) 
					{
						if ( t.entityelement[t.tentitytoselect].editorlock == 0 ) 
						{
							//  restore clone back to instance if no more entity lock
							t.tobj=t.tentityobj ; t.tte=t.tentitytoselect;
							entity_converttoinstance ( );
						}
					}
				}
			}
		}
	}
	if ( t.tentityobj>0 ) 
	{
		if ( ObjectExist(t.tentityobj) == 1 ) 
		{
			// do not reset if extracted and draggging parent/children around
			if ( t.gridentityextractedindex == 0 )
			{
				#ifdef WICKEDENGINE
				if (t.tentitytoselect > 0)
				{
					WickedSetEntityId(t.entityelement[t.tentitytoselect].bankindex);
					WickedSetElementId(t.tentitytoselect);
				}
				t.geditorhighlightingtentityID = t.tentitytoselect;

				#endif
				editor_restoreentityhighlightobj();
				#ifdef WICKEDENGINE
				WickedSetEntityId(-1);
				WickedSetElementId(0);
				#endif
			}

			// if obj is instance, and using entity_basic shader, this sets GlowIntensity constant
			int iAlphaHighlightCode = 100;
			if ( t.tentstaticmode == 0 ) 
			{
				if ( t.gridedit.autoflatten == 1 && t.gridentityobj>0 ) 
					iAlphaHighlightCode = 104;
				else
					iAlphaHighlightCode = 103;
			}
			else
			{
				if ( t.gridedit.autoflatten == 1 && t.gridentityobj>0 ) 
					iAlphaHighlightCode = 102;
				else
					iAlphaHighlightCode = 101;
			}
			SetAlphaMappingOn ( t.tentityobj, iAlphaHighlightCode );

			//PE: This overwrite out wicked basecolor.w

			// check if this entity is a parent to children, and highlight them too
			if ( t.tentitytoselect > 0 ) 
			{
				t.tstoreentityindexofprimaryhightlighted = t.tentitytoselect;
				editor_rec_addchildrentorubberband ( t.tentitytoselect );
			}

			// record primary entity object being highlighted
			t.geditorhighlightingtentityobj = t.tentityobj;
		}
	}
	else
	{
		#ifdef WICKEDENGINE
		if (t.geditorhighlightingtentityobj > 0)
		{
			int foundit = 0;
			for (int i = 1; i < t.entityelement.size(); i++)
			{
				if (t.entityelement[i].obj == t.geditorhighlightingtentityobj)
				{
					WickedSetEntityId(t.entityelement[i].bankindex);
					WickedSetElementId(i);
					t.geditorhighlightingtentityID = i;
					editor_restoreentityhighlightobj();
					WickedSetEntityId(-1);
					WickedSetElementId(0);
					break;
				}
			}
		}
		#else
		editor_restoreentityhighlightobj ( );
		#endif
	}
}

void editor_hideall3d ( void )
{
	SetCurrentCamera (  0 );
	PositionCamera (  199999,99999,99999 );
	PointCamera (  199999,100999,99999 );
	if ( gbWelcomeSystemActive == false ) 
	{
		Sync ( ); Sync ( );
	}
}

void editor_restoreeditcamera ( void )
{
	#ifdef WICKEDENGINE
	// when returning from a VR session, need to restore camera perspective and original resolution settings
	master.masterrenderer.Restore3DResolution();
	#endif

	// editor starting camera position - reset camera
	SetCurrentCamera (  0 );
	PositionCamera ( t.cx_f, 600*t.gridzoom_f, t.cy_f );
	PointCamera ( t.cx_f, 0, t.cy_f );
	#ifdef WICKEDENGINE
	SetCameraFOV(45); //PE: default 45 in wicked.
	#else
	SetCameraFOV (  90 );
	#endif
}

void editor_clearlibrary ( void )
{
	// Delete all libraries
	for ( t.tabs = 1; t.tabs <= 3; t.tabs++ )
	{
		SetFileMapDWORD ( 1, 534, t.tabs );
		SetFileMapDWORD ( 1, 542, 1 );
		SetEventAndWait ( 1 );
		while ( GetFileMapDWORD ( 1, 542 ) == 1 ) 
		{
			SetEventAndWait ( 1 );
		}
	}

	// ENTITY TAB
	t.tadd=1;

	// And create default NEW icons
	t.t1_s=t.strarr_s[347] ; t.t2_s="files\\editors\\gfx\\missing.bmp";
	SetFileMapDWORD ( 1, 508, t.tadd );
	SetFileMapString ( 1, 1000, cstr(g.mysystem.root_s+t.t2_s).Get() );
	SetFileMapString ( 1, 1256, t.t1_s.Get() );
	SetFileMapDWORD ( 1, 500, 1 );
	SetEventAndWait ( 1 );
	while ( GetFileMapDWORD(1, 500) == 1 ) 
	{
		SetEventAndWait ( 1 );
	}

	// MARKERS TAB
	t.tadd=2;

	//  Determine if extra ZONES included
	#ifdef VRTECH
	t.tstoryzoneincluded=25;
	if ( g.vrqcontrolmode != 0 )
		t.tstoryzoneincluded=23;
	// Default markers
	for ( t.tt = 0 ; t.tt <= t.tstoryzoneincluded; t.tt++ )
	{
		if ( g.vrqcontrolmode != 0 )
		{
			if (  t.tt == 0 ) { t.t1_s = t.strarr_s[349]  ; t.t2_s = "files\\entitybank\\_markers\\player start.bmp"; }
			if (  t.tt == 1 ) { t.t1_s = t.strarr_s[659]  ; t.t2_s = "files\\entitybank\\_markers\\multiplayer start.bmp"; }
			if (  t.tt == 2 ) { t.t1_s = t.strarr_s[351]  ; t.t2_s = "files\\entitybank\\_markers\\white light.bmp"; }
			if (  t.tt == 3 ) { t.t1_s = t.strarr_s[352]  ; t.t2_s = "files\\entitybank\\_markers\\red light.bmp"; }
			if (  t.tt == 4 ) { t.t1_s = t.strarr_s[353]  ; t.t2_s = "files\\entitybank\\_markers\\green light.bmp"; }
			if (  t.tt == 5 ) { t.t1_s = t.strarr_s[354]  ; t.t2_s = "files\\entitybank\\_markers\\blue light.bmp"; }
			if (  t.tt == 6 ) { t.t1_s = t.strarr_s[355]  ; t.t2_s = "files\\entitybank\\_markers\\yellow light.bmp"; }
			if (  t.tt == 7 ) { t.t1_s = t.strarr_s[356]  ; t.t2_s = "files\\entitybank\\_markers\\purple light.bmp"; }
			if (  t.tt == 8 ) { t.t1_s = t.strarr_s[357]  ; t.t2_s = "files\\entitybank\\_markers\\cyan light.bmp"; }
			if (  t.tt == 9 ) { t.t1_s = t.strarr_s[360]  ; t.t2_s = "files\\entitybank\\_markers\\win zone.bmp"; }
			if (  t.tt == 10 ) { t.t1_s = t.strarr_s[361]  ; t.t2_s = "files\\entitybank\\_markers\\trigger zone.bmp"; }
			if (  t.tt == 11 ) { t.t1_s = "Audio Zone"  ; t.t2_s = "files\\entitybank\\_markers\\audio zone.bmp"; }
			if (  t.tt == 12 ) { t.t1_s = "Video Zone"  ; t.t2_s = "files\\entitybank\\_markers\\video zone.bmp"; }
			if (  t.tt == 13 ) { t.t1_s = "Floor Zone"; t.t2_s = "files\\entitybank\\_markers\\floor zone.bmp"; }
			if (  t.tt == 14 ) { t.t1_s = "Image Zone"; t.t2_s = "files\\entitybank\\_markers\\image zone.bmp"; }
			if (  t.tt == 15 ) { t.t1_s = "Text Zone"; t.t2_s = "files\\entitybank\\_markers\\text zone.bmp"; }
			if (  t.tt == 16 ) { t.t1_s = "Ambience Zone"; t.t2_s = "files\\entitybank\\_markers\\ambience zone.bmp"; }
			if (  t.tt == 17 ) { t.t1_s = "White Spotlight"; t.t2_s = "files\\entitybank\\_markers\\white light spot.bmp"; }
			if (  t.tt == 18 ) { t.t1_s = "Red Spotlight"; t.t2_s = "files\\entitybank\\_markers\\red light spot.bmp"; }
			if (  t.tt == 19 ) { t.t1_s = "Green Spotlight"; t.t2_s = "files\\entitybank\\_markers\\green light spot.bmp"; }
			if (  t.tt == 20 ) { t.t1_s = "Blue Spotlight"; t.t2_s = "files\\entitybank\\_markers\\blue light spot.bmp"; }
			if (  t.tt == 21 ) { t.t1_s = "Yellow Spotlight"; t.t2_s = "files\\entitybank\\_markers\\yellow light spot.bmp"; }
			if (  t.tt == 22 ) { t.t1_s = "Purple Spotlight"; t.t2_s = "files\\entitybank\\_markers\\purple light spot.bmp"; }
			if (  t.tt == 23 ) { t.t1_s = "Cyan Spotlight"; t.t2_s = "files\\entitybank\\_markers\\cyan light spot.bmp"; }
		}
		else
		{
			if (  t.tt == 0 ) { t.t1_s = t.strarr_s[349]  ; t.t2_s = "files\\entitybank\\_markers\\player start.bmp"; }
			if (  t.tt == 1 ) { t.t1_s = t.strarr_s[350]  ; t.t2_s = "files\\entitybank\\_markers\\player checkpoint.bmp"; }
			if (  t.tt == 2 ) { t.t1_s = t.strarr_s[658]  ; t.t2_s = "files\\entitybank\\_markers\\cover zone.bmp"; }
			if (  t.tt == 3 ) { t.t1_s = t.strarr_s[659]  ; t.t2_s = "files\\entitybank\\_markers\\multiplayer start.bmp"; }
			if (  t.tt == 4 ) { t.t1_s = t.strarr_s[351]  ; t.t2_s = "files\\entitybank\\_markers\\white light.bmp"; }
			if (  t.tt == 5 ) { t.t1_s = t.strarr_s[352]  ; t.t2_s = "files\\entitybank\\_markers\\red light.bmp"; }
			if (  t.tt == 6 ) { t.t1_s = t.strarr_s[353]  ; t.t2_s = "files\\entitybank\\_markers\\green light.bmp"; }
			if (  t.tt == 7 ) { t.t1_s = t.strarr_s[354]  ; t.t2_s = "files\\entitybank\\_markers\\blue light.bmp"; }
			if (  t.tt == 8 ) { t.t1_s = t.strarr_s[355]  ; t.t2_s = "files\\entitybank\\_markers\\yellow light.bmp"; }
			if (  t.tt == 9 ) { t.t1_s = t.strarr_s[356]  ; t.t2_s = "files\\entitybank\\_markers\\purple light.bmp"; }
			if (  t.tt == 10 ) { t.t1_s = t.strarr_s[357]  ; t.t2_s = "files\\entitybank\\_markers\\cyan light.bmp"; }
			if (  t.tt == 11 ) { t.t1_s = t.strarr_s[360]  ; t.t2_s = "files\\entitybank\\_markers\\win zone.bmp"; }
			if (  t.tt == 12 ) { t.t1_s = t.strarr_s[361]  ; t.t2_s = "files\\entitybank\\_markers\\trigger zone.bmp"; }
			if (  t.tt == 13 ) { t.t1_s = t.strarr_s[362]  ; t.t2_s = "files\\entitybank\\_markers\\sound zone.bmp"; }
			if (  t.tt == 14 ) { t.t1_s = t.strarr_s[607]  ; t.t2_s = "files\\entitybank\\_markers\\story zone.bmp"; }
			if (  t.tt == 15 ) { t.t1_s = "Floor Zone"; t.t2_s = "files\\entitybank\\_markers\\floor zone.bmp"; }
			if (  t.tt == 16 ) { t.t1_s = "Image Zone"; t.t2_s = "files\\entitybank\\_markers\\image zone.bmp"; }
			if (  t.tt == 17 ) { t.t1_s = "Text Zone"; t.t2_s = "files\\entitybank\\_markers\\text zone.bmp"; }
			if (  t.tt == 18 ) { t.t1_s = "Ambience Zone"; t.t2_s = "files\\entitybank\\_markers\\ambience zone.bmp"; }
			if (  t.tt == 19 ) { t.t1_s = "White Spotlight"; t.t2_s = "files\\entitybank\\_markers\\white light spot.bmp"; }
			if (  t.tt == 20 ) { t.t1_s = "Red Spotlight"; t.t2_s = "files\\entitybank\\_markers\\red light spot.bmp"; }
			if (  t.tt == 21 ) { t.t1_s = "Green Spotlight"; t.t2_s = "files\\entitybank\\_markers\\green light spot.bmp"; }
			if (  t.tt == 22 ) { t.t1_s = "Blue Spotlight"; t.t2_s = "files\\entitybank\\_markers\\blue light spot.bmp"; }
			if (  t.tt == 23 ) { t.t1_s = "Yellow Spotlight"; t.t2_s = "files\\entitybank\\_markers\\yellow light spot.bmp"; }
			if (  t.tt == 24 ) { t.t1_s = "Purple Spotlight"; t.t2_s = "files\\entitybank\\_markers\\purple light spot.bmp"; }
			if (  t.tt == 25 ) { t.t1_s = "Cyan Spotlight"; t.t2_s = "files\\entitybank\\_markers\\cyan light spot.bmp"; }
		}
		SetFileMapDWORD (  1, 508, t.tadd );
		SetFileMapString (  1, 1000, cstr(g.mysystem.root_s+t.t2_s).Get() );
		SetFileMapString (  1, 1256, t.t1_s.Get() );
		SetFileMapDWORD (  1, 500, 1 );
		SetEventAndWait (  1 );
		while (  GetFileMapDWORD(1, 500) == 1 ) 
		{
			SetEventAndWait (  1 );
		}
	}

	//  actual entity names of the markers
	Dim ( t.markerentitybank_s, 30 );
	if ( g.vrqcontrolmode != 0 )
	{
		t.markerentitybank_s[1]="_markers\\player start.fpe";
		t.markerentitybank_s[2]="_markers\\multiplayer start.fpe";
		t.markerentitybank_s[3]="_markers\\white light.fpe";
		t.markerentitybank_s[4]="_markers\\red light.fpe";
		t.markerentitybank_s[5]="_markers\\green light.fpe";
		t.markerentitybank_s[6]="_markers\\blue light.fpe";
		t.markerentitybank_s[7]="_markers\\yellow light.fpe";
		t.markerentitybank_s[8]="_markers\\purple light.fpe";
		t.markerentitybank_s[9]="_markers\\cyan light.fpe";
		t.markerentitybank_s[10]="_markers\\win zone.fpe";
		t.markerentitybank_s[11]="_markers\\trigger zone.fpe";
		t.markerentitybank_s[12] = "_markers\\audio zone.fpe";
		t.markerentitybank_s[13] = "_markers\\video zone.fpe";
		t.markerentitybank_s[14] = "_markers\\floor zone.fpe";
		t.markerentitybank_s[15] = "_markers\\image zone.fpe";
		t.markerentitybank_s[16] = "_markers\\text zone.fpe";
		t.markerentitybank_s[17] = "_markers\\ambience zone.fpe";
		t.markerentitybank_s[18] = "_markers\\white light spot.fpe";
		t.markerentitybank_s[19] = "_markers\\red light spot.fpe";
		t.markerentitybank_s[20] = "_markers\\green light spot.fpe";
		t.markerentitybank_s[21] = "_markers\\blue light spot.fpe";
		t.markerentitybank_s[22] = "_markers\\yellow light spot.fpe";
		t.markerentitybank_s[23] = "_markers\\purple light spot.fpe";
		t.markerentitybank_s[24] = "_markers\\cyan light spot.fpe";
	}
	else
	{
		t.markerentitybank_s[1]="_markers\\player start.fpe";
		t.markerentitybank_s[2]="_markers\\player checkpoint.fpe";
		t.markerentitybank_s[3]="_markers\\cover zone.fpe";
		t.markerentitybank_s[4]="_markers\\multiplayer start.fpe";
		t.markerentitybank_s[5]="_markers\\white light.fpe";
		t.markerentitybank_s[6]="_markers\\red light.fpe";
		t.markerentitybank_s[7]="_markers\\green light.fpe";
		t.markerentitybank_s[8]="_markers\\blue light.fpe";
		t.markerentitybank_s[9]="_markers\\yellow light.fpe";
		t.markerentitybank_s[10]="_markers\\purple light.fpe";
		t.markerentitybank_s[11]="_markers\\cyan light.fpe";
		t.markerentitybank_s[12]="_markers\\win zone.fpe";
		t.markerentitybank_s[13]="_markers\\trigger zone.fpe";
		t.markerentitybank_s[14] = "_markers\\sound zone.fpe";
		t.markerentitybank_s[15] = "_markers\\story zone.fpe";
		t.markerentitybank_s[16] = "_markers\\floor zone.fpe";
		t.markerentitybank_s[17] = "_markers\\image zone.fpe";
		t.markerentitybank_s[18] = "_markers\\text zone.fpe";
		t.markerentitybank_s[19] = "_markers\\ambience zone.fpe";
		t.markerentitybank_s[20] = "_markers\\white light spot.fpe";
		t.markerentitybank_s[21] = "_markers\\red light spot.fpe";
		t.markerentitybank_s[22] = "_markers\\green light spot.fpe";
		t.markerentitybank_s[23] = "_markers\\blue light spot.fpe";
		t.markerentitybank_s[24] = "_markers\\yellow light spot.fpe";
		t.markerentitybank_s[25] = "_markers\\purple light spot.fpe";
		t.markerentitybank_s[26] = "_markers\\cyan light spot.fpe";
	}
	#else
	t.tstoryzoneincluded=27;
	//  Default markers
	for ( t.tt = 0 ; t.tt <= t.tstoryzoneincluded; t.tt++ )
	{
		if (  t.tt == 0 ) { t.t1_s = t.strarr_s[349]  ; t.t2_s = "files\\entitybank\\_markers\\player start.bmp"; }
		if (  t.tt == 1 ) { t.t1_s = t.strarr_s[350]  ; t.t2_s = "files\\entitybank\\_markers\\player checkpoint.bmp"; }
		if (  t.tt == 2 ) { t.t1_s = t.strarr_s[658]  ; t.t2_s = "files\\entitybank\\_markers\\cover zone.bmp"; }
		if (  t.tt == 3 ) { t.t1_s = t.strarr_s[659]  ; t.t2_s = "files\\entitybank\\_markers\\multiplayer start.bmp"; }
		if (  t.tt == 4 ) { t.t1_s = t.strarr_s[351]  ; t.t2_s = "files\\entitybank\\_markers\\white light.bmp"; }
		if (  t.tt == 5 ) { t.t1_s = t.strarr_s[352]  ; t.t2_s = "files\\entitybank\\_markers\\red light.bmp"; }
		if (  t.tt == 6 ) { t.t1_s = t.strarr_s[353]  ; t.t2_s = "files\\entitybank\\_markers\\green light.bmp"; }
		if (  t.tt == 7 ) { t.t1_s = t.strarr_s[354]  ; t.t2_s = "files\\entitybank\\_markers\\blue light.bmp"; }
		if (  t.tt == 8 ) { t.t1_s = t.strarr_s[355]  ; t.t2_s = "files\\entitybank\\_markers\\yellow light.bmp"; }
		if (  t.tt == 9 ) { t.t1_s = t.strarr_s[356]  ; t.t2_s = "files\\entitybank\\_markers\\purple light.bmp"; }
		if (  t.tt == 10 ) { t.t1_s = t.strarr_s[357]  ; t.t2_s = "files\\entitybank\\_markers\\cyan light.bmp"; }
		if (  t.tt == 11 ) { t.t1_s = t.strarr_s[360]  ; t.t2_s = "files\\entitybank\\_markers\\win zone.bmp"; }
		if (  t.tt == 12 ) { t.t1_s = t.strarr_s[361]  ; t.t2_s = "files\\entitybank\\_markers\\trigger zone.bmp"; }
		if ( g.vrqcontrolmode != 0 )
		{
			if (  t.tt == 13 ) { t.t1_s = "Audio Zone"  ; t.t2_s = "files\\entitybank\\_markers\\audio zone.bmp"; }
			if (  t.tt == 14 ) { t.t1_s = "Video Zone"  ; t.t2_s = "files\\entitybank\\_markers\\video zone.bmp"; }
		}
		else
		{
			if (  t.tt == 13 ) { t.t1_s = t.strarr_s[362]  ; t.t2_s = "files\\entitybank\\_markers\\sound zone.bmp"; }
			if (  t.tt == 14 ) { t.t1_s = t.strarr_s[607]  ; t.t2_s = "files\\entitybank\\_markers\\story zone.bmp"; }
		}
		if (  t.tt == 15 ) { t.t1_s = "Floor Zone"; t.t2_s = "files\\entitybank\\_markers\\floor zone.bmp"; }
		if (  t.tt == 16 ) { t.t1_s = "Image Zone"; t.t2_s = "files\\entitybank\\_markers\\image zone.bmp"; }
		if (  t.tt == 17 ) { t.t1_s = "Text Zone"; t.t2_s = "files\\entitybank\\_markers\\text zone.bmp"; }
		if (  t.tt == 18 ) { t.t1_s = "Ambience Zone"; t.t2_s = "files\\entitybank\\_markers\\ambience zone.bmp"; }
		if (  t.tt == 19 ) { t.t1_s = "White Spotlight"; t.t2_s = "files\\entitybank\\_markers\\white light spot.bmp"; }
		if (  t.tt == 20 ) { t.t1_s = "Red Spotlight"; t.t2_s = "files\\entitybank\\_markers\\red light spot.bmp"; }
		if (  t.tt == 21 ) { t.t1_s = "Green Spotlight"; t.t2_s = "files\\entitybank\\_markers\\green light spot.bmp"; }
		if (  t.tt == 22 ) { t.t1_s = "Blue Spotlight"; t.t2_s = "files\\entitybank\\_markers\\blue light spot.bmp"; }
		if (  t.tt == 23 ) { t.t1_s = "Yellow Spotlight"; t.t2_s = "files\\entitybank\\_markers\\yellow light spot.bmp"; }
		if (  t.tt == 24 ) { t.t1_s = "Purple Spotlight"; t.t2_s = "files\\entitybank\\_markers\\purple light spot.bmp"; }
		if (  t.tt == 25 ) { t.t1_s = "Cyan Spotlight"; t.t2_s = "files\\entitybank\\_markers\\cyan light spot.bmp"; }
		if (t.tt == 26) { t.t1_s = t.strarr_s[363]; t.t2_s = "files\\entitybank\\_markers\\Heal zone.bmp"; } // BOTR addition for FPSC 2 GG FPM program
		if (t.tt == 27) { t.t1_s = t.strarr_s[364]; t.t2_s = "files\\entitybank\\_markers\\Hurt zone.bmp"; } // BOTR addition for FPSC 2 GG FPM program

		SetFileMapDWORD (  1, 508, t.tadd );
		SetFileMapString (  1, 1000, cstr(g.mysystem.root_s+t.t2_s).Get() );
		SetFileMapString (  1, 1256, t.t1_s.Get() );
		SetFileMapDWORD (  1, 500, 1 );
		SetEventAndWait (  1 );
		while (  GetFileMapDWORD(1, 500) == 1 ) 
		{
			SetEventAndWait (  1 );
		}
	}

	//  actual entity names of the markers
	Dim ( t.markerentitybank_s, 30 );
	t.markerentitybank_s[1]="_markers\\player start.fpe";
	t.markerentitybank_s[2]="_markers\\player checkpoint.fpe";
	t.markerentitybank_s[3]="_markers\\cover zone.fpe";
	t.markerentitybank_s[4]="_markers\\multiplayer start.fpe";
	t.markerentitybank_s[5]="_markers\\white light.fpe";
	t.markerentitybank_s[6]="_markers\\red light.fpe";
	t.markerentitybank_s[7]="_markers\\green light.fpe";
	t.markerentitybank_s[8]="_markers\\blue light.fpe";
	t.markerentitybank_s[9]="_markers\\yellow light.fpe";
	t.markerentitybank_s[10]="_markers\\purple light.fpe";
	t.markerentitybank_s[11]="_markers\\cyan light.fpe";
	t.markerentitybank_s[12]="_markers\\win zone.fpe";
	t.markerentitybank_s[13]="_markers\\trigger zone.fpe";
	t.markerentitybank_s[16] = "_markers\\floor zone.fpe";
	t.markerentitybank_s[27] = "_markers\\Heal zone.fpe"; // BOTR addition for FPSC 2 GG FPM program
	t.markerentitybank_s[28] = "_markers\\Hurt zone.fpe"; // BOTR addition for FPSC 2 GG FPM program

	if ( g.vrqcontrolmode != 0 )
	{
		t.markerentitybank_s[14] = "_markers\\audio zone.fpe";
		t.markerentitybank_s[15] = "_markers\\video zone.fpe";
	}
	else
	{
		t.markerentitybank_s[14] = "_markers\\sound zone.fpe";
		t.markerentitybank_s[15] = "_markers\\story zone.fpe";
	}
	t.markerentitybank_s[17] = "_markers\\image zone.fpe";
	t.markerentitybank_s[18] = "_markers\\text zone.fpe";
	t.markerentitybank_s[19] = "_markers\\ambience zone.fpe";
	t.markerentitybank_s[20] = "_markers\\white light spot.fpe";
	t.markerentitybank_s[21] = "_markers\\red light spot.fpe";
	t.markerentitybank_s[22] = "_markers\\green light spot.fpe";
	t.markerentitybank_s[23] = "_markers\\blue light spot.fpe";
	t.markerentitybank_s[24] = "_markers\\yellow light spot.fpe";
	t.markerentitybank_s[25] = "_markers\\purple light spot.fpe";
	t.markerentitybank_s[26] = "_markers\\cyan light spot.fpe";
	#endif

	// only if EBE enabled
	if ( g.globals.hideebe == 0 )
	{
		// BUILDER TAB
		t.tadd=3;

		// set maximum to 999
		Dim ( t.ebebank_s, 999 );
		t.ebebankmax = 0;

		// Default builder tool icons
		for ( t.tt = 0; t.tt <= 6; t.tt++ )
		{
			if ( t.tt == 0 ) { t.t1_s = "Add New Site";		t.t2_s = "files\\ebebank\\_builder\\New Site.bmp"; }
			if ( t.tt == 1 ) { t.t1_s = "Cube";				t.t2_s = "files\\ebebank\\_builder\\Cube.bmp"; }
			if ( t.tt == 2 ) { t.t1_s = "Floor";			t.t2_s = "files\\ebebank\\_builder\\Floor.bmp"; }
			if ( t.tt == 3 ) { t.t1_s = "Wall";				t.t2_s = "files\\ebebank\\_builder\\Wall.bmp"; }
			if ( t.tt == 4 ) { t.t1_s = "Column";			t.t2_s = "files\\ebebank\\_builder\\Column.bmp"; }
			if ( t.tt == 5 ) { t.t1_s = "Row";				t.t2_s = "files\\ebebank\\_builder\\Row.bmp"; }
			if ( t.tt == 6 ) { t.t1_s = "Stairs";			t.t2_s = "files\\ebebank\\_builder\\Stairs.bmp"; }
			SetFileMapDWORD ( 1, 508, t.tadd );
			SetFileMapString ( 1, 1000, cstr(g.mysystem.root_s+t.t2_s).Get() );
			SetFileMapString ( 1, 1256, t.t1_s.Get() );
			SetFileMapDWORD ( 1, 500, 1 );
			SetEventAndWait ( 1 );
			while (  GetFileMapDWORD(1, 500) == 1 ) 
			{
				SetEventAndWait (  1 );
			}
		}
		t.ebebank_s[1]="..\\ebebank\\_builder\\New Site.fpe";
		t.ebebank_s[2]="ebebank\\_builder\\Cube.pfb";
		t.ebebank_s[3]="ebebank\\_builder\\Floor.pfb";
		t.ebebank_s[4]="ebebank\\_builder\\Wall.pfb";
		t.ebebank_s[5]="ebebank\\_builder\\Column.pfb";
		t.ebebank_s[6]="ebebank\\_builder\\Row.pfb";
		t.ebebank_s[7]="ebebank\\_builder\\Stairs.pfb";

		// Now scan for extra PFB files not part of default set
		int iFirstFreeSlot = 8;
		LPSTR pOld = GetDir();
		SetDir("ebebank");
		UnDim(t.filelist_s);
		buildfilelist("_builder", "");
		SetDir(pOld);
		int iExtraPFBCount = 0;
		if (ArrayCount(t.filelist_s) > 0)
		{
			for (t.chkfile = 0; t.chkfile <= ArrayCount(t.filelist_s); t.chkfile++)
			{
				t.file_s = t.filelist_s[t.chkfile];
				if (t.file_s != "." && t.file_s != "..")
				{
					if (cstr(Lower(Right(t.file_s.Get(), 4))) == ".pfb")
					{
						// ignore items in default list
						bool bIgnore = false;
						for (int dl = 1; dl < iFirstFreeSlot; dl++)
						{
							LPSTR pThisOne = t.ebebank_s[dl].Get();
							char pNameOnly[256];
							strcpy(pNameOnly, "");
							for (int n = strlen(pThisOne) - 1; n > 0; n--)
							{
								if (pThisOne[n] == '\\' || pThisOne[n] == '/')
								{
									strcpy(pNameOnly, pThisOne + n + 1);
									break;
								}
							}
							if (stricmp(pNameOnly, t.file_s.Get()) == NULL)
								bIgnore = true;
						}
						if (bIgnore == false)
						{
							// add to list
							t.ebebank_s[iFirstFreeSlot + iExtraPFBCount] = cstr("ebebank\\_builder\\") + Left(t.file_s.Get(), Len(t.file_s.Get()));

							// next slot
							iExtraPFBCount++;
							if (iExtraPFBCount > 100) iExtraPFBCount = 100;
						}
					}
				}
			}
			t.strwork = ""; t.strwork = t.strwork + "total extra PFBs=" + Str(iExtraPFBCount);
			timestampactivity(0, t.strwork.Get());
		}
		//  Now sort list into alphabetical order
		for ( t.tgid1 = 0; t.tgid1 < iExtraPFBCount; t.tgid1++ )
		{
			for ( t.tgid2 = 0; t.tgid2 < iExtraPFBCount; t.tgid2++ )
			{
				if (  t.tgid1 != t.tgid2 ) 
				{
					t.tname1_s=Lower(t.ebebank_s[iFirstFreeSlot+t.tgid1].Get());
					t.tname2_s=Lower(t.ebebank_s[iFirstFreeSlot+t.tgid2].Get());
					if ( strlen( t.tname1_s.Get() ) > strlen( t.tname2_s.Get() ) ) 
					{
						//  smallest at top
						t.ebebank_s[iFirstFreeSlot+t.tgid1]=t.tname2_s;
						t.ebebank_s[iFirstFreeSlot+t.tgid2]=t.tname1_s;
					}
				}
			}
		}
		// add to library list
		for ( int n = 0; n < iExtraPFBCount; n++ )
		{
			// create BMP thumbnail
			t.file_s = t.ebebank_s[iFirstFreeSlot+n];
			LPSTR pThisOne = t.file_s.Get();
			char pNameOnly[256];
			strcpy ( pNameOnly, "" );
			for ( int n = strlen(pThisOne)-1; n > 0; n-- )
			{
				if ( pThisOne[n] == '\\' ||  pThisOne[n] == '/' )
				{
					strcpy ( pNameOnly, pThisOne + n + 1 );
					break;
				}
			}
			t.t1_s = Left(pNameOnly,Len(pNameOnly)-4);
			t.t2_s = cstr("files\\") + cstr(Left(t.file_s.Get(),Len(t.file_s.Get())-4)) + cstr(".bmp");
			SetFileMapDWORD ( 1, 508, t.tadd );
			SetFileMapString ( 1, 1000, cstr(g.mysystem.root_s+t.t2_s).Get() );
			SetFileMapString ( 1, 1256, t.t1_s.Get() );
			SetFileMapDWORD ( 1, 500, 1 );
			SetEventAndWait ( 1 );
			while (  GetFileMapDWORD(1, 500) == 1 ) 
			{
				SetEventAndWait (  1 );
			}
		}
		t.ebebankmax = 8 + iExtraPFBCount;
	}

	//  clear counters
	t.locallibraryentidmaster=0;
	t.locallibraryentindex=0;

	//  Ensure start with entity tab
	editor_leftpanelreset ( );
}

void editor_filllibrary ( void )
{
	//  Store place before adds
	SetEventAndWait (  1 );
	t.tstoredtabindex=GetFileMapDWORD( 1, 520 );

	//  Ensure entity list is up to date in library
	while ( t.locallibraryentidmaster<g.entidmaster ) 
	{
		//  only if not marker
		++t.locallibraryentidmaster;
		t.t2_s = t.entityprofileheader[t.locallibraryentidmaster].desc_s;

		// named EBE entities can be shown
		bool bShowEntityInLocalLibrary = true;
		if (t.entityprofile[t.locallibraryentidmaster].isebe != 0)
		{
			if ( stricmp ( t.t2_s.Get(), "new site" ) == NULL ) bShowEntityInLocalLibrary = false;
			if ( strnicmp ( t.t2_s.Get(), "ebe", 3 ) == NULL ) 
			{
				// are the characters after 'ebe' numbers?
				bool bIsNumber = false;
				LPSTR pEntName = t.t2_s.Get();
				for ( int n = 3; n < (int)strlen(pEntName); n++ )
				{
					if ( pEntName[n] >= '0' && pEntName[n] <= '9' )
						bIsNumber = true;
					else
					{
						bIsNumber = false;
						break;
					}
				}
				if ( bIsNumber == true )
				{
					bShowEntityInLocalLibrary = false;
				}
			}
			LPSTR pEntityBankFilename = t.entitybank_s[t.locallibraryentidmaster].Get();
			pEntityBankFilename += strlen(pEntityBankFilename)-4;
			if ( stricmp ( pEntityBankFilename, ".fpe" ) != NULL )
			{
				bShowEntityInLocalLibrary = false;
			}
		}
		if ( bShowEntityInLocalLibrary == true )
		{
			if ( t.entityprofile[t.locallibraryentidmaster].ismarker == 0 || t.entityprofile[t.locallibraryentidmaster].ismarker == 4 ) 
			{
				//  add to actual list
				t.ttext_s=t.entitybank_s[t.locallibraryentidmaster];
				t.tbitmap_s=cstr("files\\entitybank\\")+t.ttext_s;
				t.t1_s = ""; t.t1_s=t.t1_s + Left(t.tbitmap_s.Get(),Len(t.tbitmap_s.Get())-4)+".bmp";
				if (  FileExist( cstr(cstr("..\\")+t.t1_s).Get() ) == 0  )  t.t1_s = "files\\editors\\gfx\\missing.bmp";
				SetFileMapDWORD (  1, 508, 1 );
				SetFileMapString (  1, 1000, Left(cstr(g.mysystem.root_s+t.t1_s).Get(),254) );
				SetFileMapString (  1, 1256, Left(t.t2_s.Get(),254) );
				SetFileMapDWORD (  1, 500, 1 );
				SetEventAndWait (  1 );
				while (  GetFileMapDWORD(1, 500) == 1 ) 
				{
					SetEventAndWait (  1 );
				}

				//  add to internal list array
				++t.locallibraryentindex;
				Dim (  t.locallibraryent,t.locallibraryentindex  );
				t.locallibraryent[t.locallibraryentindex] = t.locallibraryentidmaster;
			}
		}
	}

	//  Restore place after adds
	SetFileMapDWORD (  1, 534, 1+t.tstoredtabindex );
	SetEventAndWait (  1 );
}

void editor_leftpanelreset ( void )
{
	// Reset to GetPoint ( to entity tab )
	SetFileMapDWORD (  1, 534, 1 );
	SetEventAndWait (  1 );
}

void editor_filemapdefaultinitfornew ( void )
{
	//  Open for some Defaults for Editor
	#ifdef FPSEXCHANGE
	OpenFileMap (  1, "FPSEXCHANGE" );
	#endif

	//  Marker Defaults
	g.entidmaster=0;

	//  filllibrary with segments and entities from default prefabs (temp as is above)
	editor_filllibrary ( );
	editor_leftpanelreset ( );
}

void editor_filemapinit ( void )
{
	// Open for some Defaults for Editor
	#ifdef FPSEXCHANGE
	OpenFileMap (  1, "FPSEXCHANGE" );
	// Set default mouse position and visibility
	SetFileMapDWORD (  1, 0, 400 );
	SetFileMapDWORD (  1, 4, 300 );
	SetEventAndWait (  1 );
	#endif

	//  Each selection tab needs a NEW icon
	editor_clearlibrary ( );
	editor_filllibrary ( );
	editor_leftpanelreset ( );
}

void editor_loadcfg (bool bFromFPM)
{
	//  Load existing config file
	cstr cfgfile_s = g.mysystem.editorsGridedit_s + "cfg.cfg";

	#ifdef WICKEDENGINE
	if (bFromFPM)
	{
		cfgfile_s = g.mysystem.levelBankTestMap_s + "cfg.cfg";
		if (FileExist(cfgfile_s.Get()) == 0)
		{
			cfgfile_s = g.mysystem.editorsGridedit_s + "cfg.cfg";
		}
	}
	#endif

	if ( FileExist(cfgfile_s.Get()) == 1 ) 
	{
		OpenToRead (  1,cfgfile_s.Get() );
		//  Current Camera Position
		t.cx_f = ReadFloat ( 1 );
		t.cy_f = ReadFloat ( 1 );
		t.gridzoom_f = ReadFloat ( 1 );
		t.gridlayer = ReadLong ( 1 );
		//  Edit Vars
		t.nogridsmart = ReadLong ( 1 );
		t.grideditartmode = ReadLong ( 1 );

		// LB: modes 3 and 4 are view-modes (should not restore into these, no way out!!)
		int iTestGridEditSelect = ReadLong ( 1 );
		if (iTestGridEditSelect == 3 || iTestGridEditSelect == 4)
		{
			t.grideditselect = 0;
		}
		else
		{
			t.grideditselect = iTestGridEditSelect;
		}
		//  Project (only need project name if skipping FPM=using temp.fpm)
		t.temp_s = ReadString ( 1 ); if (  t.skipfpmloading == 1  )  g.projectfilename_s = t.temp_s;
		g.currentFPG_s = ReadString ( 1 );

		//  Shroud Settings
		t.a = ReadLong ( 1 );
		g.gridlayershowsingle = ReadLong ( 1 );

		#ifdef WICKEDENGINE
		//PE: Restore all camera settings.
		if (bFromFPM)
		{
			char *tmp;
			tmp = ReadString(1);
			if (tmp && tmp[0] == 'V' && tmp[1] == '2')
			{
				t.editorfreeflight.mode = ReadLong(1);
				float fTmp1 = ReadFloat(1);
				float fTmp2 = ReadFloat(1);
				float fTmp3 = ReadFloat(1);
				//PE: Double check if we have some default values and something is wrong.
				if (fTmp1 != 0.0 && fTmp2 != 0.0 && fTmp3 != 0.0)
				{
					t.editorfreeflight.c.x_f = fTmp1;
					t.editorfreeflight.c.y_f = fTmp2;
					t.editorfreeflight.c.z_f = fTmp3;
					t.cx_f = ReadFloat(1);
					t.cy_f = ReadFloat(1);
					t.editorfreeflight.c.angx_f = ReadFloat(1);
					t.editorfreeflight.c.angy_f = ReadFloat(1);
					//PE: Also update t.editorfreeflight.s if any camera animation is starting.
					t.editorfreeflight.s = t.editorfreeflight.c;
				}
			}
			//PE: In wicked after loading a new fpm. we need some frames before terrain height is ready.
			iDelayedCameraRestore = 240; //It can take some time before full terrain is regenerated, so 4 sec.
		}
		#endif
		CloseFile (  1 );
	}

	//  Reset editor slicing for now
	g.gridlayershowsingle=0;

	//  Update editor settings
	editor_refresheditmarkers ( );
	t.refreshgrideditcursor=1;
	t.updatezoom=1;

	//  Current project name stored for next time
	t.currentprojectfilename_s=g.projectfilename_s;

	return;
}

void editor_savecfg (char *filename)
{
	//  Delete config file
	//t.strwork = "" ; t.strwork = t.strwork + "editors\\gridedit\\cfg.cfg";
	t.strwork = g.mysystem.editorsGridedit_s + "cfg.cfg";
	if (filename)
	{
		t.strwork = filename;
	}

	if (FileOpen(1) == 1) CloseFile(1); //PE: To make sure, was missing a cfg.cfg file in fpm so...

	if (  FileExist( t.strwork.Get() ) == 1  )  DeleteAFile ( t.strwork.Get() );

	//PE: editors\gridedit\cfg.cfg , if exists in c:program.. and cant be deleted OpenToWrite fails (already exists).

	//  Save config file
	OpenToWrite (  1, t.strwork.Get() );

	//  Current Camera Position
	if (  t.editorfreeflight.mode == 1 ) 
	{
		//  when save while in free flight mode, use present location
		t.a_f=t.editorfreeflight.c.x_f ; WriteFloat (  1,t.a_f );
		t.a_f=t.editorfreeflight.c.z_f ; WriteFloat (  1,t.a_f );
	}
	else
	{
		WriteFloat (  1,t.cx_f );
		WriteFloat (  1,t.cy_f );
	}
	WriteFloat (  1,t.gridzoom_f );
	WriteLong (  1,t.gridlayer );
	//  Edit Vars
	WriteLong (  1,t.nogridsmart );
	WriteLong (  1,t.grideditartmode );
	WriteLong (  1,t.grideditselect );
	//  Project
	WriteString (  1,g.projectfilename_s.Get() );
	WriteString (  1,g.currentFPG_s.Get() );
	//  Shroud Settings
	WriteLong (  1,g.shroudsize );
	WriteLong (  1,g.gridlayershowsingle );

	#ifdef WICKEDENGINE
	WriteString(1, "V2");
	//PE: Write out all camera settings.
	WriteLong(1, t.editorfreeflight.mode);
	WriteFloat(1, t.editorfreeflight.c.x_f);
	WriteFloat(1, t.editorfreeflight.c.y_f);
	WriteFloat(1, t.editorfreeflight.c.z_f);
	WriteFloat(1, t.cx_f);
	WriteFloat(1, t.cy_f);
	WriteFloat(1, t.editorfreeflight.c.angx_f);
	WriteFloat(1, t.editorfreeflight.c.angy_f);
	#endif
	CloseFile (  1 );

return;

}

void editor_constructionselection ( void )
{
	if ( t.inputsys.constructselection>0 ) 
	{
		//  SINGLE ENTITY
		if ( t.grideditselect == 5 ) 
		{
			if ( t.inputsys.constructselection <= g.entidmaster ) 
			{
				#ifdef ENABLEIMGUI
				CloseDownEditorProperties();
				#endif

				//  first cancel any widget that might be opened
				widget_switchoff ( );

				//PE: Somebody removed this line in Classic ???? Nothing worked ????
				t.gridentity = t.inputsys.constructselection;

				// remove any entity group rubber band highlighting
				#ifdef WICKEDENGINE
				t.gridentity = t.inputsys.constructselection;
				int iFromGroupEntityID = false;
				if (t.entityprofile[t.gridentity].groupreference != -1)
				{
					// this entity is a group, create new child group for selection
					//int iParentGroupID = t.entityprofile[t.gridentity].groupreference;
					// look for group that matches the group object entity FPE name
					extern int GetGroupIndexFromName (cstr sLookFor);
					cstr sLookFor = cstr("entitybank\\") + t.entitybank_s[t.gridentity];
					int iParentGroupID = GetGroupIndexFromName(sLookFor);
					if (iParentGroupID != -1)
					{
						// and duplicate from that parent group
						iFromGroupEntityID = DuplicateFromListToCursor(vEntityGroupList[iParentGroupID], false);

						//PE: Keep scale rot when setup from a group.
						if(iFromGroupEntityID > 0)
							bRotScaleAlreadyUpdated = true;

						// smart object game elements are always hidden at first
						gridedit_setsmartobjectvisibilityinrubberband(false);
					}
					else
					{
						// strangely cannot find group for this parent smart object!!
						gridedit_clearentityrubberbandlist();
					}
				}
				else
				#endif
				{
					// if not a group smart object
					gridedit_clearentityrubberbandlist();
				}

				#ifdef WICKEDENGINE
				iLastEntityOnCursor = 0;
				#endif

				// the entity ID we are adding
				if ( t.entityprofile[t.gridentity].isebe > 0 )
				{
					// create unique entid and go to entity placement mode
					char pEBEFile[512];
					strcpy ( pEBEFile, t.entitybank_s[t.gridentity].Get());
					t.addentityfile_s = cstr(Left(pEBEFile,strlen(pEBEFile)-4)) + cstr(".fpe");

					#ifdef ENABLEIMGUI
					CloseDownEditorProperties();
					#endif

					// Work out EBE file and check if it exists
					char pFinalPathAndFile[1024];
					sprintf ( pFinalPathAndFile, "entitybank%s.ebe", Left(pEBEFile,strlen(pEBEFile)-4) );
					if ( FileExist ( pFinalPathAndFile ) )
					{
						// by creating one unique to the level, we can save our temp changes to it
						entity_adduniqueentity ( true );
						t.gridentity = t.entid;

						// name only
						char pNameOnly[256];
						strcpy ( pNameOnly, "" );
						for ( int n = strlen(pEBEFile)-1; n > 0; n-- )
						{
							if ( pEBEFile[n] == '\\' ||  pEBEFile[n] == '/' )
							{
								strcpy ( pNameOnly, pEBEFile + n + 1 );
								break;
							}
						}
						t.t1_s = Left(pNameOnly,Len(pNameOnly)-4);

						// give it a unique name
						t.entitybank_s[t.entid] = t.t1_s;
						t.entityprofileheader[t.entid].desc_s = t.t1_s;

						// load EBE data into entityID
						ebe_load_ebefile ( pFinalPathAndFile, t.entid );

						// get path only
						char pFinalPathOnly[1024];
						strcpy ( pFinalPathOnly, pFinalPathAndFile );
						for ( int n = strlen(pFinalPathAndFile); n > 0; n-- )
						{
							if ( pFinalPathAndFile[n] == '\\' || pFinalPathAndFile[n] == '/' )
							{
								pFinalPathOnly[n+1] = 0;
								break;
							}
						}

						// copy unique texture into levelbank\testmap so EDIT can copy over to ebebank
						cstr sUniqueFilename = t.entityprofile[t.entid].texd_s;
						sUniqueFilename = cstr(Left(sUniqueFilename.Get(),strlen(sUniqueFilename.Get())-6));
						cstr sDDSSourceFile = cstr(pFinalPathOnly) + sUniqueFilename + cstr("_D.dds");
						cstr sDDSFile = g.mysystem.levelBankTestMap_s + sUniqueFilename + cstr("_D.dds");
						if ( FileExist(sDDSFile.Get()) == 1 ) DeleteAFile ( sDDSFile.Get() );
						CopyFileA ( sDDSSourceFile.Get(), sDDSFile.Get(), FALSE );
						sDDSSourceFile = cstr(pFinalPathOnly) + sUniqueFilename + cstr("_N.dds");
						sDDSFile = g.mysystem.levelBankTestMap_s + sUniqueFilename + cstr("_N.dds");
						if ( FileExist(sDDSFile.Get()) == 1 ) DeleteAFile ( sDDSFile.Get() );
						CopyFileA ( sDDSSourceFile.Get(), sDDSFile.Get(), FALSE );
						sDDSSourceFile = cstr(pFinalPathOnly) + sUniqueFilename + cstr("_S.dds");
						sDDSFile = g.mysystem.levelBankTestMap_s + sUniqueFilename + cstr("_S.dds");
						if ( FileExist(sDDSFile.Get()) == 1 ) DeleteAFile ( sDDSFile.Get() );
						CopyFileA ( sDDSSourceFile.Get(), sDDSFile.Get(), FALSE );
					}
					else
					{
						// EBE not present, which means user protected it (not an editable EBE any more)
						if ( stricmp ( pEBEFile, "..\\ebebank\\_builder\\New Site.fpe" ) != NULL )
						{
							//New site is called EBE? 
							//if (!(pEBEFile[0] == 'E' && pEBEFile[1] == 'B' && pEBEFile[2] == 'E'))
							if(t.entityprofile[t.gridentity].model_s != "New Site.dbo" )  //Better way.
							{
								// except New Site of course
								t.entityprofile[t.gridentity].isebe = 0;
							}
						}
					}
				}
				//  select entity profile and start orientation
				t.gridedit.autoflatten=t.entityprofile[t.gridentity].autoflatten;
				//t.gridedit.entityspraymode=0; //PE: spray checkbox.
				t.inputsys.dragoffsetx_f=0;
				t.inputsys.dragoffsety_f=0;
				#ifdef WICKEDENGINE
				fHitPointX = 0;
				fHitPointY = HITPOINTYSTARTPOS;
				fHitPointZ = 0;
				fHitOffsetX = 0;
				fHitOffsetY = 0;
				fHitOffsetZ = 0;
				// LB: these can be uninitialised, but we need these filled so the plane can be under the cursor initially
				t.gridentityposx_f = t.inputsys.localx_f;
				t.gridentityposy_f = t.inputsys.localcurrentterrainheight_f;
				t.gridentityposz_f = t.inputsys.localy_f;
				g_bHoldGridEntityPosWhenManaged = true;
				g_fHoldGridEntityPosX = t.gridentityposx_f;
				g_fHoldGridEntityPosY = t.gridentityposy_f;
				g_fHoldGridEntityPosZ = t.gridentityposz_f;
				#endif
				t.gridentityposoffground=0;

				if ( t.entityprofile[t.gridentity].dontfindfloor != 0 )
				{
					// can set entity to initially ignore floor finder
					t.gridentityusingsoftauto = 0;
				}
				else
				{
					t.gridentityusingsoftauto = 1;
				}
				#ifdef WICKEDENGINE
				// MAX handles its own positioning system
				#else
				if ( t.entityprofile[t.gridentity].defaultstatic == 0 && t.entityprofile[t.gridentity].isimmobile == 1 )
				{
					//  some entities should NOT use auto-find (some collisionmode entities)
					//  11=no physics  21=player repell feature  50-59=tree collisions
					t.tcollmode=t.entityprofile[t.gridentity].collisionmode;
					if ( t.tcollmode == 11 || t.tcollmode == 12 || t.tcollmode == 21 || (t.tcollmode >= 50 && t.tcollmode <= 59) ) 
					{
						t.gridentityautofind=0;
					}
					else
					{
						t.gridentityautofind=1;
					}
				}
				else
				#endif
				{
					t.gridentityautofind=0;
				}

				#ifdef WICKEDENGINE
				//PE: We get some flicker when moving objects around, when over object sometimes it use terrainheight.
				//PE: @Lee Think terrain is inside Wicked Pick so should not be needed. if not just remove this :)
				t.gridentityusingsoftauto = 0;
				#endif

				t.gridentityeditorfixed=0;
				if (!bRotScaleAlreadyUpdated)
				{
					#ifdef WICKEDENGINE
					if (t.entityprofile[t.gridentity].ischaracter != 0)
					{
						// if character, always face the camera
						float fAngleToFaceCamera = CameraAngleY(0) + 180.0f;
						t.entityprofile[t.gridentity].roty = fAngleToFaceCamera;
					}
					#endif
					t.gridentityrotatex_f = t.entityprofile[t.gridentity].rotx;
					t.gridentityrotatey_f = t.entityprofile[t.gridentity].roty;
					t.gridentityrotatez_f = t.entityprofile[t.gridentity].rotz;
					t.gridentityrotatequatmode = 0;
					t.gridentityrotatequatx_f = 0;
					t.gridentityrotatequaty_f = 0;
					t.gridentityrotatequatz_f = 0;
					t.gridentityrotatequatw_f = 1;
					t.gridentityscalex_f = t.entityprofile[t.gridentity].scale;
					t.gridentityscaley_f = t.entityprofile[t.gridentity].scale;
					t.gridentityscalez_f = t.entityprofile[t.gridentity].scale;
				}
				bRotScaleAlreadyUpdated = false;
				t.ttrygridentitystaticmode=t.entityprofile[t.gridentity].defaultstatic;
				t.ttrygridentity=t.gridentity ; editor_validatestaticmode ( );
				//  Ensure editor zoom refreshes
				t.updatezoom=1;
				//  fill new selection with defaults
				t.sentid=t.entid ; t.entid=t.gridentity  ; entity_fillgrideleproffromprofile() ; t.entid=t.sentid;
				t.grideleproflastname_s=t.grideleprof.name_s;
				//  marker types?
				if ( t.entityprofile[t.gridentity].ismarker == 1 && t.entityprofile[t.gridentity].lives != -1 ) 
				{
					//  selecting new player start marker resets tweakables
					physics_inittweakables ( );
				}
				if ( t.entityprofile[t.gridentity].ismarker == 3 || t.entityprofile[t.gridentity].ismarker == 6 || t.entityprofile[t.gridentity].ismarker == 8 ) 
				{
					//  trigger zone marker(3) or checkpoint marker(6) or floor zone marker(8)
					//  trigger zone has a waypoint zone companion
					if ( t.entityprofile[t.gridentity].ismarker == 8 ) 
						t.waypointeditstyle = 3; // navmeshzone
					else
						t.waypointeditstyle = 2; // normalzone
					t.waypointeditstylecolor=t.entityprofile[t.gridentity].trigger.stylecolor;
					t.waypointeditentity=0;
					t.mx_f=t.cx_f ; t.mz_f=t.cy_f;
					if (  t.terrain.TerrainID>0 ) 
					{
						g.waypointeditheight_f=BT_GetGroundHeight(t.terrain.TerrainID,t.mx_f,t.mz_f);
					}
					else
					{
						g.waypointeditheight_f=g.gdefaultterrainheight;
					}
					waypoint_createnew ( );
					t.grideleprof.trigger.waypointzoneindex=t.waypointindex;
				}
			}
		}

		//  In case new 'shader' associated with new entity, refresh just in case (i.e. first entity)
		visuals_justshaderupdate ( );

		//  Construction complete
		t.inputsys.constructselection = 0;
	}
}

void editor_validatestaticmode ( void )
{
	// receives ttrygridentitystaticmode,ttrygridentity
	if ( t.ttrygridentity>0 ) 
	{
		t.gridentitystaticmode=t.ttrygridentitystaticmode;
		bool bSomeShadersForceDynamicMode = false;
		if ( strcmp ( Lower(Right(t.entityprofile[t.ttrygridentity].effect_s.Get(),18)) , "character_basic.fx" ) == 0 ) bSomeShadersForceDynamicMode = true;
		if ( strcmp ( Lower(Right(t.entityprofile[t.ttrygridentity].effect_s.Get(),14)) , "treea_basic.fx" ) == 0 ) bSomeShadersForceDynamicMode = true;
		if ( bSomeShadersForceDynamicMode == true )
		{
			if ( ObjectExist(g.entitybankoffset+t.ttrygridentity) == 1 ) 
			{
				if ( GetNumberOfFrames(g.entitybankoffset+t.ttrygridentity)>0 ) 
				{
					t.gridentitystaticmode=0;
				}
			}
		}

		#ifdef WICKEDENGINE
		if (t.entityprofile[t.ttrygridentity].ischaracter)
		{
			// Possible fix for characters appearing static.
			t.gridentitystaticmode = 0;
		}
		#endif
	}
}

void editor_overallfunctionality ( void )
{
	//  Restore current grid view
	if (  t.inputsys.doautozoomview == 1 ) { t.inputsys.doautozoomview = 0  ; t.inputsys.dozoomview = 1; }
	if (  t.inputsys.dozoomview == 1 ) 
	{
		if (  t.cameraviewmode == 2 ) 
		{
			//  mouselook mode off
			#ifdef FPSEXCHANGE
			OpenFileMap (  1, "FPSEXCHANGE" );
			SetFileMapDWORD (  1, 48, 0 );
			SetEventAndWait (  1 );
			#endif
			//  re-enable icons
			editor_enableafterzoom ( );
			//  end zoom mode
			t.grideditselect=t.stgrideditselect  ; editor_refresheditmarkers ( );
			t.inputsys.dozoomview=0;
			t.cameraviewmode=0;
		}
	}

	//  Switch to zoom view
	if (  t.inputsys.dozoomview == 1 ) 
	{
		if (  t.cameraviewmode == 0 ) 
		{
			//  Set camera to track with close-up
			t.stgrideditselect=t.grideditselect;
			t.cameraviewmode = 2;

			//  Mode - Zoom In View
			t.grideditselect=4 ; editor_refresheditmarkers ( );
			t.updatezoom=1;
		}
	}

	//  Get terrain height reading at cursor
#ifdef GGTERRAIN_USE_NEW_TERRAIN
	t.ttterrheighthere_f=BT_GetGroundHeight(t.terrain.TerrainID,t.cx_f,t.cy_f);
#else
	if (  t.terrain.TerrainID>0 ) 
	{
		t.ttterrheighthere_f=BT_GetGroundHeight(t.terrain.TerrainID,t.cx_f,t.cy_f);
	}
	else
	{
		t.ttterrheighthere_f=g.gdefaultterrainheight;
	}
#endif
	
	//  ensure zoom never penetrates terrain
	if (  t.updatezoom == 1 || t.inputsys.mclick != 0 ) 
	{
		if (  (600.0*t.gridzoom_f)<(t.ttterrheighthere_f+100) ) 
		{
			t.gridzoom_f=(t.ttterrheighthere_f+100)/600.0;
		}
	}

	//  Recalculate zoom scale for editing
	if (  t.updatezoom == 1 ) 
	{

		//  grid scale for camera cursor location and zoom
		t.gridscale_f=((800/2)/8)/t.gridzoom_f;
		t.inputsys.keypress=1;
		t.updatezoom=0;

		//  gridlayershowsingle creates an alpha slice in entity shaders
		t.gridnearcameraclip=-1;
		if (  t.grideditselect != 4 ) 
		{
			if (  g.gridlayershowsingle == 1 ) 
			{
				t.gridnearcameraclip=t.clipheight_f;
			}
		}

		//  modulate shadow strength based on distance
		t.tcamrange_f=((600.0*t.gridzoom_f)+1000);
		t.toldvisualsshadowmode=t.visuals.shadowmode;
		if (  t.tcamrange_f<4000 ) 
		{
			t.visuals.shadowmode=100;
		}
		else
		{
			if (  t.tcamrange_f<6000 ) 
			{
				t.visuals.shadowmode=(6000-t.tcamrange_f)/20.0;
			}
			else
			{
				t.visuals.shadowmode=0;
			}
		}
		if (  t.toldvisualsshadowmode != t.visuals.shadowmode ) 
		{
			visuals_justshaderupdate ( );
		}

		//  adjust clipping range of camera to match
		editor_refreshcamerarange ( );

		//  Ensure the slicing clip does not go
		if (  t.gridnearcameraclip == -1 ) 
		{
			t.gridtrueslicey_f=CameraPositionY(0);
		}
		else
		{
			t.gridtrueslicey_f=t.gridnearcameraclip;
		}

		//  feed alpha slicing height into all entity shaders
		if (  g.effectbankmax>0 ) 
		{
			for ( t.t = 1 ; t.t<=  g.effectbankmax; t.t++ )
			{
				t.effectid=g.effectbankoffset+t.t;
				if (  GetEffectExist(t.effectid) == 1 ) 
				{
					if (  t.gridnearcameraclip == -1 ) 
					{
						SetVector4 ( g.terrainvectorindex, 500000, 1, 0, 0 );
					}
					else
					{
						SetVector4 ( g.terrainvectorindex, t.gridtrueslicey_f, 1, 0, 0 );
					}
					SetEffectConstantV (  t.effectid,"EntityEffectControl",g.terrainvectorindex );
				}
			}
		}

	}

	//  use intersect test to find ground/wall and drop entity onto it
	if ( t.inputsys.k_s != "l" ) 
	{
		// but not if holding L key to link entity to a new parent
		if ( t.gridentitysurfacesnap == 1 )
		{
			// no need to find entity, surfacesnap already found best 3D coordinate
		}
		else
		{
			if (t.gridentitydroptoground >= 1 && t.gridentitydroptoground <= 2)
			{
				//PE: Need rubberband support here.
				float fdiff = t.gridentityposy_f;
				t.thardauto = 1; editor_findentityground();
				if (t.gridentityposoffground == 0)
				{
					#ifdef WICKEDENGINE
					float ftmp = BT_GetGroundHeight(t.terrain.TerrainID, t.gridentityposx_f, t.gridentityposz_f);
					//if (ftmp > 0) { //LB: Terrain height can be negative
					t.gridentityposy_f = ftmp;
					ApplyPivotToGridEntity(); //PE: Apply pivot here.
					//}
					#endif
				}
				#ifdef WICKEDENGINE
				//Only drop one time if in vertical move mode.
				if (iObjectMoveMode == 1)
				{
					if (fHitOffsetY != 0)
					{
						fdiff = fdiff -t.gridentityposy_f;
						fHitOffsetY += fdiff;
					}
					t.gridentityautofind = 0;
					t.gridentityposoffground = 1; //Dont proceed updating Y.
				}
				#endif
				t.gridentitydroptoground=0;
			}
			else
			{
				t.thardauto=0 ; editor_findentityground ( );
			}
		}
	}

	//  Change layer show mode
	if (  t.inputsys.dosinglelayer == 1 ) 
	{
		g.gridlayershowsingle=g.gridlayershowsingle+1;
		if (  g.gridlayershowsingle>1  )  g.gridlayershowsingle = 0;
		t.updatezoom=1;
	}

	//  ensure assigned third person char object stays with start marker
	if (  t.playercontrol.thirdperson.enabled == 1 ) 
	{
		t.tobj=t.entityelement[t.playercontrol.thirdperson.charactere].obj;
		if (  t.tobj>0 ) 
		{
			if (  ObjectExist(t.tobj) == 1 ) 
			{
				if (  t.gridentity>0 && t.entityprofile[t.gridentity].ismarker == 1 ) 
				{
					//  moving start marker
					t.tstmrkobj=t.gridentityobj;
				}
				else
				{
					//  update char on start marker entity
					t.tstmrke=t.playercontrol.thirdperson.startmarkere;
					t.tstmrkobj=t.entityelement[t.tstmrke].obj;
				}
				if (  t.tstmrkobj>0 ) 
				{
					if (  ObjectExist(t.tstmrkobj) == 1 ) 
					{
						PositionObject (  t.tobj,ObjectPositionX(t.tstmrkobj),ObjectPositionY(t.tstmrkobj),ObjectPositionZ(t.tstmrkobj) );
						RotateObject (  t.tobj,ObjectAngleX(t.tstmrkobj),ObjectAngleY(t.tstmrkobj),ObjectAngleZ(t.tstmrkobj) );
					}
				}
				MoveObject (  t.tobj,-35 );
				if (  t.tstmrkobj>0 ) 
				{
					if (  ObjectExist(t.tstmrkobj) == 1 ) 
					{
						EnableObjectZDepth (  t.tstmrkobj );
						EnableObjectZWrite (  t.tstmrkobj );
						EnableObjectZRead (  t.tstmrkobj );
					}
				}
			}
		}
	}
}

void editor_refreshcamerarange ( void )
{
	t.tcamneardistance_f=CameraPositionY(0)/500.0;
	if ( t.tcamneardistance_f < 10.0  ) t.tcamneardistance_f = 10.0;
	if ( t.widget.activeObject > 0 )
	{
		// 011215 - except when widget shown, we need min distance to avoid clipping widget
		if ( t.tcamneardistance_f > 30.0f ) 
		{
			// to avoid water plane clipping, move water plane away from terrain plate incrementally
			t.terrain.waterlineyadjustforclip_f = (t.tcamneardistance_f-30.0f) * 5;
			t.tcamneardistance_f = 30.0f;
		}
	}
	else
	{
		t.terrain.waterlineyadjustforclip_f = 0.0f;
	}
	if (  t.editorfreeflight.mode == 1 ) 
	{
		// free flight FULL camera distance
		SetCameraRange ( t.tcamneardistance_f, DEFAULT_FAR_PLANE );
	}
	else
	{
		//  top down camera distance
		//SetCameraRange (  t.tcamneardistance_f,t.tcamrange_f );
		//PE: Test
		SetCameraRange( t.tcamneardistance_f, DEFAULT_FAR_PLANE );
	}
}

void editor_mainfunctionality ( void )
{
	//  Rotation of entity
	if (  t.grideditselect == 5 ) 
	{
		bool bAllowRotate = true;
#ifdef WICKEDENGINE
		if (t.widget.pickedEntityIndex > 0 && t.entityelement[t.widget.pickedEntityIndex].editorlock == 1)
			bAllowRotate = false;
#endif
		//  do not rotate light or trigger entity
		//PE: Allow light rotation rem: t.entityprofile[t.gridentity].ismarker != 2 &&  t.entityprofile[t.gridentity].ismarker != 3
		if ( bAllowRotate && t.entityprofile[t.gridentity].ismarker != 3 )
		{
			if (  t.inputsys.keyshift == 1 ) 
			{
				t.tspeedofrot_f=10.0 ; t.inputsys.keypress=0;
			}
			else
			{
				if (  t.inputsys.keycontrol == 1 ) 
				{
					t.tspeedofrot_f=1.0;
				}
				else
				{
					t.tspeedofrot_f=45.0;
				}
			}
			//PE: Prefer gridentity rotation. as we can now have both active at the same time.
#ifdef WICKEDENGINE
			//PE: We dont need t.widget.pickedObject != 0 && to control widget.
			if(t.widget.pickedEntityIndex > 0 && t.gridentity == 0)
#else
			if (  t.widget.pickedObject != 0 && t.widget.pickedEntityIndex>0 )
#endif
			{
				// Rotation control of widget controlled entity
				if ( t.inputsys.domodeterrain == 0 && t.inputsys.domodeentity == 0 ) 
				{
					if ( t.inputsys.dorotation == 1 || (t.inputsys.doentityrotate >= 1 && t.inputsys.doentityrotate <= 6) ||
						 t.inputsys.keyreturn == 1 || t.inputsys.kscancode == 201 || t.inputsys.kscancode == 209 )
					{
						#ifdef WICKEDENGINE
						//PE: Make sure all groups are selected.
						int group = isEntityInGroupList(t.widget.pickedEntityIndex);
						if (group >= 0)
						{
							//Add all groups with entity to rubberband.
							CheckGroupListForRubberbandSelections(t.widget.pickedEntityIndex);
						}
						else if (g.entityrubberbandlist.size() > 0)
						{
							//Make sure all groups is selected from within rubberband selecting.
							for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
							{
								int e = g.entityrubberbandlist[i].e;
								CheckGroupListForRubberbandSelections(e);
							}
						}
						#endif
					}
					//  avoid interference from terrain/entity mode change
					GGQUATERNION quatRotationEvent = { 0,0,0,0 };
					float fMoveAngX = 0.0f;
					float fMoveAngY = 0.0f;
					float fMoveAngZ = 0.0f;
					float fStoreOrigYAngle = t.entityelement[t.widget.pickedEntityIndex].ry;
					bool bRotateObjectFromKeyPress = false;
					if (t.inputsys.dorotation == 1) 
					{ 
						fMoveAngY = fMoveAngY + t.tspeedofrot_f; 
						bRotateObjectFromKeyPress = true; 
					}
					if (t.inputsys.doentityrotate == 1) { fMoveAngX = fMoveAngX - t.tspeedofrot_f; bRotateObjectFromKeyPress = true; }
					if (t.inputsys.doentityrotate == 2) { fMoveAngX = fMoveAngX + t.tspeedofrot_f; bRotateObjectFromKeyPress = true; }
					if (t.inputsys.doentityrotate == 3) 
					{ 
						fMoveAngY = fMoveAngY - t.tspeedofrot_f; 
						bRotateObjectFromKeyPress = true; 
					}
					if (t.inputsys.doentityrotate == 4) 
					{ 
						fMoveAngY = fMoveAngY + t.tspeedofrot_f; 
						bRotateObjectFromKeyPress = true; 
					}
					if (t.inputsys.doentityrotate == 5) { fMoveAngZ = fMoveAngZ - t.tspeedofrot_f; bRotateObjectFromKeyPress = true; }
					if (t.inputsys.doentityrotate == 6) { fMoveAngZ = fMoveAngZ + t.tspeedofrot_f; bRotateObjectFromKeyPress = true; }

					#ifdef WICKEDENGINE
					// special case for characters, only rotate Y angle
					if (t.widget.pickedEntityIndex > 0)
					{
						int entidcheck = t.entityelement[t.widget.pickedEntityIndex].bankindex;
						if (t.entityprofile[entidcheck].ischaracter == 1)
						{
							fMoveAngX = 0.0f;
							fMoveAngZ = 0.0f;
						}
					}
					// ready for quat rot
					static bool bStartedKeyboardRotation = false;
					static std::vector<std::array<float, 3>> prevRotations;
					static std::vector<std::array<float, 4>> prevQuatRotations;
					static std::vector<std::array<int, 1>> prevQuatRotationsMode;
					static std::vector <std::array<float, 3>> prevPositions;			
					int index = t.widget.pickedEntityIndex;
					
					// Store initial rotations before any changes have been applied.
					if (bRotateObjectFromKeyPress && !bStartedKeyboardRotation)
					{
						if (g.entityrubberbandlist.size() == 0)
						{
							std::array<float, 3> prevRotation = { t.entityelement[index].rx, t.entityelement[index].ry, t.entityelement[index].rz };
							prevRotations.push_back(prevRotation);
							std::array<float, 4> prevQuatRotation = { t.entityelement[index].quatx, t.entityelement[index].quaty, t.entityelement[index].quatz, t.entityelement[index].quatw };
							prevQuatRotations.push_back(prevQuatRotation);
							std::array<int, 1> prevQuatRotationMode = { t.entityelement[index].quatmode };
							prevQuatRotationsMode.push_back(prevQuatRotationMode);
						}
						else
						{
							for (int i = 0; i < g.entityrubberbandlist.size(); i++)
							{
								int e = g.entityrubberbandlist[i].e;
								std::array<float, 3> prevRotation = { t.entityelement[e].rx, t.entityelement[e].ry, t.entityelement[e].rz };
								prevRotations.push_back(prevRotation);
								std::array<float, 4> prevQuatRotation = { t.entityelement[e].quatx, t.entityelement[e].quaty, t.entityelement[e].quatz, t.entityelement[e].quatw };
								prevQuatRotations.push_back(prevQuatRotation);
								std::array<int, 1> prevQuatRotationMode = { t.entityelement[e].quatmode };
								prevQuatRotationsMode.push_back(prevQuatRotationMode);
								// Need to store positions for rubberband, since they rotate about a point. 
								std::array<float,3> prevPosition = { t.entityelement[e].x, t.entityelement[e].y, t.entityelement[e].z };
								prevPositions.push_back(prevPosition);
							}
						}
						bStartedKeyboardRotation = true;
					}

					// Now that the rotation has finished, pass the event(s) to the undo system.
					if (bStartedKeyboardRotation && !bRotateObjectFromKeyPress)
					{
						bStartedKeyboardRotation = false;

						if (g.entityrubberbandlist.size() == 0)
						{
							undosys_object_changeposrotscl(index, t.entityelement[index].x, t.entityelement[index].y, t.entityelement[index].z, 
								prevRotations[0][0], prevRotations[0][1], prevRotations[0][2],
								prevQuatRotationsMode[0][0], prevQuatRotations[0][0], prevQuatRotations[0][1], prevQuatRotations[0][2], prevQuatRotations[0][3],
								t.entityelement[index].scalex, t.entityelement[index].scaley, t.entityelement[index].scalez);
						}
						else
						{
							undosys_multiplevents_start();
							for (int i = 0; i < prevPositions.size(); i++)
							{
								int e = g.entityrubberbandlist[i].e;
								undosys_object_changeposrotscl(e, prevPositions[i][0], prevPositions[i][1],	prevPositions[i][2], 
									prevRotations[i][0], prevRotations[i][1], prevRotations[i][2],
									prevQuatRotationsMode[i][0], prevQuatRotations[i][0], prevQuatRotations[i][1], prevQuatRotations[i][2], prevQuatRotations[i][3],
									t.entityelement[e].scalex, t.entityelement[e].scaley, t.entityelement[e].scalez);
							}
							undosys_multiplevents_finish();
						}

						prevRotations.clear();
						prevPositions.clear();
					}
					#endif
					
					// trigger a rotation when detect rotation key pressed
					if (bRotateObjectFromKeyPress == true)
					{
						// the object to rotate
						int iObj = t.entityelement[t.widget.pickedEntityIndex].obj;
						int entid = t.entityelement[t.widget.pickedEntityIndex].bankindex;

						// object rotation 
						GGQUATERNION QuatAroundX, QuatAroundY, QuatAroundZ;
						GGQuaternionRotationAxis(&QuatAroundX, &GGVECTOR3(1, 0, 0), GGToRadian(fMoveAngX));
						GGQuaternionRotationAxis(&QuatAroundY, &GGVECTOR3(0, 1, 0), GGToRadian(fMoveAngY));
						GGQuaternionRotationAxis(&QuatAroundZ, &GGVECTOR3(0, 0, 1), GGToRadian(fMoveAngZ));
						quatRotationEvent = QuatAroundX * QuatAroundY * QuatAroundZ;
						GGQUATERNION quatCurrentOrientation = GGQUATERNION(t.entityelement[t.widget.pickedEntityIndex].quatx, t.entityelement[t.widget.pickedEntityIndex].quaty, t.entityelement[t.widget.pickedEntityIndex].quatz, t.entityelement[t.widget.pickedEntityIndex].quatw);
						GGQUATERNION quatNewOrientation;
						GGQuaternionMultiply(&quatNewOrientation, &quatCurrentOrientation, &quatRotationEvent);
						entity_updatequat(t.widget.pickedEntityIndex, quatNewOrientation.x, quatNewOrientation.y, quatNewOrientation.z, quatNewOrientation.w);
						RotateObjectQuat(iObj, quatNewOrientation.x, quatNewOrientation.y, quatNewOrientation.z, quatNewOrientation.w);
						t.entityelement[t.widget.pickedEntityIndex].rx = ObjectAngleX(iObj);
						t.entityelement[t.widget.pickedEntityIndex].ry = ObjectAngleY(iObj);
						t.entityelement[t.widget.pickedEntityIndex].rz = ObjectAngleZ(iObj);

						// special case for characters, only want the Y angle
						if (t.entityprofile[entid].ischaracter == 1)
						{
							// quats are the true rotations of objects, but refresh euler for characters to ONLY use the Y axis
							entity_calculateeuleryfromquat(t.widget.pickedEntityIndex);
						}

						// when rotate with keys, see new value in slider/value right panel
						g_bRefreshRotationValuesFromObjectOnce = true;
					}

					//PE: Update light data for spot.
					//PE: Updating probes is slow, this is called on each frame.
					if (t.entityelement[t.widget.pickedEntityIndex].eleprof.usespotlighting)
					{
						#ifdef WICKEDENGINE
						static bool bReadyToUpdateSpot = false;
						bool bUpdate = false;
						if (!bReadyToUpdateSpot && ImGui::IsMouseClicked(0)) bReadyToUpdateSpot = true;
						if (bReadyToUpdateSpot && !ImGui::IsMouseClicked(0))
						{
							bReadyToUpdateSpot = false;
							bUpdate = true;
						}
						if(bUpdate)
						{
						#endif
							lighting_refresh();
						#ifdef WICKEDENGINE
						}
						#endif
					}

					// also update particle emitter
					#ifdef WICKEDENGINE
					entity_updateparticleemitter(t.widget.pickedEntityIndex);
					entity_updateautoflatten(t.widget.pickedEntityIndex);
					#endif

					if ( t.entityelement[t.widget.pickedEntityIndex].obj>0 ) 
					{
						int iTargetCenterObject = t.entityelement[t.widget.pickedEntityIndex].obj;
						if ( ObjectExist ( iTargetCenterObject ) == 1 ) 
						{
							if ( g.entityrubberbandlist.size() > 0 )
							{
								// rotate all the grouped entities and move around Y axis of widget as pivot
								if (bRotateObjectFromKeyPress == true)
								{
									SetStartPositionsForRubberBand(iTargetCenterObject);
									RotateAndMoveRubberBand(iTargetCenterObject, 0, 0, 0, quatRotationEvent);
								}
							}
						}
					}
				}
				//  Find Floor (  control of widget controlled entity or Raise/lower with PGUP and PGDN )
				if (t.inputsys.keyreturn == 1 || t.inputsys.kscancode == 201 || t.inputsys.kscancode == 209)
				{
					t.tforceentityfindfloor = t.widget.pickedEntityIndex;
					t.tforcepguppgdnkeys = 1;
					editor_forceentityfindfloor (false);
				}
			}
			else
			{
				if (  t.inputsys.domodeterrain == 0 && t.inputsys.domodeentity == 0 ) 
				{
					#ifdef WICKEDENGINE
					if (t.widget.pickedEntityIndex > 0)
					{
						if (iObjectMoveModeDropSystem < 0)
						{
							//PE: Support new y placement when also using shift. t.gridentity is set.
							if (t.inputsys.keyreturn == 1 || t.inputsys.kscancode == 201 || t.inputsys.kscancode == 209)
							{
								t.tforceentityfindfloor = t.widget.pickedEntityIndex;
								t.tforcepguppgdnkeys = 1;
								editor_forceentityfindfloor(false);
							}
						}

					}
					#endif
					//  avoid interference from terrain/entity mode change
					if (  t.inputsys.dorotation == 1 ) 
					{
						#ifdef WICKEDENGINE
						if (iObjectMoveMode == 2 && g_iOrientToSurfaceMode == 1)
						{
							g_fLocalTurnRotationForSmartMode += t.tspeedofrot_f;
							g_fLocalTurnRotationForSmartMode = WrapValue(g_fLocalTurnRotationForSmartMode);
						}
						else
						#endif
						{
							t.gridentityrotatey_f += t.tspeedofrot_f;
							t.gridentityrotateaxis = 1;
						}
					}
					if (  t.inputsys.doentityrotate == 1 )
					{ 
						t.gridentityrotatex_f -= t.tspeedofrot_f  ; t.gridentityrotateaxis = 0; 
					}
					if (  t.inputsys.doentityrotate == 2 ) { t.gridentityrotatex_f += t.tspeedofrot_f  ; t.gridentityrotateaxis = 0; }
					if (  t.inputsys.doentityrotate == 3 ) { t.gridentityrotatey_f -= t.tspeedofrot_f  ; t.gridentityrotateaxis = 1; }
					if (  t.inputsys.doentityrotate == 4 ) { t.gridentityrotatey_f += t.tspeedofrot_f  ; t.gridentityrotateaxis = 1; }
					if (  t.inputsys.doentityrotate == 5 ) { t.gridentityrotatez_f -= t.tspeedofrot_f  ; t.gridentityrotateaxis = 2; }
					if (  t.inputsys.doentityrotate == 6 ) { t.gridentityrotatez_f += t.tspeedofrot_f  ; t.gridentityrotateaxis = 2; }
					if (  t.inputsys.doentityrotate >= 98 ) 
					{
						if (  t.inputsys.doentityrotate == 98 ) 
						{
							if (  t.gridentityrotateaxis == 0  )  t.gridentityrotatex_f = 0;
							if (  t.gridentityrotateaxis == 1  )  t.gridentityrotatey_f = 0;
							if (  t.gridentityrotateaxis == 2  )  t.gridentityrotatez_f = 0;
						}
						if (  t.inputsys.doentityrotate == 99 ) 
						{
							t.gridentityrotatex_f=0;
							t.gridentityrotatey_f=0;
							t.gridentityrotatez_f=0;
						}
					}
				}
				t.gridentityrotatex_f=WrapValue(t.gridentityrotatex_f);
				t.gridentityrotatey_f=WrapValue(t.gridentityrotatey_f);
				t.gridentityrotatez_f=WrapValue(t.gridentityrotatez_f);
			}
		}
	}

	//  Load and Save
	if ( t.inputsys.doload == 1 ) gridedit_load_map ( );
	if ( t.inputsys.dosave == 1 ) 
	{
		if (  g.galwaysconfirmsave == 1 ) 
		{
			gridedit_saveas_map ( );
		}
		else
		{
			gridedit_save_map_ask ( );
		}
	}
	if ( t.inputsys.doopen == 1 ) gridedit_open_map_ask ( );
	if ( t.inputsys.donew == 1 || t.inputsys.donewflat == 1 ) gridedit_new_map_ask ( );
	if ( t.inputsys.dosaveas == 1 ) gridedit_saveas_map ( );
	if ( t. inputsys.dosaveandrun==1 ) { t.inputsys.dosaveandrun = 0 ; editor_previewmap ( 0 ); }

	//  Undo \ Redo
	if (t.inputsys.doundo == 1)
	{
		editor_undo ();
		#ifdef WICKEDENGINE
		t.inputsys.doundo = 0;
		#endif
	}
	if (t.inputsys.doredo == 1)
	{
		editor_redo ();
		#ifdef WICKEDENGINE
		t.inputsys.doredo = 0;
		#endif
	}

	//  Paint Select or Art Mode
	if ( t.inputsys.domodeterrain == 1 || t.inputsys.domodemarker == 1 || t.inputsys.domodeentity == 1  || t.inputsys.domodewaypoint == 1 )
	{
		// select editing mode and refresh
		if ( t.inputsys.domodeterrain == 1 ) { t.inputsys.domodeterrain=0; t.gridentitymarkersmodeonly=0; t.grideditselect=0; }
		if ( t.inputsys.domodemarker == 1 ) { t.inputsys.domodemarker=0; t.gridentitymarkersmodeonly=1; t.grideditselect=5; }
		if ( t.inputsys.domodeentity == 1 ) { t.inputsys.domodeentity=0; t.gridentitymarkersmodeonly=0; t.grideditselect=5; }
		if ( t.inputsys.domodewaypoint == 1 ) { t.inputsys.domodewaypoint=0; t.gridentitymarkersmodeonly=0; t.grideditselect=6; }
		editor_refresheditmarkers ( );
		gridedit_updateprojectname();

		// also deactivate EBE if enter a regular editing mode
		ebe_hide();
	}

	//  Manage waypoints on map
	t.tokay=0;
	if (  t.grideditselect == 5 ) 
	{
		//  entity mode can manipulate waypoint zone style
		if (  t.widget.pickedObject == 0 && t.widget.pickedSection == 0 && t.gridentity == 0 ) 
		{
			//  ensure low interference if editing, etc
			t.tokay=1;
		}
	}
	if (  t.grideditselect == 6 ) 
	{
		//  waypoint mode has access to waypoint editing
		t.tokay=1;
	}
	if (  t.tokay == 1 ) 
	{
		t.mx_f=t.inputsys.localx_f ; t.mz_f=t.inputsys.localy_f ; t.mclick=t.inputsys.mclick;
		g.waypointeditheight_f=t.inputsys.localcurrentterrainheight_f;

		// only detect waypoints when NOT using rubber band
		#ifdef WICKEDENGINE
		if (t.inputsys.rubberbandmode == 0 && t.ebe.on == 0 && t.showeditorelements)
		#else
		if (t.inputsys.rubberbandmode == 0 && t.ebe.on == 0)
		#endif
			waypoint_mousemanage ( );
	}

	//  New clip height control
	if (  t.inputsys.keycontrol == 1 ) 
	{
		if (  t.inputsys.wheelmousemove>0 ) 
		{
			t.clipheight_f -= 2.0f ; if (  t.clipheight_f<0.0f  )  t.clipheight_f = 0.0f;
			t.updatezoom=1;
		}
		if (  t.inputsys.wheelmousemove<0 ) 
		{
			t.clipheight_f += 2.0f ; if (  t.clipheight_f>50000.0f )  t.clipheight_f = 50000.0f;
			t.updatezoom=1;
		}
	}

	//  Zoom factor (for top down or freeflight+ControlKey ( ) )
	t.tspecialgridzoomadjustment=0;
	if (  t.editorfreeflight.mode == 0 || t.tspecialgridzoomadjustment != 0 ) 
	{
		if (  ((t.inputsys.dozoomin == 1 && t.inputsys.keypress == 0) || t.tspecialgridzoomadjustment == 1) && t.gridzoom_f>0.3 ) 
		{
			t.updatezoom=1;
			if (  t.inputsys.keyshift == 1 ) 
			{
				t.gridzoom_f -= 0.6f*fMouseWheelZoomFactor;
			}
			else
			{
				t.gridzoom_f -= 0.1f*fMouseWheelZoomFactor;
			}
		}
		if (  ((t.inputsys.dozoomout == 1 && t.inputsys.keypress == 0) || t.tspecialgridzoomadjustment == 2) && t.gridzoom_f<40.0 ) 
		{
			t.updatezoom=1;
			if (  t.inputsys.keyshift == 1 ) 
			{
				t.gridzoom_f += 0.6f*fMouseWheelZoomFactor;
			}
			else
			{
				t.gridzoom_f += 0.1f*fMouseWheelZoomFactor;
			}
		}
	}

	//  Scroll Map
	t.borderx_f=1024.0*50.0;
	t.bordery_f=1024.0*50.0;
	if (  t.inputsys.doscrollleft != 0 ) 
	{
		t.cx_f -= t.gridzoom_f*3*t.inputsys.doscrollleft;
		t.updatezoom=1;
	}
	if (  t.inputsys.doscrollright != 0 ) 
	{
		t.cx_f += t.gridzoom_f*3*t.inputsys.doscrollright;
		t.updatezoom=1;
	}
	if (  t.inputsys.doscrollup != 0 ) 
	{
		t.cy_f += t.gridzoom_f*3*t.inputsys.doscrollup;
		t.updatezoom=1;
	}
	if (  t.inputsys.doscrolldown != 0 ) 
	{
		t.cy_f -= t.gridzoom_f*3*t.inputsys.doscrolldown;
		t.updatezoom=1;
	}

	//  Scroll boundaries
	#ifdef WICKEDENGINE
	// no such limits in the MAX world!
	#else
	if (  t.cx_f<0  )  t.cx_f = 0;
	if (  t.cy_f<0  )  t.cy_f = 0;
	if (  t.cx_f>t.borderx_f  )  t.cx_f = t.borderx_f;
	if (  t.cy_f>t.bordery_f  )  t.cy_f = t.bordery_f;
	#endif

	#ifdef WICKEDENGINE
	//PE: Only active in object mode. t.grideditselect == 5
	if (!g_bCharacterCreatorPlusActivated && !bStoryboardWindow && t.grideditselect == 5 )
	{
		//PE: @Paul we need this in object mode :)
		MouseLeftDragXZPanning();
		MouseWheelYPanning();
		//DragCameraMovement();
	}
	#endif
}

float editor_forceentityfindfloor (bool bPredictMode)
{
	// earl out if t.gridentityinzoomview out of bounds
	if (t.gridentityinzoomview >= g.entityelementmax) return 0.0f;
	//LB: And some extra protection (backs up PE addition below)
	if (t.gridentityinzoomview >= t.entityelement.size()) return 0.0f;

	// receives; tforceentityfindfloor
	// bPredictMode = set to true when we want to work out where the object will go when forced to floor
	// but without affecting any globals or states
	float fPredictedYPosition = 0.0f;
	int ssgridentityinzoomview, ssgridentitydroptoground;
	float ssgridentityposx_f, ssgridentityposy_f, ssgridentityposz_f;
	int ssgridentityobj, ssthardauto, ssgridentityposoffground, ssgridentityusingsoftauto, ssgridentitysurfacesnap;
	if (bPredictMode == true)
	{
		ssgridentityinzoomview = t.gridentityinzoomview;
		ssgridentitydroptoground = t.gridentitydroptoground;
		ssgridentityposx_f = t.gridentityposx_f;
		ssgridentityposy_f = t.gridentityposy_f;
		ssgridentityposz_f = t.gridentityposz_f;
		ssgridentityobj = t.gridentityobj;
		ssthardauto = t.thardauto;
		ssgridentityposoffground = t.gridentityposoffground;
		ssgridentityusingsoftauto = t.gridentityusingsoftauto;
		ssgridentitysurfacesnap = t.gridentitysurfacesnap;
	}
	t.storegridentityinzoomview = t.gridentityinzoomview;
	t.gridentityinzoomview = t.tforceentityfindfloor;
	t.storegridentityposy_f = t.gridentityposy_f;
	t.gridentityposy_f = t.entityelement[t.gridentityinzoomview].y; //PE: Crash , if loading level with less entitys and selecting a object, now reset in new level.
	int iEntPassMax = 1;
	if (g.entityrubberbandlist.size() > 0) iEntPassMax = g.entityrubberbandlist.size();
	for (int iEntPass = 0; iEntPass < iEntPassMax; iEntPass++)
	{
		// which entity are we dealing with
		int e = t.gridentityinzoomview;
		#ifdef WICKEDENGINE
		if (!pref.iEnableDragDropEntityMode)
		{
			if (g.entityrubberbandlist.size() > 0)
			{
				e = g.entityrubberbandlist[iEntPass].e;
			}
		}
		else
		{
			if (g.entityrubberbandlist.size() > 0)
			{
				// Ignore if entity is part of group. It would split up the group.
				e = g.entityrubberbandlist[iEntPass].e;

				// Dont allow find floor if entity is part of group.
				int grouplist = isEntityInGroupList(e);
				if (grouplist >= 0) e = 0;
			}
		}
		#endif
		if ((e > 0 && t.entityelement[e].editorlock == 0) || bPredictMode == true)
		{
			// if RETURN key pressed
			if (bPredictMode == true)
				t.gridentityposy_f = ObjectPositionY(t.gridentityobj);
			else
				t.gridentityposy_f = t.entityelement[e].y;
			if (t.inputsys.keyreturn == 1 || bPredictMode == true)
			{
				// store globs in store
				t.storegridentitydroptoground = t.gridentitydroptoground;
				t.storegridentityposx_f = t.gridentityposx_f;
				t.storegridentityposz_f = t.gridentityposz_f;
				t.storegridentityobj = t.gridentityobj;
				t.storegridentityposoffground = t.gridentityposoffground;
				t.gridentitydroptoground = 1;
				if (bPredictMode == true)
				{
					t.gridentityposx_f = ObjectPositionX(t.gridentityobj);
					t.gridentityposz_f = ObjectPositionZ(t.gridentityobj);
				}
				else
				{
					t.gridentityposx_f = t.entityelement[e].x;
					t.gridentityposz_f = t.entityelement[e].z;
					t.gridentityobj = t.entityelement[e].obj;
				}
				t.thardauto = 1; editor_findentityground();
				if (t.gridentityposoffground == 0)
				{
					#ifdef WICKEDENGINE
					float ftmp = BT_GetGroundHeight(t.terrain.TerrainID, t.gridentityposx_f, t.gridentityposz_f);
					//if (ftmp > 0) //LB: terrain heights can be negative too!
						t.gridentityposy_f = ftmp;
					//else
					//	t.gridentityposy_f = g.gdefaultterrainheight;
					#else
					if (t.terrain.TerrainID > 0)
					{
						t.gridentityposy_f = BT_GetGroundHeight(t.terrain.TerrainID, t.gridentityposx_f, t.gridentityposz_f);
					}
					else
					{
						t.gridentityposy_f = g.gdefaultterrainheight;
					}
					#endif
					#ifdef WICKEDENGINE
					ApplyPivotToGridEntity();
					#endif
					if (t.entityprofile[t.gridentity].ismarker != 0)  t.gridentityposy_f = t.gridentityposy_f + t.entityprofile[t.gridentity].offy;
					if (t.entityprofile[t.gridentity].defaultheight != 0)  t.gridentityposy_f = t.gridentityposy_f + t.entityprofile[t.gridentity].defaultheight;
				}
				if (bPredictMode == false)
				{
					t.entityelement[e].x = t.gridentityposx_f;
					t.entityelement[e].z = t.gridentityposz_f;
				}

				// restore globs from store
				t.gridentitydroptoground = t.storegridentitydroptoground;
				t.gridentityposx_f = t.storegridentityposx_f;
				t.gridentityposz_f = t.storegridentityposz_f;
				t.gridentityobj = t.storegridentityobj;
				t.gridentityposoffground = t.storegridentityposoffground;
				t.gridentityusingsoftauto = 1;
				t.gridentitysurfacesnap = 0;
			}
			if (bPredictMode == false)
			{
				if (t.tforcepguppgdnkeys == 1)
				{
					editor_handlepguppgdn();
				}
				if (t.entityelement[e].y != t.gridentityposy_f)
				{
					t.entityelement[e].beenmoved = 1;
				}
				t.entityelement[e].y = t.gridentityposy_f;
				if (t.entityelement[e].obj > 0)
				{
					if (ObjectExist(t.entityelement[e].obj) == 1)
					{
						PositionObject(t.entityelement[e].obj, t.entityelement[e].x, t.entityelement[e].y, t.entityelement[e].z);
					}
				}
			}
			else
			{
				// have the prediction for where the object would be placed
				fPredictedYPosition = t.gridentityposy_f;
			}
		}
	}
	t.gridentityposy_f = t.storegridentityposy_f;
	t.gridentityinzoomview = t.storegridentityinzoomview;
	if (bPredictMode == true)
	{
		// restore any changes and return prediction
		t.gridentityinzoomview = ssgridentityinzoomview;
		t.gridentitydroptoground = ssgridentitydroptoground;
		t.gridentityposx_f = ssgridentityposx_f;
		t.gridentityposy_f = ssgridentityposy_f;
		t.gridentityposz_f = ssgridentityposz_f;
		t.gridentityobj = ssgridentityobj;
		t.thardauto = ssthardauto;
		t.gridentityposoffground = ssgridentityposoffground;
		t.gridentityusingsoftauto = ssgridentityusingsoftauto;
		t.gridentitysurfacesnap = ssgridentitysurfacesnap;
		return fPredictedYPosition;
	}
	else
	{
		// regular usage
		return 0.0f;
	}
}

void editor_viewfunctionality ( void )
{
	// map view controls
	if ( t.grideditselect == 3 ) 
	{
		if ( t.inputsys.mclick == 1 ) 
		{
			t.stcx_f=t.inputsys.mmx*100.0;
			t.stcy_f=t.inputsys.mmy*100.0;
			t.cx_f=t.stcx_f ; t.cy_f=t.stcy_f ; t.gridzoom_f=t.stgridzoom_f;
			t.grideditselect=t.stgrideditselect ; editor_refresheditmarkers ( );
			while ( t.inputsys.mclick==1 ) { input_getcontrols() ; Sync() ; }
			t.cameraviewmode=0;
			t.updatezoom=1;
		}
	}

	// zoom view controls
	if ( t.grideditselect == 4 ) 
	{
		#ifdef WICKEDENGINE
		// control camera of 'zoomed entity' in a different way
		#else
		// can repos and rotate non-editor-entities
		if ( t.entityelement[t.gridentityinzoomview].editorfixed == 0 ) 
		{
			// position adjustment
			t.tposadjspeed_f=1.0;
			if ( t.inputsys.keycontrol == 1  )  t.tposadjspeed_f = 0.05f;
			if ( t.inputsys.dozoomviewmovex == 1  )  t.zoomviewtargetx_f -= t.tposadjspeed_f;
			if ( t.inputsys.dozoomviewmovex == 2  )  t.zoomviewtargetx_f += t.tposadjspeed_f;
			if ( t.inputsys.dozoomviewmovey == 1  )  t.zoomviewtargety_f -= t.tposadjspeed_f;
			if ( t.inputsys.dozoomviewmovey == 2  )  t.zoomviewtargety_f += t.tposadjspeed_f;
			if ( t.inputsys.dozoomviewmovez == 1  )  t.zoomviewtargetz_f -= t.tposadjspeed_f;
			if ( t.inputsys.dozoomviewmovez == 2  )  t.zoomviewtargetz_f += t.tposadjspeed_f;

			// rotation adjustment
			//PE: rotate lights rem: t.entityprofile[t.gridentity].ismarker != 2 &&
			if ( t.entityprofile[t.gridentity].ismarker != 3 ) 
			{
				if ( t.inputsys.keyshift == 1 ) 
				{
					t.tspeedofrot_f=10.0 ; t.inputsys.keypress=0;
				}
				else
				{
					if ( t.inputsys.keycontrol == 1 ) 
					{
						t.tspeedofrot_f=1.0;
					}
					else
					{
						t.tspeedofrot_f=45.0;
					}
				}
				if ( t.inputsys.dorotation == 1 ) {  t.zoomviewtargetry_f += t.tspeedofrot_f  ; t.gridentityrotateaxis = 1; }
				if ( t.inputsys.dozoomviewrotatex == 1 ) { t.zoomviewtargetrx_f -= t.tspeedofrot_f  ; t.gridentityrotateaxis = 0; }
				if ( t.inputsys.dozoomviewrotatex == 2 ) { t.zoomviewtargetrx_f += t.tspeedofrot_f  ; t.gridentityrotateaxis = 0; }
				if ( t.inputsys.dozoomviewrotatey == 1 ) { t.zoomviewtargetry_f -= t.tspeedofrot_f  ; t.gridentityrotateaxis = 1; }
				if ( t.inputsys.dozoomviewrotatey == 2 ) { t.zoomviewtargetry_f += t.tspeedofrot_f  ; t.gridentityrotateaxis = 1; }
				if ( t.inputsys.dozoomviewrotatez == 1 ) { t.zoomviewtargetrz_f -= t.tspeedofrot_f  ; t.gridentityrotateaxis = 2; }
				if ( t.inputsys.dozoomviewrotatez == 2 ) { t.zoomviewtargetrz_f += t.tspeedofrot_f  ; t.gridentityrotateaxis = 2; }
				if ( t.inputsys.dozoomviewrotatex >= 98 ) 
				{
					if ( t.inputsys.dozoomviewrotatex == 98 ) 
					{
						if ( t.gridentityrotateaxis == 0  )  t.zoomviewtargetrx_f = 0;
						if ( t.gridentityrotateaxis == 1  )  t.zoomviewtargetry_f = 0;
						if ( t.gridentityrotateaxis == 2  )  t.zoomviewtargetrz_f = 0;
					}
					if ( t.inputsys.dozoomviewrotatex == 99 ) 
					{
						t.zoomviewtargetrx_f=0;
						t.zoomviewtargetry_f=0;
						t.zoomviewtargetrz_f=0;
					}
				}
			}

			// update gridentity vars for visual
			t.gridentityposx_f=t.zoomviewtargetx_f;
			t.gridentityposy_f=t.zoomviewtargety_f;
			t.gridentityposz_f=t.zoomviewtargetz_f;
			t.gridentityrotatex_f=t.zoomviewtargetrx_f;
			t.gridentityrotatey_f=t.zoomviewtargetry_f;
			t.gridentityrotatez_f=t.zoomviewtargetrz_f;


			//PE: We are in properties and have snap mode, the original object position is then moved.
			//PE: We dont want this snap 5x5 grid in properties.
			// aply grid if 5x5
			#ifdef THISHASBEENREMOVED
			if ( t.gridentitygridlock == 1 ) 
			{
				t.gridentityposx_f=(int(t.gridentityposx_f/5)*5);
				t.gridentityposz_f=(int(t.gridentityposz_f/5)*5);
			}
			#endif
		}

		// mouselook mode on/off RMB
		OpenFileMap ( 1, "FPSEXCHANGE" );
		if ( t.inputsys.mclick == 2 ) 
		{
			// center mouse
			#if !defined(ENABLEIMGUI) || defined(USEOLDIDE)
			SetFileMapDWORD (  1, 48, 1 );
			#else
			if (g.mouseishidden == 0) 
			{
				g.mouseishidden = 1;
				t.tgamemousex_f = t.inputsys.xmouse; //MouseX();
				t.tgamemousey_f = t.inputsys.ymouse; //MouseY();
				HideMouse();
				#ifdef USERENDERTARGET

				POINT tmp;
				GetCursorPos(&tmp);
				t.editorfreeflight.storemousex = tmp.x;
				t.editorfreeflight.storemousey = tmp.y;

				ImVec2 setPos = { (OldrenderTargetSize.x*0.5f) + OldrenderTargetPos.x , (OldrenderTargetSize.y*0.5f) + OldrenderTargetPos.y };
				setPos.x = (int)setPos.x;
				setPos.y = (int)setPos.y;
				SetCursorPos(setPos.x, setPos.y);

				float RatioX = ((float)GetDisplayWidth() / (float)renderTargetAreaSize.x) * ((float)GetDisplayWidth() / (float)GetChildWindowWidth(-1));
				float RatioY = ((float)GetDisplayHeight() / (float)renderTargetAreaSize.y) * ((float)GetDisplayHeight() / (float)GetChildWindowHeight(-1));
				xmouseold = (setPos.x - renderTargetAreaPos.x) * RatioX;
				ymouseold = (setPos.y - renderTargetAreaPos.y) * RatioY;
				t.inputsys.xmousemove = 0;
				t.inputsys.ymousemove = 0;
				#else
				RECT rect;
				GetWindowRect(g_pGlob->hWnd, &rect);
				SetCursorPos(rect.left + (GetChildWindowWidth() / 2), rect.top + (GetChildWindowHeight() / 2));
				xmouseold = rect.left + (GetChildWindowWidth() / 2); //t.inputsys.xmouse;
				ymouseold = rect.top + (GetChildWindowHeight() / 2); //t.inputsys.xmouse;
				#endif
			}
			else 
			{
				//Center mouse here.
				//PE: imgui this need to be center on imgui window.
				#ifdef USERENDERTARGET
				extern ImVec2 OldrenderTargetSize;
				extern ImVec2 OldrenderTargetPos;
				ImVec2 setPos = { (OldrenderTargetSize.x*0.5f) + OldrenderTargetPos.x , (OldrenderTargetSize.y*0.5f) + OldrenderTargetPos.y };
				SetCursorPos(setPos.x, setPos.y);

				float RatioX = ((float)GetDisplayWidth() / (float)renderTargetAreaSize.x) * ((float)GetDisplayWidth() / (float)GetChildWindowWidth(-1));
				float RatioY = ((float)GetDisplayHeight() / (float)renderTargetAreaSize.y) * ((float)GetDisplayHeight() / (float)GetChildWindowHeight(-1));
				xmouseold = (setPos.x - renderTargetAreaPos.x) * RatioX;
				ymouseold = (setPos.y - renderTargetAreaPos.y) * RatioY;

				#else
				RECT rect;
				GetWindowRect(g_pGlob->hWnd, &rect);
				SetCursorPos(rect.left + (GetChildWindowWidth() / 2), rect.top + (GetChildWindowHeight() / 2));
				#endif
			}
			#endif			

			// camera position
			t.zoomviewcameraangle_f += (float) t.inputsys.xmousemove/2.0f;
			t.zoomviewcameraheight_f -= (float) t.inputsys.ymousemove/1.5f;
		}
		else
		{
			#if defined(ENABLEIMGUI) && !defined(USEOLDIDE)
			if (g.mouseishidden == 1) 
			{
				g.mouseishidden = 0;
				ShowMouse();
			}
			#else
			SetFileMapDWORD (  1, 48, 0 );
			#endif
		}
		SetEventAndWait (  1 );
		#endif

		//  exit zoom view
		#if defined(ENABLEIMGUI) && !defined(USEOLDIDE) 
		if (!bImGuiGotFocus && bImGuiRenderTargetFocus && t.inputsys.mclick == 1)  t.tpressedtoleavezoommode = 1;

#ifdef WICKEDENGINE
		//PE: We cant leave before bEntity_Properties_Window = false;
		//PE: If we have a wicked "texture" rendered in imgui , changing texture ("clone" after properties) will crash.
		if (bEntity_Properties_Window && !bImGuiGotFocus && bImGuiRenderTargetFocus && t.inputsys.mclick == 0 && t.tpressedtoleavezoommode == 1) bEntity_Properties_Window = false;
		else if (!bImGuiGotFocus && bImGuiRenderTargetFocus && t.inputsys.mclick == 0 && t.tpressedtoleavezoommode == 1)  t.tpressedtoleavezoommode = 2;
#else
		if (!bImGuiGotFocus && bImGuiRenderTargetFocus && t.inputsys.mclick == 0 && t.tpressedtoleavezoommode == 1)  t.tpressedtoleavezoommode = 2;
#endif

		//When properties window open , they should click "apply","cancel".
		if(bProperties_Window_Block_Mouse)
			t.tpressedtoleavezoommode = 0;

		if (bProperties_Window_Block_Mouse) 
		{
			//Must have a release before block is released.
			if (t.inputsys.mclick == 0) 
			{
				bProperties_Window_Block_Mouse = false;
				t.tpressedtoleavezoommode = 0;
			}
		}
		#else
		if ( t.inputsys.mclick == 1  )  t.tpressedtoleavezoommode = 1;
		if ( t.inputsys.mclick == 0 && t.tpressedtoleavezoommode == 1 )  t.tpressedtoleavezoommode = 2;
		#endif

		if ( (t.tpressedtoleavezoommode == 2 || t.inputsys.kscancode == 211) || t.editorinterfaceleave == 1 ) 
		{
			// leave zoomview
			t.inputsys.doautozoomview=1;

			// reset mouse click (must release LMB before zoom mode ends)
			t.tpressedtoleavezoommode=0;

			// close any property window
			interface_closepropertywindow ( );
			t.editorinterfaceleave=0;

			// 310315 - Ensure clipping is restored when return
			t.updatezoom=1;
			#if defined(ENABLEIMGUI) && !defined(USEOLDIDE) 
			#endif

			// place entity on the map
			if ( t.gridentityinzoomview>0 ) 
			{
				// DELETE key deletes entity no matter what (for fixed entities too)
				if ( t.gridentity != 0 && t.inputsys.kscancode == 211 ) 
				{
					// Delete any associated waypoint/trigger zone
					t.waypointindex=t.grideleprof.trigger.waypointzoneindex;
					if (  t.waypointindex>0 ) 
					{
						t.w=t.waypoint[t.waypointindex].start;
						waypoint_delete ( );
					}
					t.grideleprof.trigger.waypointzoneindex=0;

					// And now delete entity from cursor
					if (  t.gridentityobj == 0 ) 
					{
						DeleteObject (  t.gridentityobj );
						t.gridentityobj=0;
					}
					t.gridentityinzoomview = 0;
				}
				else
				{
					// Add entity back into map
					#ifdef VRTECH
					if (iOldgridentity == t.gridentity) 
					{
						#ifdef WICKEDENGINE
						//PE: InstanceObject - Cursor,Object Tools - objects must always be real clones.
						extern bool bNextObjectMustBeClone;
						bNextObjectMustBeClone = true;
						#endif

						gridedit_addentitytomap();
						#ifdef WICKEDENGINE
						bNextObjectMustBeClone = false;
						#endif

						t.gridentityinzoomview = 0;
					}
					else 
					{
						timestampactivity(0, "t.gridentity!=lastpropertiesid ?");
					}
					#else
					gridedit_addentitytomap();
					t.gridentityinzoomview = 0;
					#endif
					//  Hide widget to make clean return to editor
					t.widget.pickedObject=0  ; widget_updatewidgetobject ( );
				}

				// Reset cursor object settings
				t.refreshgrideditcursor=1;
				t.gridentity=0;
				t.gridedit.autoflatten=0;
				t.gridedit.entityspraymode=0;
				t.gridentityposoffground=0;
				t.gridentityusingsoftauto=1;
				t.gridentitysurfacesnap=1-g.gdisablesurfacesnap;
				#ifdef WICKEDENGINE
				// MAX handles its own positioning system
				t.gridentityautofind = 0;
				#else
				t.gridentityautofind=1;
				#endif
				t.inputsys.dragoffsetx_f=0;
				t.inputsys.dragoffsety_f=0;
				editor_refreshentitycursor ( );

				#ifdef ENABLEIMGUI
				if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
				if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
				bEntity_Properties_Window = false; //Close Properties window.
				#endif
			}
		}
	}
}

void editor_findentityground ( void )
{
	//  for entities that can be moved
	if (  t.entityelement[t.gridentityinzoomview].editorfixed == 0 ) 
	{
		//  finds ground
		if ( t.gridentitydroptoground == 1 || (t.thardauto == 0 && t.gridentityusingsoftauto == 1) ) 
		{
			#ifdef WICKEDENGINE
			bDetectTerrainOnly = false;
			#endif

			//PE: MUST disable collision on ALL rubberband objects.
			std::vector<sRubberBandType> entityvisible = g.entityrubberbandlist;
			if (g.entityrubberbandlist.size() > 0)
			{
				for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
				{
					int e = g.entityrubberbandlist[i].e;
					int obj = t.entityelement[e].obj;
					if (obj > 0 && GetVisible(obj))
					{
						entityvisible[i].x = 1;
						HideObject(obj);
					}
					else
					{
						entityvisible[i].x = 0;
					}
				}
			}


			t.tbestdist_f=99999 ; t.tbesty_f=0;
			#ifdef WICKEDENGINE
			t.tto_f = t.gridentityposy_f - 9000.0; //Make sure we hit.
			#else
			t.tto_f=t.gridentityposy_f-200.0;
			#endif
			for ( t.e = 1 ; t.e <= g.entityelementlist; t.e++ )
			{
				if ( t.thardauto == 1 ) 
				{
					// regular
					if ( t.entityelement[t.e].editorlock == 0 ) 
					{
						#ifdef WICKEDENGINE
						if (ObjectExist(t.gridentityobj) == 1)
						{
							// only allow a stack slightly higher than the height of the object we are stacking (so dont end up on a roof)
							//float fObjectSizeY = ObjectSizeY(t.gridentityobj, 1);
							//float fMargin = fObjectSizeY * 0.2f;
							//t.tfrom_f = t.gridentityposy_f + fObjectSizeY + fMargin;
							// Rick complainted, so use a fixed high height so we can stack anything, even if on the roof
							t.tfrom_f = t.gridentityposy_f + 200.0f;// fObjectSizeY + fMargin;

							// and make sure never higher than the camera Y (what we can really 'see' generally)
							if (t.tfrom_f > t.gridtrueslicey_f)
							{
								t.tfrom_f = t.gridtrueslicey_f;
							}
						}
						#else
						if (  t.inputsys.keyshift == 0 ) 
						{
							//  if close to building (clipping top of it), do not exceed clip theshold
							t.tfrom_f = t.gridentityposy_f + 50000.0;
							if (t.tfrom_f > t.gridtrueslicey_f)
							{
								t.tfrom_f = t.gridtrueslicey_f;
							}
						}
						else
						{
							t.tfrom_f=t.gridentityposy_f+75.0;
						}
						#endif
					}
					else
					{
						t.tfrom_f=t.gridentityposy_f+75.0;
					}
				}
				else
				{
					//  very subtle surface scan (to defeat small floors)
					t.tfrom_f=t.gridentityposy_f+11.0;
				}
				t.tokay=1;
				if ( t.entityprofile[t.entid].addhandlelimb>0  ) t.tokay = 0;
				if ( t.playercontrol.thirdperson.enabled == 1 ) 
				{
					// if third person char, ignore when finding surface
					if ( t.e == t.playercontrol.thirdperson.charactere  )  t.tokay = 0;
					if ( t.e == t.playercontrol.thirdperson.startmarkere  )  t.tokay = 0;
				}
				if ( t.tokay == 1 ) 
				{
					t.obj=t.entityelement[t.e].obj;
					if ( t.obj>0 && t.obj != t.gridentityobj ) 
					{
						if ( ObjectExist(t.obj) == 1 ) 
						{
							if ( GetVisible(t.obj) == 1 ) 
							{
								// 210415 - added distance check to speed up ground scan
								t.tdiffx_f=ObjectPositionX(t.obj)-t.gridentityposx_f;
								t.tdiffz_f=ObjectPositionZ(t.obj)-t.gridentityposz_f;
								t.tdiff_f=Sqrt(abs(t.tdiffx_f*t.tdiffx_f)+abs(t.tdiffz_f*t.tdiffz_f));
								if ( t.tdiff_f<ObjectSize(t.obj)*2 ) 
								{
									if ( IntersectObject(t.obj,t.gridentityposx_f,t.tfrom_f,t.gridentityposz_f,t.gridentityposx_f,t.tto_f,t.gridentityposz_f) != 0 ) 
									{
										t.tdist_f=abs(ChecklistFValueB(6)-t.tfrom_f);
										if ( t.tdist_f<t.tbestdist_f ) 
										{
											t.tbesty_f=ChecklistFValueB(6);
											t.tbestdist_f=t.tdist_f;
										}
									}
								}
							}
						}
					}
				}
			}
			if ( t.tbestdist_f < 99999 ) 
			{
				// found GetPoint ( where our entity will rest vertically )
				t.gridentityposy_f=t.tbesty_f; t.zoomviewtargety_f=t.tbesty_f;

				// now need entities own thickness from object 0,0,0 to base
				// grid of ray casts for good base detect resolution
				if ( t.gridentityobj>0 && t.thardauto == 1 ) 
				{
					if ( ObjectExist(t.gridentityobj) == 1 ) 
					{
						t.ttentsizex_f=ObjectSizeX(t.gridentityobj)/2.0;
						t.ttentsizez_f=ObjectSizeZ(t.gridentityobj)/2.0;
						if (  t.ttentsizex_f<1.0 && t.ttentsizex_f<t.ttentsizez_f  )  t.ttentsizex_f = t.ttentsizez_f;
						if (  t.ttentsizez_f<1.0 && t.ttentsizez_f<t.ttentsizex_f  )  t.ttentsizez_f = t.ttentsizex_f;
						t.stepvaluex_f=ObjectSizeX(t.gridentityobj)/10.0;
						t.stepvaluez_f=ObjectSizeZ(t.gridentityobj)/10.0;
						if (  t.stepvaluex_f<1  )  t.stepvaluex_f = 1.0;
						if (  t.stepvaluez_f<1  )  t.stepvaluez_f = 1.0;
						if (  ObjectExist(g.entityworkobjectoffset) == 1  )  DeleteObject (  g.entityworkobjectoffset );
						MakeObjectBox (  g.entityworkobjectoffset,ObjectSizeX(t.gridentityobj),ObjectSizeY(t.gridentityobj),ObjectSizeZ(t.gridentityobj) );
						PositionObject (  g.entityworkobjectoffset,ObjectPositionX(t.gridentityobj)+GetObjectCollisionCenterZ(t.gridentityobj),ObjectPositionY(t.gridentityobj)+GetObjectCollisionCenterY(t.gridentityobj),ObjectPositionZ(t.gridentityobj)+GetObjectCollisionCenterZ(t.gridentityobj) );
						RotateObject (  g.entityworkobjectoffset,ObjectAngleX(t.gridentityobj),ObjectAngleY(t.gridentityobj),ObjectAngleZ(t.gridentityobj) );
						HideObject (  g.entityworkobjectoffset );
						t.tsmallest_f=99999;
						t.tscbase_f=ObjectPositionY(g.entityworkobjectoffset)-(ObjectSizeY(g.entityworkobjectoffset)*2);
						if (  t.tsmallest_f<99999 ) 
						{
							t.tthickness_f=ObjectPositionY(t.gridentityobj)-(t.tscbase_f+t.tsmallest_f);
						}
						else
						{
							t.tthickness_f=0;
						}
						if (  ObjectExist(g.entityworkobjectoffset) == 1  )  DeleteObject (  g.entityworkobjectoffset );
						t.gridentityposy_f=t.tbesty_f+t.tthickness_f ; t.zoomviewtargety_f=t.tbesty_f+t.tthickness_f;
					}
				}
				// ensure a 'autofoundYpos' never drops BELOW Floor ( ( (i.e. skull under Floor) ) )
				#ifdef WICKEDENGINE
				float ftmp = BT_GetGroundHeight(t.terrain.TerrainID, t.gridentityposx_f, t.gridentityposz_f);
				//if (ftmp > 0) //LB: terrain height can be negative
				t.trygridentityposy_f = ftmp;
				#else
				if (  t.terrain.TerrainID>0 ) 
				{
					t.trygridentityposy_f=BT_GetGroundHeight(t.terrain.TerrainID,t.gridentityposx_f,t.gridentityposz_f);
				}
				else
				{
					t.trygridentityposy_f=g.gdefaultterrainheight;
				}
				#endif
				#ifdef WICKEDENGINE
				//PE: Apply pivot here.
				ApplyPivotToGridEntity();
				#endif
				if (  t.gridentityposy_f<t.trygridentityposy_f ) 
				{
					t.gridentityposy_f = t.trygridentityposy_f;
					#ifdef WICKEDENGINE
					//PE: Apply pivot here.
					ApplyPivotToGridEntity();
					#endif
					if (  t.entityprofile[t.gridentity].ismarker != 0  )  t.gridentityposy_f = t.gridentityposy_f + t.entityprofile[t.gridentity].offy;
					if (  t.entityprofile[t.gridentity].defaultheight != 0  )  t.gridentityposy_f = t.gridentityposy_f + t.entityprofile[t.gridentity].defaultheight;
				}
				//  we are sitting on an entity, no need for ground terrain resting
				t.gridentityposoffground=1;
			}
			else
			{
				//  if not find any entities, use terrain ground base
				t.gridentityposoffground=0;
			}

			//PE: Reenable rubberband collision.
			if (entityvisible.size() > 0)
			{
				for (int i = 0; i < (int)entityvisible.size(); i++)
				{
					int e = entityvisible[i].e;
					int obj = t.entityelement[e].obj;
					if (entityvisible[i].x == 1)
					{
						ShowObject(obj);
					}
				}
			}
		}
		else
		{
			#ifdef WICKEDENGINE
			if (!(t.gridentitydroptoground == 2 && t.thardauto == 1))
			{
				if (bDetectTerrainOnly && t.gridentity > 0 && t.gridentityobj > 0)
				{
					float newy = 0.0f;
					newy = BT_GetGroundHeight(t.terrain.TerrainID, t.gridentityposx_f, t.gridentityposz_f);
					if (newy != 0.0f)
					{
						t.gridentityposy_f = newy;
						//PE: Apply pivot here.
						bool bTmp = bExtractFixPivot;
						bExtractFixPivot = true;
						ApplyPivotToGridEntity();
						bExtractFixPivot = bTmp;
					}
				}
			}
			#endif
		}

		// finds wall
		if ( t.gridentitydroptoground == 2 && t.thardauto == 1 ) 
		{
			#ifdef WICKEDENGINE
			bDetectTerrainOnly = false;
			#endif

			t.tbestdist_f=99999 ; t.tbestx_f=0 ; t.tbestz_f=0;
			t.tbesty_f=t.gridentityposy_f+GetObjectCollisionCenterY(t.gridentityobj);
			t.a=t.gridentityrotatey_f;
			t.tfromx=NewXValue(t.gridentityposx_f,t.a,-5.0) ; t.ttox=NewXValue(t.gridentityposx_f,t.a,75.0);
			t.tfromz=NewZValue(t.gridentityposz_f,t.a,-5.0) ; t.ttoz=NewZValue(t.gridentityposz_f,t.a,75.0);
			for ( t.e = 1 ; t.e<=  g.entityelementlist; t.e++ )
			{
				t.obj=t.entityelement[t.e].obj;
				if (  t.obj>0 && t.obj != t.gridentityobj ) 
				{
					if (  ObjectExist(t.obj) == 1 ) 
					{
						if (  GetVisible(t.obj) == 1 ) 
						{
							t.tdist_f=IntersectObject(t.obj,t.tfromx,t.tbesty_f,t.tfromz,t.ttox,t.tbesty_f,t.ttoz);
							if (  t.tdist_f != 0 ) 
							{
								if (  t.tdist_f<t.tbestdist_f ) 
								{
									t.tbestx_f=ChecklistFValueA(6);
									t.tbestz_f=ChecklistFValueC(6);
									t.tbestdist_f=t.tdist_f;
								}
							}
						}
					}
				}
			}
			if (  t.tbestdist_f<99999 ) 
			{
				//  found GetPoint (  where our entity will rest on wall )
				//  now need entities own thickness from object 0,0,0 to wall-contact
				t.tbestx_f=NewXValue(t.tbestx_f,t.a+180,-5.0);
				t.tbestz_f=NewZValue(t.tbestz_f,t.a+180,-5.0);
				t.ttox=NewXValue(t.tbestx_f,t.a+180,100.0);
				t.ttoz=NewZValue(t.tbestz_f,t.a+180,100.0);
				if (  ObjectExist(g.entityworkobjectoffset) == 1  )  DeleteObject (  g.entityworkobjectoffset );
				MakeObjectBox (  g.entityworkobjectoffset,ObjectSizeX(t.gridentityobj),ObjectSizeY(t.gridentityobj),ObjectSizeZ(t.gridentityobj) );
				PositionObject (  g.entityworkobjectoffset,ObjectPositionX(t.gridentityobj)+GetObjectCollisionCenterZ(t.gridentityobj),ObjectPositionY(t.gridentityobj)+GetObjectCollisionCenterY(t.gridentityobj),ObjectPositionZ(t.gridentityobj)+GetObjectCollisionCenterZ(t.gridentityobj) );
				RotateObject (  g.entityworkobjectoffset,ObjectAngleX(t.gridentityobj),ObjectAngleY(t.gridentityobj),ObjectAngleZ(t.gridentityobj) );
				HideObject (  g.entityworkobjectoffset );
				t.tgap_f=IntersectObject(g.entityworkobjectoffset,t.tbestx_f,t.tbesty_f,t.tbestz_f,t.ttox,t.tbesty_f,t.ttoz);
				if (  t.tgap_f >= 4.9 ) 
				{
					t.tgapx_f=ChecklistFValueA(6);
					t.tgapz_f=ChecklistFValueC(6);
					t.ttddx_f=t.tgapx_f-ObjectPositionX(t.gridentityobj);
					t.ttddz_f=t.tgapz_f-ObjectPositionZ(t.gridentityobj);
					t.tthickness_f=5.0+Sqrt(abs(t.ttddx_f*t.ttddx_f)+abs(t.ttddz_f*t.ttddz_f));
				}
				else
				{
					t.tthickness_f=5.0;
				}
				t.tbestx_f=NewXValue(t.tbestx_f,t.a+180,t.tthickness_f+0.5);
				t.tbestz_f=NewZValue(t.tbestz_f,t.a+180,t.tthickness_f+0.5);
				t.gridentityposx_f=t.tbestx_f ; t.zoomviewtargetx_f=t.tbestx_f;
				t.gridentityposz_f=t.tbestz_f ; t.zoomviewtargetz_f=t.tbestz_f;
				if (  ObjectExist(g.entityworkobjectoffset) == 1  )  DeleteObject (  g.entityworkobjectoffset );
			}
		}
	}
}

void editor_refresheditmarkers ( void )
{
	//  Deactivate widget if still in effect
	widget_switchoff ( );

	//  Deactivate floating selection of entity
	if ( t.grideditselect != 5 && t.grideditselect != 4 ) 
	{
		if ( t.grideditselect != 5 ) HideObject ( t.editor.objectstartindex+5 );
		t.gridentity=0 ; t.gridentityposoffground=0;
		t.gridentityusingsoftauto=0;
		t.gridentitysurfacesnap=1-g.gdisablesurfacesnap;
		#ifdef WICKEDENGINE
		// MAX handles its own positioning system
		t.gridentityautofind = 0;
		#else
		t.gridentityautofind=1;
		#endif
		t.inputsys.dragoffsetx_f=0;
		t.inputsys.dragoffsety_f=0;
	}

	//  Update entity cursor? (delete many of these as it WAS old shroud updater!)
	t.refreshgrideditcursor=1;

	//  Update clipboard items based on mode
	editor_cutcopyclearstate ( );

	//  Waypoint visibility
	if (  t.grideditselect != t.lastgrideditselect ) 
	{
		t.lastgrideditselect=t.grideditselect;
		if (  t.grideditselect == 6 ) 
		{
			waypoint_showallpaths ( );
		}
		else
		{
			if (  t.inputsys.dowaypointview == 0 ) 
			{
				waypoint_showallpaths ( );
			}
			else
			{
				waypoint_hideallpaths ( );
			}
		}
	}

	#ifdef WICKEDENGINE
	// clear any gridentity light if gridentity no longer used
	if (t.gridentity == 0)
	{
		if (t.gridentitywickedlightindex > 0)
		{
			WickedCall_DeleteLight(t.gridentitywickedlightindex);
			t.gridentitywickedlightindex = 0;
		}
	}
	#endif
}

void editor_visuals ( void )
{
	//  Control entity selection and alpha of layers
	if (  t.refreshgrideditcursor == 1 ) 
	{
		gridedit_recreateentitycursor ( );
		t.refreshgrideditcursor=0;
	}
	gridedit_displayentitycursor ( );

	//  Update Camera
	editor_camera ( );
}

void editor_camera(void)
{
	// Camera Mode
#ifdef WICKEDENGINE
	float fFlatFloorY = BT_GetGroundHeight(t.terrain.TerrainID, t.editorfreeflight.c.x_f, t.editorfreeflight.c.z_f) + 100.0f;
	if (!bProceduralLevel && !bStoryboardWindow && !bWelcomeScreen_Window && t.game.gameisexe == 0 && !bImGuiInTestGame )
	{
		bool bCameraOutSideEditArea = false;
		float fEditableSizeHalved = GGTerrain_GetEditableSize();
		t.terraineditableareasizeminx = -fEditableSizeHalved;
		t.terraineditableareasizeminz = -fEditableSizeHalved;
		t.terraineditableareasizemaxx = fEditableSizeHalved;
		t.terraineditableareasizemaxz = fEditableSizeHalved;
		if (CameraPositionX() < t.terraineditableareasizeminx) { bCameraOutSideEditArea = true; }
		if (CameraPositionX() > t.terraineditableareasizemaxx) { bCameraOutSideEditArea = true; }
		if (CameraPositionZ() < t.terraineditableareasizeminz) { bCameraOutSideEditArea = true; }
		if (CameraPositionZ() > t.terraineditableareasizemaxz) { bCameraOutSideEditArea = true; }
		if (bCameraOutSideEditArea)
		{
			//Trigger warning.
			sprintf(cSmallTriggerMessage, "Outside of editable area, you cannot add objects or change the terrain here. Press spacebar to recenter.");
			
			if(t.inputsys.keyspace == 1)
			{
				// Recentre camera.
				t.inputsys.keyspace = 0;
				
				// Get terrain height at centre.
				float yHit = 0.0f;
				GGTerrain::GGTerrain_GetHeight(0, 0, &yHit);
				yHit += 100.0f;

				// Ensure the camera will be placed above the water.
				if (yHit < (g.gdefaultwaterheight + 100.0f))
					yHit = g.gdefaultwaterheight + 100.0f;

				t.editorfreeflight.mode = 3;
				t.editorfreeflight.s.x_f = 0;
				t.editorfreeflight.s.y_f = yHit;
				t.editorfreeflight.s.z_f = 0;
				t.editorfreeflight.s.angx_f = 0.0f;
				t.editorfreeflight.s.angy_f = 0.0f;
				t.editorfreeflight.c = t.editorfreeflight.s;
			
				
			}
			iTriggerMessageFrames = 15;
			bTriggerSmallMessage = true;

		}
	}
	#else
	float fFlatFloorY = 600.0f;
	#endif

	static bool bPressedFKey = false;
	switch ( t.cameraviewmode )
	{
		#ifdef WICKEDENGINE
		//PE: Disable zoom view. in wicked , i got some wierd results with lensflare from wicked so you could not see the object.
		//PE: Also the zoom it is a distraction.
		case 2:
		#endif
		case 0:
		{
			//  Control free flight camera viewing angle (mouselook)
			#if defined(ENABLEIMGUI) && !defined(USEOLDIDE) 
			//PE: Delta already reset , so use t.inputsys.xmousemove,y
			if (g.gminvert == 1)  t.ttmousemovey = t.inputsys.xmousemove*-1; else t.ttmousemovey = t.inputsys.ymousemove;
			t.cammousemovex_f = t.inputsys.xmousemove;
			#else
			if (g.gminvert == 1)  t.ttmousemovey = MouseMoveY()*-1; else t.ttmousemovey = MouseMoveY();
			t.cammousemovex_f = MouseMoveX();
			#endif

			#ifdef WICKEDENGINE
			//PE: If outside 3D area.
			static bool bBlockRightMouseButton = false;
			if (ImGui::IsMouseDown(1) && !bImGuiRenderTargetFocus) bBlockRightMouseButton = true;
			if (!ImGui::IsMouseDown(1))  bBlockRightMouseButton = false;
			if(bImGuiRenderTargetFocus && !bBlockRightMouseButton)
			#endif

			{
				t.cammousemovey_f = t.ttmousemovey;
				if (t.inputsys.mclick == 0)  t.inputsys.mclickreleasestate = 0;
				t.trmb = 0;
				if (t.inputsys.mclick == 2 && t.inputsys.mclickreleasestate == 0)
				{
					#if defined(ENABLEIMGUI) && !defined(USEOLDGUI)
					#ifdef USERENDERTARGET
					if (g.mouseishidden == 1)
					{
						#ifdef WICKEDENGINE
						ImVec2 setPos;
						//PE: Always center relative to window position , or you cant have a small window at the right of screen.
						RECT rect;
						GetWindowRect(g_pGlob->hWnd, &rect);
						setPos = { rect.left + (OldrenderTargetSize.x*0.5f) + OldrenderTargetPos.x , rect.top + (OldrenderTargetSize.y*0.5f) + OldrenderTargetPos.y };
						setPos.x = (int)setPos.x;
						setPos.y = (int)setPos.y;
						SetCursorPos(setPos.x, setPos.y);
						#else
						ImVec2 setPos = { (OldrenderTargetSize.x*0.5f) + OldrenderTargetPos.x , (OldrenderTargetSize.y*0.5f) + OldrenderTargetPos.y };
						setPos.x = (int)setPos.x;
						setPos.y = (int)setPos.y;
						SetCursorPos(setPos.x, setPos.y);
						#endif
						#ifdef WICKEDENGINE
						xmouseold = setPos.x;
						ymouseold = setPos.y;
						#else
						float RatioX = ((float)GetDisplayWidth() / (float)renderTargetAreaSize.x) * ((float)GetDisplayWidth() / (float)GetChildWindowWidth(-1));
						float RatioY = ((float)GetDisplayHeight() / (float)renderTargetAreaSize.y) * ((float)GetDisplayHeight() / (float)GetChildWindowHeight(-1));
						xmouseold = (setPos.x - renderTargetAreaPos.x) * RatioX;
						ymouseold = (setPos.y - renderTargetAreaPos.y) * RatioY;
						#endif
					}
					#else
					//PE: imgui this need to be center on imgui window.
					RECT rect;
					GetWindowRect(g_pGlob->hWnd, &rect);
					SetCursorPos(rect.left + (GetChildWindowWidth() / 2), rect.top + (GetChildWindowHeight() / 2));
					xmouseold = rect.left + (GetChildWindowWidth() / 2); //t.inputsys.xmouse;
					ymouseold = rect.top + (GetChildWindowHeight() / 2); //t.inputsys.xmouse;
					#endif
					#endif
					t.trmb = 1;
				}
				if (t.inputsys.mclick == 4 && t.inputsys.mclickreleasestate == 0)  t.trmb = 2;
				if (t.trmblock == 0)
				{
					if (t.cammousemovex_f != 0 || t.cammousemovex_f != 0 || t.inputsys.kscancode != 0)  t.trmblock = 1;
				}
				else
				{
					if (t.inputsys.mclick == 0)  t.trmblock = 0;
				}
				if (t.trmblock == 0)  t.trmb = 0;
				if (g.globals.disablefreeflight == 1)  t.trmb = 0;
				if (t.trmb != 0)
				{
					if (g.mouseishidden == 0)
					{
						game_hidemouse();
						#if defined(ENABLEIMGUI) && !defined(USEOLDIDE) 
						POINT tmp;
						GetCursorPos(&tmp);
						t.editorfreeflight.storemousex = tmp.x;
						t.editorfreeflight.storemousey = tmp.y;
						#else
						t.editorfreeflight.storemousex = t.inputsys.xmouse;
						t.editorfreeflight.storemousey = t.inputsys.ymouse;
						#endif
					}
					if (t.editorfreeflight.mode == 0)
					{
						t.editorfreeflight.mode = 1; t.updatezoom = 1;
						t.editorfreeflight.c.x_f = t.cx_f;
						t.editorfreeflight.c.y_f = fFlatFloorY + (50.0f*t.gridzoom_f);
						t.editorfreeflight.c.z_f = t.cy_f;
						t.editorfreeflight.c.angx_f = CameraAngleX();
						t.editorfreeflight.c.angy_f = CameraAngleY();
					}
					else
					{
						if (t.trmb == 1)
						{
							// rotate with RMB
							#if defined(ENABLEIMGUI) && !defined(USEOLDIDE)
							//PE: a bit more smooth.
							t.tRotationDivider_f = 6.0;
							#else
							t.tRotationDivider_f = 5.0;
							#endif
							
							t.editorfreeflight.c.angx_f = CameraAngleX() + (t.cammousemovey_f / t.tRotationDivider_f);
							t.editorfreeflight.c.angy_f = CameraAngleY() + (t.cammousemovex_f / t.tRotationDivider_f);
							if (t.editorfreeflight.c.angx_f > 180.0f)  t.editorfreeflight.c.angx_f = t.editorfreeflight.c.angx_f - 360.0f;
							if (t.editorfreeflight.c.angx_f < -89.999f)  t.editorfreeflight.c.angx_f = -89.999f;
							if (t.editorfreeflight.c.angx_f > 89.999f)  t.editorfreeflight.c.angx_f = 89.999f;
						}
					}
					#if defined(ENABLEIMGUI)
					//Always display skybox.
					sky_loop();
					#endif
				}
				else
				{
					if (g.mouseishidden == 1)
					{
						t.tideframestartx = 70; t.tideframestarty = 15;
						#if defined(ENABLEIMGUI) && !defined(USEOLDIDE) 
						//PE: Restore mouse pos.
						SetCursorPos(t.editorfreeflight.storemousex, t.editorfreeflight.storemousey);
						#ifdef WICKEDENGINE
						xmouseold = t.editorfreeflight.storemousex;
						ymouseold = t.editorfreeflight.storemousey;
						#else
						float RatioX = ((float)GetDisplayWidth() / (float)renderTargetAreaSize.x) * ((float)GetDisplayWidth() / (float)GetChildWindowWidth(-1));
						float RatioY = ((float)GetDisplayHeight() / (float)renderTargetAreaSize.y) * ((float)GetDisplayHeight() / (float)GetChildWindowHeight(-1));
						xmouseold = (t.editorfreeflight.storemousex - renderTargetAreaPos.x) * RatioX;
						ymouseold = (t.editorfreeflight.storemousey - renderTargetAreaPos.y) * RatioY;
						#endif
						t.inputsys.xmouse = xmouseold;
						t.inputsys.xmouse = ymouseold;
						#ifdef WICKEDENGINE
						game_showmouse();
						#else
						ShowMouse();
						#endif
						g.mouseishidden = 0;
						#else
						t.inputsys.xmouse = ((t.tideframestartx + t.editorfreeflight.storemousex + 0.0) / 800.0)*(GetDisplayWidth() + 0.0);
						t.inputsys.ymouse = ((t.tideframestarty + t.editorfreeflight.storemousey + 0.0) / 600.0)*(GetDisplayHeight() + 0.0);
						game_showmouse_restore_mouse(); //PE: Will use exact mouse positon stored by editor when hiding mouse. (if available, else t.tideframestartx...)
						#endif
						t.terrain.X_f = 999999; t.terrain.Y_f = 999999;
					}
				}
			}
			#ifdef WICKEDENGINE
			static int delayedNewLevelCamera = 0;
			if (delayedNewLevelCamera > 0)
			{
				delayedNewLevelCamera--;
				//PE: It can take up to 60 frames before we have a terrain height here. so just keep checking.
				t.tcurrenth_f = BT_GetGroundHeight(t.terrain.TerrainID, t.editorfreeflight.c.x_f, t.editorfreeflight.c.z_f);
				if (t.tcurrenth_f != GGORIGIN_Y) delayedNewLevelCamera = 0; //We got a height.
				if (delayedNewLevelCamera == 0)
				{
					t.editorfreeflight.mode = 3;
					t.editorfreeflight.s = t.editorfreeflight.c;
					t.editorfreeflight.s.y_f = t.tcurrenth_f + 325.0; //125.0;
					t.editorfreeflight.s.angy_f = -45.0f;
					t.editorfreeflight.s.angx_f = 16.0f;
				}
			}
			#endif
			// Handle free flight camea movement
			if (t.inputsys.k_s != "f") bPressedFKey = false;
			if (t.editorfreeflight.mode == 0)
			{
				t.editorfreeflight.c.x_f = t.cx_f;
				t.editorfreeflight.c.y_f = fFlatFloorY + (50.0f*t.gridzoom_f);
				t.editorfreeflight.c.z_f = t.cy_f;
				bool bSwitchToFFView = false;
				#ifdef WICKEDENGINE
				if (g_bResetCameraToFreeFlightOnNewLevel == true) 
				{ 
					// extra condition to only 'zoom in' after Welcome screen exits
					// as it looks cooler and hides the launch load stutters
					if (iTriggerWelcomeSystemStuff == 0)
					{
						bSwitchToFFView = true;
						g_bResetCameraToFreeFlightOnNewLevel = false;
					}
				}
				if (t.inputsys.k_s == "f" && bPressedFKey == false && g.globals.disablefreeflight == 0) { bPressedFKey = true;  bSwitchToFFView = true; }
				#else
				if (t.inputsys.k_s == "f" && g.globals.disablefreeflight == 0) bSwitchToFFView = true;
				#endif
				if (bSwitchToFFView == true )
				{
					// top down back to last free flight
					t.editorfreeflight.mode = 3;
					#ifdef WICKEDENGINE

					t.editorfreeflight.s = t.editorfreeflight.c;

					t.tcurrenth_f = BT_GetGroundHeight(t.terrain.TerrainID, t.editorfreeflight.c.x_f, t.editorfreeflight.c.z_f);
					if (t.tcurrenth_f != GGORIGIN_Y)
					{
						t.editorfreeflight.s.y_f = t.tcurrenth_f + 325.0; //125.0;
					}
					else
					{
						//Start up high. as we dont have the real height at this point.
						t.editorfreeflight.s.y_f = 2600.0;
						delayedNewLevelCamera = 100; //PE: Terrain need a few frames before we can set the camera.
					}

					t.editorfreeflight.s.angy_f = -45.0f;
					t.editorfreeflight.s.angx_f = 16.0f;

					#else
					if (t.editorfreeflight.sused == 0)
					{
						t.editorfreeflight.sused = 1;
						t.editorfreeflight.s = t.editorfreeflight.c;
						t.tcurrenth_f = BT_GetGroundHeight(t.terrain.TerrainID, t.editorfreeflight.c.x_f, t.editorfreeflight.c.z_f);
						t.editorfreeflight.s.y_f = t.tcurrenth_f + 100.0;
						t.editorfreeflight.s.angy_f = .00f;
						t.editorfreeflight.s.angx_f = 20.0f;
					}
					#endif
				}
			}
			if ( t.editorfreeflight.mode == 1 ) 
			{
				#ifdef WICKEDENGINE
				static float fAccelerationTimer = 0.0f;

				if (t.inputsys.k_s == "f"  && bPressedFKey == false && t.inputsys.keycontrol == 0 && t.importer.importerActive == 0)
				#else
				if ( t.inputsys.k_s == "g"  && t.inputsys.keycontrol == 0 )
				#endif
				{
					// free flight to top down
					bPressedFKey = true;
					t.editorfreeflight.s=t.editorfreeflight.c;
					t.cx_f=t.editorfreeflight.c.x_f;
					t.cy_f=t.editorfreeflight.c.z_f;
					t.editorfreeflight.mode=2;
				}
				if (  t.inputsys.keyup == 1  )  t.plrkeyW = 1; else t.plrkeyW = 0;
				if (  t.inputsys.keyleft == 1  )  t.plrkeyA = 1; else t.plrkeyA = 0;
				if (  t.inputsys.keydown == 1  )  t.plrkeyS = 1; else t.plrkeyS = 0;
				if (  t.inputsys.keyright == 1  )  t.plrkeyD = 1; else t.plrkeyD = 0;

				//  mouse wheel mimmics W and S when no CONTROL key pressed (170616 - but not when in EBE mode as its used for grid layer control)
				int usingWheel = 0;
				if ( t.ebe.on == 0 )
				{
					if (  t.inputsys.keycontrol == 0 ) 
					{
						if (  t.inputsys.wheelmousemove<0 || t.inputsys.dozoomout == 1) { t.plrkeyS = 1; usingWheel = 1; }
						if (  t.inputsys.wheelmousemove>0 || t.inputsys.dozoomin == 1 ) { t.plrkeyW = 1; usingWheel = 1; }
					}
				}
				t.traise_f=0.0;
				if (  t.inputsys.keyshift == 1 ) 
				{
					#ifdef WICKEDENGINE
					fAccelerationTimer += g.timeelapsed_f * 0.005f;
					if (fAccelerationTimer > 1.0f) fAccelerationTimer = 1.0f;
					// reduce this until we sort out scale!
					t.tffcspeed_f=10.0*g.timeelapsed_f;
					#else
					t.tffcspeed_f=300.0*g.timeelapsed_f;
					#endif
				}
				else
				{
					#ifdef WICKEDENGINE
					fAccelerationTimer = 0.0f;
					#endif					
					if (  t.inputsys.keycontrol == 1 ) 
					{
						#ifdef WICKEDENGINE
						// reduce this until we sort out scale!
						t.tffcspeed_f=1.0*g.timeelapsed_f;
						#else
						t.tffcspeed_f=5.0*g.timeelapsed_f;
						#endif
					}
					else
					{
						#ifdef WICKEDENGINE
						// reduce this until we sort out scale!
						t.tffcspeed_f=5.0*g.timeelapsed_f;
						#else
						t.tffcspeed_f=35.0*g.timeelapsed_f;
						#endif
					}
				}
				#if defined(ENABLEIMGUI)
				if (g_bCharacterCreatorPlusActivated) 
				{
					//Slow down movement when i CCP.
					t.tffcspeed_f *= 0.25;
				}
				#endif

				//PE: Classic way to fast.
				#ifndef PRODUCTCLASSIC
				#ifndef PRODUCTV3
				// Only increase movement speed when not in the importer or CCP.
				if (t.importer.importerActive == 0 && !g_bCharacterCreatorPlusActivated)
				{
					// modify movement speed based on camera height
					// LBNOTE: Should not be based on pure height, but height relative to terrain on which objects are being managed
					float fHeightAtThisPartOfTerrain = BT_GetGroundHeight(t.terrain.TerrainID, t.editorfreeflight.c.x_f, t.editorfreeflight.c.z_f);
					float height = t.editorfreeflight.c.y_f - fHeightAtThisPartOfTerrain;
					if (height < 0) height = 0;
					float modifier = height * height * 0.00001f + 2 + 50 * fAccelerationTimer; // ZJ: added 50 * fAccelerationTimer so you can reach the same high speed when holding shift, regardless of height.
					if (modifier > 50) modifier = 50;
					if (modifier < 2) modifier = 2;
					t.tffcspeed_f *= modifier;

					// Add additional acceleration when shift is pressed.
					//t.tffcspeed_f += 30 * fAccelerationTimer;
				}
				// speed up wheel movement
				if ( usingWheel ) t.tffcspeed_f *= 4;
				#endif
				#endif

				#ifdef WICKEDENGINE
				if (t.inputsys.k_s == "e")  t.traise_f = -90;
				if (t.inputsys.k_s == "q")  t.traise_f = 90;
				#else
				if (  t.inputsys.k_s == "]" || t.inputsys.k_s == "\\"  )  t.traise_f = -90;
				if (  t.inputsys.k_s == "["  )  t.traise_f = 90;
				#endif
				PositionCamera (  t.editorfreeflight.c.x_f,t.editorfreeflight.c.y_f,t.editorfreeflight.c.z_f );
				
				if (  t.plrkeyW == 1  )
					MoveCamera (  t.tffcspeed_f );

				if (  t.plrkeyS == 1  )  MoveCamera (  t.tffcspeed_f*-1 );
				if (  t.plrkeyA == 1 ) { RotateCamera (  0,t.editorfreeflight.c.angy_f-90,0  ) ; MoveCamera (  t.tffcspeed_f ); }
				if (  t.plrkeyD == 1 ) { RotateCamera (  0,t.editorfreeflight.c.angy_f+90,0  ) ; MoveCamera (  t.tffcspeed_f ); }
				if (  t.traise_f != 0 ) { RotateCamera (  t.traise_f,0,0  ) ; MoveCamera (  t.tffcspeed_f ); }
				if (  t.inputsys.mclick == 4 ) 
				{
					//  new middle mouse panning
					RotateCamera (  0,t.editorfreeflight.c.angy_f,0 );
					MoveCamera (  t.cammousemovey_f*-2 );
					if (  t.cammousemovex_f<0 ) { RotateCamera (  0,t.editorfreeflight.c.angy_f-90,0  ) ; MoveCamera (  abs(t.cammousemovex_f*2) ); }
					if (  t.cammousemovex_f>0 ) { RotateCamera (  0,t.editorfreeflight.c.angy_f+90,0  ) ; MoveCamera (  t.cammousemovex_f*2 ); }
				}
				t.editorfreeflight.c.x_f=CameraPositionX();
				t.editorfreeflight.c.y_f=CameraPositionY();
				t.editorfreeflight.c.z_f=CameraPositionZ();

				#if defined(ENABLEIMGUI)
				//Always display skybox.
				sky_loop();
				#endif
			}

			//  view mode transitions
			if (  t.editorfreeflight.mode == 2 ) 
			{
				//  from free flight to top down
				t.tcamheight_f= fFlatFloorY+(50.0f*t.gridzoom_f);
				t.editorfreeflight.c.x_f=CurveValue(t.cx_f,CameraPositionX(),10.0);
				t.editorfreeflight.c.y_f=CurveValue(t.tcamheight_f,CameraPositionY(),10.0);
				t.editorfreeflight.c.z_f=CurveValue(t.cy_f,CameraPositionZ(),10.0);
				if (  abs(t.editorfreeflight.c.y_f-t.tcamheight_f)<20.0 ) 
				{
					t.editorfreeflight.mode=0 ; t.updatezoom=1;
				}
			}
			if (  t.editorfreeflight.mode == 3 ) 
			{
				//  from top down to free flight storage
				t.editorfreeflight.c.x_f=CurveValue(t.editorfreeflight.s.x_f,CameraPositionX(),10.0);
				t.editorfreeflight.c.y_f=CurveValue(t.editorfreeflight.s.y_f,CameraPositionY(),10.0);
				t.editorfreeflight.c.z_f=CurveValue(t.editorfreeflight.s.z_f,CameraPositionZ(),10.0);
				if (  abs(t.editorfreeflight.c.x_f-t.editorfreeflight.s.x_f)<20.0 && abs(t.editorfreeflight.c.y_f-t.editorfreeflight.s.y_f)<20.0 && abs(t.editorfreeflight.c.z_f-t.editorfreeflight.s.z_f)<20.0 ) 
				{
					t.editorfreeflight.c.x_f=t.editorfreeflight.s.x_f;
					t.editorfreeflight.c.y_f=t.editorfreeflight.s.y_f;
					t.editorfreeflight.c.z_f=t.editorfreeflight.s.z_f;
					t.editorfreeflight.mode=1 ; t.updatezoom=1;
				}
			}

			//  ensure camera NEVER goes into Floor (  )
			#ifdef WICKEDENGINE
			//PE: In wicked after loading a new fpm. we need some frames before terrain height is ready.
			if(iDelayedCameraRestore > 0)
			{
				iDelayedCameraRestore--;
			}
			else
			{
			#endif
				t.tcurrenth_f = BT_GetGroundHeight(t.terrain.TerrainID, t.editorfreeflight.c.x_f, t.editorfreeflight.c.z_f) + 10.0;
					if (t.editorfreeflight.c.y_f < t.tcurrenth_f)
					{
						t.editorfreeflight.c.y_f = t.tcurrenth_f;
					}

				if (t.editorfreeflight.s.y_f < t.tcurrenth_f)
				{
					t.editorfreeflight.s.y_f = t.tcurrenth_f;
				}

			#ifdef WICKEDENGINE
			}
			#endif
			//  update camera for free flight or top down modes
			PositionCamera (t.editorfreeflight.c.x_f, t.editorfreeflight.c.y_f, t.editorfreeflight.c.z_f);
			if (t.editorfreeflight.mode == 0)
			{
				PointCamera (t.cx_f, -99999, t.cy_f);
			}
			if (t.editorfreeflight.mode == 1)
			{
				RotateCamera (t.editorfreeflight.c.angx_f, t.editorfreeflight.c.angy_f, 0);
			}
			if (t.editorfreeflight.mode == 2)
			{
				t.editorfreeflight.c.angx_f = CurveAngle(90, CameraAngleX(), 10.0);
				t.editorfreeflight.c.angy_f = CurveAngle(0, CameraAngleY(), 10.0);
				RotateCamera (t.editorfreeflight.c.angx_f, t.editorfreeflight.c.angy_f, 0);
			}
			if (t.editorfreeflight.mode == 3)
			{
				t.editorfreeflight.c.angx_f = CurveAngle(t.editorfreeflight.s.angx_f, CameraAngleX(), 10.0);
				t.editorfreeflight.c.angy_f = CurveAngle(t.editorfreeflight.s.angy_f, CameraAngleY(), 10.0);
				RotateCamera (t.editorfreeflight.c.angx_f, t.editorfreeflight.c.angy_f, 0);
			}

			//  view mode prompt (top right status Text ( ) )
			if (  t.editorfreeflight.mode == 0 || t.editorfreeflight.mode == 2 ) 
			{
				t.t_s="TOP DOWN VIEW ('F' to toggle)";
				#ifdef WICKEDENGINE
				bEditorInFreeFlightMode = false;
				#endif
			}
			else
			{
				t.t_s="FREE FLIGHT VIEW ('G' to toggle)";
				#ifdef WICKEDENGINE
				bEditorInFreeFlightMode = true;
				#endif
			}
			#if defined(ENABLEIMGUI) && !defined(USEOLDIDE) 
			//PE: TODO
			//Not really usefull in imgui , to small , we need another way to display this.
			//t.ttxtwid = getbitmapfontwidth(t.t_s.Get(), 3);
			//pastebitmapfont(t.t_s.Get(), GetChildWindowWidth(0) - 8 - t.ttxtwid, 4, 3, 228);
			#else
			t.ttxtwid=getbitmapfontwidth(t.t_s.Get(),2);
			pastebitmapfont(t.t_s.Get(),GetChildWindowWidth(0)-8-t.ttxtwid,4,2,228);
			#endif
		}
		break;

		#ifdef WICKEDENGINE
		case 999:
		#else
		case 2:
		#endif
			//  process live updates from
			interface_live_updates ( );

			//  update camera XZ with entity if editing position
			if (  t.gridentityinzoomview>0 ) 
			{
				t.cx_f=t.zoomviewtargetx_f ; t.cy_f=t.zoomviewtargetz_f;
			}

			//  if third person start marker mode, override range and angle
			t.tlayerheight_f=t.layerheight_f;
			if (  t.playercontrol.thirdperson.enabled == 1 ) 
			{
				t.zoomviewcamerarange_f=t.playercontrol.thirdperson.livecameradistance;
				t.zoomviewcameraheight_f=t.playercontrol.thirdperson.livecameraheight;
				t.zoomviewcamerafocus_f=t.playercontrol.thirdperson.livecamerafocus;
				t.zoomviewcamerashoulder_f=t.playercontrol.thirdperson.livecamerashoulder;
				if (  t.gridentityobj>0 ) 
				{
					if (  ObjectExist(t.gridentityobj) == 1 ) 
					{
						t.zoomviewcameraangle_f=(0-ObjectAngleY(t.gridentityobj));
						t.tlayerheight_f=ObjectPositionY(t.gridentityobj);
					}
				}
			}
			else
			{
				t.zoomviewcamerafocus_f=0;
				t.zoomviewcamerashoulder_f=0;
			}

			//  calculate view from position
			t.daa_f=WrapValue(180-t.zoomviewcameraangle_f);
			t.dcx_f=t.cx_f+(Sin(t.daa_f)*t.zoomviewcamerarange_f);
			t.dcy_f=t.tlayerheight_f+t.zoomviewcameraheight_f;
			t.dcz_f=t.cy_f+(Cos(t.daa_f)*t.zoomviewcamerarange_f);
			t.tcx_f=CurveValue(t.dcx_f,CameraPositionX(),4.0);
			t.tcy_f=CurveValue(t.dcy_f,CameraPositionY(),2.0);
			t.tcz_f=CurveValue(t.dcz_f,CameraPositionZ(),4.0);

			//  if target was entity, view center of it
			if (  t.gridentityinzoomview>0 ) 
			{
				t.tobj=t.entityelement[t.gridentityinzoomview].profileobj;
				if (  t.tobj>0 ) 
				{
					t.viewatx_f=t.cx_f ; t.viewaty_f=t.zoomviewtargety_f+ObjectSizeY(t.tobj)/2.0 ; t.viewatz_f=t.cy_f;
				}
				else
				{
					t.viewatx_f=t.cx_f ; t.viewaty_f=t.zoomviewtargety_f+5 ; t.viewatz_f=t.cy_f;
				}
			}
			else
			{
				t.viewatx_f=t.cx_f ; t.viewaty_f=t.zoomviewtargety_f+5 ; t.viewatz_f=t.cy_f;
			}

			//  set smoothed camera view
			PositionCamera (  t.tcx_f,t.tcy_f,t.tcz_f );
			PointCamera (  t.viewatx_f,t.viewaty_f,t.viewatz_f );
			t.tcamax_f=CameraAngleX() ; t.tcamay_f=CameraAngleY() ; t.tcamaz_f=CameraAngleZ();
			RotateCamera (  0,t.tcamay_f+90,0 );
			MoveCamera (  t.zoomviewcamerashoulder_f );
			RotateCamera (  t.tcamax_f-t.zoomviewcamerafocus_f,t.tcamay_f,t.tcamaz_f );

			#if defined(ENABLEIMGUI)
			//Always display skybox.
			sky_loop();
			#endif
			
		break;
	}
}

void editor_undoredoprojectstate ( void )
{
	// set as modified
	g.projectmodified=1 ; gridedit_changemodifiedflag ( );
	g.projectmodifiedstatic = 1;
}

void editor_cutcopyclearstate ( void )
{
	//  control enabling of UNDO REDO menu items
	#ifdef FPSEXCHANGE
	OpenFileMap (  1, "FPSEXCHANGE" );
	SetFileMapDWORD (  1, 474, 0 );
	SetFileMapDWORD (  1, 478, 0 );
	SetFileMapDWORD (  1, 482, 0 );
	SetEventAndWait (  1 );
	#endif
}

void editor_undo ( void )
{
	// undo last stage
	if ( t.ebe.on == 1 )
	{
		ebe_undo();
	}
	else
	{
		#ifdef WICKEDENGINE
		// all handled inside new undo/redo system
		entity_undo ( );
		#else
		if (  t.entityundo.undoperformed == 0 ) 
		{
			terrain_undo ( );
			entity_undo ( );
			editor_undoredoprojectstate ( );
			t.entityundo.undoperformed=1;
		}
		#endif
	}
}

void editor_redo ( void )
{
	if ( t.ebe.on == 1 )
	{
		ebe_redo();
	}
	else
	{
		#ifdef WICKEDENGINE
		// all handled inside new undo/redo system
		entity_redo ( );
		#else
		// redo last stage
		if ( t.entityundo.undoperformed == 1 ) 
		{
			entity_redo ( );
			terrain_redo ( );
			editor_undoredoprojectstate ( );
			t.entityundo.undoperformed=0;
		}
		#endif
	}
}

void gridedit_showtobjlegend ( void )
{
	t.relaytostatusbar_s="";
	if (  t.tobj>0 ) 
	{
		if (  ObjectExist(t.tobj)>0 ) 
		{
			if (  t.taddstaticlegend == 1 ) 
			{
				//  static
				t.tname_s=t.tname_s+" "+t.strarr_s[608];
			}
			else
			{
				//  dynamic
				t.tname_s=t.tname_s+" "+t.strarr_s[609];
			}
			if (  t.gridedit.autoflatten == 1  )  t.tname_s = t.tname_s+"(autoflatten)";
			if (  t.gridedit.entityspraymode == 1  )  t.tname_s = t.tname_s+"(spray mode)";
			t.relaytostatusbar_s=t.tname_s;
		}
	}
	return;
}

void editor_checkIfInSubApp ( void )
{
	t.result = 0;
	#ifdef VRTECH
	///if ( g_bCharacterCreatorPlusActivated == true ) charactercreatorplus_free(); //if ( t.characterkit.loaded == 1 ) characterkit_free ( );
	#else
	//if (t.characterkit.loaded == 1) characterkit_free();
	if ( t.importer.loaded == 1 ) importer_free ( );
	#endif
}

int findentitycursorobj ( int currentlyover )
{
	#ifdef WICKEDENGINE
	if (pref.iDragCameraMovement && t.ebe.on == 0 && bDragCameraActive)
		return 0;

	// Uses simpler system to detect what is under cursor
	int result = 0;
	uint64_t hitentity = 0;

	//PE: We already sent a ray reuse data.
	if (iReusePickObjectID != -1)
	{
		g.glastpickedx_f = fReusePickHitX;
		g.glastpickedy_f = fReusePickHitY;
		g.glastpickedz_f = fReusePickHitZ;
		t.lastfindentitycursorobj = iReusePickEntityID;
		return(iReusePickEntityID);
	}

	float fHitX, fHitY, fHitZ;
	WickedCall_GetPick(&fHitX, &fHitY, &fHitZ, NULL, NULL, NULL, &hitentity, GGRENDERLAYERS_NORMAL | GGRENDERLAYERS_TERRAIN); // LB: Added GGRENDERLAYERS_TERRAIN so cannot select objects UNDER the terrain!
	if (hitentity>0)
	{
		iLastHitObjectID = 0;

		// found object under hovering cursor, match to entity index
		sObject* pHitObject = m_ObjectManager.FindObjectFromWickedObjectEntityID(hitentity);
		if (pHitObject && CameraInsideObject(pHitObject) == true) pHitObject = NULL;
		if (pHitObject)
		{
			for (int e = 1; e <= g.entityelementlist; e++)
			{
				if (t.entityelement[e].obj == pHitObject->dwObjectNumber)
				{
					iLastHitObjectID = pHitObject->dwObjectNumber;
					g.glastpickedx_f = fHitX;
					g.glastpickedy_f = fHitY;
					g.glastpickedz_f = fHitZ;
					result = e;
					break;
				}
			}
		}
	}
	#else
	// Don't update this every frame as it is extremely intensive. 60->4 fps drop
	// If the user is scrolling, return out also
	if ( currentlyover != -1 )
	{
		//Exit out if within the time limit / scroll keys are pressed etc
		if ( Timer() - t.lastfindentitycursorobjTime < 250 || ( t.inputsys.keyup || t.inputsys.keyleft || t.inputsys.keydown || t.inputsys.keyright ) )
		{
			if ( t.lastfindentitycursorobj > 0 )
			{
				if ( t.entityelement[t.lastfindentitycursorobj].obj > 0 )
				{
					if ( ObjectExist ( t.entityelement[t.lastfindentitycursorobj].obj ) == 0 )
						t.lastfindentitycursorobj = 0;
				}
			}

			return t.lastfindentitycursorobj;
		}

		t.lastfindentitycursorobjTime = Timer();
	}

	float tadjustedtoareax_f = 0;
	float tadjustedtoareay_f = 0;
	float tbestdist_f = 0;
	int efinish = 0;
	float tdist_f = 0;
	float tdstx_f = 0;
	float tdsty_f = 0;
	float tdstz_f = 0;
	int tlayers = 0;
	float tsize_f = 0;
	int estart = 0;
	int result = 0;
	int tokay = 0;
	int e;
	int o;
	int c;
	result=0 ; tbestdist_f=99999.0;

	//PE: This could use some love (really slow), not even sure the tlayers system is actually working as it should.
	if (  currentlyover <= 0 ) { estart = 1  ; efinish = g.entityelementlist; }
	if (  currentlyover >= 1 ) { estart = currentlyover  ; efinish = currentlyover; }
	for ( tlayers = 0 ; tlayers<=  2; tlayers++ )
	{
		for ( e = estart ; e <= efinish; e++ )
		{
			// 301115 - skip if in marker mode and not a marker
			int tentid = t.entityelement[e].bankindex;
			if ( t.gridentitymarkersmodeonly == 1 && t.entityprofile[tentid].ismarker==0 )
				continue;

			// when ignore non seletables on (due to alpha slice), only do this for 'addhandle' entities
			// 190520 - special case, when TAB doing alpha slice, set this flag 
			// (so that any objects with a 'handle' only detect that handle and not the huge
			// invisible quad that stops selection of other entities)
			int iIgnoreSomeNonSelectables = 0;
			if (t.gridnearcameraclip > 0)
				if (t.entityprofile[tentid].addhandlelimb != 0)
					iIgnoreSomeNonSelectables = 1;

			// is entity valid
			o=t.entityelement[e].obj;
			if (  o>0 ) 
			{
				if (  ObjectExist(o) == 1 ) 
				{
					if (  GetVisible(o) == 1 ) 
					{
						tokay=1;
						if ( 1 ) 
						{
							if (  g.gridlayershowsingle == 1 && tlayers == 0 ) 
							{
								//  do not select if TAB slice mode active and entity too big (buildings, walls, etc)
								if (  ObjectSizeX(o)>95 && ObjectSizeY(o)>95 && ObjectSizeZ(o)>95 ) 
								{
									tokay=0;
								}
							}
							if (  tlayers == 0 ) 
							{
								// 041115 - a sphere check falsely ignores things like doors which you are
								// outside of when the doors are closed (animated, etc)
								sObject* pObject = GetObjectData ( o );
								if ( CameraPositionX(0) > pObject->collision.vecMin.x && CameraPositionX(0) < pObject->collision.vecMax.x )
								{
									if ( CameraPositionY(0) > pObject->collision.vecMin.y && CameraPositionY(0) < pObject->collision.vecMax.y )
									{
										if ( CameraPositionZ(0) > pObject->collision.vecMin.z && CameraPositionZ(0) < pObject->collision.vecMax.z )
										{
											tokay=0;
										}
									}
								}
							}
							if ( t.inputsys.keyspace == 0 && g.entityrubberbandlist.size() == 0 )  // 010416 - t.inputsys.keyshift == 0 && g.entityrubberbandlist.size() == 0 ) 
							{
								//  SPACE key can bypass the lock system
								if ( t.entityelement[e].editorlock == 1 ) 
								{
									#if defined(ENABLEIMGUI) && !defined(USEOLDIDE) 
									//PE: imgui Need testing.
									tadjustedtoareax_f = ((float)t.inputsys.xmouse / (float)GetDisplayWidth()) / ((float)GetDisplayWidth() / (float)GetChildWindowWidth(-1));
									tadjustedtoareay_f = ((float)t.inputsys.ymouse / (float)GetDisplayHeight()) / ((float)GetDisplayHeight() / (float)GetChildWindowHeight(-1));
									#else
									//  work out visible part of full backbuffer (i.e. 1212 of 1360)
									tadjustedtoareax_f=(GetDisplayWidth()+0.0)/(GetChildWindowWidth()+0.0);
									tadjustedtoareay_f=(GetDisplayHeight()+0.0)/(GetChildWindowHeight()+0.0);
									//  scale full mouse to fit in visible area
									tadjustedtoareax_f=((t.inputsys.xmouse+0.0)/800.0)/tadjustedtoareax_f;
									tadjustedtoareay_f=((t.inputsys.ymouse+0.0)/600.0)/tadjustedtoareay_f;
									#endif
									//  then provide in a format for the pick-from-screen command
									#ifdef DX11
									tadjustedtoareax_f=tadjustedtoareax_f*(GetDisplayWidth()+0.0);
									tadjustedtoareay_f=tadjustedtoareay_f*(GetDisplayHeight()+0.0);
									#else
									tadjustedtoareax_f=tadjustedtoareax_f*(GetChildWindowWidth()+0.0);
									tadjustedtoareay_f=tadjustedtoareay_f*(GetChildWindowHeight()+0.0);
									#endif
									c=PickScreenObjectEx(tadjustedtoareax_f,tadjustedtoareay_f,o,o,0,iIgnoreSomeNonSelectables);
									if (  c != 0  )  g.gentityundercursorlocked = e;
									tokay=0;
								}
							}
						}
						if (  tokay == 1 ) 
						{
							#if defined(ENABLEIMGUI) && !defined(USEOLDIDE)
							//PE: imgui Need testing.
							tadjustedtoareax_f = ((float)t.inputsys.xmouse / (float)GetDisplayWidth()) / ((float)GetDisplayWidth() / (float)GetChildWindowWidth(-1));
							tadjustedtoareay_f = ((float)t.inputsys.ymouse / (float)GetDisplayHeight()) / ((float)GetDisplayHeight() / (float)GetChildWindowHeight(-1));
							#else
							//  work out visible part of full backbuffer (i.e. 1212 of 1360)
							tadjustedtoareax_f=(GetDisplayWidth()+0.0)/(GetChildWindowWidth()+0.0);
							tadjustedtoareay_f=(GetDisplayHeight()+0.0)/(GetChildWindowHeight()+0.0);
							//  scale full mouse to fit in visible area
							tadjustedtoareax_f=((t.inputsys.xmouse+0.0)/800.0)/tadjustedtoareax_f;
							tadjustedtoareay_f=((t.inputsys.ymouse+0.0)/600.0)/tadjustedtoareay_f;
							#endif

							//  then provide in a format for the pick-from-screen command
							#ifdef DX11
							tadjustedtoareax_f=tadjustedtoareax_f*(GetDisplayWidth()+0.0);
							tadjustedtoareay_f=tadjustedtoareay_f*(GetDisplayHeight()+0.0);
							#else
							tadjustedtoareax_f=tadjustedtoareax_f*(GetChildWindowWidth()+0.0);
							tadjustedtoareay_f=tadjustedtoareay_f*(GetChildWindowHeight()+0.0);
							#endif
							#ifdef VRTECH
							c=PickScreenObjectEx(tadjustedtoareax_f,tadjustedtoareay_f,o,o,0,iIgnoreSomeNonSelectables);
							#else
							if(t.gridnearcameraclip == -1)
								c=PickScreenObject(tadjustedtoareax_f,tadjustedtoareay_f,o,o);
							else
								c=PickScreenObjectFromHeight(tadjustedtoareax_f, tadjustedtoareay_f, o, o, t.gridnearcameraclip-2.0f);
							#endif
							if (  c != 0 ) 
							{
								tdstx_f = GetPickVectorX();
								tdsty_f = GetPickVectorY();
								tdstz_f = GetPickVectorZ();
								tdist_f = Sqrt(abs(tdstx_f*tdstx_f)+abs(tdsty_f*tdsty_f)+abs(tdstz_f*tdstz_f));
								bool bIsMarker = false;
								if ( t.entityprofile[t.entityelement[e].bankindex].ismarker != 0 ) { tdist_f = 0; bIsMarker = true; }
								if ( tdist_f<tbestdist_f ) 
								{
									// 201015 - also ensure the point is BELOW any clipping
									float fTryLastPickedY = CameraPositionY() + GetPickVectorY();
									if (t.gridnearcameraclip > 0) {
										fTryLastPickedY = GetFromVectorY() + GetPickVectorY();
									}

									if ( bIsMarker==true || t.gridnearcameraclip == -1 || fTryLastPickedY < t.gridnearcameraclip + 20.0f )
									{
										if (t.gridnearcameraclip > 0) {
											g.glastpickedx_f = GetFromVectorX() + GetPickVectorX();
											g.glastpickedy_f = fTryLastPickedY;
											g.glastpickedz_f = GetFromVectorZ() + GetPickVectorZ();
										}
										else {
											g.glastpickedx_f = CameraPositionX() + GetPickVectorX();
											g.glastpickedy_f = fTryLastPickedY;
											g.glastpickedz_f = CameraPositionZ() + GetPickVectorZ();
										}
										tbestdist_f = tdist_f; result = e;
									}
								}
							}
						}
					}
				}
			}
		}
		if (  t.playercontrol.thirdperson.enabled == 1 ) 
		{
			//  if third person char, redirect to start marker
			if (  result>0 ) 
			{
				if (  result == t.playercontrol.thirdperson.charactere ) 
				{
					result=t.playercontrol.thirdperson.startmarkere;
				}
			}
		}
		if (  tlayers == 0 && result>0 ) 
		{
			if (  currentlyover == -1  )  g.gentityundercursorlocked = 0;
			if ( t.entityelement[result].editorlock == 1 )
			{
				// remove lock visual effect (zwrite)
				t.tentid = t.entityelement[result].bankindex;
				t.tte = result; entity_converttoinstance();
			}
			t.entityelement[result].editorlock=0;
			t.lastfindentitycursorobj = result;
			return result;
		}
	}
	if (  result>0 && currentlyover == -1 ) 
	{
		g.gentityundercursorlocked=0;
		t.entityelement[result].editorlock=0;
	}
	#endif
	t.lastfindentitycursorobj = result;
	return result;
}

void gridedit_clearentityrubberbandlist ( void )
{
	if ( g.entityrubberbandlist.size() > 0 )
	{
		for ( int i = 0; i < (int)g.entityrubberbandlist.size(); i++ )
		{
			int e = g.entityrubberbandlist[i].e;
			//PE: Got exception here: e was to large.
			if (e <= t.entityelement.size()) {
				int tobj = t.entityelement[e].obj;
				if (tobj > 0)
				{
					#ifdef WICKEDENGINE
					int mi = t.entityelement[e].bankindex;
					if(mi > 0 && t.entityprofile[mi].bIsDecal) //PE: Got crash here, should be bankindex.
						SetupDecalObject(tobj, e);
					else
					#endif
						SetAlphaMappingOn(tobj, 100);
				}
			}
		}
	}
	g.entityrubberbandlist.clear();
}

void gridedit_addEntityToRubberBandHighlights ( int e )
{
	// 011215 - skip if in marker mode and not a marker
	if ( t.gridentitymarkersmodeonly == 1 && t.entityprofile[t.entityelement[e].bankindex].ismarker==0 ) 
		return;

	#ifdef ALLOWSELECTINGLOCKEDOBJECTS
	if (t.entityelement[e].editorlock) return;
	#endif
	// add entity to rubber band
	int tobj = t.entityelement[e].obj;
	bool bEntityIsHighlighted = false;
	if ( g.entityrubberbandlist.size() > 0 )
	{
		for ( int i = 0; i < (int)g.entityrubberbandlist.size(); i++ )
		{
			int thise = g.entityrubberbandlist[i].e;
			if ( e == thise ) bEntityIsHighlighted = true;
		}
	}
	if ( bEntityIsHighlighted == false )
	{
		sRubberBandType rubberbandItem;
		rubberbandItem.e = e;
		rubberbandItem.x = t.entityelement[e].x;
		rubberbandItem.y = t.entityelement[e].y;
		rubberbandItem.z = t.entityelement[e].z;
		#ifdef WICKEDENGINE
		rubberbandItem.px = t.entityelement[e].x;
		rubberbandItem.py = t.entityelement[e].y;
		rubberbandItem.pz = t.entityelement[e].z;
		rubberbandItem.rx = t.entityelement[e].rx;
		rubberbandItem.ry = t.entityelement[e].ry;
		rubberbandItem.rz = t.entityelement[e].rz;	
		rubberbandItem.quatmode = t.entityelement[e].quatmode;
		rubberbandItem.quatx = t.entityelement[e].quatx;
		rubberbandItem.quaty = t.entityelement[e].quaty;
		rubberbandItem.quatz = t.entityelement[e].quatz;
		rubberbandItem.quatw = t.entityelement[e].quatw;
		rubberbandItem.scalex = t.entityelement[e].scalex;
		rubberbandItem.scaley = t.entityelement[e].scaley;
		rubberbandItem.scalez = t.entityelement[e].scalez;
		#endif
		g.entityrubberbandlist.push_back ( rubberbandItem );
		if ( t.entityelement[e].staticflag == 0 ) 
			SetAlphaMappingOn ( tobj, 103 );
		else
			SetAlphaMappingOn ( tobj, 101 );
	}
}

void gridedit_mapediting ( void )
{
	//  Determine if cursor is at rest, allows performance boost to skip
	//  expensive ray casts to find entities in map
	if (  t.inputsys.atrest != 2 ) 
	{
		t.inputsys.atrest=0;
		if (  t.inputsys.localx_f == t.inputsys.atrestx && t.inputsys.localy_f == t.inputsys.atresty ) 
		{
			t.inputsys.atrest=1;
		}
		//  never at rest when widget menu active
		if (  t.widget.pickedSection != 0  )  t.inputsys.atrest = 0;
	}
	else
	{
		if (  t.inputsys.localx_f != t.inputsys.atrestx || t.inputsys.localy_f != t.inputsys.atresty ) 
		{
			t.inputsys.atrest=0;
		}
	}

	t.inputsys.atrestx=t.inputsys.localx_f;
	t.inputsys.atresty=t.inputsys.localy_f;

	//  flag to determine if character will attach to start marker
	t.inputsys.willmakethirdperson=0;

	//  Only if within map
	if (  t.inputsys.mmx >= 0 && t.inputsys.mmy >= 0 && t.inputsys.mmx<t.maxx && t.inputsys.mmy<t.maxy ) 
	{
		//  Any click inside 3D area constitues some sort of edit
		if ( t.inputsys.mclick != 0 ) 
		{ 
			g.projectmodified = 1; 
			gridedit_changemodifiedflag ( ); 
			// effect on g.projectmodifiedstatic
		}

		//  ENTITY EDIT Handling (onedrag=0 means no waypoint dragging)
		if (  t.grideditselect !=  5  )  t.tentitytoselect  =  0;

		if (  t.grideditselect == 5 && t.onedrag == 0 ) 
		{
			//  Regular entity editing
			t.layer=t.gridlayer ; t.mx=t.inputsys.mmx ; t.my=t.inputsys.mmy;

			if (  t.selstage == 0 ) 
			{
				//  single entity highlight
				t.tshowasstatic=0 ; t.showentityid=0 ; t.tforcedynamic=0 ; t.tentitytoselect=0;

				if ( t.gridentity == 0 ) 
				{
					//  no entity attached to cursor (if RMB, deactivate entity detection for smoother moving)
					if ( t.widget.activeObject == 0 && t.inputsys.xmouse != 500000 && t.inputsys.mclick != 2 && t.inputsys.rubberbandmode == 0 ) 
					{
						if ( t.inputsys.atrest == 1 || t.inputsys.keyspace == 1 )
						{
							t.tentitytoselect = findentitycursorobj(-1);
							t.tlasttentitytoselect = t.tentitytoselect;
							t.inputsys.atrest = 2;
						}
						else
						{
							#ifdef WICKEDENGINE
							// wicked fast enough to do this test each frame
							t.tentitytoselect = findentitycursorobj(-1);
							#else
							//  quickly check if over SAME object, if so, keep selection
							if ( findentitycursorobj(t.tlasttentitytoselect)>0 ) 
							{
								//  yep, hovering over same entity
								t.tentitytoselect=t.tlasttentitytoselect;
							}
							else
							{
								//  nope, end hover selection
								t.tentitytoselect=0;
							}
							#endif
						}
						#ifdef WICKEDENGINE
						//Group edit mode ?
						if (t.tentitytoselect > 0 && current_selected_group >= 0 && group_editing_on)
						{
							//Only allow selection within group.
							int grouplist = isEntityInGroupList(t.tentitytoselect);
							if (grouplist < 0 || current_selected_group != grouplist) //Dont allow selecting objects from another group.
								t.tentitytoselect = 0;
						}
						#endif
					}
					else
					{
						t.tentitytoselect=0;
					}

					bool bActivateRubberBand = true;
					#ifdef WICKEDENGINE
					if (bDotObjectDragging || (g_hovered_dot_pobject && t.inputsys.rubberbandmode == 0) ) {
						bActivateRubberBand = false;
					}
					if (pref.iEnableDragDropEntityMode) {
						if (bWaitOnMouseRelease || iDragDropActive > 0 ) {
							t.inputsys.rubberbandmode = 0;
							bActivateRubberBand = false;
						}
					}
					if (current_selected_group >= 0 && group_editing_on)
					{
						t.inputsys.rubberbandmode = 0;
						bActivateRubberBand = false;
					}

					//PE: Added ctrl allow selecting multiply objects.
					if (pref.iDragCameraMovement && t.ebe.on == 0 && t.inputsys.keyshift == 0 && t.inputsys.keycontrol == 0)
					{
						bActivateRubberBand = false;
						//PE: Still support unselecting rubberband.
						if (t.inputsys.mclick == 1 && t.inputsys.rubberbandmode == 0 && t.widget.activeObject == 0)
						{
							if (t.inputsys.keycontrol == 0)
							{
								if (pref.iEnableDragDropEntityMode && g_hovered_pobject) 
								{
									//hover over object and click on object, this should trigger a move in the new system.
								}
								else
								{
									gridedit_clearentityrubberbandlist();
								}
							}
						}
						if (t.inputsys.rubberbandmode == 1)
						{
							bool bCancelRubberBand = false;
							if (pref.iEnableDragDropEntityMode) 
							{
								if (bWaitOnMouseRelease)
									bCancelRubberBand = true;
							}
							if (t.inputsys.xmouse == 500000 || bCancelRubberBand)
							{
								// mouse left area, cancel rubber band
								t.inputsys.rubberbandmode = 0;
							}
						}
					}
					if (pref.iDragCameraMovement && t.ebe.on == 0 && t.inputsys.keycontrol == 1 && bActivateRubberBand)
					{
						bActivateRubberBand = false;
						// if clicked a single entity WHILE holding control, can add to list
						if (t.inputsys.keycontrol == 1 && t.tentitytoselect > 0)
						{
							if (g.entityrubberbandlist.size() > 0)
							{
								//PE: When using ctrl to add to rubberband. make sure no locked items is inside rubberband.
								for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
								{
									int e = g.entityrubberbandlist[i].e;
									if (e > 0 && t.entityelement[e].editorlock)
									{
										//Locked obects in list, start new list.
										g.entityrubberbandlist.clear();
									}
								}
							}
							if (t.widget.pickedEntityIndex > 0)
							{
								// add initial selected object if not in list already
								bool bAlreadyInList = false;
								for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
								{
									int e = g.entityrubberbandlist[i].e;
									if (e == t.widget.pickedEntityIndex)
									{
										bAlreadyInList = true;
										break;
									}
								}
								if (bAlreadyInList == false)
								{
									gridedit_addEntityToRubberBandHighlights(t.widget.pickedEntityIndex);
									
								}
							}
							gridedit_addEntityToRubberBandHighlights(t.tentitytoselect);
						}
						// when select entity (widget called up), if parent to children, add them to rubberband so they can all be modified at the same time
						if (t.tentitytoselect > 0)
						{
							bool bHasChildren = false;
							t.tstoreentityindexofprimaryhightlighted = 0;
							for (int te = 1; te <= g.entityelementlist; te++)
							{
								if (t.entityelement[te].iHasParentIndex == t.tentitytoselect && t.entityelement[te].obj > 0)
								{
									gridedit_addEntityToRubberBandHighlights(te);
									editor_rec_addchildrentorubberband(te);
									bHasChildren = true;
								}
							}
							if (bHasChildren == true)
							{
								if (t.inputsys.k_s != "l")
								{
									gridedit_addEntityToRubberBandHighlights(t.tentitytoselect);
								}
							}
						}
					}
					#endif

					if (bActivateRubberBand && t.inputsys.mclick == 1 && t.inputsys.rubberbandmode == 0 && t.widget.activeObject == 0 )
					{
						// clear any previous highlights
						if ( t.inputsys.keycontrol ==  0 )
						{
#ifdef WICKEDENGINE
							if (pref.iEnableDragDropEntityMode && g_hovered_pobject) {
								//hover over object and click on object, this should trigger a move in the new system.
							}
							else
#endif
							{
								gridedit_clearentityrubberbandlist();
							}
						}
						else
						{
							// if clicked a single entity WHILE holding control, can add to list
							if ( t.tentitytoselect > 0 )
							{
								gridedit_addEntityToRubberBandHighlights ( t.tentitytoselect );
							}
						}

						// when select entity (widget called up), if parent to children, add them to rubberband so they can all be modified at the same time
						if ( t.tentitytoselect > 0 )
						{
							bool bHasChildren = false;
							t.tstoreentityindexofprimaryhightlighted = 0;
							for ( int te = 1; te <= g.entityelementlist; te++ )
							{
								if ( t.entityelement[te].iHasParentIndex == t.tentitytoselect && t.entityelement[te].obj > 0 )
								{
									gridedit_addEntityToRubberBandHighlights ( te );
									editor_rec_addchildrentorubberband ( te );
									bHasChildren = true;
								}
							}
							if ( bHasChildren == true )
							{
								if ( t.inputsys.k_s != "l" ) 
								{
									gridedit_addEntityToRubberBandHighlights ( t.tentitytoselect );
								}
							}
						}
					}

					if (bActivateRubberBand && t.tentitytoselect > 0 && t.entityelement[t.tentitytoselect].obj > 0 )
					{
						// specific entity highlighted 
						PositionObject (  t.editor.objectstartindex+5,t.entityelement[t.tentitytoselect].x,t.entityelement[t.tentitytoselect].y,t.entityelement[t.tentitytoselect].z );
						t.showentityid=t.entityelement[t.tentitytoselect].bankindex;
						if (  t.entityprofile[t.showentityid].ismarker == 3 || t.entityprofile[t.showentityid].ismarker == 6 || t.entityprofile[t.showentityid].ismarker == 8 ) 
						{
							//  trigger zone or checkpoint
							t.tscale_f=100;
						}
						else
						{
							if (  t.entityprofile[t.showentityid].islightmarker == 1 ) 
							{
								t.tscale_f=(100/3.0)*2*(t.entityelement[t.tentitytoselect].eleprof.light.range/50.0);
							}
							else
							{
								t.tscale_f = get_cursor_scale_for_obj(t.entityelement[t.tentitytoselect].obj);
							}
						}
						ScaleObject (  t.editor.objectstartindex+5,t.tscale_f,t.tscale_f,t.tscale_f );
						t.tshowasstatic=1+t.entityelement[t.tentitytoselect].staticflag;
					}
					else
					{
						// 201015 - if not highlighting an entity, click to start dragging a rubber band box
						if (bActivateRubberBand && t.widget.activeObject == 0 && t.inputsys.xmouse != 500000 )
						{
							if ( t.inputsys.mclick == 1 )
							{
								// start rubber band box
								if ( t.inputsys.rubberbandmode == 0 )
								{
									t.inputsys.rubberbandmode = 1;
									t.inputsys.spacekeynotreleased = 1;
									//PE: Make mouse relative to window pos.
									t.inputsys.rubberbandx = ImGuiGetMouseX();
									t.inputsys.rubberbandy = ImGuiGetMouseY();
								}
							}
						}
					}

					#ifdef WICKEDENGINE
					if (pref.iDragCameraMovement && t.ebe.on == 0 && t.inputsys.keyshift == 0 && t.inputsys.rubberbandmode == 1)
					{
						//PE: Shift released , end rubberband on mouse release.
						if (t.inputsys.mclick == 0)
						{
							float fCurrentRubberBandX1 = t.inputsys.rubberbandx;
							float fCurrentRubberBandX2 = ImGuiGetMouseX();
							float fCurrentRubberBandY1 = t.inputsys.rubberbandy;
							float fCurrentRubberBandY2 = ImGuiGetMouseY();
							if (fCurrentRubberBandX1 > fCurrentRubberBandX2) { float fStore = fCurrentRubberBandX1; fCurrentRubberBandX1 = fCurrentRubberBandX2; fCurrentRubberBandX2 = fStore; }
							if (fCurrentRubberBandY1 > fCurrentRubberBandY2) { float fStore = fCurrentRubberBandY1; fCurrentRubberBandY1 = fCurrentRubberBandY2; fCurrentRubberBandY2 = fStore; }

							// finish rubber banding
							t.inputsys.rubberbandmode = 0;
							bRubberBandCreated = true;
							fLastRubberBandX1 = fCurrentRubberBandX1;
							fLastRubberBandX2 = fCurrentRubberBandX2;
							fLastRubberBandY1 = fCurrentRubberBandY1;
							fLastRubberBandY2 = fCurrentRubberBandY2;
							// auto choose an entity to act as the widget achor object
							if (g.entityrubberbandlist.size() > 0)
							{
								if (g.entityrubberbandlist.size() == 1)
								{
									// if only range selected on, make it a regular entity selection
									t.widget.pickedEntityIndex = g.entityrubberbandlist[0].e;
									gridedit_clearentityrubberbandlist();
								}
								else
								{
									t.widget.pickedEntityIndex = g.entityrubberbandlist[0].e;
								}
								t.widget.pickedObject = t.entityelement[t.widget.pickedEntityIndex].obj;
								t.widget.offsetx = 0;
								t.widget.offsety = 0;
								t.widget.offsetz = 0;

								if (pref.iEnableDragDropEntityMode)
								{
									fHitOffsetZ = 0.0001; //So we trigger a widget.
								}

								i_switch_group_tab = 1; //Display "current objects" tab.
							}
							t.inputsys.rubberbandmode = 0;
						}
					}
					#endif

					// 201015 - rubber band effect and control
					if (bActivateRubberBand && t.inputsys.rubberbandmode == 1 )
					{
						//bWaitOnMouseRelease
						bool bCancelRubberBand = false;
						#ifdef WICKEDENGINE
						if (pref.iEnableDragDropEntityMode) {
							if (bWaitOnMouseRelease)
								bCancelRubberBand = true;
						}
						#endif
						if ( t.inputsys.xmouse == 500000 || bCancelRubberBand )
						{
							// mouse left area, cancel rubber band
							t.inputsys.rubberbandmode = 0;
						}
						else
						{
							#ifdef WICKEDENGINE
							float fMX = 1.0f;
							float fMY = 1.0f;
							#else
							#if defined(ENABLEIMGUI) && !defined(USEOLDIDE) 
							//PE: imgui Need testing.
							// draw and detect
							float fMX = (GetChildWindowWidth(-1) + 0.0) / (float)GetDisplayWidth(); //GetChildWindowWidth(1)
							float fMY = (GetChildWindowHeight(-1) + 0.0) / (float)GetDisplayHeight(); //GetChildWindowHeight(-1)
							#else
							// draw and detect
							float fMX = (GetChildWindowWidth(1)+0.0) / 800.0f;
							float fMY = (GetChildWindowHeight(1)+0.0) / 600.0f;
							#endif
							#endif
						
							// reverse bound box if inside out
							float fCurrentRubberBandX1 = t.inputsys.rubberbandx;
							float fCurrentRubberBandX2 = ImGuiGetMouseX();
							float fCurrentRubberBandY1 = t.inputsys.rubberbandy;
							float fCurrentRubberBandY2 = ImGuiGetMouseY();
							#ifdef WICKEDENGINE
							//PE: Y a bit off
							fCurrentRubberBandY1 -= 20.0f;
							#endif
							if ( fCurrentRubberBandX1 > fCurrentRubberBandX2 ) { float fStore = fCurrentRubberBandX1; fCurrentRubberBandX1 = fCurrentRubberBandX2; fCurrentRubberBandX2 = fStore; }
							if ( fCurrentRubberBandY1 > fCurrentRubberBandY2 ) { float fStore = fCurrentRubberBandY1; fCurrentRubberBandY1 = fCurrentRubberBandY2; fCurrentRubberBandY2 = fStore; }

							// detect all entities within box and highlight
							for ( int e = 1; e <= g.entityelementlist; e++ )
							{
								// 060116 - if locked and holding space, unlock it now
								if (t.inputsys.keyspace != 0) 
								{
									t.entityelement[e].editorlock = false;
									sObject* pObject;
									if (t.entityelement[e].obj > 0) 
									{
										pObject = g_ObjectList[t.entityelement[e].obj];
										#ifdef WICKEDENGINE
										if (pObject) 
										{
											if (t.entityelement[e].editorlock) 
											{
												#ifndef ALLOWSELECTINGLOCKEDOBJECTS
												WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_CURSOROBJECT);
												#endif
											}
											else
												WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
										}
										#endif
									}
								}

								// only if not locked
								if ( t.entityelement[e].editorlock==false )
								{
									int tobj = t.entityelement[e].obj;
									if ( tobj > 0 )
									{
										#ifdef WICKEDENGINE
										ImVec2 v2DPos = Convert3DTo2D(ObjectPositionX(tobj), ObjectPositionY(tobj), ObjectPositionZ(tobj));
										int iEntityScreenX = v2DPos.x;
										int iEntityScreenY = v2DPos.y;
										#else
										int iEntityScreenX = GetScreenX(tobj);
										int iEntityScreenY = GetScreenY(tobj);
										#endif
										if ( iEntityScreenX > fCurrentRubberBandX1*fMX && iEntityScreenX < fCurrentRubberBandX2*fMX )
										{
											if ( iEntityScreenY > fCurrentRubberBandY1*fMY && iEntityScreenY < fCurrentRubberBandY2*fMY )
											{
												// only if not already highlighted
												gridedit_addEntityToRubberBandHighlights ( e );
											}
										}
									}
								}
							}

							// now de-highlight any in the list NOT covered by the boundbox
							if ( g.entityrubberbandlist.size() > 0 )
							{
								int i = 0;
								while ( i < (int)g.entityrubberbandlist.size() )
								{
									bool bThisOneInBox = false;
									int e = g.entityrubberbandlist[i].e;
									int tobj = t.entityelement[e].obj;
									if ( tobj > 0 )
									{
										#ifdef WICKEDENGINE
										//PE: This one work better. The old have problems selecting objects at the bottom of screen.
										ImVec2 v2DPos = Convert3DTo2D(ObjectPositionX(tobj), ObjectPositionY(tobj), ObjectPositionZ(tobj));
										int iEntityScreenX = v2DPos.x;
										int iEntityScreenY = v2DPos.y;
										#else
										int iEntityScreenX = GetScreenX(tobj);
										int iEntityScreenY = GetScreenY(tobj);
										#endif
										if ( iEntityScreenX > fCurrentRubberBandX1*fMX && iEntityScreenX < fCurrentRubberBandX2*fMX )
										{
											if ( iEntityScreenY > fCurrentRubberBandY1*fMY && iEntityScreenY < fCurrentRubberBandY2*fMY )
											{
												bThisOneInBox = true;
											}
										}
									}
									if ( bThisOneInBox == false )
									{
										SetAlphaMappingOn ( tobj, 100 );
										g.entityrubberbandlist.erase(g.entityrubberbandlist.begin() + i);
										i = 0;
									}
									else
									{
										i++;
									}
								}
							}

							// when release mouse while rubber banding
							#ifdef WICKEDENGINE
							WickedCall_SetSpriteBoundBox(false,0,0,0,0);
							#endif
							if ( t.inputsys.mclick == 0 )
							{
								// finish rubber banding
								t.inputsys.rubberbandmode = 0;
								#ifdef WICKEDENGINE
								bRubberBandCreated = true;
								fLastRubberBandX1 = fCurrentRubberBandX1;
								fLastRubberBandX2 = fCurrentRubberBandX2;
								fLastRubberBandY1 = fCurrentRubberBandY1;
								fLastRubberBandY2 = fCurrentRubberBandY2;
								#endif
								// auto choose an entity to act as the widget achor object
								if (g.entityrubberbandlist.size() > 0)
								{
									if (g.entityrubberbandlist.size() == 1)
									{
										// if only range selected on, make it a regular entity selection
										t.widget.pickedEntityIndex = g.entityrubberbandlist[0].e;
										gridedit_clearentityrubberbandlist();
									}
									else
									{
										t.widget.pickedEntityIndex = g.entityrubberbandlist[0].e;
									}
									t.widget.pickedObject = t.entityelement[t.widget.pickedEntityIndex].obj;
									t.widget.offsetx = 0;
									t.widget.offsety = 0;
									t.widget.offsetz = 0;

									#ifdef WICKEDENGINE
									if (pref.iEnableDragDropEntityMode)
									{
										fHitOffsetZ = 0.0001; //So we trigger a widget.
									}

									i_switch_group_tab = 1; //Display "current objects" tab.
									#endif
								}
							}
							else
							{
								#ifdef WICKEDENGINE
								//PE: Not relative to win rect, only when selecting the actual objects, 2D is different.
								RECT rect = { NULL };
								GetWindowRect(g_pGlob->hWnd, &rect);
								float fX1 = (t.inputsys.rubberbandx + rect.left)*fMX;
								float fX2 = t.inputsys.xmouse*fMX;
								float fY1 = (t.inputsys.rubberbandy + rect.top)*fMY;
								float fY2 = t.inputsys.ymouse*fMY;
								//PE: A bit off.
								fX1 += 6.0;
								fX2 += 6.0;
								fY1 += 6.0;
								fY2 += 6.0;
								#else
								float fX1 = t.inputsys.rubberbandx*fMX;
								float fX2 = ImGuiGetMouseX()*fMX;
								float fY1 = t.inputsys.rubberbandy*fMY;
								float fY2 = ImGuiGetMouseY()*fMY;
								#endif
								if ( fX2 < fX1 )
								{
									float fSt = fX1;
									fX1 = fX2;
									fX2 = fSt;
								}
								if ( fY2 < fY1 )
								{
									float fSt = fY1;
									fY1 = fY2;
									fY2 = fSt;
								}
								#ifdef WICKEDENGINE
								if(!g_bCharacterCreatorPlusActivated)
									WickedCall_SetSpriteBoundBox(true, fX1, fY1, fX2, fY2);
								#else
								Sprite ( 123, -10000, -10000, g.editorimagesoffset+14 );
								SizeSprite ( 123, fX2-fX1, 2 );
								PasteSprite ( 123, fX1, fY1 );
								SizeSprite ( 123, fX2-fX1, 2 );
								PasteSprite ( 123, fX1, fY2-2 );
								SizeSprite ( 123, 2, fY2-fY1 );
								PasteSprite ( 123, fX1, fY1 );
								SizeSprite ( 123, 2, fY2-fY1 );
								PasteSprite ( 123, fX2-2, fY1 );
								#endif
							}
						}
					}
				}
				else
				{
					//  entity attached to cursor
					PositionObject (  t.editor.objectstartindex+5,t.gridentityposx_f,t.gridentityposy_f,t.gridentityposz_f );
					if (  ObjectExist(g.entitybankoffset+t.gridentity) == 1 ) 
					{
						if (  t.entityprofile[t.gridentity].ismarker == 3 || t.entityprofile[t.gridentity].ismarker == 6 || t.entityprofile[t.gridentity].ismarker == 8 ) 
						{
							//  trigger zone or checkpoint
							t.tscale_f=100;
						}
						else
						{
							if (  t.entityprofile[t.gridentity].islightmarker == 1 || t.gridedit.entityspraymode == 1) 
							{
								if ( t.gridedit.entityspraymode == 1 )
								{
									t.tscale_f=(100/3.0)*2*(t.gridedit.entitysprayrange/50.0);
								}
								else
								{
									t.tscale_f=(100/3.0)*2*(t.grideleprof.light.range/50.0);
								}
							}
							else
							{
								t.tscale_f = get_cursor_scale_for_obj(g.entitybankoffset+t.gridentity);
							}
						}
						ScaleObject (  t.editor.objectstartindex+5,t.tscale_f,t.tscale_f,t.tscale_f );
					}
					//if (  t.entityprofile[t.gridentity].ischaracter == 1 && t.entityprofile[t.gridentity].isthirdperson == 1 ) 
					if (  t.entityprofile[t.gridentity].ischaracter == 1 ) // 220217 - now for all characters
					{
						// third person char+marker detection (will not work in VR edit mode)
						if ( t.playercontrol.thirdperson.enabled == 0 && g.vrqcontrolmode == 0 ) 
						{
							t.tattachtothis=findentitycursorobj(-1);
							if (  t.tattachtothis>0 ) 
							{
								if (  t.entityprofile[t.entityelement[t.tattachtothis].bankindex].ismarker == 1 ) 
								{
									t.tobj=t.entityelement[t.tattachtothis].obj;
									if (  t.tobj>0 ) 
									{
										if (  ObjectExist(t.tobj) == 1 ) 
										{
											t.tmousemodifierx_f=(GetDisplayWidth()+0.0)/(GetChildWindowWidth()+0.0);
											t.tmousemodifiery_f=(GetDisplayHeight()+0.0)/(GetChildWindowHeight()+0.0);
											pastebitmapfontcenter("ATTACH FOR THIRD PERSON CONTROL",GetScreenX(t.tobj)*t.tmousemodifierx_f,(GetScreenY(t.tobj)*t.tmousemodifiery_f)+50,2,255);
											t.inputsys.willmakethirdperson=t.tattachtothis;
										}
									}
								}
							}
						}
					}
					t.tshowasstatic=1+t.gridentitystaticmode;
					t.showentityid=t.gridentity;

					#ifdef WICKEDENGINE
					// no linking in MAX
					t.tentityoverdraggingcursor = 0;
					#else
					// when holding down "L", and holding an entity, this means we are looking to 'link/associate'
					// if dragging about an entity, continue scanning for pointing at another entity
					// so we can have the option of link/associate it as a parent
					if ( t.tentityoverdraggingcursor > 0 && t.tlastentityoverdraggingcursor > 0 )
					{
						int iWhichEntityObj = findentitycursorobj(-1);
						if ( iWhichEntityObj != t.tlastentityoverdraggingcursor || t.inputsys.k_s != "l" ) 
						{
							if ( t.entityelement[t.tlastentityoverdraggingcursor].obj > 0 )
							{
								// only if not EXTRACTed
								SetAlphaMappingOn ( t.entityelement[t.tlastentityoverdraggingcursor].obj, 100 );
							}
							t.tentityoverdraggingcursor = 0;
						}
						else
							t.tentityoverdraggingcursor = t.tlastentityoverdraggingcursor;
					}
					else
					{
						if ( t.inputsys.k_s == "l" ) 
						{
							#ifdef WICKEDENGINE
							iReusePickObjectID = -1;
							#endif
							t.tentityoverdraggingcursor = findentitycursorobj(-1);
							t.tlastentityoverdraggingcursor = t.tentityoverdraggingcursor;
							if ( t.tentityoverdraggingcursor > 0 )
							{
								if ( t.tentstaticmode != 0 ) 
									SetAlphaMappingOn ( t.entityelement[t.tentityoverdraggingcursor].obj, 101 );
								else
									SetAlphaMappingOn ( t.entityelement[t.tentityoverdraggingcursor].obj, 103 );
							}
						}
						else
							t.tentityoverdraggingcursor = 0;
					}
					#endif
				}

				if (  t.tshowasstatic>0 && t.inputsys.activemouse == 1 ) 
				{
					t.tentityworkobjectchoice=0;
					if (  t.entityprofile[t.showentityid].ismarker == 1  )  t.tforcedynamic = 1;
					if (  t.entityprofile[t.showentityid].ismarker == 4  )  t.tforcedynamic = 1;
					if (  t.entityprofile[t.showentityid].ismarker == 10  )  t.tforcedynamic = 1;
					if (  t.entityprofile[t.showentityid].ismarker == 3 || t.entityprofile[t.showentityid].ismarker == 6 || t.entityprofile[t.showentityid].ismarker == 8 ) 
					{
						//  trigger area or checkpoint
						HideObject (  t.editor.objectstartindex+5 );
						t.tforcedynamic=1;
					}
					else
					{
						#ifdef WICKEDENGINE
						// No flat range decal in wicked!
						HideObject (  t.editor.objectstartindex+5 );
						#else
						ShowObject (  t.editor.objectstartindex+5 );
						if ( t.entityprofile[t.showentityid].islightmarker == 1 || t.gridedit.entityspraymode == 1) 
						{
							//  light range visual
							TextureObject (  t.editor.objectstartindex+5,0,g.editorimagesoffset+18 );
							YRotateObject (  t.editor.objectstartindex+5,0 );
							if (  t.tshowasstatic == 2 ) 
							{
								t.tentityworkobjectchoice=1820;
								modifyplaneimagestrip(t.editor.objectstartindex+5,2,0);
							}
							else
							{
								t.tentityworkobjectchoice=1821;
								modifyplaneimagestrip(t.editor.objectstartindex+5,2,1);
							}
						}
						else
						{
							if (  t.entityprofile[t.showentityid].forwardfacing == 1 ) 
							{
								//  coloured circle blob with arrow
								TextureObject (  t.editor.objectstartindex+5,0,g.editorimagesoffset+26 );
								YRotateObject (  t.editor.objectstartindex+5,t.gridentityrotatey_f );
								t.tentityworkobjectchoice=2600;
							}
							else
							{
								//  coloured circle blob
								TextureObject (  t.editor.objectstartindex+5,0,g.editorimagesoffset+7 );
								YRotateObject (  t.editor.objectstartindex+5,0 );
								t.tentityworkobjectchoice=700;
							}
							if (  t.gridedit.entityspraymode == 1 ) 
							{
								//  spray mode active
								if (  t.tshowasstatic == 2 ) 
								{
									modifyplaneimagestrip(t.editor.objectstartindex+5,8,2);
									t.tentityworkobjectchoice=1882;
								}
								else
								{
									modifyplaneimagestrip(t.editor.objectstartindex+5,8,4);
									t.tentityworkobjectchoice=1884;
								}
							}
							else
							{
								if (  t.gridedit.autoflatten == 1 ) 
								{
									//  rem purple and cyan for auto-flatten
									if (  t.tshowasstatic == 2 ) 
									{
										modifyplaneimagestrip(t.editor.objectstartindex+5,8,7);
										t.tentityworkobjectchoice=1887;
									}
									else
									{
										modifyplaneimagestrip(t.editor.objectstartindex+5,8,4);
										t.tentityworkobjectchoice=1884;
									}
								}
								else
								{
									//  rem red and green for NONE auto-flatten
									if (  t.tshowasstatic == 2 ) 
									{
										modifyplaneimagestrip(t.editor.objectstartindex+5,8,1);
										t.tentityworkobjectchoice=1881;
									}
									else
									{
										modifyplaneimagestrip(t.editor.objectstartindex+5,8,3);
										t.tentityworkobjectchoice=1883;
									}
								}
							}
						}
						ShowObject (  t.editor.objectstartindex+5 );
						#endif
					}
					//  show legend of entity hovering over (and static legend)
					t.taddstaticlegend=0;
					if (  t.tentitytoselect>0 ) 
					{
						t.tstatic=t.entityelement[t.tentitytoselect].staticflag;
						t.tentid=t.entityelement[t.tentitytoselect].bankindex;
					}
					else
					{
						t.tstatic=t.gridentitystaticmode;
						t.tentid=t.gridentity;
					}
					if (  t.tstatic == 1 ) 
					{
						t.taddstaticlegend=1;
					}
					else
					{
						t.taddstaticlegend=0;
					}
					t.editor.entityworkobjectchoice=t.tentityworkobjectchoice;
					t.editor.entitytoselect=t.tentitytoselect;
					if ( t.tentitytoselect>0 ) 
					{
						t.tobj=t.entityelement[t.tentitytoselect].obj;
						t.tname_s = "" ; t.tname_s=t.tname_s + "["+Str(t.tentitytoselect)+" {"+Str(t.tobj)+"}] "+t.entityelement[t.tentitytoselect].eleprof.name_s;
						t.ttentid=t.entityelement[t.tentitytoselect].bankindex;
						gridedit_showtobjlegend ( );
					}
					else
					{
						t.tobj=t.gridentityobj ; t.tname_s=t.grideleprof.name_s;
						t.ttentid=t.gridentity;
						gridedit_showtobjlegend ( );
					}
				}
				else
				{
					HideObject (  t.editor.objectstartindex+5 );
				}

				editor_refreshentitycursor ( );

				//  prompt when over locked entity
				if (  g.gentityundercursorlocked>0 ) 
				{
					t.relaytostatusbar_s="LOCKED - Hold SPACEBAR and click to unlock";
				}
				else
				{
					if (  t.tentitytoselect == 0 && t.gridentity == 0 ) 
					{
						t.relaytostatusbar_s="None Selected";
					}
				}

				// Entity Edit Mode
				if ( 1 ) 
				{
					// only place plane on each new placement
					static int iInitialPlacementOfPlane = 0;
					if (iInitialPlacementOfPlane == 0 && t.gridentity != 0) { iInitialPlacementOfPlane = 1; g_bResetPlaneAfterXZAdjust = false; }
					if (iInitialPlacementOfPlane == 2 && t.gridentity == 0) iInitialPlacementOfPlane = 0;

					bool bPlaceEntity = false;
					if ((t.widget.duplicatebuttonselected == 2 && t.gridentity == 0))
						bPlaceEntity = true;

					if (!bPlaceEntity)
					{
						#ifdef WICKEDENGINE
						//PE: We should only do this if we have a drag/drop process active.
						if (pref.iEnableDragDropEntityMode && bDraggingActive) 
						{
							//PE: In this mode we need a mouse release to drop
							if (ImGui::IsMouseClicked(0))
								bReadyToDropEntity = true;
							if (t.inputsys.mclick == 1)
								bReadyToDropEntity = true;
							if (t.gridentity != 0 && bReadyToDropEntity && t.inputsys.mclick == 0 && !ImGui::IsMouseDown(0))
							{
								bPlaceEntity = true;
								bReadyToDropEntity = false;
								bDraggingActive = true;
								if (iObjectMoveMode == 2 && (iObjectMoveModeDropSystemUsing == 1 && g_bHoldGridEntityPosWhenManaged == false))
								{
									// trigger force find surface events
									iObjectMoveModeDropSystem = -3;
								}
								iObjectMoveModeDropSystemUsing = 0;
							}
						}
						else
						#endif
						{
							if ((t.inputsys.mclick == 1 && t.gridentity != 0))
								bPlaceEntity = true;
						}
					}

					// so can get the plane position info later
					bool bPlanePosRegistered = false;
					float fPlanePosX, fPlanePosY, fPlanePosZ;
					fPlanePosX = 0;
					fPlanePosY = -999999.9f;
					fPlanePosZ = 0;

					#ifdef WICKEDENGINE
					// special horiz mode to match terrain height when about to go under it
					static bool bDepartedFromChosenY = false;
					static float fDepartedFromThisY = 0.0f;
					if (t.inputsys.mclick != 1) bDepartedFromChosenY = false;
					int newpicksystem = -99;

					//LB: widget control handled elsewhere, so no smart placement if widget active!
					bool bWidgetHasControlHere = false;
					if (t.widget.pickedSection > 0 && t.widget.pickedSection != -98 && t.widget.pickedSection != -99) bWidgetHasControlHere = true;
					if (bTriggerVisibleWidget == true) bWidgetHasControlHere = true;

					//Dont change anyhthing when we are ready to place entity.
					if (!bPlaceEntity && bWidgetHasControlHere == false )
					#endif
					{
						#ifdef WICKEDENGINE
						//PE: Prevent user for placing objects outside playable area.
						bool bObjectOutSideEditArea = false;
						float fEditableSizeHalved = GGTerrain_GetEditableSize();
						t.terraineditableareasizeminx = -fEditableSizeHalved;
						t.terraineditableareasizeminz = -fEditableSizeHalved;
						t.terraineditableareasizemaxx = fEditableSizeHalved;
						t.terraineditableareasizemaxz = fEditableSizeHalved;
						if (t.gridentityposx_f < t.terraineditableareasizeminx) { t.gridentityposx_f = t.terraineditableareasizeminx; bObjectOutSideEditArea = true; }
						if (t.gridentityposx_f > t.terraineditableareasizemaxx) { t.gridentityposx_f = t.terraineditableareasizemaxx; bObjectOutSideEditArea = true; }
						if (t.gridentityposz_f < t.terraineditableareasizeminz) { t.gridentityposz_f = t.terraineditableareasizeminz; bObjectOutSideEditArea = true; }
						if (t.gridentityposz_f > t.terraineditableareasizemaxz) { t.gridentityposz_f = t.terraineditableareasizemaxz; bObjectOutSideEditArea = true; }
						float fOldgridentityposx_f = t.gridentityposx_f;
						float fOldgridentityposy_f = t.gridentityposy_f;
						float fOldgridentityposz_f = t.gridentityposz_f;
						#endif

						//  entity placement update
						if (t.inputsys.mclick == 2)
						{
							//  070415 - in RMB mode, mouse pos is changed so HIDE gridentity obj as it shifts!
							#ifdef WICKEDENGINE
							if (pref.iEnableDragDropEntityMode && !bDraggingActive)
							#endif
							{
								// this breaks all future dragging
								//t.gridentityposx_f = -999000;
								//t.gridentityposz_f = -999000;
							}
						}
						else
						{
							#ifdef WICKEDENGINE
							static float fActivePosX = t.gridentityposx_f;
							static float fActivePosZ = t.gridentityposz_f;
							static float fActivePosY = fHitPointY;

							bMouseInputSystemUsed = false;
							if (pref.iEnableDragDropEntityMode)
							{
								int picksystem = t.widget.pickedSection;
								// LB: Fixes initial selection and dragging once positioned
								//if (fHitPointY == 0.0f) 
								{
									if (bDraggingActive == false) bDraggingActiveInitial = false;
									if (t.inputsys.localselectedrayhit == true && (bDraggingActive == false || bDraggingActiveInitial == true || iObjectMoveMode == 2))
									{
										fHitPointY = t.inputsys.localcurrentterrainheight_f;

										// and move plane to discovered surface position (for specific modes)
										if (iInitialPlacementOfPlane == 2)
										{
											if (iObjectMoveMode == 2)
											{
												if (g.entityrubberbandlist.size() > 1)
												{
													// groups need to find floor fast!
													fActivePosY = fHitPointY;
												}
												else
												{
													if (g_bAdjustPlaneXZUsingSurfaceXZ == true)
													{
														float fUpDownAngle = WrapValue(CameraAngleX(0));
														int iForwardFacing = t.entityprofile[t.gridentity].forwardfacing;
														if (t.gridentitygridlock == 0 || iForwardFacing != 0)
														{
															if (iForwardFacing == 0 && fUpDownAngle > 10.0f && fUpDownAngle < 91.0f)
															{
																if (iObjectMoveMode == 2 && iObjectMoveModeDropSystemUsing == 1)
																{
																	// smart mode keeps the initial XZ plane height for predictable positioning of object
																	// then uses the iObjectMoveModeDropSystem to plop the object on the ground
																}
																else
																{
																	// normally go to surface
																	fActivePosY = fHitPointY;
																}
															}
															if (iForwardFacing == 1)
															{
																fActivePosX = t.inputsys.localx_f;
																fActivePosZ = t.inputsys.localy_f;
																fActivePosY = fHitPointY;
															}
															if (iForwardFacing == 2)
															{
																fActivePosY = fHitPointY;
															}
														}
														g_bAdjustPlaneXZUsingSurfaceXZ = false;
													}
												}

												// small shifts cause glitch grabs, so round them off
												fActivePosX = floor(fActivePosX);
												fActivePosY = floor(fActivePosY);
												fActivePosZ = floor(fActivePosZ);
											}
										}
									}
								}

								// LB: mousepick functionality disabled for now, see how new smart find ground system works out...
								//bool bMousePickEnabled = true;
								/* bMousePickEnabled never actually used
								bool bMousePickEnabled = false;
								*/
								if (!(fHitOffsetX == 0 && fHitOffsetY == 0 && fHitOffsetZ == 0))
								{
									if (iObjectMoveMode == 1)
									{
										newpicksystem = -98;
									}
									int iRealObjectMoveMode = iObjectMoveMode;
									if (iObjectMoveModeDropSystem > 0) iRealObjectMoveMode = 0;
									if (iRealObjectMoveMode == 2)
									{
										// allow mouse pick if positioning mode is find surface
									}
									else
									{
										// and disable if not using mouse pick system
										/* bMousePickEnabled never actually used
										bMousePickEnabled = false;
										*/
									}
								}

								// only move plane on initial object selection, this avoids drift when placing objects
								bool bIgnoreFirstPlaneDetectItIsWrong = false;
								if (iInitialPlacementOfPlane == 1)
								{
									bool bJustForInitialDragIn = false;
									if (bDraggingActive == false && fHitOffsetX == 0 && fHitOffsetY == 0 && fHitOffsetZ == 0) bJustForInitialDragIn = true;
									if (bDraggingActive == true && t.gridentityposx_f == 0 && t.gridentityposz_f == 0) bJustForInitialDragIn = true;
									if (bDraggingActiveInitial == true)	bJustForInitialDragIn = true;
									if (bJustForInitialDragIn == true && t.inputsys.localselectedrayhit == false)
									{
										// new selection from left panel
										g_bResetPlaneAfterXZAdjust = false;
										float fDistCap = 1000.0f;
										MoveCamera(0, fDistCap);
										fActivePosX = CameraPositionX(0);
										fActivePosY = CameraPositionY(0);
										fActivePosZ = CameraPositionZ(0);
										MoveCamera(0, -fDistCap);
									}
									else
									{
										// selected object from level
										fActivePosX = t.gridentityposx_f;
										fActivePosZ = t.gridentityposz_f;

										// only put plane on surface if object connected with a surface
										if (iObjectMoveMode == 2)
										{
											bool bMustFaceDown = false;
											int iForwardFacing = t.entityprofile[t.gridentity].forwardfacing;
											float fUpDownAngle = WrapValue(CameraAngleX(0));
											if (fUpDownAngle > -30.0f && fUpDownAngle < 91.0f) //LB: was 10.0f - Rick wanted to find floor when looking camera directly forward
											{
												if (iObjectMoveModeDropSystemUsing == 1)
												{
													// drop system keeps object on initial plane
													fActivePosY = t.gridentityposy_f + fHitOffsetY;
												}
												else
												{
													if (t.gridentitygridlock != 0 && iForwardFacing == 0 && bJustForInitialDragIn == false)
													{
														// if in grid/snap mode, do not use surface Y
														fActivePosY = t.gridentityposy_f + fHitOffsetY;
													}
													else
													{
														// find nearby surface
														fActivePosY = fHitPointY;
													}
												}
											}
											else
											{
												// side/up
												fActivePosY = t.gridentityposy_f + fHitOffsetY;
											}
										}
										else
										{
											if (iObjectMoveMode == 1)
											{
												// LB: directly on site of initial click
												fActivePosX = t.gridentityposx_f + fHitOffsetX;
												fActivePosY = t.gridentityposy_f + fHitOffsetY;
												fActivePosZ = t.gridentityposz_f + fHitOffsetZ;
											}
											else
											{
												fActivePosY = t.gridentityposy_f + fHitOffsetY;
											}
										}
									}

									// small shifts cause glitch grabs, so round them off
									fActivePosX = floor(fActivePosX);
									fActivePosY = floor(fActivePosY);
									fActivePosZ = floor(fActivePosZ);
									iInitialPlacementOfPlane = 2;
									bIgnoreFirstPlaneDetectItIsWrong = true; // because it only seems to work after wicked has synced all of a sudden, ah well.
								}

								// handed to smart system for plane position and orientation
								t.widget.pickedSection = newpicksystem;

								// find where mouse is on the plane we have positioned
								bool widget_getplanepos(float fActivePosX, float fActivePosY, float fActivePosZ, float* pPlanePosX, float* pPlanePosY, float* pPlanePosZ);
								bPlanePosRegistered = widget_getplanepos(fActivePosX, fActivePosY, fActivePosZ, &fPlanePosX, &fPlanePosY, &fPlanePosZ);
								if (bPlanePosRegistered == true && bIgnoreFirstPlaneDetectItIsWrong == false)
								{
									fPlanePosX -= fHitOffsetX;
									fPlanePosY -= fHitOffsetY;
									fPlanePosZ -= fHitOffsetZ;
									if (newpicksystem == -98)
									{
										// adjusting only Y
										t.gridentityposy_f = fPlanePosY;
										//leelee, maybe some grid/snap here so vertical make sense?
									}
									else
									{
										// adjusting X and Z
										t.gridentityposx_f = fPlanePosX;
										t.gridentityposz_f = fPlanePosZ;
									}
								}
								//DEBUG: if (ObjectExist(t.widget.widgetPlaneObj)) ShowObject(t.widget.widgetPlaneObj);
								t.widget.pickedSection = picksystem;
							}
							else
							#endif
							{
								t.gridentityposx_f = t.inputsys.localx_f + t.inputsys.dragoffsetx_f;
								t.gridentityposz_f = t.inputsys.localy_f + t.inputsys.dragoffsety_f;
							}
						}

						bool bUseOldYSystem = true;

						#ifdef WICKEDENGINE
						bool bDontUsePivot = false;
						if (iExtractMode == 1) 
						{ 
							//0 = find floor, 1 = extracted y value. , 3 = fixed y value.
							t.gridentityposy_f = fExtractYValue;
							bUseOldYSystem = false;
							bDontUsePivot = true;
						}
						if (iExtractMode == 2) 
						{
							t.gridentityposy_f = fExtractFixedYValue;
							bUseOldYSystem = false;
						}

						#endif

						//PE: Add snap,grid as functions , so can be used in widget system.
						//LB: moved it further down after all user influenced changes to gridentityposXYZ
						//Add_Grid_Snap_To_Position();

						if (t.tforcedynamic == 1)
						{
							t.gridentitystaticmode = 0;
						}

						//PE: Display red/green box of cursor object. to display static/dynamic.
						#ifdef WICKEDENGINE
						if (!Shooter_Tools_Window_Active)
						{
							//PE: Allow t.widget.pickedObject to be selected in this mode.
							if (!pref.iEnableDragDropEntityMode)
							{
								g_selected_editor_object = NULL;
							}
							if (t.gridentityobj > 0) 
							{
								if (t.gridentityobj < g_iObjectListCount)
								{
									if (g_ObjectList[t.gridentityobj])
									{
										if (t.gridentitystaticmode)
											g_selected_editor_color = XMSTATICCOLOR;
										else
											g_selected_editor_color = XMDYNAMICCOLOR;
										g_selected_editor_object = g_ObjectList[t.gridentityobj];
									}
								}
							}
						}
						#endif

						// Find ground while placing entity on terrain
						bool bApplyEntityOffsets = false;
						bool bCanUpdateY = true;
						int iForwardFacing = 0;
						if (t.gridentity > 0) iForwardFacing = t.entityprofile[t.gridentity].forwardfacing;
						if (t.gridentitysurfacesnap == 1 || t.inputsys.picksystemused == 2)
						//if (t.gridentity > 0 && (t.gridentitysurfacesnap == 1 || t.inputsys.picksystemused == 2)) // code only needed when picked cursor object - bit not using this for now as currently stable and tested
						{
							#ifdef WICKEDENGINE
							if (pref.iEnableDragDropEntityMode)
							{
								//PE: Only newly created obects can also adjust Y
								//PE: If we grab one from the level, it should use the settings. Y or XZ.
								if (!(fHitOffsetX == 0 && fHitOffsetY == 0 && fHitOffsetZ == 0))
								{
									// object being dragged about and already in the level
									if (pref.iEnableDragDropWidgetSelect)
									{
										// but only if not dragging in objects that need fHitOffsetXYZ offset at very start
										bool bCanActivateWidgetNow = true;
										if (t.entityprofile[t.gridentity].ismarker == 2) bCanActivateWidgetNow = false;
										if (iForwardFacing == 2 && t.entityprofile[t.gridentity].ismarker == 0) bCanActivateWidgetNow = false;
										if (bCanActivateWidgetNow == true)
										{
											bTriggerVisibleWidget = true;
										}
									}
									else
										bTriggerVisibleWidget = false;

									int iRealObjectMoveMode = iObjectMoveMode;
									if (iObjectMoveModeDropSystem > 0) iRealObjectMoveMode = 0;
									if (iRealObjectMoveMode == 2)
									{
										/* drop system removed, now this mode can find the surface
										// LB: mousepick functionality disabled for now, see how new smart find ground system works out...
										// can update Y if using move object and find surface positioning mode
										bCanUpdateY = false;
										*/
										bCanUpdateY = true;
									}
									else
									{
										// cannot update Y if horiz or vert positioning modes
										bCanUpdateY = false;
									}
								}
								else
								{
									// dragged direct from 'Level objects'
									if (bWidgetHasControlHere == false)
									{
										//LB: keep widget visible when dragging it about
										bTriggerVisibleWidget = false;
									}
								}

								//LB: requested ease of use feature, if in horiz mode, and object falls below terrain, raise it up
								if (iObjectMoveMode == 0)
								{
									// horiz position XZ mode
									if (bDepartedFromChosenY == true) t.gridentityposy_f = fDepartedFromThisY;
									float fActualHeightUnderObject = BT_GetGroundHeight(0, t.gridentityposx_f, t.gridentityposz_f);
									if ( t.gridentityobj > 0 )
									{
										// and ensure we CAN place objects that are submerged, just make sure they do not go entirely under
										// the floor, so keep 20% of them anove the ground height
										fActualHeightUnderObject -= ((float)ObjectSizeY(t.gridentityobj, 1) * 0.8f);
									}
									if (t.gridentityposy_f < fActualHeightUnderObject )
									{
										if (bDepartedFromChosenY == false)
										{
											bDepartedFromChosenY = true;
											fDepartedFromThisY = t.gridentityposy_f;
										}
										t.gridentityposy_f = fActualHeightUnderObject;
										bApplyEntityOffsets = true;
									}
								}
							}
							#endif

							// when drag in object initially, use new smart placement system
							bool bJustForInitialDragIn = false;
							#ifdef WICKEDENGINE
							if (bDraggingActive == false && fHitOffsetX == 0 && fHitOffsetY == 0 && fHitOffsetZ == 0) bJustForInitialDragIn = true;
							if (bDraggingActive == true && t.gridentityposx_f == 0 && t.gridentityposz_f == 0) bJustForInitialDragIn = true;
							if (bDraggingActiveInitial == true)	bJustForInitialDragIn = true;
							#endif

							// new system to locate grid ent pos at point where mouse touches terrain/entity surface
							// LB: Note, "t.inputsys.localcurrentterrainheight_f" will not account for 'entity surface' if iObjectMoveMode != 2!!
							if ((bUseOldYSystem && bCanUpdateY) || bJustForInitialDragIn == true)
							{
								#ifdef WICKEDENGINE
								if ((iObjectMoveMode == 2 && (t.gridentitygridlock == 0 || iForwardFacing != 0)) || bJustForInitialDragIn == true)
								{
									if (bJustForInitialDragIn == true)
									{
										if (t.inputsys.localselectedrayhit == true)
										{
											t.gridentityposx_f = t.inputsys.localx_f - fHitOffsetX;
											t.gridentityposz_f = t.inputsys.localy_f - fHitOffsetZ;
											t.gridentityposy_f = t.inputsys.localcurrentterrainheight_f - fHitOffsetY;
										}
										else
										{
											if (bPlanePosRegistered == true)
											{
												t.gridentityposy_f = fPlanePosY;
											}
										}
									}
									else
									{
										if (bPlanePosRegistered == true)
										{
											if (iForwardFacing == 2)
											{
												float fUpDownAngle = WrapValue(CameraAngleX(0));
												if ((fUpDownAngle > 10.0f && fUpDownAngle < 350.0f) || (t.gridentity>0 && t.entityprofile[t.gridentity].ismarker == 2))
												{
													t.gridentityposx_f = t.inputsys.localx_f - fHitOffsetX;
													t.gridentityposz_f = t.inputsys.localy_f - fHitOffsetZ;
													t.gridentityposy_f = t.inputsys.localcurrentterrainheight_f - fHitOffsetY;
												}
												else
												{
													t.gridentityposx_f = t.inputsys.localx_f;
													t.gridentityposz_f = t.inputsys.localy_f;
													t.gridentityposy_f = t.inputsys.localcurrentterrainheight_f;
												}
											}
											else
											{
												t.gridentityposy_f = fPlanePosY;
											}
										}
										float fUpDownAngle = WrapValue(CameraAngleX(0));
										if (fUpDownAngle > 10.0f && fUpDownAngle < 350.0f)
										{
											// horizontal plane handles this - stops shake that happens when use ray Y instead of plane Y
										}
										else
										{
											// plane is vertical, so need to determine if ray hit closer than vertical plane
											if (t.inputsys.localselectedrayhit == true && iForwardFacing == 0)
											{
												float fDX = t.inputsys.localx_f - CameraPositionX(0);
												float fDY = t.inputsys.localcurrentterrainheight_f - CameraPositionY(0);
												float fDZ = t.inputsys.localy_f - CameraPositionZ(0);
												float fDistToPick = sqrt(fabs(fDX*fDX) + fabs(fDY*fDY) + fabs(fDZ*fDZ));
												fDX = fPlanePosX - CameraPositionX(0);
												fDY = fPlanePosY - CameraPositionY(0);
												fDZ = fPlanePosZ - CameraPositionZ(0);
												float fDistToPlane = sqrt(fabs(fDX*fDX) + fabs(fDY*fDY) + fabs(fDZ*fDZ));
												if (fDistToPlane > fDistToPick)
												{
													t.gridentityposx_f = t.inputsys.localx_f - fHitOffsetX;
													t.gridentityposz_f = t.inputsys.localy_f - fHitOffsetZ;
													t.gridentityposy_f = t.inputsys.localcurrentterrainheight_f - fHitOffsetY;
												}
											}
										}
									}
								}
								else
								#endif
								{
									if (t.gridentitygridlock == 0 || iForwardFacing != 0)
									{
										t.gridentityposy_f = t.inputsys.localcurrentterrainheight_f;
									}
								}
								bApplyEntityOffsets = true;
							}

							#ifdef WICKEDENGINE
							if (pref.iEnableDragDropEntityMode )//&& bCanUpdateY)
							{
								/* no need for the 'ray from above' in the new positining modes system
								   as we can rely on the GetPick to pick terrain only or pick object surfaces!
								bApplyEntityOffsets = true;

								//PE: We need t.inputsys.dragoffsetx_f as close to zero as possible.
								//PE: So when moving slowly adjust for center position.
								static int ad_oldx, ad_oldz;
								if (t.gridentityobj > 0) HideObject(t.gridentityobj);

								//PE: MUST disable collision on ALL rubberband objects.
								std::vector<sRubberBandType> entityvisible = g.entityrubberbandlist;
								if (g.entityrubberbandlist.size() > 0)
								{
									for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
									{
										int e = g.entityrubberbandlist[i].e;
										int obj = t.entityelement[e].obj;
										if (obj > 0 && GetVisible(obj))
										{
											entityvisible[i].x = 1;
											HideObject(obj);
										}
										else
										{
											entityvisible[i].x = 0;
										}
									}
								}

								// ray direct from above
								float fHitX, fHitY, fHitZ;
								fHitRayFrom = t.gridentityposy_f + 1000.0f;
								if (fLastHitY == 0.0f)
									fLastHitY = t.gridentityposy_f;

								//PE: Test try to take a object from the middle of a stack , and place it again.
								sObject* pObject = g_ObjectList[t.gridentityobj];
								if (pObject) { //&& t.entityprofile[entid].ischaracter != 1
									float fAdjustScaleX = 1.0, fAdjustScaleY = 1.0, fAdjustScaleZ = 1.0;
									if (pObject->pInstanceOfObject)
									{
										fAdjustScaleX = pObject->position.vecScale[0];
										fAdjustScaleY = pObject->position.vecScale[1];
										fAdjustScaleZ = pObject->position.vecScale[2];
										pObject = pObject->pInstanceOfObject;
									}
									float fValue;
									//Use max from boundingbox.
									fValue = (pObject->collision.vecMax[1] + abs(pObject->collision.vecMin[1])) * pObject->position.vecScale[1] * fAdjustScaleY;
									fHitRayFrom = fLastHitY + (fValue); //Just to get from top pos.
								}

								if (WickedCall_SentRay(t.gridentityposx_f, fHitRayFrom, t.gridentityposz_f, 0, -1.0f, 0, &fHitX, &fHitY, &fHitZ, NULL, NULL, NULL, NULL, GGRENDERLAYERS_NORMAL))
								{
									//g_ray_pobject , got gg object nr.
									t.gridentityposy_f = fHitY;
									fLastHitY = fHitY;
								}
								if (t.gridentityobj > 0) ShowObject(t.gridentityobj);

								//PE: Enable rubberband collision again.
								if (entityvisible.size() > 0)
								{
									for (int i = 0; i < (int)entityvisible.size(); i++)
									{
										int e = entityvisible[i].e;
										int obj = t.entityelement[e].obj;
										if (entityvisible[i].x == 1)
										{
											ShowObject(obj);
										}
									}
								}
								*/

								// bMouseInputSystemUsed functionality
								/* bMousePickEnabled never actually used
								if (bMouseInputSystemUsed )
								{
									t.gridentityposy_f = t.inputsys.localcurrentterrainheight_f;
								}
								*/
							}
							if (fHitPointY == 0.0f)
								fHitPointY = t.gridentityposy_f;

							//LB: prevent any t.gridentitypos movement until user has moved the mouse pointer
							if (g_bHoldGridEntityPosWhenManaged == true)
							{
								t.gridentityposx_f = g_fHoldGridEntityPosX;
								t.gridentityposy_f = g_fHoldGridEntityPosY;
								t.gridentityposz_f = g_fHoldGridEntityPosZ;
							}
							#endif
						}
						else
						{
							if (t.gridentityposoffground == 0)
							{
								#ifdef GGTERRAIN_USE_NEW_TERRAIN
								if (bUseOldYSystem)
								{
									t.gridentityposy_f = BT_GetGroundHeight(t.terrain.TerrainID, t.gridentityposx_f, t.gridentityposz_f);
									bApplyEntityOffsets = true;
								}
								#else
								if (t.terrain.TerrainID > 0)
								{
									if (bUseOldYSystem)
									{
										t.gridentityposy_f = BT_GetGroundHeight(t.terrain.TerrainID, t.gridentityposx_f, t.gridentityposz_f);
										bApplyEntityOffsets = true;
									}
								}
								else
								{
									if (bUseOldYSystem)
									{
										t.gridentityposy_f = g.gdefaultterrainheight;
										bApplyEntityOffsets = true;
									}
								}
								#endif
							}
						}

						#ifdef WICKEDENGINE
						//PE: Prevent user for placing objects outside playable area.
						if (t.gridentityobj > 0 && t.gridentity > 0)
						{
							if (t.gridentityposx_f < t.terraineditableareasizeminx) { t.gridentityposx_f = fOldgridentityposx_f; t.gridentityposy_f = fOldgridentityposy_f; bObjectOutSideEditArea = true; }
							if (t.gridentityposx_f > t.terraineditableareasizemaxx) { t.gridentityposx_f = fOldgridentityposx_f; t.gridentityposy_f = fOldgridentityposy_f; bObjectOutSideEditArea = true; }
							if (t.gridentityposz_f < t.terraineditableareasizeminz) { t.gridentityposz_f = fOldgridentityposz_f; t.gridentityposy_f = fOldgridentityposy_f; bObjectOutSideEditArea = true; }
							if (t.gridentityposz_f > t.terraineditableareasizemaxz) { t.gridentityposz_f = fOldgridentityposz_f; t.gridentityposy_f = fOldgridentityposy_f; bObjectOutSideEditArea = true; }
							if (bObjectOutSideEditArea)
							{
								//Trigger warning.
								t.gridentityposy_f = BT_GetGroundHeight(0, t.gridentityposx_f, t.gridentityposz_f);
								sprintf(cSmallTriggerMessage, "Object is Outside Editable Area");
								iTriggerMessageFrames = 60;
								bTriggerSmallMessage = true;
							}
						}
						#endif

						//LB: now apply grid/snap when user finished positioning XYZ
						if (iForwardFacing != 1)
						{
							// do not apply grid/snap for things like switches, they NEED the XZ from the surface to be exact
							Add_Grid_Snap_To_Position();
						}

						#ifdef WICKEDENGINE
						// new pick and drag system does not use OFFY and DEFAULTHEIGHT - causes jump Y pos on markers
						#else
						// handle adjustments that are object based
						if (bApplyEntityOffsets == true)
						{
							// for markers, apply Y offset
							if (t.entityprofile[t.gridentity].ismarker != 0)
							{
								if (bUseOldYSystem)
									t.gridentityposy_f = t.gridentityposy_f + t.entityprofile[t.gridentity].offy;
							}

							// for entities with default height, apply Y offset
							if (t.entityprofile[t.gridentity].defaultheight != 0)
							{
								if (bUseOldYSystem)
									t.gridentityposy_f = t.gridentityposy_f + t.entityprofile[t.gridentity].defaultheight;
							}
						}
						#endif

						// handle any pivots that are object based
						#ifdef WICKEDENGINE
						if (!bDontUsePivot ) ApplyPivotToGridEntity();
						#endif

						// Create and manage a ghost object for when selecting objects to move
						// so can be used by special smart positioning mode
						#ifdef WICKEDENGINE
						int iGhostObj = g.ghostcursorobjectoffset;
						if (iGhostObj > 0)
						{
							// remove if not needed
							if (ObjectExist(iGhostObj) == 1 && t.gridentityobj == 0) DeleteObject (iGhostObj);

							// create placement line of needed
							if (iObjectMoveMode == 0 || iObjectMoveMode == 1)
							{
								// create a thin line to indicate where the surface below the object is
								if (ObjectExist(iGhostObj) == 0 && t.gridentityobj > 0)
								{
									WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_CURSOROBJECT);
									MakeObjectBox(iGhostObj, 1, 1, 1);
									WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_NORMAL);
									sObject* pObject = GetObjectData(iGhostObj);
									WickedCall_TextureObject(pObject, NULL);
									if (pObject)
									{
										for (int iMeshIndex = 0; iMeshIndex < pObject->iMeshCount; iMeshIndex++)
										{
											sMesh* pMesh = pObject->ppMeshList[iMeshIndex];
											if (pMesh)
											{
												pMesh->mMaterial.Diffuse.r = 1.0f;
												pMesh->mMaterial.Diffuse.g = 1.0f;
												pMesh->mMaterial.Diffuse.b = 1.0f;
												pMesh->mMaterial.Diffuse.a = 0.2f;
												WickedCall_SetMeshMaterial (pMesh);
												pMesh->bTransparency = true;
												WickedCall_SetMeshTransparent(pMesh);
											}
										}
										WickedCall_SetObjectCastShadows(pObject, false);
									}
								}
								if (ObjectExist(iGhostObj) == 1)
								{
									// position line so it fills the gap directly below the object
									sObject* pObject = GetObjectData(t.gridentityobj);
									float fRealMeshCenterY = pObject->collision.vecMin.y + ((pObject->collision.vecMax.y - pObject->collision.vecMin.y) / 2.0f);
									fRealMeshCenterY *= pObject->position.vecScale.y;
									float fY = ObjectPositionY(t.gridentityobj) + fRealMeshCenterY;
									float fPredictedY = editor_forceentityfindfloor(true);
									if (fPredictedY > fY) fPredictedY = 0.0f;
									float fX = ObjectPositionX(t.gridentityobj);
									float fZ = ObjectPositionZ(t.gridentityobj);
									float fDefaultHeight = t.entityprofile[t.gridentity].defaultheight;
									fY += fDefaultHeight;
									float fGapDistance = fY - fPredictedY;
									float fHalfWay = fPredictedY + (fGapDistance / 2.0f);
									PositionObject (iGhostObj, fX, fHalfWay-fDefaultHeight, fZ);
									ScaleObject(iGhostObj, 25, fGapDistance*100.0f, 25);
								}
							}

							//PE: When first dragged in we dont have a entityelement and cant check usespotlighting so...
							//PE: Dont make ghost on light objects.
							bool bIsLightObject = false;
							if (t.gridentity > 0 && t.entityprofile[t.gridentity].ismarker == 2)
							{
								bIsLightObject = true;
								//PE: Perhaps do this later, if needed stacking light is not really used :) , and only if we have a extracted entityid.
								//int spotlighting = t.entityelement[e].eleprof.usespotlighting;
								//entity_updatelightobjtype(obj, spotlighting);
							}

							// create ghost if needed
							bool bShowGhostIfSingleObject = false;
							if (iObjectMoveModeDropSystemUsing == 1 && g.entityrubberbandlist.size() <= 1 && g_bHoldGridEntityPosWhenManaged == false) bShowGhostIfSingleObject = true;
							if (iObjectMoveMode == 2 && bShowGhostIfSingleObject==true && !bIsLightObject && bDraggingActive)
							{
								if (ObjectExist(iGhostObj) == 0 && t.gridentityobj > 0)
								{
									WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_CURSOROBJECT);
									CloneObject (iGhostObj, t.gridentityobj);
									WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_NORMAL);
									sObject* pObject = GetObjectData(iGhostObj);
									WickedCall_TextureObject(pObject, NULL);
									if (pObject)
									{
										for (int iMeshIndex = 0; iMeshIndex < pObject->iMeshCount; iMeshIndex++)
										{
											sMesh* pMesh = pObject->ppMeshList[iMeshIndex];
											if (pMesh)
											{
												pMesh->mMaterial.Diffuse.r = 1.0f;
												pMesh->mMaterial.Diffuse.g = 1.0f;
												pMesh->mMaterial.Diffuse.b = 1.0f;
												pMesh->mMaterial.Diffuse.a = 0.3f;
												WickedCall_SetMeshMaterial (pMesh);
												pMesh->bTransparency = true;
												WickedCall_SetMeshTransparent(pMesh);
											}
										}
										WickedCall_SetObjectCastShadows(pObject, false);
									}
								}
								if (ObjectExist(iGhostObj) == 1)
								{
									// position ghost version to the intended destination of a smart positioned object
									float fPredictedY = editor_forceentityfindfloor(true);
									float fX = ObjectPositionX(t.gridentityobj);
									float fY = ObjectPositionY(t.gridentityobj);
									float fZ = ObjectPositionZ(t.gridentityobj);
									PositionObject (iGhostObj, fX, fPredictedY, fZ);
									SetObjectToObjectOrientation(iGhostObj, t.gridentityobj);
									float fCurrentObjFrame = WickedCall_GetObjectFrame(GetObjectData(t.gridentityobj));
									SetObjectFrame(iGhostObj, fCurrentObjFrame);
								}
							}
						}
						#endif

						#ifdef WICKEDENGINE
						//PE: Check if object is overlapping another object.
						//PE: MISSING - Lock position if object is not visible to camera (goes to the other side of another object).
						int iRealObjectMoveMode = iObjectMoveMode;
						if (iObjectMoveModeDropSystem > 0) iRealObjectMoveMode = 0;
						if (bObjectAllowOverlapping == 0 && (iRealObjectMoveMode == 0 || iRealObjectMoveMode == 2)) //iObjectMoveMode NO Y rays yet.
						{
							//#define CENTERSYSTEM
							#define NOOVERLABDEBUG
							sObject* pObject = g_ObjectList[t.gridentityobj];
							if (pObject)
							{
								PositionObject(t.obj, t.gridentityposx_f, t.gridentityposy_f, t.gridentityposz_f);
								RotateObject(t.obj, t.gridentityrotatex_f, t.gridentityrotatey_f, t.gridentityrotatez_f);
								
								//only set t.gridentityposx_f , t.gridentityposz_f
								ImVec4 ObjectCenter = GetRealCenterToGridEntity();
								ImVec4 ObjectSize;
								if (ObjectCenter.w) //Only if valid object.
								{
									XMFLOAT3 fObjCenter = { pObject->position.vecPosition.x + ObjectCenter.x,pObject->position.vecPosition.y + ObjectCenter.y,pObject->position.vecPosition.z + ObjectCenter.z };

									void WickedCall_DrawPoint(float fx, float fy, float fz, float size, XMFLOAT4 color, bool bThickLine);
									XMFLOAT4 color = { 1.0,1.0,0.0,1.0 }; //real center of object.
									#ifndef NOOVERLABDEBUG
									WickedCall_DrawPoint(fObjCenter.x, fObjCenter.y, fObjCenter.z, 4.0f, color, true);
									#endif

									static float fLastRayDist[6];
									ImVec4 vBestOffsetLeft = { 0,0,0,0 };
									ImVec4 vBestOffsetUp = { 0,0,0,0 };
									for (int i = 0; i < 4; i++)
									{
										if (i == 0) color = { 1.0,1.0,1.0,1.0 };
										if (i == 1) color = { 1.0,0.0,0.0,1.0 };
										if (i == 2) color = { 0.0,1.0,0.0,1.0 };
										if (i == 3) color = { 0.0,0.0,1.0,1.0 };
										ObjectSize = GetRealSizeToGridEntity(i);
										XMFLOAT3 fObjPos = { pObject->position.vecPosition.x + ObjectCenter.x + (ObjectSize.x) , pObject->position.vecPosition.y + ObjectCenter.y ,pObject->position.vecPosition.z + ObjectCenter.z + (ObjectSize.z) };
										#ifndef CENTERSYSTEM
										XMFLOAT3 fObjRayPos = { pObject->position.vecPosition.x + ObjectCenter.x - (ObjectSize.x) , pObject->position.vecPosition.y + ObjectCenter.y ,pObject->position.vecPosition.z + ObjectCenter.z - (ObjectSize.z) };
										#ifndef NOOVERLABDEBUG
										WickedCall_DrawPoint(fObjRayPos.x, fObjRayPos.y, fObjRayPos.z, 3.0f, color, true);
										#endif
										#else
										#ifndef NOOVERLABDEBUG
										WickedCall_DrawPoint(fObjPos.x, fObjPos.y, fObjPos.z, 4.0f, color, true);
										#endif
										#endif
										XMVECTOR vectorSub = XMVectorSubtract(XMLoadFloat3(&fObjPos), XMLoadFloat3(&fObjCenter));
										XMVECTOR rayDirection = XMVector3Normalize(vectorSub);
										XMFLOAT3 f3Dir;
										XMStoreFloat3(&f3Dir, rayDirection);
										float fHitX, fHitY, fHitZ, fdist = 99999.0;
										#ifndef CENTERSYSTEM
										if (WickedCall_SentRay(fObjRayPos.x, fObjRayPos.y, fObjRayPos.z, f3Dir.x, 0.0f, f3Dir.z, &fHitX, &fHitY, &fHitZ, NULL, NULL, NULL, NULL, GGRENDERLAYERS_NORMAL))
										#else
										if (WickedCall_SentRay(fObjCenter.x, fObjCenter.y, fObjCenter.z, f3Dir.x, 0.0f, f3Dir.z, &fHitX, &fHitY, &fHitZ, NULL, NULL, NULL, NULL, GGRENDERLAYERS_NORMAL))
										#endif
										{
											XMFLOAT3 fObjHit = { fHitX, fHitY, fHitZ };

											#ifndef CENTERSYSTEM
											float fdist = sqrt((fObjPos.x - fObjHit.x) * (fObjPos.x - fObjHit.x) +
												(fObjPos.z - fObjHit.z) * (fObjPos.z - fObjHit.z));
											fLastRayDist[i] = fdist;
											float fdist2 = sqrt((fObjRayPos.x - fObjPos.x) * (fObjRayPos.x - fObjPos.x) +
												(fObjRayPos.z - fObjPos.z) * (fObjRayPos.z - fObjPos.z));

											float fdist3 = sqrt((fObjRayPos.x - fObjHit.x) * (fObjRayPos.x - fObjHit.x) +
												(fObjRayPos.z - fObjHit.z) * (fObjRayPos.z - fObjHit.z));

											#else
											float fdist = sqrt((fObjPos.x - fObjHit.x) * (fObjPos.x - fObjHit.x) +
												(fObjPos.z - fObjHit.z) * (fObjPos.z - fObjHit.z));

											float fdist2 = sqrt((fObjCenter.x - fObjPos.x) * (fObjCenter.x - fObjPos.x) +
												(fObjCenter.z - fObjPos.z) * (fObjCenter.z - fObjPos.z));

											float fdist3 = sqrt((fObjCenter.x - fObjHit.x) * (fObjCenter.x - fObjHit.x) +
												(fObjCenter.z - fObjHit.z) * (fObjCenter.z - fObjHit.z));
											#endif

											float fDistFinal = fdist3 - fdist2;
											fDebug = fdist; //debug
											fDebug2 = fdist2; //debug
											fDebug3 = fdist3; //debug

											if (fdist3 < fdist2)
											{
												//Glue.
												float fDistFromPivot = -fdist;
												ImVec4 vOffset = { f3Dir.x*fDistFromPivot, f3Dir.y*fDistFromPivot , f3Dir.z*fDistFromPivot ,1.0f };

												if (i == 0)
													vBestOffsetLeft = vOffset;
												if (i == 2 && fLastRayDist[2] < fLastRayDist[0])
													vBestOffsetLeft = vOffset;
												if (i == 1)
													vBestOffsetUp = vOffset;
												if (i == 3 && fLastRayDist[3] < fLastRayDist[1])
													vBestOffsetUp = vOffset;

												//t.gridentityposx_f += vOffset.x;
												//t.gridentityposz_f += vOffset.z;
											}
											#ifndef NOOVERLABDEBUG
											WickedCall_DrawPoint(fHitX, fHitY, fHitZ, 6.0f, color, true);
											#endif
										}
									}
									if (vBestOffsetLeft.w > 0)
									{
										t.gridentityposx_f += vBestOffsetLeft.x;
										t.gridentityposz_f += vBestOffsetLeft.z;
									}
									if (vBestOffsetUp.w > 0)
									{
										t.gridentityposx_f += vBestOffsetUp.x;
										t.gridentityposz_f += vBestOffsetUp.z;
									}
								}
							}
						}
						#endif

						//  move waypoint zone when move trigger entity
						if (t.grideleprof.trigger.waypointzoneindex > 0)
						{
							if (t.gridentity > 0)
							{
								waypoint_movetogrideleprof();
							}
							else
							{
								t.grideleprof.trigger.waypointzoneindex = 0;
							}
						}

						//  control modification of entity element details
						if (t.gridentitymodifyelement == 1)
						{
							if (t.gridedit.entityspraymode == 1)
							{
								if (t.gridedit.entitysprayrange > 0) t.gridedit.entitysprayrange -= 50;
							}
							else
							{
								if (t.grideleprof.light.range > 50) t.grideleprof.light.range -= 50;
							}
							t.gridentitymodifyelement = 0;
						}
						if (t.gridentitymodifyelement == 2)
						{
							if (t.gridedit.entityspraymode == 1)
							{
								if (t.gridedit.entitysprayrange < 1000) t.gridedit.entitysprayrange += 50;
							}
							else
							{
								if (t.grideleprof.light.range < 1000) t.grideleprof.light.range += 50;
							}
							t.gridentitymodifyelement = 0;
						}

					} //WICKED (!bPlaceEntity)

					//  extract entity (RMB) or place entity (LMB)
					if (bPlaceEntity)
					{
						#ifdef WICKEDENGINE
						bDetectTerrainOnly = false;
						#endif
						// widget closure
						if (  t.widget.duplicatebuttonselected == 2 ) 
						{
							t.tentitytoselect=t.widget.pickedEntityIndex;
							t.widget.duplicatebuttonselected=0;
							t.gridentityautofind=7;
						}
						t.widget.pickedObject=0; 
						widget_updatewidgetobject ( );

						// either add entity to map OR extract one specified by 't.tentitytoselect'
						if ( t.gridentity != 0 ) 
						{
							// ADD ENTITY TO MAP
							// Determine if we will be adding (or moving an entity if spray mode)
							t.tentitybeingsprayed=0;
							t.tentitytomodifyindex=0;
							if ( t.gridedit.entityspraymode == 1 && t.entityprofile[t.gridentity].ismarker == 0 ) 
							{
								//  Scan area of spray and determine if density reached
								t.tpickrandoment=Rnd(t.tcountentinrange);
								t.tcountentinrange=0;
								for ( t.e = 1 ; t.e<=  g.entityelementlist; t.e++ )
								{
									if (  t.entityelement[t.e].bankindex == t.gridentity ) 
									{
										//  this entity is same as that sprayed
										t.tdx_f=t.entityelement[t.e].x-t.gridentityposx_f;
										t.tdz_f=t.entityelement[t.e].z-t.gridentityposz_f;
										t.tdd_f=Sqrt(abs(t.tdx_f*t.tdx_f)+abs(t.tdz_f*t.tdz_f));
										if (  t.tdd_f <= t.gridedit.entitysprayrange ) 
										{
											//  this entity in range
											if (  t.tcountentinrange == 0  )  t.tentitytomodifyindex = t.e;
											if (  t.tcountentinrange == t.tpickrandoment  )  t.tentitytomodifyindex = t.e;
											++t.tcountentinrange;
										}
									}
								}
								if (  t.tcountentinrange <= 5  )  t.tentitytomodifyindex = 0;
								t.tentitybeingsprayed=1;
							}

							//  Store original entity cursor settings (for later random feature)
							t.storegridentityposx_f=t.gridentityposx_f;
							t.storegridentityposz_f=t.gridentityposz_f;
							t.storegridentityrotatex_f=t.gridentityrotatex_f;
							t.storegridentityrotatey_f=t.gridentityrotatey_f;
							t.storegridentityrotatez_f=t.gridentityrotatez_f;
							t.storegridentityrotatequatmode = t.gridentityrotatequatmode;
							t.storegridentityrotatequatx_f = t.gridentityrotatequatx_f;
							t.storegridentityrotatequaty_f = t.gridentityrotatequaty_f;
							t.storegridentityrotatequatz_f = t.gridentityrotatequatz_f;
							t.storegridentityrotatequatw_f = t.gridentityrotatequatw_f;
							t.storegridentityscalex_f=t.gridentityscalex_f;
							t.storegridentityscaley_f=t.gridentityscaley_f;
							t.storegridentityscalez_f=t.gridentityscalez_f;

							//  Spray allows entity placement to be randomised
							if (  t.tentitybeingsprayed == 1 ) 
							{
								//  rotation and scale back in (also uses native entity ROT values)
								t.gridentityrotatex_f=t.entityprofile[t.gridentity].rotx;
								t.gridentityrotatey_f=t.entityprofile[t.gridentity].roty;
								t.gridentityrotatez_f=t.entityprofile[t.gridentity].rotz;
								t.gridentityrotatequatmode = 0;
								t.gridentityscalex_f=t.gridentityscalex_f;
								t.gridentityscaley_f=t.gridentityscaley_f;
								t.gridentityscalez_f=t.gridentityscalez_f;
								if ( t.entityprofile[t.gridentity].ischaracter==0 && t.entityprofile[t.gridentity].noXZrotation==0 )
								{
									// ignore X and Z rotation for characters
									t.gridentityrotatex_f=t.gridentityrotatex_f+10.0-Rnd(20);
									t.gridentityrotatez_f=t.gridentityrotatez_f+10.0-Rnd(20);
									t.gridentityscaley_f=t.gridentityscaley_f+(Rnd(20)-10);
								}
								t.gridentityrotatey_f=t.gridentityrotatey_f+Rnd(360);
								t.gridentityrotatequatmode = 0;
								t.gridentityrotatequatx_f = 0;
								t.gridentityrotatequaty_f = 0;
								t.gridentityrotatequatz_f = 0;
								t.gridentityrotatequatw_f = 1;
								t.ttrandomposx_f=NewXValue(0,Rnd(360),Rnd(t.gridedit.entitysprayrange));
								t.ttrandomposz_f=NewZValue(0,Rnd(360),Rnd(t.gridedit.entitysprayrange));
								t.gridentityposx_f=t.gridentityposx_f+t.ttrandomposx_f;
								t.gridentityposz_f=t.gridentityposz_f+t.ttrandomposz_f;
#ifdef GGTERRAIN_USE_NEW_TERRAIN
								t.gridentityposy_f=BT_GetGroundHeight(t.terrain.TerrainID,t.gridentityposx_f,t.gridentityposz_f);
#else
								if (  t.terrain.TerrainID>0 ) 
								{
									t.gridentityposy_f=BT_GetGroundHeight(t.terrain.TerrainID,t.gridentityposx_f,t.gridentityposz_f);
								}
								else
								{
									t.gridentityposy_f=g.gdefaultterrainheight;
								}
#endif
								#ifdef WICKEDENGINE
								//PE: Apply pivot here.
								ApplyPivotToGridEntity();
								#endif

							}

							//  Version Control - stop high resource use
							t.resourceused=2; //version_resourcewarning ( );

							//  Either modify existing entity or place a new one (default behaviour)
							if (  t.tentitytomodifyindex>0 ) 
							{
								//  MODIFY EXISTING ENTITY
								t.entityelement[t.tentitytomodifyindex].x=t.gridentityposx_f;
								t.entityelement[t.tentitytomodifyindex].y=t.gridentityposy_f;
								t.entityelement[t.tentitytomodifyindex].z=t.gridentityposz_f;
								t.entityelement[t.tentitytomodifyindex].rx=t.gridentityrotatex_f;
								t.entityelement[t.tentitytomodifyindex].ry=t.gridentityrotatey_f;
								t.entityelement[t.tentitytomodifyindex].rz=t.gridentityrotatez_f;
								t.entityelement[t.tentitytomodifyindex].quatmode = t.gridentityrotatequatmode;
								t.entityelement[t.tentitytomodifyindex].quatx = t.gridentityrotatequatx_f;
								t.entityelement[t.tentitytomodifyindex].quaty = t.gridentityrotatequaty_f;
								t.entityelement[t.tentitytomodifyindex].quatz = t.gridentityrotatequatz_f;
								t.entityelement[t.tentitytomodifyindex].quatw = t.gridentityrotatequatw_f;
								t.tobj=t.entityelement[t.tentitytomodifyindex].obj;
								if (  t.tobj>0 ) 
								{
									if (  ObjectExist(t.tobj) == 1 ) 
									{
										PositionObject (  t.tobj,t.gridentityposx_f,t.gridentityposy_f,t.gridentityposz_f );
										RotateObject (  t.tobj,t.gridentityrotatex_f,t.gridentityrotatey_f,t.gridentityrotatez_f );
									}
								}
								#ifdef WICKEDENGINE
								if (t.gridedit.entityspraymode == 1)
								{
									//PE: Set selection to the one being changed.
									t.widget.pickedObject = t.tobj;
									t.widget.pickedEntityIndex = t.tentitytomodifyindex;

								}
								#endif
							}
							else
							{
								//  PLACE NEW ENTITY
								//  after add, adjust so it auto-finds a Floor (  or wall (convenience) )
								t.gridentitydroptoground=1+t.entityprofile[t.gridentity].forwardfacing;
								if (  t.gridentitydroptoground == 2 ) 
								{
									#ifdef WICKEDENGINE
									 // already dealt with, positioned perfectly
									#else
									 // not too convenient for floors, but wall furniture look okay!!
									 t.thardauto = 1; editor_findentityground ();
									#endif
								}
								t.gridentitydroptoground=0;

								//  find unique name for this selection (if flagged)
								if (  g.guseuniquelynamedentities == 0 ) 
								{
									//  use same name as original entity
									t.tbase_s=t.grideleprof.name_s;
								}
								else
								{
									t.tokay=0 ; t.tindex=1;
									if (  cstr(Lower(Left(t.grideleprof.name_s.Get(),Len(t.grideleproflastname_s.Get())))) == Lower(t.grideleproflastname_s.Get()) ) 
									{
										t.tbase_s=t.grideleproflastname_s;
									}
									else
									{
										t.tbase_s=t.grideleprof.name_s;
									}
									while (  t.tokay == 0 ) 
									{
										t.tokay=1 ; t.grideleprof.name_s=t.tbase_s ; t.grideleproflastname_s=t.tbase_s;
										if (  t.tindex>1  )  t.grideleprof.name_s = t.grideleprof.name_s+" "+Str(t.tindex);
										for ( t.e = 1 ; t.e<=  g.entityelementlist; t.e++ )
										{
											if (  t.entityelement[t.e].bankindex>0 ) 
											{
												if (  cstr(Lower(t.entityelement[t.e].eleprof.name_s.Get())) == cstr(Lower(t.grideleprof.name_s.Get())) ) 
												{
													//  this name exists already, try another
													t.tokay=0 ; break;
												}
											}
										}
										++t.tindex;
									}
								}
								//  player start markers have exclusivity
								if (  t.entityprofile[t.gridentity].ismarker == 1 && t.entityprofile[t.gridentity].lives != -1 ) 
								{
									for ( t.e = 1 ; t.e<=  g.entityelementlist; t.e++ )
									{
										if (  t.entityelement[t.e].bankindex>0 ) 
										{
											if (  t.entityprofile[t.entityelement[t.e].bankindex].ismarker == 1 && t.entityprofile[t.entityelement[t.e].bankindex].lives != -1 ) 
											{
												t.tentitytoselect=t.e;
												gridedit_deleteentityfrommap ( );
											}
										}
									}
								}

								//  copy entity to map (keep selection for repeat process)
								if ( g.entityrubberbandlist.size() > 0 )
								{
									#ifdef WICKEDENGINE
									//PE: This normally makes a duplicate, what we dont need in this system.
									if (pref.iEnableDragDropEntityMode)
									{
										//We might have to do some kind of support.
										int iStoreGridEntity = t.gridentity;

										// add parent entity
										#ifdef WICKEDENGINE
										//PE: InstanceObject - Cursor,Object Tools - objects must always be real clones.
										extern bool bNextObjectMustBeClone;
										bNextObjectMustBeClone = true;
										#endif

										gridedit_addentitytomap();

										#ifdef WICKEDENGINE
										bNextObjectMustBeClone = false;
										#endif

										if (iLastEntityOnCursor != 0 && iLastEntityOnCursor != t.e)
										{
											ReplaceEntityInGroupList(iLastEntityOnCursor, t.e);
											iLastEntityOnCursor = 0;
										}

										int iNewParentEntityIndex = t.e;

										if (pref.iEnableDragDropEntityMode && t.e > 0) {
											//PE: After placing it, sent it to widget.
											iWidgetSelection = t.e;
										}
										bDraggingActive = false;
										t.gridentity = iStoreGridEntity;
										t.e = iNewParentEntityIndex;

										if (bCreateNewGroupOnNextDrop)
										{
											//Create a new group
											fLastRubberBandX2 = 0; //We dont have a rubberband so...
											fLastRubberBandX1 = 0;
											fLastRubberBandY2 = 0;
											fLastRubberBandY1 = 0;

											CreateNewGroup(-1);
											bCreateNewGroupOnNextDrop = false;
										}
									}
									else
									#endif
									{
										// store original ent ID pased down
										int iStoreGridEntity = t.gridentity;

										// add parent entity

										#ifdef WICKEDENGINE
										//PE: InstanceObject - Cursor,Object Tools - objects must always be real clones.
										extern bool bNextObjectMustBeClone;
										bNextObjectMustBeClone = true;
										#endif

										gridedit_addentitytomap();

										#ifdef WICKEDENGINE
										bNextObjectMustBeClone = false;
										#endif

										int iNewParentEntityIndex = t.e;

										t.entityelement[t.e].iHasParentIndex = t.gridentityhasparent;

										// add children for the parent
										int* piNewEntIndex = new int[g.entityrubberbandlist.size()];
										for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
										{
											int e = g.entityrubberbandlist[i].e;
											if (e == 0)
											{
												t.e = iNewParentEntityIndex;
											}
											else
											{
												// duplicate this child and add to map
												t.gridentity = t.entityelement[e].bankindex;

												#ifdef WICKEDENGINE
												//PE: InstanceObject - Cursor,Object Tools - objects must always be real clones.
												extern bool bNextObjectMustBeClone;
												bNextObjectMustBeClone = true;
												#endif

												gridedit_addentitytomap(); //use entityelement[t.e].

												#ifdef WICKEDENGINE
												bNextObjectMustBeClone = false;
												#endif

												// update child with pos/rot from source
												t.entityelement[t.e].x = t.entityelement[e].x;
												t.entityelement[t.e].y = t.entityelement[e].y;
												t.entityelement[t.e].z = t.entityelement[e].z;
												t.entityelement[t.e].rx = t.entityelement[e].rx;
												t.entityelement[t.e].ry = t.entityelement[e].ry;
												t.entityelement[t.e].rz = t.entityelement[e].rz;			
												t.entityelement[t.e].quatmode = t.entityelement[e].quatmode;
												t.entityelement[t.e].quatx = t.entityelement[e].quatx;
												t.entityelement[t.e].quaty = t.entityelement[e].quaty;
												t.entityelement[t.e].quatz = t.entityelement[e].quatz;
												t.entityelement[t.e].quatw = t.entityelement[e].quatw;
												t.entityelement[t.e].editorfixed = t.entityelement[e].editorfixed;
												t.entityelement[t.e].staticflag = t.entityelement[e].staticflag;
												t.entityelement[t.e].scalex = t.entityelement[e].scalex;
												t.entityelement[t.e].scaley = t.entityelement[e].scaley;
												t.entityelement[t.e].scalez = t.entityelement[e].scalez;
												t.entityelement[t.e].soundset = t.entityelement[e].soundset;
												t.entityelement[t.e].soundset1 = t.entityelement[e].soundset1;
												t.entityelement[t.e].soundset2 = t.entityelement[e].soundset2;
												t.entityelement[t.e].soundset3 = t.entityelement[e].soundset3;
												t.entityelement[t.e].soundset4 = t.entityelement[e].soundset4;
												#ifdef WICKEDENGINE
												t.entityelement[t.e].soundset5 = t.entityelement[e].soundset5;
												t.entityelement[t.e].soundset6 = t.entityelement[e].soundset6;
												#endif
												t.entityelement[t.e].eleprof = t.entityelement[e].eleprof;
												PositionObject(t.entityelement[t.e].obj, t.entityelement[t.e].x, t.entityelement[t.e].y, t.entityelement[t.e].z);
												RotateObject(t.entityelement[t.e].obj, t.entityelement[t.e].rx, t.entityelement[t.e].ry, t.entityelement[t.e].rz);
											}
											piNewEntIndex[i] = t.e;
										}

										// and once all new entities created, link new parents to them
										for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
										{
											t.e = piNewEntIndex[i];
											int e = g.entityrubberbandlist[i].e;
											if (e != 0)
											{
												// find source parent of this child, if any
												if (t.entityelement[e].iHasParentIndex > 0)
												{
													if (t.entityelement[e].iHasParentIndex == t.gridentityextractedindex)
													{
														// entity was child of parent entity extacted
														t.entityelement[t.e].iHasParentIndex = iNewParentEntityIndex;
													}
													else
													{
														// entity was child of another entity (a child in here)
														for (int ii = 0; ii < (int)g.entityrubberbandlist.size(); ii++)
														{
															int ee = g.entityrubberbandlist[ii].e;
															if (ee > 0)
															{
																if (t.entityelement[e].iHasParentIndex == ee)
																{
																	// entity was child of parent entity extacted
																	t.entityelement[t.e].iHasParentIndex = piNewEntIndex[ii];
																}
															}
														}
													}
												}
											}
										}
										SAFE_DELETE(piNewEntIndex);

										// restore original ent ID
										t.gridentity = iStoreGridEntity;
										t.e = iNewParentEntityIndex;
									}
								}
								else
								{
									#ifdef VRTECH
									//TUT: Add here.
									//TUT: PLACEIT
									CheckTutorialAction("PLACEIT"); //Tutorial: check if we are waiting for this action
									if (bTutorialCheckAction) TutorialNextAction(); //If we are waiting for PLACEIT its done.
									#endif

									#ifdef WICKEDENGINE
									//PE: InstanceObject - Cursor,Object Tools - objects must always be real clones.
									extern bool bNextObjectMustBeClone;
									bNextObjectMustBeClone = true;

									if (t.gridedit.entityspraymode == 1 || t.inputsys.keyshift)
									{
										bNextObjectMustBeClone = false;
									}
									#endif

									gridedit_addentitytomap ( );

									#ifdef WICKEDENGINE
									if (!bNextObjectMustBeClone)
									{
										// Any particle that was duplicated should have a new emitter id.
										if (t.entityprofile[t.entityelement[t.e].bankindex].ismarker == 10)
										{
											t.entityelement[t.e].eleprof.newparticle.emitterid = -1;
											entity_updateparticleemitter(t.e);
										}
									}

									bNextObjectMustBeClone = false;
									#endif

									#ifdef WICKEDENGINE
									if (iLastEntityOnCursor != 0 && iLastEntityOnCursor != t.e)
									{
										ReplaceEntityInGroupList(iLastEntityOnCursor, t.e);
										iLastEntityOnCursor = 0;
									}
									#endif

									#ifdef WICKEDENGINE
									if (pref.iEnableDragDropEntityMode && t.e > 0) {
										//PE: After placing it, sent it to widget.
										iWidgetSelection = t.e;
										//PE: Instant activete it.
										t.widget.pickedEntityIndex = iWidgetSelection;
										t.entityelement[t.widget.pickedEntityIndex].editorlock = 0;
										t.widget.pickedObject = t.entityelement[iWidgetSelection].obj;
									}
									bDraggingActive = false;
									#endif
								}

								//  if drag char to start marker, assign here
								if (  t.inputsys.willmakethirdperson>0 ) 
								{
									// set this characte as third person and game as TPP 
									t.playercontrol.thirdperson.enabled=1;
									t.playercontrol.thirdperson.charactere=t.tupdatee;
									t.playercontrol.thirdperson.startmarkere=t.inputsys.willmakethirdperson;

									// also change the script of the character to a third person script (by default)
									t.entityelement[t.tupdatee].eleprof.aimain_s = "tpp\\thirdperson.lua";
									t.entityelement[t.tupdatee].eleprof.aimain = 0;
								}

								//  if trigger zone, remove from entity cursor as well
								if (  t.entityprofile[t.gridentity].ismarker == 3 || t.entityprofile[t.gridentity].ismarker == 6 || t.entityprofile[t.gridentity].ismarker == 8 ) 
								{
									//  detatch trigger zone / checkpoint here
									t.grideleprof.trigger.waypointzoneindex=0;
									t.gridentitydelete=1;
								}
								else
								{
									//  update for refresh
									t.refreshgrideditcursor=1;
								}

								// if was targetting a parent for link/associate connection (CTRL down)
								// then make this entity a child of the entity targetted
								if ( t.tentityoverdraggingcursor > 0 )
								{
									// parents influence children when they move, and shift children relatively
									t.entityelement[t.e].iHasParentIndex = t.tentityoverdraggingcursor;
								}
								else
								{
									// if still holding CTRL put place entity down on NON-entity, remove parent link/associated status
									if ( t.inputsys.k_s == "l" ) 
									{
										t.entityelement[t.e].iHasParentIndex = 0;
									}
								}

								//  080415 - if NOT holding SHIFT, delete after one placement
								bool bShiftBeingHeldDown = false;
								if ( t.inputsys.keyshift != 0 ) 
									bShiftBeingHeldDown = true;

#ifdef WICKEDENGINE
								if (bShiftBeingHeldDown == false && t.gridedit.entityspraymode == 0 )
								{
									t.inputsys.kscancode = 211;
								}
								//PE: Dont allow spraying with markers.
								if (bShiftBeingHeldDown == false && t.gridedit.entityspraymode == 1 && t.entityprofile[t.gridentity].ismarker != 0 )
								{
									t.inputsys.kscancode = 211;
								}
#else
								//  260515 - but if in spray mode, continue using entity
								if ( bShiftBeingHeldDown == false && t.gridedit.entityspraymode == 0 ) 
								{
									t.inputsys.kscancode=211;
								}
#endif

								#ifdef WICKEDENGINE
								//PE: If this system rubberband is not dublicated, so we cant do shift. also it react on mouse release not mouse down.
								//PE: So mouse release we have no rubberband selection, if still works fine with single objects.
								if (pref.iEnableDragDropEntityMode ) {
									if (g.entityrubberbandlist.size() > 0)
									{
										t.inputsys.kscancode = 211;
									}
									//PE: Perhaps if shift we could dublicate a new group ?
									//int grouplist = isEntityInGroupList(t.e);
									//if (grouplist >= 0) {
									//	//Only allow one group at the same time, no shift.
									//	t.inputsys.kscancode = 211;
									//}
								}
								#endif
								t.selstage=1;
							}

							// restore original entity cursor position (after random spray feature)
							t.gridentityposx_f=t.storegridentityposx_f;
							t.gridentityposz_f=t.storegridentityposz_f;
							t.gridentityrotatex_f=t.storegridentityrotatex_f;
							t.gridentityrotatey_f=t.storegridentityrotatey_f;
							t.gridentityrotatez_f=t.storegridentityrotatez_f;
							t.gridentityrotatequatmode = t.storegridentityrotatequatmode;
							t.gridentityrotatequatx_f = t.storegridentityrotatequatx_f;
							t.gridentityrotatequaty_f = t.storegridentityrotatequaty_f;
							t.gridentityrotatequatz_f = t.storegridentityrotatequatz_f;
							t.gridentityrotatequatw_f = t.storegridentityrotatequatw_f;
							t.gridentityscalex_f=t.storegridentityscalex_f;
							t.gridentityscaley_f=t.storegridentityscaley_f;
							t.gridentityscalez_f=t.storegridentityscalez_f;
						}
						else
						{
							// EXTRACT ENTITY FROM MAP
							// Set flag so do not instantly delete entity (below)
							t.onetimeentitypickup=1;

							//  extract entity from the map
							if ( t.tentitytoselect>0 ) 
							{
								if ( t.entityelement[t.tentitytoselect].editorfixed == 0 ) 
								{
									t.gridentityeditorfixed=t.entityelement[t.tentitytoselect].editorfixed;
									t.gridentity=t.entityelement[t.tentitytoselect].bankindex;
									t.ttrygridentitystaticmode=t.entityelement[t.tentitytoselect].staticflag;
									t.ttrygridentity=t.gridentity; editor_validatestaticmode ( );
									t.gridedit.autoflatten=t.entityprofile[t.gridentity].autoflatten;
									t.gridedit.entityspraymode=0;
									if ( t.gridentityautofind == 7 ) 
									{
										//  widget extracts without forcing entity to Floor
										t.gridentityautofind=0;
										t.gridentityposoffground=1;
										t.gridentityusingsoftauto=0;
									}
									else
									{
										t.gridentityposoffground=0;
										t.gridentityusingsoftauto=1;
										#ifdef WICKEDENGINE
										// MAX handles its own positioning system
										#else
										if ( t.entityprofile[t.gridentity].defaultstatic == 0 && t.entityprofile[t.gridentity].isimmobile == 1 ) 
										{
											t.gridentityautofind=1;
										}
										else
										#endif
										{
											t.gridentityautofind=0;
										}
									}
									t.gridentitysurfacesnap=0; // surfacesnap off as messes up extract offset for entity
									t.gridentityextractedindex = t.tentitytoselect;
									t.gridentityhasparent = 0;//t.entityelement[t.tentitytoselect].iHasParentIndex; 210317 - break association when extract so can place free of parent
									t.gridentityposx_f=t.entityelement[t.tentitytoselect].x;
									t.gridentityposy_f=t.entityelement[t.tentitytoselect].y;
									t.gridentityposz_f=t.entityelement[t.tentitytoselect].z;
									t.gridentityrotatex_f=t.entityelement[t.tentitytoselect].rx;
									t.gridentityrotatey_f=t.entityelement[t.tentitytoselect].ry;
									t.gridentityrotatez_f=t.entityelement[t.tentitytoselect].rz;
									t.gridentityrotatequatmode = t.entityelement[t.tentitytoselect].quatmode;
									t.gridentityrotatequatx_f = t.entityelement[t.tentitytoselect].quatx;
									t.gridentityrotatequaty_f = t.entityelement[t.tentitytoselect].quaty;
									t.gridentityrotatequatz_f = t.entityelement[t.tentitytoselect].quatz;
									t.gridentityrotatequatw_f = t.entityelement[t.tentitytoselect].quatw;
									if (t.entityprofile[t.gridentity].ismarker == 10)
									{
										t.gridentityscalex_f = 100.0f + t.entityelement[t.tentitytoselect].scalex;
										t.gridentityscaley_f = 100.0f + t.entityelement[t.tentitytoselect].scaley;
										t.gridentityscalez_f = 100.0f + t.entityelement[t.tentitytoselect].scalez;
									}
									else
									{
										t.gridentityscalex_f = ObjectScaleX(t.entityelement[t.tentitytoselect].obj);
										t.gridentityscaley_f = ObjectScaleY(t.entityelement[t.tentitytoselect].obj);
										t.gridentityscalez_f = ObjectScaleZ(t.entityelement[t.tentitytoselect].obj);
									}
									t.grideleprof = t.entityelement[t.tentitytoselect].eleprof;
									t.grideleproflastname_s=t.grideleprof.name_s;

									//  Transfer any waypoint association
									t.waypointindex=t.entityelement[t.tentitytoselect].eleprof.trigger.waypointzoneindex;
									t.grideleprof.trigger.waypointzoneindex=t.waypointindex;
									t.waypoint[t.waypointindex].linkedtoentityindex=0;

									//  delete from map (checks grideleprof.trigger.waypointzoneindex too)
									gridedit_deleteentityfrommap ( );
									t.refreshgrideditcursor=1;

									// remove entity index from rubber band selection
									for ( int i = 0; i < (int)g.entityrubberbandlist.size(); i++ )
										if ( g.entityrubberbandlist[i].e == t.tentitytoselect )
											g.entityrubberbandlist[i].e = 0;

									//  Ensure grab GetPoint (  does not move entity! )
									//t.inputsys.dragoffsetx_f=t.entityelement[t.tentitytoselect].x-t.inputsys.localx_f;
									//t.inputsys.dragoffsety_f=t.entityelement[t.tentitytoselect].z-t.inputsys.localy_f;
									t.inputsys.dragoffsetx_f=t.entityelement[t.tentitytoselect].x-t.inputsys.originallocalx_f;
									t.inputsys.dragoffsety_f=t.entityelement[t.tentitytoselect].z-t.inputsys.originallocaly_f;
								}
							}
						}
						t.selstage=1;
					}

					//  If EXTRACT button clicked initially, first reposition mouse before operation and to get mouse coord correct
					if ( t.widget.duplicatebuttonselected == 1 && t.gridentity == 0 ) 
					{
						//  work out screen/mouse position from real-world XZ coordinate
						if (  t.inputsys.picksystemused == 0 ) 
						{
							//  only if not using pick stsrem (no Floor (  to target) )
							SetCurrentCamera ( 0 );

							//  fix camera range for correct projection matrix
							SetCameraRange ( DEFAULT_NEAR_PLANE, DEFAULT_FAR_PLANE );
							t.screenwidth_f=800.0;
							t.screenheight_f=600.0;
							GetProjectionMatrix (  g.m4_projection );
							GetViewMatrix (  g.m4_view );

							// works in DX9 (D3DXVec4Transform) but not DX11 (KMATRIX)
							//SetVector4 (  g.v4_far, ObjectPositionX(t.widget.widgetXYObj), ObjectPositionY(t.widget.widgetXYObj), ObjectPositionZ(t.widget.widgetXYObj), 1 );
							//TransformVector4 (  g.v4_far,g.v4_far,g.m4_view );
							//t.tx_f=GetXVector4(g.v4_far);
							//t.ty_f=GetYVector4(g.v4_far);
							SetVector3 ( g.v3_far, ObjectPositionX(t.widget.widgetXYObj), ObjectPositionY(t.widget.widgetXYObj), ObjectPositionZ(t.widget.widgetXYObj) );
							TransformVectorCoordinates3 ( g.v3_far, g.v3_far, g.m4_view );
							t.tx_f=GetXVector3(g.v3_far);
							t.ty_f=GetYVector3(g.v3_far);

							SetVector4 ( g.v4_far, GetXVector3(g.v3_far), GetYVector3(g.v3_far), GetZVector3(g.v3_far), 1 );
							TransformVector4 ( g.v4_far,g.v4_far,g.m4_projection );
							t.tx_f=GetXVector4(g.v4_far);
							t.ty_f=GetYVector4(g.v4_far);
							t.tx_f=t.tx_f/GetWVector4(g.v4_far);
							t.ty_f=t.ty_f/GetWVector4(g.v4_far);

							t.tadjustedtoareax_f=(((t.tx_f+1.0)/2.0)*(GetDisplayWidth()+0.0));
							t.tadjustedtoareay_f=((((t.ty_f*-1)+1.0)/2.0)*(GetDisplayHeight()+0.0));
							t.inputsys.xmouse=t.tadjustedtoareax_f;
							t.inputsys.ymouse=t.tadjustedtoareay_f;
							t.tideframestartx=148 ; t.tideframestarty=96;

							#ifdef ENABLEIMGUI
							//PE: Why do we need this ? everything should already match.
							//PE: IMGUI need fix.
							//PositionMouse (  (t.tideframestartx+t.inputsys.xmouse)*-1,(t.tideframestarty+t.inputsys.ymouse)*-1 );
							#else
							PositionMouse (  (t.tideframestartx+t.inputsys.xmouse)*-1,(t.tideframestarty+t.inputsys.ymouse)*-1 );
							#endif

							editor_refreshcamerarange ( );
						}

						// trigger actual extraction on next cycle
						t.widget.duplicatebuttonselected = 2;
					}
				}

				#ifdef WICKEDENGINE
				// ZJ: Moved this to a function so it can be called from the delete button in the edit menu.
				//  delete selected entity via delete key
				//bool bNoDelete = false;
				//static bool bWaitOnDelRelease = false;
				//#ifdef WICKEDENGINE
				//if (bWaitOnDelRelease && t.inputsys.kscancode == 211)
				//	bNoDelete = true;
				//else
				//	bWaitOnDelRelease = false;
				//#endif

				//if ( !bNoDelete && t.onetimeentitypickup == 0 )
				//{
				//	if ( t.gridentity != 0 ) 
				//	{
				//		if ( t.inputsys.kscancode == 211 ) 
				//		{
				//			t.inputsys.mclickreleasestate=1;
				//			t.gridentitydelete=1;
				//			t.selstage=1;
				//			t.inputsys.kscancode = 0;
				//			t.widget.pickedObject = 0; //dont remove widget object.
				//			bWaitOnDelRelease = true;
				//		}
				//	}
				//	else
				//	{
				//		if ( t.inputsys.kscancode == 211 || (t.widget.deletebuttonselected == 1 && t.inputsys.mclick == 0) ) 
				//		{
				//			t.widget.deletebuttonselected=0;
				//			bool bContinueWithDelete = true;
				//			if ( t.widget.pickedEntityIndex > 0 )
				//			{
				//				// specifically avoid deleting child entities if highlighting a parent
				//				if ( g.entityrubberbandlist.size() > 0 )
				//				{
				//					bool bDisableRubberBandMoving = false;
				//					#ifdef WICKEDENGINE
				//					if (current_selected_group >= 0 && group_editing_on)
				//					{
				//						bDisableRubberBandMoving = true;
				//					}
				//					#endif
				//					if (!bDisableRubberBandMoving)
				//					{
				//						//LB: to ensure cannot delete objects that are part of a group, 
				//						// check if the group is a parent group (user can delete child groups okay)
				//						#ifdef WICKEDENGINE
				//						// before make final decision, see if a parent group can hand over control to one of its child groups
				//						if (current_selected_group >= 0 && vEntityGroupList[current_selected_group][0].iGroupID != -1)
				//						{
				//							// this group is a parent, so see if there are any child groups
				//							int iLookForThisID = vEntityGroupList[current_selected_group][0].iGroupID;
				//							for (int gi = 0; gi < MAXGROUPSLISTS; gi++)
				//							{
				//								if (gi != current_selected_group && vEntityGroupList[gi].size() > 0)
				//								{
				//									if (vEntityGroupList[gi][0].iParentGroupID == iLookForThisID)
				//									{
				//										// found a child of this parent, switch roles (so parent can be deleted below)
				//										for (int n = 0; n < vEntityGroupList[gi].size(); n++)
				//										{
				//											// child becomes the parent
				//											vEntityGroupList[gi][n].iGroupID = iLookForThisID;
				//											vEntityGroupList[gi][n].iParentGroupID = -1;
				//										}
				//										for (int n = 0; n < vEntityGroupList[current_selected_group].size(); n++)
				//										{
				//											// parent becomes the child (temporarily so they can be deleted)
				//											vEntityGroupList[current_selected_group][n].iGroupID = -1;
				//											vEntityGroupList[current_selected_group][n].iParentGroupID = iLookForThisID;
				//										}
				//										// also, ensure the original parent group image survives, so copy just before deletions
				//										iEntityGroupListImage[gi] = iEntityGroupListImage[current_selected_group];
				//										// only need one child to become parent
				//										break;
				//									}
				//								}
				//							}
				//						}
				//						// prevent deleting them, and instead instruct user to ungroup the objects first
				//						if (current_selected_group >= 0 && vEntityGroupList[current_selected_group][0].iGroupID != -1)
				//						{
				//							// do not delete 'key' objects that are part of group
				//							strcpy(cTriggerMessage, "Cannot delete a parent group. First ungroup objects, then you can delete them all.");
				//							bTriggerMessage = true;
				//							bContinueWithDelete = false;
				//						}
				//						else
				//						#endif
				//						{
				//							#ifdef WICKEDENGINE
				//							// before delete, ensure child groups are ungrouped before the delete
				//							if (current_selected_group >= 0 && vEntityGroupList[current_selected_group][0].iParentGroupID != -1)
				//							{
				//								// pass flag to ensure rubber band list not cleared, so we can delete below
				//								UnGroupSelected(true);
				//							}
				//							#endif
				//							// delete all entities in rubber band highlight list
				//							gridedit_deleteentityrubberbandfrommap();
				//							gridedit_clearentityrubberbandlist();
				//							t.widget.pickedEntityIndex = 0;
				//						}
				//					}
				//				}
				//			}
				//			if (bContinueWithDelete == true)
				//			{
				//				if (t.widget.pickedObject > 0)
				//				{
				//					// delete a single entity selected by widget
				//					if (t.widget.pickedEntityIndex > 0)
				//					{
				//						t.tentitytoselect = t.widget.pickedEntityIndex;
				//						#ifdef WICKEDENGINE
				//						DeleteEntityFromLists(t.tentitytoselect);
				//						#endif
				//						gridedit_deleteentityfrommap ();
				//					}
				//					t.widget.pickedObject = 0;
				//					widget_updatewidgetobject ();
				//				}
				//				bWaitOnDelRelease = true;
				//				t.tentitytoselect = 0;
				//			}
				//		}
				//		if ( t.inputsys.keyspace == 0 ) t.inputsys.spacekeynotreleased = 0;
				//		if ( t.inputsys.keyspace == 1 && t.inputsys.rubberbandmode == 0 && t.inputsys.spacekeynotreleased == 0 )
				//		{
				//			// end selection when press SPACE
				//			gridedit_clearentityrubberbandlist();
				//			t.widget.pickedEntityIndex = 0;
				//			if (  t.widget.pickedObject>0 ) 
				//			{
				//				t.widget.pickedObject=0;
				//				widget_updatewidgetobject ( );
				//			}
				//			t.tentitytoselect=0;
				//		}
				//	}
				//}
				//else
				//{
				//	if (  t.inputsys.mclick == 0  )  t.onetimeentitypickup = 0;
				//}
				#else
				// still needed for CLASSIC and VRQUEST - delete selected entity via delete key
				bool bNoDelete = false;
				static bool bWaitOnDelRelease = false;
				if ( !bNoDelete && t.onetimeentitypickup == 0 )
				{
					if ( t.gridentity != 0 ) 
					{
						if ( t.inputsys.kscancode == 211 ) 
						{
							t.inputsys.mclickreleasestate=1;
							t.gridentitydelete=1;
							t.selstage=1;
							t.inputsys.kscancode = 0;
							t.widget.pickedObject = 0; //dont remove widget object.
							bWaitOnDelRelease = true;
						}
					}
					else
					{
						if ( t.inputsys.kscancode == 211 || (t.widget.deletebuttonselected == 1 && t.inputsys.mclick == 0) ) 
						{
							t.widget.deletebuttonselected=0;
							bool bContinueWithDelete = true;
							if ( t.widget.pickedEntityIndex > 0 )
							{
								// specifically avoid deleting child entities if highlighting a parent
								if ( g.entityrubberbandlist.size() > 0 )
								{
									bool bDisableRubberBandMoving = false;
									if (!bDisableRubberBandMoving)
									{
										// check if the group is a parent group (user can delete child groups okay)
										// delete all entities in rubber band highlight list
										gridedit_deleteentityrubberbandfrommap();
										gridedit_clearentityrubberbandlist();
										t.widget.pickedEntityIndex = 0;
									}
								}
							}
							if (bContinueWithDelete == true)
							{
								if (t.widget.pickedObject > 0)
								{
									// delete a single entity selected by widget
									if (t.widget.pickedEntityIndex > 0)
									{
										t.tentitytoselect = t.widget.pickedEntityIndex;
										gridedit_deleteentityfrommap ();
									}
									t.widget.pickedObject = 0;
									widget_updatewidgetobject ();
								}
								bWaitOnDelRelease = true;
								t.tentitytoselect = 0;
							}
						}
						if ( t.inputsys.keyspace == 0 ) t.inputsys.spacekeynotreleased = 0;
						if ( t.inputsys.keyspace == 1 && t.inputsys.rubberbandmode == 0 && t.inputsys.spacekeynotreleased == 0 )
						{
							// end selection when press SPACE
							gridedit_clearentityrubberbandlist();
							t.widget.pickedEntityIndex = 0;
							if (  t.widget.pickedObject>0 ) 
							{
								t.widget.pickedObject=0;
								widget_updatewidgetobject ( );
							}
							t.tentitytoselect=0;
						}
					}
				}
				else
				{
					if (  t.inputsys.mclick == 0  )  t.onetimeentitypickup = 0;
				}
				#endif

				#ifdef WICKEDENGINE
				HandleObjectDeletion();
				#endif
				bool bDisableWidgetSelection = false;
				#ifdef WICKEDENGINE
				if (bDotObjectDragging)
					bDisableWidgetSelection = true;

				//PE: Disable selections when imgui is in drag mode.
				ImGuiContext& gui = *GImGui;
				if (gui.DragDropActive)
				{
					bDisableWidgetSelection = true;
				}

				#endif
				// Select widget controlled object
				if (!bDisableWidgetSelection && (t.inputsys.mclick == 1|| iWidgetSelection > 0 ) && t.gridentity == 0)
				{
					if (iWidgetSelection > 0)
					{
						t.tentitytoselect = iWidgetSelection;
					}
					if ( t.tentitytoselect>0 ) 
					{
						#ifdef WICKEDENGINE
						//PE: Dont allow changing group when in edit mode.
						if (!group_editing_on && !bRubberBandCreated && t.tentitytoselect != iLastSelectedEntity)
						{
							//Clear rubberband. Allow CTRL to select multiply groups.
							if (t.inputsys.keycontrol == 0) {
								//Only if not in same group.
								int grouplist = isEntityInGroupList(t.tentitytoselect);
								
								if (iLastSelectedEntityGroup != grouplist)
								{
									iLastSelectedEntityGroup = grouplist;
									current_selected_group = grouplist;
									g.entityrubberbandlist.clear();
								}
								else
								{
									if (t.tentitytoselect != iLastSelectedEntity)
									{
										//PE: If we have made a selection not in rubberband, clear rubberband.
										if (g.entityrubberbandlist.size() > 0)
										{
											bool bInRubberBand = false;
											for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
											{
												int ent = g.entityrubberbandlist[i].e;
												if (ent == t.tentitytoselect)
												{
													bInRubberBand = true;
													break;
												}
											}
											if (!bInRubberBand)
											{
												//New selection not in rubberband, clear.
												g.entityrubberbandlist.clear();
											}
										}
									}
								}
							}

							iLastSelectedEntity = t.tentitytoselect;
						}
						if (bRubberBandCreated)
						{
							int grouplist = isEntityInGroupList(t.tentitytoselect);
							iLastSelectedEntityGroup = grouplist;

							if (t.tentitytoselect != iLastSelectedEntity)
							{
								//PE: If we have made a selection not in rubberband, clear rubberband.
								if (g.entityrubberbandlist.size() > 0)
								{
									bool bInRubberBand = false;
									for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
									{
										int ent = g.entityrubberbandlist[i].e;
										if (ent == t.tentitytoselect)
										{
											bInRubberBand = true;
											break;
										}
									}
									if (!bInRubberBand)
									{
										//New selection not in rubberband, clear.
										g.entityrubberbandlist.clear();
									}
								}
								iLastSelectedEntity = t.tentitytoselect;
							}

						}
							
						bRubberBandCreated = false;
						if (pref.iEnableDragDropEntityMode && iWidgetSelection == 0)
						{
							//PE: Disable single click, widget selection, and replace with entity cursor.
							CheckGroupListForRubberbandSelections(t.tentitytoselect);
							AddEntityToCursor(t.tentitytoselect,false);

							//PE: Instant activate it.
							t.widget.pickedEntityIndex = t.tentitytoselect;

							#ifdef ALLOWSELECTINGLOCKEDOBJECTS
							if (!t.entityelement[t.widget.pickedEntityIndex].editorlock)
							{
							#endif
								t.entityelement[t.widget.pickedEntityIndex].editorlock = 0;
								t.widget.pickedObject = 0; //t.entityelement[t.tentitytoselect].obj;

								t.tentitytoselect = 0;
								bReadyToDropEntity = true;
								bWaitOnMouseRelease = true;
								iDragDropActive = 0;
								bDraggingActive = true;

							#ifdef ALLOWSELECTINGLOCKEDOBJECTS
							}
							#endif
						}
						else
						{
							bDraggingActive = false;
							#endif
							iWidgetSelection = 0;
							if (t.widget.pickedObject == 0)
							{
								//PE: respect markers mode only.
								if (t.gridentitymarkersmodeonly == 0 || (t.gridentitymarkersmodeonly == 1 && t.entityprofile[t.entityelement[t.tentitytoselect].bankindex].ismarker != 0))
								{
									t.widget.pickedEntityIndex = t.tentitytoselect;
									t.widget.pickedObject = t.entityelement[t.tentitytoselect].obj;
									#ifndef ALLOWSELECTINGLOCKEDOBJECTS
									t.entityelement[t.widget.pickedEntityIndex].editorlock = 0;
									#endif
									#ifdef WICKEDENGINE
									// makes widget gadgets easier to manipulate
									t.widget.offsetx = g.glastpickedx_f - ObjectPositionX(t.widget.pickedObject);
									t.widget.offsety = g.glastpickedy_f - ObjectPositionY(t.widget.pickedObject);
									t.widget.offsetz = g.glastpickedz_f - ObjectPositionZ(t.widget.pickedObject);

									CheckGroupListForRubberbandSelections(t.tentitytoselect);
									#else
									t.widget.offsetx = g.glastpickedx_f - ObjectPositionX(t.widget.pickedObject);
									t.widget.offsety = g.glastpickedy_f - ObjectPositionY(t.widget.pickedObject);
									t.widget.offsetz = g.glastpickedz_f - ObjectPositionZ(t.widget.pickedObject);
									#endif

									// 271015 - this may not be required as it is duplicated later on..
									if (g.entityrubberbandlist.size() > 0)
										gridedit_moveentityrubberband();
									else
									{
										#ifdef WICKEDENGINE
										//MessageBoxA(NULL, "move", "", MB_OK);
										#else
										entity_recordbuffer_move();
										#endif
									}
								}
							}
						#ifdef WICKEDENGINE
						}
						#endif
					}
				}

				// zoom into entity properties (or EBE EDIT)
				if ( t.widget.propertybuttonselected == 1 ) 
				{
					t.widget.propertybuttonselected = 0;
					if ( t.widget.pickedEntityIndex > 0 ) 
					{
						int entid = t.entityelement[t.widget.pickedEntityIndex].bankindex;
						if ( t.entityprofile[entid].isebe != 0 )
						{
							// EBE entity - begin editing this site
							ebe_newsite ( t.widget.pickedEntityIndex );
						}

						//  End widget control of this object
						t.widget.pickedObject=0;
					}
				}
				if (  t.widget.propertybuttonselected == 2 ) 
				{
					// Entity properties or EBE Save
					t.widget.propertybuttonselected = 0;
					if ( t.widget.pickedEntityIndex > 0 ) 
					{
						int entid = t.entityelement[t.widget.pickedEntityIndex].bankindex;
						if ( t.entityprofile[entid].isebe != 0 )
						{
							// EBE entity - begin editing this site
							if ( ebe_save ( t.widget.pickedEntityIndex ) == 1 )
							{
								// Added NEW (not overwritten) - now saved to entitybank\user\ebestructures
								//editor_addEBEtoLibrary ( entid );
							}

							// and close widget as Save bit big deal
							widget_switchoff();
						}
						else
						{
							// regular entity
							// prepare zoom-in adjustment vars
							t.tentitytoselect=t.widget.pickedEntityIndex;
							#ifdef WICKEDENGINE
							//MessageBoxA(NULL, "move", "", MB_OK);
							#else
							entity_recordbuffer_move ( );
							#endif
							t.e=t.tentitytoselect;

							t.gridentityinzoomview=t.e;
							t.zoomviewtargetx_f=t.entityelement[t.e].x;
							t.zoomviewtargety_f=t.entityelement[t.e].y;
							t.zoomviewtargetz_f=t.entityelement[t.e].z;
							t.zoomviewtargetrx_f=t.entityelement[t.e].rx;
							t.zoomviewtargetry_f=t.entityelement[t.e].ry;
							t.zoomviewtargetrz_f=t.entityelement[t.e].rz;
							gridedit_updatezoomviewvalues ( );

							//  extract entity from the map
							t.gridentityeditorfixed=t.entityelement[t.e].editorfixed;
							t.gridentity=t.entityelement[t.e].bankindex;
							t.ttrygridentitystaticmode=t.entityelement[t.e].staticflag;
							t.ttrygridentity=t.gridentity ; editor_validatestaticmode ( );
							t.gridentityautofind=0;
							t.gridentityposoffground=1;
							t.gridentityusingsoftauto=0;
							t.gridentitysurfacesnap=1-g.gdisablesurfacesnap;
							t.gridentityhasparent=t.entityelement[t.e].iHasParentIndex;
							t.gridentityposx_f=t.entityelement[t.e].x;
							t.gridentityposy_f=t.entityelement[t.e].y;
							t.gridentityposz_f=t.entityelement[t.e].z;
							t.gridentityrotatex_f=t.entityelement[t.e].rx;
							t.gridentityrotatey_f=t.entityelement[t.e].ry;
							t.gridentityrotatez_f=t.entityelement[t.e].rz;
							t.gridentityrotatequatmode = t.entityelement[t.e].quatmode;
							t.gridentityrotatequatx_f = t.entityelement[t.e].quatx;
							t.gridentityrotatequaty_f = t.entityelement[t.e].quaty;
							t.gridentityrotatequatz_f = t.entityelement[t.e].quatz;
							t.gridentityrotatequatw_f = t.entityelement[t.e].quatw;
							if (t.entityprofile[t.gridentity].ismarker == 10)
							{
								t.gridentityscalex_f = 100.0f + t.entityelement[t.e].scalex;
								t.gridentityscaley_f = 100.0f + t.entityelement[t.e].scaley;
								t.gridentityscalez_f = 100.0f + t.entityelement[t.e].scalez;
							}
							else
							{
								t.gridentityscalex_f = ObjectScaleX(t.entityelement[t.e].obj);
								t.gridentityscaley_f = ObjectScaleY(t.entityelement[t.e].obj);
								t.gridentityscalez_f = ObjectScaleZ(t.entityelement[t.e].obj);
							}
							t.grideleprof = t.entityelement[t.e].eleprof;

							//  Transfer any waypoint association
							t.waypointindex=t.entityelement[t.e].eleprof.trigger.waypointzoneindex;
							t.grideleprof.trigger.waypointzoneindex=t.waypointindex;
							t.waypoint[t.waypointindex].linkedtoentityindex=0;

							//  Delete entity from map
							gridedit_deleteentityfrommap ( );
							t.refreshgrideditcursor=1;

							//  simply use its current position (no offset)
							t.inputsys.dragoffsetx_f=0;
							t.inputsys.dragoffsety_f=0;

							//  zoom in to entity for fine detail
							//PE: In wicked we dont actually zoom in so keep cx,cy
							#ifndef WICKEDENGINE
							t.cx_f=t.entityelement[t.e].x;
							t.cy_f=t.entityelement[t.e].z*-1.0;
							#endif
							t.inputsys.doautozoomview=1;
							if (t.zoomviewcamerarange_f > 2000.0f)
							{
								//This can fail after test game. if really large set defaults.
								t.zoomviewcamerarange_f = 175.0f;
								t.zoomviewcameraheight_f = 150.0f;
							}
							//  disable icons that interfere with zoom mode
							editor_disableforzoom ( );
	
							HideObject ( t.editor.objectstartindex+5 );
							t.selstage=1;

							//  prepare entity property handler
							#if defined(ENABLEIMGUI) && !defined(USEOLDIDE)
							//PE: Just open the window..
							bEntity_Properties_Window = true;
							#else
							interface_openpropertywindow ( );
							#endif

							//  End widget control of this object
							t.widget.pickedObject=0;
						}
					}
				}

				bool bDisableRubberBandMoving = false;
				#ifdef WICKEDENGINE
				if (current_selected_group >= 0 && group_editing_on)
				{
					bDisableRubberBandMoving = true;
				}
				#endif
				// update rubberband selection connected to primary cursor entity
				if ( !bDisableRubberBandMoving && t.gridentity > 0 && g.entityrubberbandlist.size() > 1 && t.fOldGridEntityX > -99999.0f )
				{
					float fMovedActiveObjectX = t.gridentityposx_f - t.fOldGridEntityX;
					float fMovedActiveObjectY = t.gridentityposy_f - t.fOldGridEntityY;
					float fMovedActiveObjectZ = t.gridentityposz_f - t.fOldGridEntityZ;
					t.gridentityrotatex_f = t.fOldGridEntityRX;
					t.gridentityrotatey_f = t.fOldGridEntityRY;
					t.gridentityrotatez_f = t.fOldGridEntityRZ;
					t.gridentityrotatequatmode = t.fOldGridEntityQuatMode;
					t.gridentityrotatequatx_f = t.fOldGridEntityQuatX;
					t.gridentityrotatequaty_f = t.fOldGridEntityQuatY;
					t.gridentityrotatequatz_f = t.fOldGridEntityQuatZ;
					t.gridentityrotatequatw_f = t.fOldGridEntityQuatW;
					t.tobj = t.gridentityobj;
					if ( t.tobj>0 ) 
					{
						// rotate all selected around t.tobj, the active object
						GGQUATERNION QuatAroundX, QuatAroundY, QuatAroundZ;
						//GGQuaternionRotationAxis(&QuatAroundX, &GGVECTOR3(1, 0, 0), GGToRadian(fMovedActiveObjectRX)); (see above)
						//GGQuaternionRotationAxis(&QuatAroundY, &GGVECTOR3(0, 1, 0), GGToRadian(fMovedActiveObjectRY));
						//GGQuaternionRotationAxis(&QuatAroundZ, &GGVECTOR3(0, 0, 1), GGToRadian(fMovedActiveObjectRZ));
						GGQuaternionRotationAxis(&QuatAroundX, &GGVECTOR3(1, 0, 0), GGToRadian(0));
						GGQuaternionRotationAxis(&QuatAroundY, &GGVECTOR3(0, 1, 0), GGToRadian(0));
						GGQuaternionRotationAxis(&QuatAroundZ, &GGVECTOR3(0, 0, 1), GGToRadian(0));
						GGQUATERNION quatRotationEvent = QuatAroundX * QuatAroundY * QuatAroundZ;
						SetStartPositionsForRubberBand(t.tobj);
						RotateAndMoveRubberBand(t.tobj, fMovedActiveObjectX, fMovedActiveObjectY, fMovedActiveObjectZ, quatRotationEvent);
					}
				}
				// record all current offsets from primary cursor entity and rubberband selection
				#ifdef WICKEDENGINE
				if (pref.iEnableDragDropEntityMode && t.gridentity > 0) 
				{
					//PE: Dont reset t.fOldGridEntityX when we got a t.gridentity
				}
				else
				#endif
				{
					//PE: t.gridentityposx_f can go below -1, if you drag it way out there , and you could loose moving of rubberband (out of sync).
					if (!bDisableRubberBandMoving)
					{
						t.fOldGridEntityX = -99999.0f;
						t.fOldGridEntityY = -99999.0f;
						t.fOldGridEntityZ = -99999.0f;
						t.fOldGridEntityRX = -99999.0f;
						t.fOldGridEntityRY = -99999.0f;
						t.fOldGridEntityRZ = -99999.0f;
						t.fOldGridEntityQuatMode = 0;
						t.fOldGridEntityQuatX = 0;
						t.fOldGridEntityQuatY = 0;
						t.fOldGridEntityQuatZ = 0;
						t.fOldGridEntityQuatW = 1;
					}
				}
				if (!bDisableRubberBandMoving && t.gridentity > 0 && t.gridentityobj > 0 && g.entityrubberbandlist.size() > 1 )
				{
					t.fOldGridEntityX = t.gridentityposx_f;
					t.fOldGridEntityY = t.gridentityposy_f;
					t.fOldGridEntityZ = t.gridentityposz_f;
					t.fOldGridEntityRX = t.gridentityrotatex_f;
					t.fOldGridEntityRY = t.gridentityrotatey_f;
					t.fOldGridEntityRZ = t.gridentityrotatez_f;
					t.fOldGridEntityQuatMode = t.gridentityrotatequatmode;
					t.fOldGridEntityQuatX = t.gridentityrotatequatx_f;
					t.fOldGridEntityQuatY = t.gridentityrotatequaty_f;
					t.fOldGridEntityQuatZ = t.gridentityrotatequatz_f;
					t.fOldGridEntityQuatW = t.gridentityrotatequatw_f;
					for ( int i = 0; i < (int)g.entityrubberbandlist.size(); i++ )
					{
						int e = g.entityrubberbandlist[i].e;
						GGVECTOR3 VecPos;
						VecPos.x = t.entityelement[e].x - t.gridentityposx_f;
						VecPos.y = t.entityelement[e].y - t.gridentityposy_f;
						VecPos.z = t.entityelement[e].z - t.gridentityposz_f;
						int tobj = t.entityelement[e].obj;
						if ( tobj > 0 )
						{
							float fDet = 0.0f;
							sObject* pObject = GetObjectData(tobj);
							GGMATRIX inverseMatrix = pObject->position.matObjectNoTran;
							GGMatrixInverse ( &inverseMatrix, &fDet, &inverseMatrix );
							GGVec3TransformCoord ( &VecPos, &VecPos, &inverseMatrix );
							g.entityrubberbandlist[i].x = VecPos.x;
							g.entityrubberbandlist[i].y = VecPos.y;
							g.entityrubberbandlist[i].z = VecPos.z;
						}
					}
				}

				//  gridentity delete
				if (  t.gridentitydelete == 1 ) 
				{
					//  Delete any associated waypoint/trigger zone
					t.waypointindex=t.grideleprof.trigger.waypointzoneindex;
					if (  t.waypointindex>0 ) 
					{
						t.w=t.waypoint[t.waypointindex].start;
						waypoint_delete ( );
					}
					t.grideleprof.trigger.waypointzoneindex=0;
					//  delete grid entity object and reset
					t.gridentitydelete=0;
					if (  t.gridentityobj>0 ) 
					{
						DeleteObject (  t.gridentityobj );
						t.gridentityobj=0;
					}
					t.refreshgrideditcursor=1;
					t.gridentity=0;
					t.gridentityposoffground=0;
					t.gridentityusingsoftauto=0;
					t.gridentitysurfacesnap=1-g.gdisablesurfacesnap;
					#ifdef WICKEDENGINE
					// MAX handles its own positioning system
					t.gridentityautofind = 0;
					#else
					t.gridentityautofind=1;
					#endif
					t.inputsys.dragoffsetx_f=0;
					t.inputsys.dragoffsety_f=0;
					editor_refreshentitycursor ( );
					t.widget.pickedObject=0;

					#ifdef WICKEDENGINE
					//PE: We dont actualle make new duplicates so can skib this.
					if (pref.iEnableDragDropEntityMode)
					{
						//We might have to do some kind of support.
					}
					else
					#endif
					{
						bool bDisableRubberBandMoving = false;
						#ifdef WICKEDENGINE
						if (current_selected_group >= 0 && group_editing_on)
						{
							bDisableRubberBandMoving = true;
						}
						#endif
						if (!bDisableRubberBandMoving)
						{
							// if rubberband selection, delete all in selection
							gridedit_deleteentityrubberbandfrommap();
						}
					}

					// flag also used to restore highlighting behavior
					t.gridentityextractedindex = 0;

					// when place down, ensure waypoint not affected until release mouse button
					t.mclickpressed = 1;
				}
			}

			if (  t.inputsys.mclick == 0 && t.selstage == 1 ) 
			{
				t.selstage=0;
			}
			if (  t.gridedit.entityspraymode == 1 && t.selstage == 1 ) 
			{
				//  entity spray keeps going while button pressed
				t.selstage=0;
			}
		}

		// this is triggered when set to a negative, and continues to force find surface until zero
		#ifdef WICKEDENGINE
		if (iObjectMoveModeDropSystem < 0)
		{
			iObjectMoveModeDropSystem++;
			iForceScancode = 13;
		}
		#endif
	}
}

void gridedit_updatezoomviewvalues ( void )
{
	//  accepts gridentityinzoomview
	if (  t.gridentityinzoomview>0 ) 
	{
		t.zoomviewcameraangle_f=0.0;
		t.zoomviewcameraheight_f=50.0;
		t.zoomviewcamerarange_f=75.0;
		if (  t.entityelement[t.gridentityinzoomview].obj>0 ) 
		{
			if (  ObjectExist(t.entityelement[t.gridentityinzoomview].obj) == 1 ) 
			{
				t.zoomviewcamerarange_f=ObjectSize(t.entityelement[t.gridentityinzoomview].obj,1)*2.0;
				t.zoomviewcameraheight_f=(ObjectSize(t.entityelement[t.gridentityinzoomview].obj,1)/2.0)-100.0;
				if (  t.zoomviewcameraheight_f<5  )  t.zoomviewcameraheight_f = 5;

				// ensure camera always faces the front of an entity
				t.zoomviewcameraangle_f = (0-ObjectAngleY(t.entityelement[t.gridentityinzoomview].obj))+180.0f;
			}
		}
	}
}

void gridedit_save_test_map ( void )
{
	//  Save map data locally only (not to FPM)
	timestampactivity(0,"SAVETESTMAP: Save map");
	mapfile_savemap ( );

	//  Settings specific to the player
	timestampactivity(0,"SAVETESTMAP: Save player config");
	mapfile_saveplayerconfig ( );

	//  Save entity elements
	timestampactivity(0,"SAVETESTMAP: Save elements");
	entity_savebank ( );
	entity_savebank_ebe ( );
	entity_saveelementsdata ( );

	//  Save waypoints
	timestampactivity(0,"SAVETESTMAP: Save waypoints");
	waypoint_savedata ( );

	//  Save editor configuration
	timestampactivity(0,"SAVETESTMAP: Save config");
	editor_savecfg ( );

	//  Save terrain
	timestampactivity(0,"SAVETESTMAP: Save terrain textures");
	#ifdef VRTECH
	t.tfileveg_s = g.mysystem.levelBankTestMap_s + "vegmask.png";// dds";
	t.tfilewater_s = g.mysystem.levelBankTestMap_s + "watermask.png";// dds"; 
	#else
	t.tfileveg_s=g.mysystem.levelBankTestMap_s+"vegmask.dds"; //"levelbank\\testmap\\vegmask.dds";
	t.tfilewater_s=g.mysystem.levelBankTestMap_s+"watermask.dds"; //"levelbank\\testmap\\watermask.dds";
	#endif
	terrain_savetextures ( );
	#ifdef WICKEDENGINE
	t.tfileveggrass_s=g.mysystem.levelBankTestMap_s+"TTR0XR0\\vegmaskgrass.dat";
	#else
	t.tfileveggrass_s=g.mysystem.levelBankTestMap_s+"vegmaskgrass.dat";
	#endif
	timestampactivity(0,"SAVETESTMAP: Save terrain veg");
	grass_savegrass ( );
	timestampactivity(0,"SAVETESTMAP: Save terrain height data");
	t.tfile_s=g.mysystem.levelBankTestMap_s+"m.dat";
	#ifdef WICKEDENGINE
	terrain_save ( t.tfile_s.Get() );
	#else
	terrain_save();
	#endif

	//  this ensures change flag does not use filemap port 1 (avoid freeze in build game)
	t.lastprojectmodified=0;

	//  Set modification flag
	timestampactivity(0,"SAVETESTMAP: Change modified flag of level");
	g.projectmodified = 0; gridedit_changemodifiedflag ( );
	g.projectmodifiedstatic = 0; 
	timestampactivity(0,"SAVETESTMAP: Complete");
}

void gridedit_save_map ( void )
{
	#ifdef WICKEDENGINE
	// seems save can cause IMGUI to crash out when rendering a texture that no longer exists
	extern bool bBlockImGuiUntilNewFrame;
	bBlockImGuiUntilNewFrame = true;
	#endif

	// Proper saving message to user
	if (  t.recoverdonotuseany3dreferences == 0 ) 
	{
		editor_hideall3d ( );
	}

	// Use large prompt
	t.statusbar_s=t.strarr_s[365]; 
	popup_text(t.statusbar_s.Get());

	// Save only to TESTMAP area (for map testing)
	gridedit_save_test_map ( );

	// Now store all part-files into main FPM project
	mapfile_saveproject_fpm ( );

	// Add Latest project To Recent List
	gridedit_updateprojectname ( );

	// Clear status Text (  )
	t.statusbar_s="" ; popup_text_close();

	// refresh as SAVE can remove entities and segments
	if ( t.entityorsegmententrieschanged == 1 ) 
	{
		// 111115 - and if not exiting GG
		if ( g.savenoreloadflag == 0 )
		{
			gridedit_load_map ( );
		}
		t.entityorsegmententrieschanged=0;
	}
}

void gridedit_updatemapbeforeedit ( void )
{

//  Completely reset filemap (and interface parts ie library)
editor_filemapinit ( );

//  Newly loaded map starts at layer X
t.gridlayer=5 ; t.refreshgrideditcursor=1;

return;

}

void gridedit_clear_settings ( void )
{
	//  Default settings
	gridedit_clear_configsettings ( );
	t.gridscale_f=((800/2)/8)/t.gridzoom_f;
	t.currentprojectfilename_s="";
	t.gridground=0;
	t.gridselection=1;
	t.bufferlayer=-1;
	g.gridlayershowsingle=0;
	t.grideditartwidth=1;
	t.grideditartwidthx=1;
	t.grideditartwidthy=1;
	t.locallibrarysegidmaster=0;
	t.locallibraryentidmaster=0;
}

void gridedit_clear_configsettings ( void )
{
	// defaults
	#ifdef GGTERRAIN_USE_NEW_TERRAIN
	t.borderx_f = 1024.0*50.0; t.cx_f = GGORIGIN_X;
	t.bordery_f = 1024.0*50.0; t.cy_f = GGORIGIN_Z;
	#else
	t.borderx_f=1024.0*50.0 ; t.cx_f=t.borderx_f/2.0;
	t.bordery_f=1024.0*50.0 ; t.cy_f=t.bordery_f/2.0;
	#endif

	//  Default zoom
	t.gridzoom_f=3.0 ; t.clipheight_f=655;

	//  default grideditselect
	//  0=terrain mode
	//  4=zoom mode
	//  5=entity editing
	//  6=waypoint mode
	t.grideditselect=0;
}

void gridedit_clear_map ( void )
{
	//  Delete ALL light map objects
	lm_deleteall ( );

	#ifdef WICKEDENGINE
	//Stop delete any particle effects.
	gpup_deleteAllEffects();
	#endif

	//  Delete any old entity objects
	gridedit_deletelevelobjects ( );

	//  Delete any old weapon objects (and reload original data in case last level edited them)
	gun_releaseresources ( );
	gun_scaninall_dataonly ( );

	//  Remove any shader lighting
	lighting_free ( );

	//  delete any conkit objects
	///conkit_saveload_clear ( );

	//  Ensure whether New or Load, physics tweakables for player are reset
	physics_inittweakables ( );

	//  Set modification flag
	g.projectmodified = 0 ; gridedit_changemodifiedflag ( );
	g.projectmodifiedstatic = 0;

	//  ensure no leftovers from last edit session
	t.tlasttentitytoselect=-1;

	//  Must generate super texture when do test level for this new level map
	t.terrain.generatedsupertexture=0;

	//  reset free flight mode
	t.editorfreeflight.mode=0 ; t.updatezoom=1;
	t.editorfreeflight.sused=0;
	t.gridentityhidemarkers=0;
	t.cameraviewmode=0;
}

void gridedit_resetmemortracker ( void )
{
	// 121115 - good place to reset memory tracking
	int iMemoryLostFromActivitySoFar = g.gamememactuallyusedstart - SMEMAvailable(1);
	g.gamememactualmaxrightnow = g.gamememactualmaxrightnow - iMemoryLostFromActivitySoFar;
	g.gamememactuallyusedstart = SMEMAvailable(1);
}

#ifdef VRTECH
void gridedit_emptyallcustomfiles ( void )
{
	ChecklistForFiles();
	for ( t.c = 1 ; t.c <= ChecklistQuantity(); t.c++ )
	{
		t.tfile_s = ChecklistString(t.c);
		if ( t.tfile_s != "." && t.tfile_s != ".." ) 
		{
			// only if a CUSTOM file - needs clearing when new level created
			if ( strnicmp ( t.tfile_s.Get(), "CUSTOM_", 7 ) == NULL )
			{
				DeleteAFile ( t.tfile_s.Get() );
			}
		}
	}
}
#endif

#ifdef WICKEDENGINE
void gridedit_emptyallterrainobjfiles (void)
{
	// Delete all terrainobj files so fresh caches can be created
	ChecklistForFiles();
	for (t.c = 1; t.c <= ChecklistQuantity(); t.c++)
	{
		t.tfile_s = ChecklistString(t.c);
		if (t.tfile_s != "." && t.tfile_s != "..")
		{
			// only if a CUSTOM file - needs clearing when new level created
			if (strnicmp (t.tfile_s.Get(), "terrainobj", 10) == NULL)
			{
				DeleteAFile (t.tfile_s.Get());
			}
		}
	}
}
#endif

#ifdef WICKEDENGINE
// force new level camera into free flight mode
void gridedit_resetcameraanddynamicsky(void)
{
	// set camera to free flight on specific angle and starting defaults
	g_bResetCameraToFreeFlightOnNewLevel = true;
	t.editorfreeflight.sused = 0;
}
#endif

void gridedit_new_map(void)
{
#ifdef WICKEDENGINE
	// seems new 'may' cause IMGUI to crash out when rendering a texture that no longer exists
	extern bool bBlockImGuiUntilNewFrame;
	bBlockImGuiUntilNewFrame = true;
	ClearAllGroupLists();
	t.widget.pickedEntityIndex = 0;
	t.gridentity = 0;
#endif
	
	//PE: These need to be reset.
	t.gridentityinzoomview = 0;
	t.tforceentityfindfloor = 0;

	// ensure tab mode vars reset (no carry from previous session)
	g.tabmode = 0; //TABTAB mode
	g.tabmodeshowfps = 0; //F11 mode
	g.tabmodehidehuds = 0;
	g.mouseishidden = 0;
	t.terrain.terrainpaintermode = 1;

	// reset weather display flag
#ifdef VRTECH
	bEnableWeather = false;
#endif

	//  Start time profiling
	timestampactivity(0, "NEWMAP: Starting new map");

	//  No project - new map
	g.projectfilename_s = "";
	g.projectmodified = 0; t.lastprojectmodified = 0;
	g.projectmodifiedstatic = 0;
	gridedit_updateprojectname();

	// hide EBE if starting new map
	ebe_hide();
	ebe_hardreset();

	// hide terrain texture panel
	terrain_paintselector_hide();

#ifdef VRTECH
	//if ( gbWelcomeSystemActive == false ) 
	Sync();
#else
	if (gbWelcomeSystemActive == false) Sync();
#endif

	//  Reset visual settings for new map
	visuals_newlevel();

	// Reset all water settings.
	visuals_water_reset();

	//  Ensure default terrain and veg graphics
	terrain_changestyle();
	g.vegstyleindex = t.visuals.vegetationindex;
	grass_changevegstyle();

	//  Load map data
	editor_hideall3d();
	t.statusbar_s = t.strarr_s[366]; gridedit_updatestatusbar();

	//  Clear all settings
	timestampactivity(0, "NEWMAP: _gridedit_clear_settings");
	gridedit_clear_settings();

	//  Empty the lightmap folder
	timestampactivity(0, "NEWMAP: _lm_emptylightmapandttsfilesfolder");
	lm_emptylightmapandttsfilesfolder();

	#ifdef WICKEDENGINE
	void lm_emptylightmapandttsfilesfolder_wicked(void);
	lm_emptylightmapandttsfilesfolder_wicked();
	#endif

	#ifdef VRTECH
	// Reset texture/profile in EBE folder
	ebe_restoreebedefaulttextures();
	#endif

	// Empty EBEs from testmap folder
	cstr pStoreOld = GetDir(); 
	if ( PathExist ( g.mysystem.levelBankTestMap_s.Get() ) == 0 )
	{
		// somehow levelbank\testmap folder gone (can be deleted sometimes)
		SetDir ( cstr(g.fpscrootdir_s + "\\Files\\").Get() );
		if ( PathExist ( "levelbank" ) == 0 )
		{
			MakeDirectory ( "levelbank" );
			SetDir ( "levelbank" );
		}
		if ( PathExist ( "testmap" ) == 0 )
		{
			MakeDirectory ( "testmap" );
			SetDir ( "testmap" );
		}
	}
	else
		SetDir ( g.mysystem.levelBankTestMap_s.Get() );

	// Delete any EBE files for new levels
	timestampactivity(0,"NEWMAP: mapfile_emptyebesfromtestmapfolder");
	mapfile_emptyebesfromtestmapfolder(false);

	#ifdef VRTECH
	// Delete any CUSTOM files for new levels, otherwise messes up new asset addition work
	timestampactivity(0,"NEWMAP: gridedit_emptyallcustomfiles");
	gridedit_emptyallcustomfiles ( );
	#endif

	#ifdef WICKEDENGINE
	gridedit_emptyallterrainobjfiles();
	#endif

	// restore folder to default 
	SetDir ( pStoreOld.Get() );

	// Empty terraintexture files from testmap folder
	SetDir ( g.mysystem.levelBankTestMap_s.Get() );
	if ( FileExist ( "superpalette.ter" ) == 1 ) DeleteFileA ( "superpalette.ter" );
	if ( FileExist ( "Texture_D.dds" ) == 1 ) DeleteFileA ( "Texture_D.dds" );
	if ( FileExist ( "Texture_D.jpg" ) == 1 ) DeleteFileA ( "Texture_D.jpg" );
	if ( FileExist ( "Texture_N.dds" ) == 1 ) DeleteFileA ( "Texture_N.dds" );
	if ( FileExist ( "Texture_N.jpg" ) == 1 ) DeleteFileA ( "Texture_N.jpg" );
	if ( FileExist ( "globalenvmap.dds" ) == 1 ) DeleteFileA ( "globalenvmap.dds" );
	SetDir ( pStoreOld.Get() );

	// ensures new terrain in new map is loaded into terrain texture panel when shown
	terrain_resetfornewlevel();

	//  Ensure no old OBS file and OBS triggers to generate
	timestampactivity(0,"NEWMAP: invalidate any old OBS");
	darkai_invalidateobstacles ( );

	//  Clear map first
	timestampactivity(0,"NEWMAP: _gridedit_clear_map");
	gridedit_clear_map ( );

	// 121115 - Reset memory tracker
	gridedit_resetmemortracker ( );

	//  Delete all assets of map work
	timestampactivity(0,"NEWMAP: _waypoint_deleteall");
	waypoint_deleteall ( );
	mapfile_newmap ( );
#ifdef WICKEDENGINE
	// Cleanup any visual logic connection objects.
	void deleterelationobjects();
	deleterelationobjects();
#endif

	//  Update remaining map data before editing
	timestampactivity(0,"NEWMAP: _gridedit_updatemapbeforeedit");
	gridedit_updatemapbeforeedit ( );

	//  Some default setup for new scene (load markers)
	timestampactivity(0,"NEWMAP: _editor_filemapdefaultinitfornew");
	editor_filemapdefaultinitfornew ( );

	//  Recreate terrain to remove links to old LOD1 objects
	timestampactivity(0,"NEWMAP: _terrain_createactualterrain");
	terrain_createactualterrain ( );

	//  Randomise/Flatten terrain when NEW level created
	if (  t.inputsys.donewflat == 1 ) 
	{
		timestampactivity(0,"NEWMAP: Save newly flattened terrain");
		terrain_flattenterrain ( );
	}
	else
	{
		timestampactivity(0,"NEWMAP: Save newly randomised terrain");
		terrain_randomiseterrain ( );
	}
	t.tfile_s=g.mysystem.levelBankTestMap_s+"m.dat";
#ifdef WICKEDENGINE
	terrain_save ( t.tfile_s.Get() );
#else
	terrain_save();
#endif

	timestampactivity(0,"NEWMAP: Save terrain data");
	#ifdef VRTECH
	t.tfileveg_s = g.mysystem.levelBankTestMap_s + "vegmask.png";// dds";
	t.tfilewater_s = g.mysystem.levelBankTestMap_s + "watermask.png";// dds";
	#else
	t.tfileveg_s=g.mysystem.levelBankTestMap_s+"vegmask.dds"; //"levelbank\\testmap\\vegmask.dds";
	t.tfilewater_s=g.mysystem.levelBankTestMap_s+"watermask.dds"; //"levelbank\\testmap\\watermask.dds";
	#endif
	t.tgeneratefreshwatermaskflag=1;
	terrain_generatevegandmaskfromterrain ( );
	timestampactivity(0,"NEWMAP: Save terrain mask data");
	#ifdef WICKEDENGINE
	t.tfileveggrass_s=g.mysystem.levelBankTestMap_s+"TTR0XR0\\vegmaskgrass.dat";
	#else
	t.tfileveggrass_s=g.mysystem.levelBankTestMap_s+"vegmaskgrass.dat";
	#endif
	grass_buildblankgrass_fornew ( );

	timestampactivity(0,"NEWMAP: Finish t.terrain generation");
	
	//  Set standard start height for camera
	t.gridzoom_f=3.0 ; t.clipheight_f=655 ; t.updatezoom=1;

	//  Reset cursor
	t. grideditselect = 0 ; editor_refresheditmarkers ( );

	//  Clear status Text (  )
	t.statusbar_s = "" ; gridedit_updatestatusbar ( );

	//  Clear widget status
	t.widget.pickedObject=0 ; widget_updatewidgetobject ( );

	//  Reset UNDO/REDO buffer
	t.entityundo.action=0;
	t.entityundo.entityindex=0;
	t.entityundo.bankindex=0;
	t.entityundo.undoperformed=0;
	t.terrainundo.bufferfilled=0;
	t.terrainundo.mode=0;

	#ifdef WICKEDENGINE
	gridedit_resetcameraanddynamicsky();
	bForceRefreshLightCount = true;
	#endif

	//  Finished new map
	timestampactivity(0,"NEWMAP: Finish creating new map");
}

void gridedit_new_map_quick(void)
{
	#ifdef WICKEDENGINE
	ClearAllGroupLists();
	t.widget.pickedEntityIndex = 0;
	t.gridentity = 0;
	#endif
	// ensure tab mode vars reset (no carry from previous session)
	g.tabmode = 0; //TABTAB mode
	g.tabmodeshowfps = 0; //F11 mode
	g.tabmodehidehuds = 0;
	g.mouseishidden = 0;
	t.terrain.terrainpaintermode = 1;

	//LB: These need to be reset also
	t.gridentityinzoomview = 0;
	t.tforceentityfindfloor = 0;

	//  Start time profiling
	timestampactivity(0, "NEWMAP: Starting new map");

	//  No project - new map
	g.projectfilename_s = "";
	g.projectmodified = 0; t.lastprojectmodified = 0;
	g.projectmodifiedstatic = 0;
	gridedit_updateprojectname();

	// hide EBE if starting new map
	ebe_hide();
	ebe_hardreset();

	// hide terrain texture panel
	terrain_paintselector_hide();

	//  Reset visual settings for new map
	visuals_newlevel();

	// Reset all water settings.
	visuals_water_reset();

	//  Reset visual settings for new map
	t.visuals.refreshshaders = 1;
	
	//  Load map data
	editor_hideall3d();
	t.statusbar_s = t.strarr_s[366]; gridedit_updatestatusbar();

	//  Clear all settings
	timestampactivity(0, "NEWMAP: _gridedit_clear_settings");
	gridedit_clear_settings();

	// Empty EBEs from testmap folder
	cstr pStoreOld = GetDir();
	if (PathExist(g.mysystem.levelBankTestMap_s.Get()) == 0)
	{
		// somehow levelbank\testmap folder gone (can be deleted sometimes)
		SetDir(cstr(g.fpscrootdir_s + "\\Files\\").Get());
		if (PathExist("levelbank") == 0)
		{
			MakeDirectory("levelbank");
			SetDir("levelbank");
		}
		if (PathExist("testmap") == 0)
		{
			MakeDirectory("testmap");
			SetDir("testmap");
		}
	}
	else {
		SetDir(g.mysystem.levelBankTestMap_s.Get());
		//  Empty the lightmap folder
		timestampactivity(0, "NEWMAP: cleantestmapfolder");
		if (FileExist("superpalette.ter") == 1) DeleteFileA("superpalette.ter");
		if (FileExist("Texture_D.dds") == 1) DeleteFileA("Texture_D.dds");
		if (FileExist("Texture_D.jpg") == 1) DeleteFileA("Texture_D.jpg");
		if (FileExist("Texture_N.dds") == 1) DeleteFileA("Texture_N.dds");
		if (FileExist("Texture_N.jpg") == 1) DeleteFileA("Texture_N.jpg");
		if (FileExist("globalenvmap.dds") == 1) DeleteFileA("globalenvmap.dds");
		//  Ensure no old OBS file and OBS triggers to generate
		if (t.tignoreinvalidateobstacles == 0) {
			if (FileExist("map.obs") == 1) DeleteFileA("map.obs");
			t.aisystem.generateobs = 1;
		}

		lm_emptylightmapandttsfilesfolder();

		#ifdef WICKEDENGINE
		void lm_emptylightmapandttsfilesfolder_wicked(void);
		lm_emptylightmapandttsfilesfolder_wicked();
		#endif

		// Delete any EBE files for new levels
		mapfile_emptyebesfromtestmapfolder(false);
		#ifdef VRTECH
		gridedit_emptyallcustomfiles();
		#endif
		#ifdef WICKEDENGINE
		gridedit_emptyallterrainobjfiles();
		#endif
	}

	// restore folder to default 
	SetDir(pStoreOld.Get());

	// ensures new terrain in new map is loaded into terrain texture panel when shown
	terrain_resetfornewlevel();

	//  Clear map first
	t.tlasttentitytoselect = -1;
	g.projectmodified = 0; gridedit_changemodifiedflag();
	g.projectmodifiedstatic = 0;

	#ifdef WICKEDENGINE
	//Stop delete any particle effects.
	gpup_deleteAllEffects();
	#endif

	lighting_free();
	gridedit_deletelevelobjects();

	// 121115 - Reset memory tracker
	gridedit_resetmemortracker();

	//  Delete all assets of map work
	//timestampactivity(0, "NEWMAP: _waypoint_deleteall");
	//waypoint_deleteall();
	mapfile_newmap();

	//  Update remaining map data before editing
	//timestampactivity(0, "NEWMAP: _gridedit_updatemapbeforeedit");
	//gridedit_updatemapbeforeedit();
	if (t.game.gameisexe == 0)
	{
		// for now, it seems the standalone can call this function!!
		editor_clearlibrary();
		g.entidmaster = 0;
		editor_filllibrary();
		editor_leftpanelreset();
		t.gridlayer = 5; t.refreshgrideditcursor = 1;
	}

	//  Recreate terrain to remove links to old LOD1 objects
	timestampactivity(0, "NEWMAP: _terrain_createactualterrain");
	terrain_createactualterrain();

	//  Randomise/Flatten terrain when NEW level created
	if (t.inputsys.donewflat == 1)
	{
		timestampactivity(0, "NEWMAP: Save newly flattened terrain");
		terrain_flattenterrain();
	}
	else
	{
		timestampactivity(0, "NEWMAP: Save newly randomised terrain");
		terrain_randomiseterrain();
	}
	t.tfile_s = g.mysystem.levelBankTestMap_s + "m.dat";
#ifdef WICKEDENGINE
	terrain_save ( t.tfile_s.Get() );
#else
	terrain_save();
#endif
	timestampactivity(0, "NEWMAP: Save terrain data");
	t.tfileveg_s = g.mysystem.levelBankTestMap_s + "vegmask.png";// dds";
	t.tfilewater_s = g.mysystem.levelBankTestMap_s + "watermask.png";// dds";
	t.tgeneratefreshwatermaskflag = 1;
	terrain_generatevegandmaskfromterrain();
	#ifdef WICKEDENGINE
	t.tfileveggrass_s = g.mysystem.levelBankTestMap_s + "TTR0XR0\\vegmaskgrass.dat";
	#else
	t.tfileveggrass_s = g.mysystem.levelBankTestMap_s + "vegmaskgrass.dat";
	#endif
	grass_buildblankgrass_fornew(); //Delay this ?

	//  Set standard start height for camera
	t.gridzoom_f = 3.0; t.clipheight_f = 655; t.updatezoom = 1;

	//  Reset cursor
	t.grideditselect = 0; editor_refresheditmarkers();

	//  Clear status Text (  )
	t.statusbar_s = ""; gridedit_updatestatusbar();

	//  Clear widget status
	t.widget.pickedObject = 0; widget_updatewidgetobject();

	//  Reset UNDO/REDO buffer
	t.entityundo.action = 0;
	t.entityundo.entityindex = 0;
	t.entityundo.bankindex = 0;
	t.entityundo.undoperformed = 0;
	t.terrainundo.bufferfilled = 0;
	t.terrainundo.mode = 0;

	#ifdef WICKEDENGINE
	gridedit_resetcameraanddynamicsky();
	bForceRefreshLightCount = true;
	#endif

	//  Finished new map
	timestampactivity(0, "NEWMAP: Finish creating new map");
}

void gridedit_updatestatusbar ( void )
{
	//  020315 - 012 - display in the status bar if multiplayer lobbies are currently available
	mp_checkIfLobbiesAvailable ( );
	if (  t.statusbar_s+t.steamStatusBar_s != t.laststatusbar_s.Get() ) 
	{
		t.strwork = ""; t.strwork = t.strwork + t.statusbar_s + t.steamStatusBar_s;
		#ifdef FPSEXCHANGE
		OpenFileMap (  1,"FPSEXCHANGE" );
		SetFileMapString (  1, 4000, t.strwork.Get() );
		SetEventAndWait (  1 );
		#endif
		t.laststatusbar_s=t.statusbar_s+t.steamStatusBar_s;
	}
}

void gridedit_load_map ( void )
{
#ifdef WICKEDENGINE
	ClearAllGroupLists();
	t.widget.pickedEntityIndex = 0;
	t.gridentity = 0;
	//Stop delete any particle effects.
	gpup_deleteAllEffects();

#endif
	//  Load map data
	editor_hideall3d ( );

	//LB: These need to be reset (probably can put these in a common 'new something' area
	t.gridentityinzoomview = 0;
	t.tforceentityfindfloor = 0;

	// hide terrain texture panel
	terrain_paintselector_hide(); Sync();

	//  Use large prompt
	t.statusbar_s=t.strarr_s[367]; 
	popup_text(t.statusbar_s.Get());

	//  Reset visual settings for new map
	if (  t.skipfpmloading == 0 ) 
	{
		// 131115 - prevent visual settings for game get wiped out if restart session
		// where project loaded from levelbank\testlevel and visuals already filled
		visuals_newlevel ( );
	}

	//  Force the zoom to be updated to prevent black screen bug, due to old camera range
	t.updatezoom=1;

	//  Load FPM project into testmap files area
	t.tloadsuccessfully=1;
	if (  t.skipfpmloading == 1 ) 
	{
		//  replace NEW with RELOAD
		#ifdef FPSEXCHANGE
		OpenFileMap (  1,"FPSEXCHANGE" );
		SetFileMapDWORD (  1, 408, 0 );
		SetEventAndWait (  1 );
		#endif
	}
	else
	{
		//  this setstloadsuccessfully to zero if failed to load FPM (corrupt zipfile)
		mapfile_loadproject_fpm ( );
	}

	//  Loaded successfully
	if ( t.tloadsuccessfully == 1 ) 
	{
		//  Clear map first
		gridedit_clear_map ( );

		// 121115 - Reset memory tracker
		gridedit_resetmemortracker ( );

		//  Determine if FPM is accompanied by .REPLACE file
		t.treplacefilename_s = "" ; t.treplacefilename_s = t.treplacefilename_s + Left(g.projectfilename_s.Get(),Len(g.projectfilename_s.Get())-4)+".replace";
		if (  FileExist(t.treplacefilename_s.Get()) == 1 ) 
		{
			t.editor.replacefilepresent_s=t.treplacefilename_s;
		}
		else
		{
			t.editor.replacefilepresent_s="";
		}

		//  Load entity bank and elements
		popup_text_change(t.strarr_s[611].Get());
		entity_loadbank ( );
		timestampactivity(0, "s:entity_loadelementsdata()");
		entity_loadelementsdata ( );
		timestampactivity(0, "e:entity_loadelementsdata()");
		t.editor.replacefilepresent_s="";

		//  Load waypoints
		popup_text_change(t.strarr_s[612].Get());
		waypoint_loaddata ( );
		waypoint_recreateobjs ( );

		//  Load data
		popup_text_change(t.strarr_s[613].Get());
		mapfile_loadmap ( );

		//  Load player settings
		timestampactivity(0,"Load player config");
		mapfile_loadplayerconfig ( );

		//  Load terrain
		popup_text_change(t.strarr_s[610].Get());
		timestampactivity(0, "Create Terrain");
		terrain_createactualterrain ( );
		terrain_loaddata ( );

		//  Update remaining map data before editing
		timestampactivity(0, "Reset Editor.");
		gridedit_updatemapbeforeedit ( );

		//  Load editor configuration
		int iOldGE = t.grideditselect;
		editor_loadcfg ( true );

		#ifdef WICKEDENGINE
		extern bool g_bNeedToConvertClassicPositionsToMAX;
		if (g_bNeedToConvertClassicPositionsToMAX == true)
		{
			// new terrain system is located at 0,0,0 (not 25600x600x25600), so shift to new location
			GGVECTOR3 vToMAXShift = GGVECTOR3(25600, 600, 25600);
			if (g.entityelementlist > 0)
			{
				// shift all entity elements to new positions
				for (int e = 1; e <= g.entityelementlist; e++)
				{
					t.entityelement[e].x -= vToMAXShift.x;
					t.entityelement[e].y -= vToMAXShift.y;
					t.entityelement[e].z -= vToMAXShift.z;
				}
			}

			// LB: also shift camera position to match (if seemingly the old coordinate system) [need a better way to detect 'classic' levels and 'old MAX' levels!!
			if (fabs(t.cx_f-25600)<1000.0f && fabs(t.cy_f - 25600) < 1000.0f)
			{
				t.cx_f -= vToMAXShift.x;
				t.cy_f -= vToMAXShift.z;
			}
		}
		#endif

		//In wicked keep current window open, terrain , entity...
		#ifdef WICKEDENGINE
		t.grideditselect = iOldGE;
		#endif
		//  Load segments/prefab/entities into window
		#ifdef FPSEXCHANGE
		OpenFileMap (  1,"FPSEXCHANGE" );
		#endif
		editor_filllibrary ( );

		//  Add Latest project To Recent List
		gridedit_updateprojectname ( );
	}
	else
	{
		//  FPM could not be extracted (likely a corrupt zipfile)
		if (  t.tloadsuccessfully == 0 ) 
		{
			t.strwork = ""; t.strwork = t.strwork + t.strarr_s[614]+" : "+Right(g.projectfilename_s.Get(),Len(g.projectfilename_s.Get())-Len(g.fpscrootdir_s.Get()));
			popup_text_change( t.strwork.Get() );
		}
		if (  t.tloadsuccessfully == 2 ) 
		{
			popup_text_change("The FPM was not created with Game Guru");
		}
		SleepNow (  2000 );

		//  Create blank in this case
		t.inputsys.donewflat=1;
		gridedit_new_map ( );
	}

	//  Popup warning if load found some missing files
	if ( g.timestampactivityflagged == 1 ) 
	{
		//  message prompt
		t.statusbar_s=t.strarr_s[368];
		popup_text_change(t.statusbar_s.Get()) ; SleepNow (  2000 );
		g.timestampactivityflagged=0;

		//  copy time stamp log to map bank log
		if (  ArrayCount(t.missingmedia_s) >= 0 ) 
		{
			t.tmblogfile_s = "" ; t.tmblogfile_s=t.tmblogfile_s + Left(g.projectfilename_s.Get(),Len(g.projectfilename_s.Get())-4)+".log";
			if (  FileExist(t.tmblogfile_s.Get()) == 1  )  DeleteAFile (  t.tmblogfile_s.Get() );
			if (  Len(t.tmblogfile_s.Get())>4 ) 
			{
				t.missingmedia_s[0]="MISSING MEDIA:";
				for ( t.m = 1 ; t.m <= ArrayCount(t.missingmedia_s); t.m++ )
				{
					if (  Len(t.missingmedia_s[t.m].Get())>2 ) 
					{
						t.missingmedia_s[t.m]=t.missingmedia_s[t.m]+"=replace"+t.missingmedia_s[t.m];
					}
				}
				SaveArray (  t.tmblogfile_s.Get() ,t.missingmedia_s );
			}
		}
	}
	else
	{
		// if no missing media, is parental control system removing some?
		if ( g_bBlackListRemovedSomeEntities == true ) 
		{
			t.statusbar_s = "Parental Control system has removed some content from this level";
			popup_text_change(t.statusbar_s.Get()) ; SleepNow ( 3000 );
		}
	}

	// free usages
	if (  ArrayCount(t.missingmedia_s) >= 0 ) 
	{
		UnDim (  t.missingmedia_s );
	}
	g.missingmediacounter=0;

	//  Clear status Text (  )
	t.statusbar_s="" ; popup_text_close();

	//  Quick update of cursor
	t.lastgrideditselect=-1 ; editor_refresheditmarkers ( );

	//  Recreate all entities in level

	//DumpImageList(); // PE: DEBUG - Dump image usage after loading master objects.
	//DEBUG - United Tribes of Gahkistahn.fpm: 7.6 gb wicked engine textures , 400mb legacy images.

	char debug[MAX_PATH];
	sprintf(debug, "Setup objects: %ld", g.entityelementlist);
	timestampactivity(0, debug);
	#ifdef WICKEDENGINE
	extern bool bNoHierarchySorting;
	bNoHierarchySorting = true;
	extern int iInstancedTotal;
	iInstancedTotal = 0;
	#endif
	for ( t.e = 1 ; t.e <=  g.entityelementlist; t.e++ )
	{
		//PE: DEBUG - Crash here at 654 level have (1200+) : United Tribes of Gahkistahn.fpm
		//if (t.e == 600)
		//{
		//	DumpImageList(); // PE: Dump image usage.
		//}
		//int entid = t.entityelement[t.e].bankindex;
		//if (entid > 0 && entid < t.entityprofileheader.size())
		//{
		//	char debug[MAX_PATH];
		//	sprintf(debug, "Adding %d: %s", t.e, t.entityprofileheader[entid].desc_s.Get());
		//	timestampactivity(0, debug);
		//}

		t.tupdatee=t.e ; gridedit_updateentityobj ( );
	}
	timestampactivity(0, "End Setup objects:");
	
	#ifdef WICKEDENGINE
	sprintf(debug, "Instanced objects: %ld", iInstancedTotal);
	timestampactivity(0, debug);
	bNoHierarchySorting = false;
	#endif
	lighting_refresh ( );

	//  Ensure newly updated entity does not trigger a terrain update!
	t.terrain.terrainpainteroneshot=0;

	//  Ensure visual indices for sky, terrain and veg up to date (for when we use test game)
	visuals_updateskyterrainvegindex ( );

	//  Refresh any 'shaders' that associat with new entities loaded in
	visuals_justshaderupdate ( );

	//  Generate heightmap texture for cheap shadows (if required)
	//t.terrain.terraintriggercheapshadowrefresh=2;

	//  Ensure editor zoom refreshes
	t.updatezoom=1;

	// 161115 - in any event, ensure we generate super texture for 'distant' terrain texture 
	t.visuals.refreshterrainsupertexture = 2;

	#ifdef WICKEDENGINE
	//PE: Restore locked state. from locked.cfg
	for (int i = 0; i < vEntityLockedList.size(); i++)
	{
		int e = vEntityLockedList[i].e;
		if(e < t.entityelement.size())
			t.entityelement[e].editorlock = 1;
	}
	bForceRefreshLightCount = true;
	#endif
}

void gridedit_changemodifiedflag ( void )
{
	// project flag changed, update window Text (  )
	if ( t.game.gameisexe == 0 ) 
	{
		if ( t.lastprojectmodified != g.projectmodified ) 
		{
			t.lastprojectmodified=g.projectmodified;
			gridedit_updateprojectname ( );
		}
		if ( g.projectmodified == 1 && g.projectmodifiedstatic == 1 ) 
		{
			// trigger actions if any modification made
			darkai_invalidateobstacles ( );
			g.projectmodifiedstatic = 0;
		}
	}
}

void gridedit_updateprojectname ( void )
{
	#ifdef FPSEXCHANGE
	OpenFileMap (  1,"FPSEXCHANGE" );
	#endif

	//  add to project title
	if ( strcmp ( Lower(Left(g.projectfilename_s.Get(),Len(g.rootdir_s.Get()))) , Lower(g.rootdir_s.Get()) ) == 0 ) 
	{
		t.tprojname_s=Right(g.projectfilename_s.Get(),Len(g.projectfilename_s.Get())-Len(g.rootdir_s.Get()));
	}
	else
	{
		t.tprojname_s=g.projectfilename_s;
	}
	if (  g.projectmodified != 0  )  t.tprojname_s = t.tprojname_s+"*";

	// 011215 - Add which mode you are in
	int iEditingMode = 0;
	if ( t.grideditselect==0 ) iEditingMode = 1; // terrain
	if ( t.grideditselect==5 && t.gridentitymarkersmodeonly==0 ) iEditingMode = 2; // entity
	if ( t.grideditselect==5 && t.gridentitymarkersmodeonly==1 ) iEditingMode = 3; // markers
	if ( t.grideditselect==6 ) iEditingMode = 4; // waypoints
	switch ( iEditingMode )
	{
		case 1 : t.tprojname_s = t.tprojname_s + cstr("] - [Terrain Editing Mode"); break;
		case 2 : t.tprojname_s = t.tprojname_s + cstr("] - [Entity Editing Mode"); break;
		case 3 : t.tprojname_s = t.tprojname_s + cstr("] - [Marker Only Editing Mode"); break;
		case 4 : t.tprojname_s = t.tprojname_s + cstr("] - [Waypoint Editing Mode"); break;
	}

	// send window title text to IDE
	#ifdef FPSEXCHANGE
	OpenFileMap(1, "FPSEXCHANGE");
	SetFileMapString (  1, 1000, t.tprojname_s.Get() );
	SetFileMapDWORD (  1, 416, 1 );
	SetEventAndWait (  1 );
	while (  GetFileMapDWORD(1, 416) == 1 ) 
	{
		SetEventAndWait (  1 );
	}
	//  add to recent files list
	if (  g.projectfilename_s != "" ) 
	{
		// 091215 - if folder exists
		if ( PathExist(g.projectfilename_s.Get()) == 1 )
		{
			SetFileMapString(1, 1000, g.projectfilename_s.Get());
			SetFileMapDWORD(1, 438, 1);
			SetEventAndWait(1);
			while (GetFileMapDWORD(1, 438) == 1)
			{
				SetEventAndWait(1);
			}
		}
	}
	#endif
}

void gridedit_import_ask ( void )
{
	#ifdef FPSEXCHANGE
	OpenFileMap (  1, "FPSEXCHANGE" );
	SetEventAndWait (  1 );
	do
	{
		t.inputsys.kscancode=GetFileMapDWORD( 1, 100 );

		//PE: Virtual keys should not be included , as if you press a cancel (in IDE) afer that import , import will not open.
	} while ( (  t.inputsys.kscancode > 3 ) );

	// if not already loaded
	if (  t.importer.loaded == 0 ) 
	{
		OpenFileMap (  1,"FPSEXCHANGE" );
		if ( strlen ( t.timporterpath_s.Get() ) == 0 )
		{
			t.strwork = ""; t.strwork = t.strwork + g.rootdir_s+"entitybank\\";
		}
		else
		{
			t.strwork = t.timporterpath_s + "\\";
		}
		SetFileMapString (  1, 1000, t.strwork.Get() );
		t.tdone = 0;
		while (  t.tdone  !=  2 ) 
		{
			if (  t.tdone  ==  0 ) 
			{
				SetFileMapString ( 1 , 1256 , "Choose an X or FBX file for a new object or an .fpe file for existing (*.*)" );
				SetFileMapString (  1, 1512, "Import New Entity" );
			}
			else
			{
				SetFileMapString (  1, 1256, "Please try again ) You must choose either an X or FBX file or an .fpe file! (*.*)" );
				SetFileMapString (  1, 1512, "Invalid File, Please t.try again" );
			}
			SetFileMapDWORD (  1, 424, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD(1, 424) == 1 ) 
			{
				SetEventAndWait (  1 );
			}
			t.returnstring_s=GetFileMapString(1, 1000);
			t.tdone = 1;
			if (	strcmp ( Lower(Right(t.returnstring_s.Get(),2)) , ".x" ) == 0 
			||		strcmp ( Lower(Right(t.returnstring_s.Get(),4)) ,".fbx" ) == 0 
			||		strcmp ( Lower(Right(t.returnstring_s.Get(),4)) , ".dbo" ) == 0 
			||		strcmp ( Lower(Right(t.returnstring_s.Get(),4)) , ".fpe" ) == 0 
			||		t.returnstring_s  ==  ""  )  
			{
				t.tdone  =  2;
			}
		}

		// refresh 3d view so dialog Box (  (  not left black Box ) )
		for ( t.tsync = 1 ; t.tsync <=  5 ; t.tsync++ ) { Sync ( ); SleepNow ( 10 );  }

		// if successfully selected a good file extension
		if (  t.returnstring_s != "" ) 
		{
			// load the model
			t.timporterfile_s = t.returnstring_s;
			importer_loadmodel ( );

			// and remember folder we arrived at, so can restore next time we use importer
			LPSTR pReturnedFile = t.timporterfile_s.Get();
			for ( int n = strlen(pReturnedFile); n>0; n-- )
			{
				if ( pReturnedFile[n] == '\\' || pReturnedFile[n] == '/' )
				{
					t.timporterpath_s = t.timporterfile_s;
					LPSTR pImporterPath = t.timporterpath_s.Get();
					pImporterPath[n] = 0;
					break;
				}
			}
		}
	}
	#endif
}

void gridedit_intercept_savefirst ( void )
{
	t.editorcanceltask=0;
	if (  g.projectmodified == 1 ) 
	{
		#ifdef FPSEXCHANGE
		OpenFileMap (  1,"FPSEXCHANGE" );
		SetFileMapString (  1, 1000, t.strarr_s[369].Get() );
		SetFileMapString (  1, 1256, t.strarr_s[370].Get() );
		SetFileMapDWORD (  1, 900, 2 );
		SetEventAndWait (  1 );
		while (  GetFileMapDWORD(1, 900) != 0 ) 
		{
			SetEventAndWait (  1 );
		}
		t.tokay=GetFileMapDWORD(1, 904);
		#endif

		//  refresh 3d view so dialog Box (  (  not left black Box ) )
		for ( t.tsync = 1 ; t.tsync <= 5 ; t.tsync++ ) {  Sync (   ); SleepNow (  10  ); }

		if (  t.tokay == 1 ) 
		{
			//  yes save first
			gridedit_save_map_ask ( );
			g.projectmodified=0  ; gridedit_changemodifiedflag ( );
			g.projectmodifiedstatic = 0;
		}
		if (  t.tokay == 2 ) 
		{
			//  task cancelled
			t.editorcanceltask=1;
		}
	}
}

void gridedit_intercept_savefirst_noreload ( void )
{
	g.savenoreloadflag = 1;
	gridedit_intercept_savefirst();
	g.savenoreloadflag = 0;
}

void gridedit_open_map_ask ( void )
{
	//  SAVE CURRENT (IF ANY)
	t.editorcanceltask=0;
	if (  g.projectmodified == 1 ) 
	{
		//  If project modified, ask if want to save first
		gridedit_intercept_savefirst ( );
	}
	if (  t.editorcanceltask == 0 ) 
	{
		//  OPEN FPM
		#ifdef FPSEXCHANGE
		OpenFileMap (  1,"FPSEXCHANGE" );
		t.strwork = g.mysystem.mapbankAbs_s;		
		SetFileMapString (  1, 1000, t.strwork.Get() );
		SetFileMapString (  1, 1256, t.strarr_s[371].Get() );
		SetFileMapString (  1, 1512, t.strarr_s[372].Get() );
		SetFileMapDWORD (  1, 424, 1 );
		SetEventAndWait (  1 );
		while (  GetFileMapDWORD(1, 424) == 1 ) 
		{
			SetEventAndWait (  1 );
		}
		t.returnstring_s=GetFileMapString(1, 1000);
		#endif

		//  refresh 3d view so dialog Box (  (  not left black Box ) )
		for ( t.tsync = 1 ; t.tsync <=  5 ; t.tsync++ ) { Sync ( ); SleepNow ( 10 ); }

		if (  t.returnstring_s != "" ) 
		{
			if (  cstr(Lower(Right(t.returnstring_s.Get(),4))) == ".fpm" ) 
			{
				g.projectfilename_s=t.returnstring_s;
				gridedit_load_map ( );
			}
		}
	}
}

void gridedit_new_map_ask ( void )
{
	//  SAVE CURRENT (IF ANY)
	t.editorcanceltask=0;
	if (  g.projectmodified == 1 ) 
	{
		//  If project modified, ask if want to save first
		gridedit_intercept_savefirst ( );
	}

	#ifdef VRTECH
	//  refresh 3d view so dialog Box-  not left black Box
	//if ( gbWelcomeSystemActive == false )
	//{
	//	for ( t.tsync = 1 ; t.tsync <=  5 ; t.tsync++ ) { Sync ( ); SleepNow ( 10 ); }
	//}
	#else
	//  refresh 3d view so dialog Box-  not left black Box
	if ( gbWelcomeSystemActive == false )
	{
		for ( t.tsync = 1 ; t.tsync <=  5 ; t.tsync++ ) { Sync ( ); SleepNow ( 10 ); }
	}
	#endif

	if (  t.editorcanceltask == 0 ) 
	{
		//  NEW MAP
		gridedit_new_map ( );
	}
}

void gridedit_save_map_ask ( void )
{
	#ifdef WICKEDENGINE
	#ifdef ENABLEAUTOLEVELSAVE
	if (!pref.iDisableLevelAutoSave && g.projectfilename_s != "")
	{
		//Auto save.
		gridedit_save_map();
		g.projectmodified = 0; gridedit_changemodifiedflag();
		g.projectmodifiedstatic = 0;
		return;
	}
	#endif
	#endif

	if (  g.projectfilename_s == "" ) 
	{
		gridedit_saveas_map ( );
	}
	else
	{
		gridedit_save_map ( );
	}
return;

}

void gridedit_saveas_map ( void )
{
	//  SAVE AS DIALOG
	#ifdef FPSEXCHANGE
	OpenFileMap (  1,"FPSEXCHANGE" );
	t.strwork = g.mysystem.mapbankAbs_s;
	SetFileMapString (  1, 1000, t.strwork.Get() );
	SetFileMapString (  1, 1256, t.strarr_s[373].Get() );
	SetFileMapString (  1, 1512, t.strarr_s[374].Get() );
	SetFileMapDWORD (  1, 428, 1 );
	SetEventAndWait (  1 );
	while (  GetFileMapDWORD(1, 428) == 1 ) 
	{
		SetEventAndWait (  1 );
	}
	t.returnstring_s=GetFileMapString(1, 1000);
	#endif

	//  refresh 3d view so dialog Box (  (  not left black Box ) )
	for ( t.tsync = 1 ; t.tsync <=  5 ; t.tsync++ ) { Sync ( ); SleepNow ( 10 ); }

	if (  t.returnstring_s != "" ) 
	{
		if (  cstr(Lower(Right(t.returnstring_s.Get(),4))) != ".fpm"  )  t.returnstring_s = t.returnstring_s+".fpm";
		g.projectfilename_s=t.returnstring_s;
		gridedit_save_map ( );
	}
}

void gridedit_addentitytomap(void)
{
	// mark as static if it was
	if (t.gridentitystaticmode == 1) g.projectmodifiedstatic = 1;
	entity_addentitytomap();
	#ifdef WICKEDENGINE

	//PE: we loose status somewhere, so force it off after adding a entity to map.
	extern bool bCubesVisible;
	if (bCubesVisible == false) bCubesVisible = true; //Force.

	if (g_UndoSysObjectRememberBeforeMove == true)
	{
		// this happens when object deleted from level (addtocursor) but it could be a move event
		// if the object has not moved/rotated/scaled, we can skip adding a move event
		if (g_UndoSysObjectRememberBeforeMovePX == t.entityelement[t.e].x
			&&  g_UndoSysObjectRememberBeforeMovePY == t.entityelement[t.e].y
			&&  g_UndoSysObjectRememberBeforeMovePZ == t.entityelement[t.e].z
			&&  g_UndoSysObjectRememberBeforeMoveRX == t.entityelement[t.e].rx
			&&  g_UndoSysObjectRememberBeforeMoveRY == t.entityelement[t.e].ry
			&&  g_UndoSysObjectRememberBeforeMoveRZ == t.entityelement[t.e].rz
			&&  g_UndoSysObjectRememberBeforeMoveQuatMode == t.entityelement[t.e].quatmode
			&&  g_UndoSysObjectRememberBeforeMoveQuatX == t.entityelement[t.e].quatx
			&&  g_UndoSysObjectRememberBeforeMoveQuatY == t.entityelement[t.e].quaty
			&&  g_UndoSysObjectRememberBeforeMoveQuatZ == t.entityelement[t.e].quatz
			&&  g_UndoSysObjectRememberBeforeMoveQuatW == t.entityelement[t.e].quatw
			&&  g_UndoSysObjectRememberBeforeMoveSX == t.entityelement[t.e].scalex
			&&  g_UndoSysObjectRememberBeforeMoveSY == t.entityelement[t.e].scaley
			&&  g_UndoSysObjectRememberBeforeMoveSZ == t.entityelement[t.e].scalez )
		{
			// object has not moved, rotated or scaled
		}
		else
		{
			// object has moved, create a move event
			if (g.entityrubberbandlist.size() == 0)
			{
				// but only if single object move, as rubberband has its own multi object move events created when move a rubberband group
				undosys_object_changeposrotscl (g_UndoSysObjectRememberBeforeMoveE,
					g_UndoSysObjectRememberBeforeMovePX,
					g_UndoSysObjectRememberBeforeMovePY,
					g_UndoSysObjectRememberBeforeMovePZ,
					g_UndoSysObjectRememberBeforeMoveRX,
					g_UndoSysObjectRememberBeforeMoveRY,
					g_UndoSysObjectRememberBeforeMoveRZ,
					g_UndoSysObjectRememberBeforeMoveQuatMode,
					g_UndoSysObjectRememberBeforeMoveQuatX,
					g_UndoSysObjectRememberBeforeMoveQuatY,
					g_UndoSysObjectRememberBeforeMoveQuatX,
					g_UndoSysObjectRememberBeforeMoveQuatW,
					g_UndoSysObjectRememberBeforeMoveSX,
					g_UndoSysObjectRememberBeforeMoveSY,
					g_UndoSysObjectRememberBeforeMoveSZ);
			}
		}

		// and return undo sys to normal after this special case
		g_UndoSysObjectRememberBeforeMove = false;
	}
	else
	{
		// regular object addition
		entity_createundoaction(eUndoSys_Object_Add, t.e);
	}
	#else
	entity_recordbuffer_add();
	#endif

	// if entity is a light, has a probe
	#ifdef WICKEDENGINE
	int entid = t.entityelement[t.e].bankindex;
	if (entid > 0)
	{
		if (t.entityprofile[entid].ismarker == 2)
		{
			float fLightProbeScale = t.entityelement[t.e].eleprof.light.fLightHasProbe;
			if ( fLightProbeScale > 0 )
				entity_placeprobe(t.entityelement[t.e].obj, fLightProbeScale);
			else
				entity_deleteprobe(t.entityelement[t.e].obj);
		}
	}
	// clear any gridentity light if gridentity no longer used
	if (t.gridentitywickedlightindex > 0)
	{
		WickedCall_DeleteLight(t.gridentitywickedlightindex);
		t.gridentitywickedlightindex = 0;
	}
	#endif
}

void gridedit_deleteentityfrommap ( void )
{
	// can intercept delete if char+start marker
	t.tstoretentitytoselect=t.tentitytoselect;
	if (  t.playercontrol.thirdperson.enabled == 1 ) 
	{
		if (  t.gridentity == 0 || (t.gridentity>0 && t.entityprofile[t.gridentity].ismarker != 1) ) 
		{
			t.tstmrke=t.playercontrol.thirdperson.startmarkere;
			if (  t.tentitytoselect == t.tstmrke ) 
			{
				//  first delete char on start marker, and restore marker
				t.tentitytoselect=t.playercontrol.thirdperson.charactere;
				t.tstmrkobj=t.entityelement[t.tstmrke].obj;
				if (  t.tstmrkobj>0 ) 
				{
					if (  ObjectExist(t.tstmrkobj) == 1 ) 
					{
						DisableObjectZDepth (  t.tstmrkobj );
						DisableObjectZWrite (  t.tstmrkobj );
						DisableObjectZRead (  t.tstmrkobj );
					}
				}
				//  and reset third person settings
				t.playercontrol.thirdperson.enabled=0;
				t.playercontrol.thirdperson.charactere=0;
				t.playercontrol.thirdperson.startmarkere=0;
			}
		}
	}

	// if entity is a light, remove its probe
	#ifdef WICKEDENGINE
	int entid = t.entityelement[t.tentitytoselect].bankindex;
	if (entid > 0)
	{
		if (t.entityprofile[entid].ismarker == 2)
		{
			entity_deleteprobe(t.entityelement[t.tentitytoselect].obj);
		}
	}

	//If particle delete the effect.
	if (g_UndoSysObjectIsBeingMoved != true)
	{
		if (entid > 0 && t.entityprofile[entid].ismarker == 10)
		{
			int iParticleEmitter = t.entityelement[t.tentitytoselect].eleprof.newparticle.emitterid;
			if (iParticleEmitter != -1)
			{
				gpup_deleteEffect(iParticleEmitter);
				t.entityelement[t.tentitytoselect].eleprof.newparticle.emitterid = -1;
			}
		}
	}
	#endif

	// mark as static if it was
	if ( t.entityelement[t.tentitytoselect].staticflag == 1 ) g.projectmodifiedstatic = 1;
	#ifdef WICKEDENGINE
	int te = t.tentitytoselect;
	if (g_UndoSysObjectIsBeingMoved == true)
	{
		// its move - so we store the change posrotscl event so we know where the entity came from
		//g_UndoSysObjectIsBeingMoved = false; //PE: Reuse for entity_deleteentityfrommap
		g_UndoSysObjectRememberBeforeMove = true;
		g_UndoSysObjectRememberBeforeMoveE = te;
		g_UndoSysObjectRememberBeforeMovePX = t.entityelement[te].x;
		g_UndoSysObjectRememberBeforeMovePY = t.entityelement[te].y;
		g_UndoSysObjectRememberBeforeMovePZ = t.entityelement[te].z;
		g_UndoSysObjectRememberBeforeMoveRX = t.entityelement[te].rx;
		g_UndoSysObjectRememberBeforeMoveRY = t.entityelement[te].ry;
		g_UndoSysObjectRememberBeforeMoveRZ = t.entityelement[te].rz;
		g_UndoSysObjectRememberBeforeMoveQuatMode = t.entityelement[te].quatmode;
		g_UndoSysObjectRememberBeforeMoveQuatX = t.entityelement[te].quatx;
		g_UndoSysObjectRememberBeforeMoveQuatY = t.entityelement[te].quaty;
		g_UndoSysObjectRememberBeforeMoveQuatZ = t.entityelement[te].quatz;
		g_UndoSysObjectRememberBeforeMoveQuatW = t.entityelement[te].quatw;
		g_UndoSysObjectRememberBeforeMoveSX = t.entityelement[te].scalex;
		g_UndoSysObjectRememberBeforeMoveSY = t.entityelement[te].scaley;
		g_UndoSysObjectRememberBeforeMoveSZ = t.entityelement[te].scalez;
	}
	else
	{
		if (t.entityelement[te].eleprof.trigger.waypointzoneindex > 0)
		{
			// if its a zone, create multiple events - one for middle object and one for the waypoint zone data so it can be restored later.
			undosys_multiplevents_start();
			entity_createundoaction(eUndoSys_Object_Delete, te);
			entity_createundoaction(eUndoSys_Object_DeleteWaypoint, te);
			undosys_multiplevents_finish();
		}
		else
		{
			entity_createundoaction(eUndoSys_Object_Delete, te);
		}
			
		
	}
	#else
	entity_recordbuffer_delete ( );
	#endif
	entity_deleteentityfrommap ( );

	//  restore tentitytoselect in case switched it
	t.tentitytoselect=t.tstoretentitytoselect;
}

void gridedit_deleteentityrubberbandfrommap ( void )
{
	#ifdef WICKEDENGINE
	undosys_multiplevents_start();
	#else
	g.entityrubberbandlistundo.clear();
	#endif

	// will delete all entities in rubber band list, and preserve them into undo buffer
	for ( int i = 0; i < (int)g.entityrubberbandlist.size(); i++ )
	{
		t.tentitytoselect = g.entityrubberbandlist[i].e;
		if ( t.tentitytoselect > 0 && t.entityelement[t.tentitytoselect].editorlock == 0)
		{
			#ifdef WICKEDENGINE
			DeleteEntityFromLists(t.tentitytoselect);
			#endif

			if ( t.entityelement[t.tentitytoselect].staticflag == 1 ) g.projectmodifiedstatic = 1;
			gridedit_deleteentityfrommap ( );
			g.entityrubberbandlistundo.push_back ( t.entityundo );
		}
	}
	#ifdef WICKEDENGINE
	undosys_multiplevents_finish();
	#else
	// special code to point this undo event to the rubberbandlist undo buffer
	if ( g.entityrubberbandlistundo.size() > 0 )
	{
		t.entityundo.entityindex = -123;
		t.entityundo.bankindex = -123;
	}
	#endif
}

void gridedit_moveentityrubberband ( void )
{
	// will move all entities in rubber band list, and preserve them into undo buffer
	#ifdef WICKEDENGINE
	undosys_multiplevents_start();
	#else
	g.entityrubberbandlistundo.clear();
	#endif
	for ( int i = 0; i < (int)g.entityrubberbandlist.size(); i++ )
	{
		#ifdef WICKEDENGINE
		int te = g.entityrubberbandlist[i].e;
		undosys_object_changeposrotscl (te, g.entityrubberbandlist[i].px,
			g.entityrubberbandlist[i].py,
			g.entityrubberbandlist[i].pz,
			g.entityrubberbandlist[i].rx,
			g.entityrubberbandlist[i].ry,
			g.entityrubberbandlist[i].rz,
			g.entityrubberbandlist[i].quatmode,
			g.entityrubberbandlist[i].quatx,
			g.entityrubberbandlist[i].quaty,
			g.entityrubberbandlist[i].quatz,
			g.entityrubberbandlist[i].quatw,
			g.entityrubberbandlist[i].scalex,
			g.entityrubberbandlist[i].scaley,
			g.entityrubberbandlist[i].scalez);
		#else
		t.tentitytoselect = g.entityrubberbandlist[i].e;
		entity_recordbuffer_move ( );
		g.entityrubberbandlistundo.push_back ( t.entityundo );
		#endif
	}
	#ifdef WICKEDENGINE
	undosys_multiplevents_finish();

	// also, update rubberband to new entity states, so can move multiple times and undo them
	for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
	{
		int te = g.entityrubberbandlist[i].e;
		g.entityrubberbandlist[i].px = t.entityelement[te].x;
		g.entityrubberbandlist[i].py = t.entityelement[te].y;
		g.entityrubberbandlist[i].pz = t.entityelement[te].z;
		g.entityrubberbandlist[i].rx = t.entityelement[te].rx;
		g.entityrubberbandlist[i].ry = t.entityelement[te].ry;
		g.entityrubberbandlist[i].rz = t.entityelement[te].rz;
		g.entityrubberbandlist[i].quatmode = t.entityelement[te].quatmode;
		g.entityrubberbandlist[i].quatx = t.entityelement[te].quatx;
		g.entityrubberbandlist[i].quaty = t.entityelement[te].quaty;
		g.entityrubberbandlist[i].quatz = t.entityelement[te].quatz;
		g.entityrubberbandlist[i].quatw = t.entityelement[te].quatw;
		g.entityrubberbandlist[i].scalex = t.entityelement[te].scalex;
		g.entityrubberbandlist[i].scaley = t.entityelement[te].scaley;
		g.entityrubberbandlist[i].scalez = t.entityelement[te].scalez;
	}
	#else
	// special code to point this undo event to the rubberbandlist undo buffer
	if ( g.entityrubberbandlistundo.size() > 0 )
	{
		t.entityundo.entityindex = -123;
		t.entityundo.bankindex = -123;
	}
	#endif
}

void gridedit_updateentityobj ( void )
{
	//  moved to m-entity
	entity_updateentityobj ( );
}

void gridedit_recreateentitycursor ( void )
{
	int ele_id = 0;
	//  Entity floating selection
	if ( t.gridentityobj>0 ) 
	{
		//  character creator remove glued objects
		if (  t.toldCursorEntidForCharacterCreator > 0 ) 
		{
			if (  t.entityprofile[t.toldCursorEntidForCharacterCreator].ischaractercreator  ==  1 ) 
			{
				t.tccobj = g.charactercreatorrmodelsoffset+((t.toldCursorEntidForCharacterCreator*3)-t.characterkitcontrol.bankOffset);
				if (  ObjectExist(t.tccobj) == 1 ) 
				{
					UnGlueObject (  g.charactercreatorrmodelsoffset+((t.toldCursorEntidForCharacterCreator*3)-t.characterkitcontrol.bankOffset)+1 );
					UnGlueObject (  g.charactercreatorrmodelsoffset+((t.toldCursorEntidForCharacterCreator*3)-t.characterkitcontrol.bankOffset)+2 );
					UnGlueObject (  t.tccobj );
				}
			}
		}
		if ( ObjectExist(t.gridentityobj) == 1  ) DeleteObject (  t.gridentityobj );
		t.gridentityobj=0;
		t.toldCursorEntidForCharacterCreator = 0;
	}
	if (  t.gridentity>0 ) 
	{
		t.obj=g.entityviewcursorobj;
		t.sourceobj=g.entitybankoffset+t.gridentity;
		if (ObjectExist(t.sourceobj) == 1)
		{
			#ifdef WICKEDENGINE
			WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_CURSOROBJECT);
			if (t.gridentityextractedindex > 0) 
			{
				if (t.gridentityextractedindex > 0 && t.gridentityextractedindex <= ArrayCount(t.entityelement))
				{
					ele_id = t.gridentityextractedindex;
				}
			}
			if (ele_id == 0 && t.tentitytoselect > 0 && t.tentitytoselect <= ArrayCount(t.entityelement) )
			{
				ele_id = t.tentitytoselect;
			}
			WickedSetEntityId(t.gridentity);
			WickedSetElementId(ele_id);
			#endif
			t.entid=t.gridentity ; t.entobj=t.obj;
			if ( t.entityprofile[t.entid].ischaracter == 1 || t.entityprofile[t.entid].ismarker != 0 || t.entityprofile[t.entid].animmax>0 ) 
			{
				//  Close allows animation independence
				CloneObject ( t.obj, t.sourceobj );

				//  Character creator head
				if ( t.entityprofile[t.entid].ischaractercreator == 1 ) 
				{
					t.toldCursorEntidForCharacterCreator = t.entid;
					t.tSourcebip01_head=getlimbbyname(t.obj, "Bip01_Head");
					if ( t.tSourcebip01_head > 0 ) 
					{
						t.tccobj = g.charactercreatorrmodelsoffset+((t.entid*3)-t.characterkitcontrol.bankOffset);
						if ( ObjectExist(t.tccobj) == 1 ) 
						{
							t.tBip01_FacialHair=getlimbbyname(t.tccobj, "Bip01_FacialHair");
							if ( t.tBip01_FacialHair > 0  )  GlueObjectToLimbEx (  g.charactercreatorrmodelsoffset+((t.entid*3)-t.characterkitcontrol.bankOffset)+1,t.tccobj,t.tBip01_FacialHair,2 );
							t.Bip01_Headgear=getlimbbyname(t.tccobj, "Bip01_Headgear");
							if ( t.Bip01_Headgear > 0  )  GlueObjectToLimbEx (  g.charactercreatorrmodelsoffset+((t.entid*3)-t.characterkitcontrol.bankOffset)+2,t.tccobj,t.Bip01_Headgear,2 );
							GlueObjectToLimbEx (  t.tccobj,t.obj,t.tSourcebip01_head,2 );
						}
					}
				}
			}
			else
			{
				//  Instance creation cheaper
				InstanceObject (  t.obj,t.sourceobj );
			}
			#ifdef WICKEDENGINE
			WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_NORMAL);
			WickedSetEntityId(-1);
			WickedSetElementId(0);
			#endif
			t.gridentityunderground=0;

			//LB: incorporate overrideanimset into object creation step (during editing/loading/etc)
			if (t.obj > 0)
			{
				LPSTR pOverrideAnimSet = t.entityelement[ele_id].eleprof.overrideanimset_s.Get();
				if (strlen(pOverrideAnimSet) > 1) // "" = default to weapon type, "-" = default to object anim
				{
					// replace actual object animations
					sObject* pObject = GetObjectData(t.obj);
					AppendObject(pOverrideAnimSet, t.obj, 0);
					WickedCall_RefreshObjectAnimations(pObject, pObject->wickedloaderstateptr);
				}
			}

			// other entity attributes
			if ( t.entityprofile[t.entid].ismarker != 0 && t.entityprofile[t.entid].ismarker != 11 ) //Allow cullmode on 11
			{
				// special setup for marker objects
				SetObjectTransparency ( t.obj, 2 );
				SetObjectCull ( t.obj, 1 );
				#ifdef WICKEDENGINE
				sObject* pObject = g_ObjectList[t.obj];
				if (pObject)
				{
					WickedCall_TextureObject(pObject, NULL);
				}
				#endif
			}
			else
			{
				#ifdef WICKEDENGINE
				// For Wicked, cull mode controlled per-mesh with parent default as normal
				//PE: Prefer WEMaterial over old cullmode
				bool bUseWEMaterial = false;
				if (t.entityprofile[t.entid].WEMaterial.MaterialActive)
				{
					WickedSetEntityId(t.entid);
					if(ele_id  > 0)
						WickedSetElementId(ele_id);
					else
						WickedSetElementId(0);
					sObject* pObject = g_ObjectList[t.obj];
					if (pObject)
					{
						bUseWEMaterial = true;
						for (int iMeshIndex = 0; iMeshIndex < pObject->iMeshCount; iMeshIndex++)
						{
							sMesh* pMesh = pObject->ppMeshList[iMeshIndex];
							if (pMesh)
							{
								// set properties of mesh
								WickedSetMeshNumber(iMeshIndex);
								bool bDoubleSided = WickedDoubleSided();
								if (bDoubleSided)
								{
									pMesh->bCull = false;
									pMesh->iCullMode = 0;
									WickedCall_SetMeshCullmode(pMesh);
								}
								else
								{
									pMesh->iCullMode = 1;
									pMesh->bCull = true;
									WickedCall_SetMeshCullmode(pMesh);
								}
							}
						}
					}
					WickedSetEntityId(-1);
				}

				if (!bUseWEMaterial)
					SetObjectCull(t.obj, 1);
				#else
				if (t.entityprofile[t.entid].cullmode >= 0)
				{
					if (t.entityprofile[t.entid].cullmode != 0)
					{
						//  cull mode OFF used for single sided polygon models (Reloaded)
						//  to help with palm tree leaves
						SetObjectCull(t.obj, 0);
					}
					else
					{
						SetObjectCull(t.obj, 1);
					}
				}
				#endif
				//  set transparency mode
				#ifdef WICKEDENGINE
				if (t.entityprofile[t.entid].islightmarker == 1)
				{
					sObject* pObject = g_ObjectList[t.obj];
					if (pObject)
						WickedCall_SetObjectCastShadows(pObject, false);
					t.entityprofile[t.entid].castshadow = -1;
				}
				//LB: Always process new object through TextureMesh to set from element or parent, cannot skip this step now
				//if ((ele_id > 0 && t.entityelement[ele_id].eleprof.WEMaterial.MaterialActive) || (ele_id==0 && t.gridentity>0 && t.entityprofile[t.gridentity].WEMaterial.MaterialActive ))
				if ((ele_id > 0) || (ele_id==0 && t.gridentity>0))
				{
					//PE: Wicked material can overwrite objects settings.
					#ifdef WICKEDENGINE
					WickedSetEntityId(t.gridentity);
					WickedSetElementId(ele_id);
					// LB: apply WEMaterial to all meshes of this object, not just the first one
					// LB: Setting object transparency defaults here (so not everything is transparent), but the TextureMesh can then set per-mesh transparency :)
					SetObjectTransparency(t.obj, t.entityelement[ele_id].eleprof.WEMaterial.bTransparency[0]);
					sObject* pObject = g_ObjectList[t.obj];
					for (int iMeshIndex = 0; iMeshIndex < pObject->iMeshCount; iMeshIndex++)
					{
						sMesh* pMesh = pObject->ppMeshList[iMeshIndex];
						if (pMesh)
						{
							// set properties of mesh
							WickedSetMeshNumber(iMeshIndex);
							// sets ALL properties of each mesh from WEMaterial
							WickedCall_TextureMesh(pMesh);
						}
					}
					#else
					SetObjectTransparency(t.obj, t.entityelement[ele_id].eleprof.WEMaterial.bTransparency[0]);
					#endif
					if (t.obj == 70000) 
					{
						//Update mesh materials.
						sObject* pObject = g_ObjectList[t.obj];
						if (pObject)
						{
							for (int iMesh = 0; iMesh < pObject->iMeshCount; iMesh++)
								WickedCall_SetMeshMaterial(pObject->ppMeshList[iMesh]);
						}
					}		
					#ifdef WICKEDENGINE
					WickedSetEntityId(-1);
					WickedSetElementId(0);
					#endif
				}
				else
				#endif
				{
					if (t.entityprofile[t.entid].transparency >= 0)
					{
						#ifdef WICKEDENGINE
						WickedSetEntityId(t.gridentity);
						WickedSetElementId(ele_id);
						SetObjectTransparency(t.obj, t.entityprofile[t.entid].transparency);
						WickedSetEntityId(-1);
						WickedSetElementId(0);
						#else
						SetObjectTransparency(t.obj, t.entityprofile[t.entid].transparency);
						#endif
					}
				}
				// 051115 - only if not using limb visibility for hiding decal arrow
				if ( t.entityprofile[t.entid].addhandlelimb==0 )
				{
					//  set LOD attributes for entities
					entity_calculateentityLODdistances ( t.entid, t.obj, 0 );
				}
			}
			if (t.obj > 0 && GetNumberOfFrames(t.obj)>0 )
			{
				SetObjectFrame (  t.obj,0 );
				if (  t.entityprofile[t.entid].animmax>0 && t.entityprofile[t.entid].playanimineditor>0 && t.entityprofile[t.entid].ischaractercreator == 0 ) 
				{
					t.q=t.entityprofile[t.entid].playanimineditor-1;
					LoopObject (  t.obj,t.entityanim[t.entid][t.q].start,t.entityanim[t.entid][t.q].finish );
				}
				else if (t.entityprofile[t.entid].playanimineditor < 0)
				{
					// uses name instead of index, the negative is the ordinal into the animset
					extern void entity_loop_using_negative_playanimineditor(int e, int obj, cstr animname);
					entity_loop_using_negative_playanimineditor(ele_id, t.obj, t.entityprofile[t.entid].playanimineditor_name);
				}
				else
				{
					LoopObject (  t.obj  ); StopObject (  t.obj );
				}
			}
		}
		else
		{
			MakeObjectCube (  t.obj,25 );
		}
		//  ensure new object ONLY interacts with main camera and shadow camera
		//PE: 130217 added t.entityprofile[t.gridentity].zdepth == 0 to prevent decals from calling technique11 DepthMap
		if (  t.entityprofile[t.gridentity].ismarker != 0 || t.entityprofile[t.gridentity].zdepth == 0 )
		{
			SetObjectMask (  t.obj, 1 );
		}
		else
		{
			SetObjectMask (  t.obj, 1+(1<<31) );
		}
		//  pivot alignment
		if (  t.entityprofile[t.gridentity].fixnewy != 0 ) 
		{
			RotateObject (  t.obj,0,t.entityprofile[t.gridentity].fixnewy,0 );
			FixObjectPivot (  t.obj );
		}
		// scale
		t.tescale=t.entityprofile[t.gridentity].scale;
		if (t.tescale > 0)
		{
			ScaleObject (t.obj, t.tescale, t.tescale, t.tescale);
			//PE: Particle scale bug fix.
			//if (t.entityprofile[t.gridentity].ismarker == 10)
			//{
			//	// and then reset scale for particle markers
			//	ScaleObject(t.obj, t.entityprofile[t.gridentity].scale, t.entityprofile[t.gridentity].scale, t.entityprofile[t.gridentity].scale);
			//}
		}

		SetObjectCollisionOff (  t.obj );
		if ( g.entityrubberbandlist.size() == 1 )
		{
			#ifdef WICKEDENGINE
			if (!pref.iEnableDragDropEntityMode)
			#endif
			{
				// only dehighlight if single extract, not if a rubber band / linked entities extraction
				#ifdef WICKEDENGINE
				t.geditorhighlightingtentityID = ele_id;
				#endif
				editor_restoreobjhighlightifnotrubberbanded(t.obj);
			}
		}
		t.gridentityobj=t.obj;

#ifdef WICKEDENGINE
		if (t.entityprofile[t.gridentity].ismarker == 2)
		{
			if (ele_id > 0)
			{
				// full light update inc. color
				entity_updatelightobj(ele_id, t.gridentityobj);
			}
			else
			{
				// do not know light settings, so just white point light
				entity_updatelightobjtype(t.gridentityobj, 0);
			}
		}
#endif

#ifdef WICKEDENGINE
		if (t.entityprofile[t.gridentity].islightmarker == 1)
		{
			sObject* pObject = g_ObjectList[t.obj];
			if (pObject)
				WickedCall_SetObjectCastShadows(pObject, false);
			t.entityprofile[t.gridentity].castshadow = -1;
		}
#endif
		
#ifdef WICKEDENGINE
		//PE: Old decal support.
		if (t.entityprofile[t.gridentity].bIsDecal)
		{
			SetupDecalObject(t.obj, ele_id);
		}
#endif

	}
#ifdef WICKEDENGINE
	//HighLight instantly.
	if (t.gridentityobj > 0) {
		if (t.gridentityobj < g_iObjectListCount)
		{
			if (g_ObjectList[t.gridentityobj])
			{
				if (t.gridentitystaticmode)
					g_selected_editor_color = XMSTATICCOLOR;
				else
					g_selected_editor_color = XMDYNAMICCOLOR;
				g_selected_editor_object = g_ObjectList[t.gridentityobj];
			}
		}
	}

#endif

	editor_refreshentitycursor ( );
}

void gridedit_displayentitycursor ( void )
{
	//  create entity foating selection
	if (  t.gridentity>0 ) 
	{
		t.obj=t.gridentityobj;
		if (  ObjectExist(t.obj) == 1 ) 
		{
			PositionObject (  t.obj,t.gridentityposx_f,t.gridentityposy_f,t.gridentityposz_f );
			RotateObject (  t.obj,t.gridentityrotatex_f,t.gridentityrotatey_f,t.gridentityrotatez_f );
			t.tfinalscalex_f=t.gridentityscalex_f;
			t.tfinalscaley_f=t.gridentityscaley_f;
			t.tfinalscalez_f=t.gridentityscalez_f;
			ScaleObject ( t.obj, t.tfinalscalex_f, t.tfinalscaley_f, t.tfinalscalez_f );
			//PE: Particle scale bug fix.
			//if (t.entityprofile[t.gridentity].ismarker == 10)
			//{
			//	ScaleObject (t.obj, t.entityprofile[t.gridentity].scale, t.entityprofile[t.gridentity].scale, t.entityprofile[t.gridentity].scale);
			//}
			if (  t.gridentity>0 )
			{
				if (  t.entityprofile[t.gridentity].ischaracter == 0 ) 
				{
					t.tanimspeed_f=t.entityprofile[t.gridentity].animspeed;
					SetObjectSpeed (  t.obj,g.timeelapsed_f*t.tanimspeed_f );
				}
			}
		}
	}

	//  if entity cursor light, instantly feed into shader OVERRIDING LIGHT ZERO
	lighting_override ( );
}

void gridedit_deletelevelobjects ( void )
{
	// clear OBJ values in entityelements (as all objects are being removed)
	if ( g.entityelementlist>0 ) 
	{
		for ( t.e = 1 ; t.e <= g.entityelementlist; t.e++ )
		{
			#ifdef WICKEDENGINE
			// delete any env probes 
			int entid = t.entityelement[t.e].bankindex;
			if (entid > 0)
			{
				if (t.entityprofile[entid].ismarker == 2)
				{
					entity_deleteprobe(t.entityelement[t.e].obj);
				}
			}
			#endif

			t.obj = t.entityelement[t.e].obj;
			if ( t.obj > 0 ) 
			{
				if ( ObjectExist(t.obj) == 1 ) DeleteObject (  t.obj );
			}

			//  clear any character creator objects associated with this entity
			#ifdef VRTECH
			#else
			t.ccobjToDelete=t.obj;
			characterkit_deleteEntity ( );
			#endif

			t.entityelement[t.e].obj=0;
			t.entityelement[t.e].bankindex=0;
			deleteinternalsound(t.entityelement[t.e].soundset) ; t.entityelement[t.e].soundset=0;
			deleteinternalsound(t.entityelement[t.e].soundset1) ; t.entityelement[t.e].soundset1=0;
			deleteinternalsound(t.entityelement[t.e].soundset2) ; t.entityelement[t.e].soundset2=0;
			deleteinternalsound(t.entityelement[t.e].soundset3) ; t.entityelement[t.e].soundset3=0;
			deleteinternalsound(t.entityelement[t.e].soundset4) ; t.entityelement[t.e].soundset4=0;
			#ifdef WICKEDENGINE
			deleteinternalsound(t.entityelement[t.e].soundset5); t.entityelement[t.e].soundset5 = 0;
			deleteinternalsound(t.entityelement[t.e].soundset6); t.entityelement[t.e].soundset6 = 0;
			#endif
		}
	}
	UnDim (  t.entityelement );
	#ifdef VRTECH
	#else
	UnDim (  t.entityshadervar );
	UnDim (  t.entitydebug_s );
	#endif
	g.entityelementmax=100;
	Dim (  t.entityelement,g.entityelementmax  );
	#ifdef VRTECH
	#else
	Dim2(  t.entityshadervar,g.entityelementmax, g.globalselectedshadermax  );
	Dim (  t.entitydebug_s,g.entityelementmax  );
	#endif
	g.entityelementlist=0;

	//  delete all objects used for level edit
	for ( t.obj = g.entityviewstartobj ; t.obj <= g.entityviewendobj; t.obj++ )
	{
		if (  ObjectExist(t.obj) == 1  )  DeleteObject (  t.obj );
	}

	//  also delete all entitybank references
	entity_deletebank ( );

	//  Indicate no level objects
	g.entityviewendobj=0;

	//  270215 - 011 - Create new entities from the beginning
	g.entityviewcurrentobj=g.entityviewstartobj;
}

void modifyplaneimagestrip ( int objno, int texmax, int texindex )
{
	float s_f = 0;
	float u_f = 0;

	//  Lock the vertex data of the object
	LockVertexDataForLimbCore (  objno,0,1 );

	//  adjust UV data
	s_f=1.0/texmax ; u_f=texindex*s_f;
	SetVertexDataUV (  0,u_f+s_f,0.0 );
	SetVertexDataUV (  1,u_f,0.0 );
	SetVertexDataUV (  2,u_f+s_f,1.0 );
	SetVertexDataUV (  3,u_f,0.0 );
	SetVertexDataUV (  4,u_f,1.0 );
	SetVertexDataUV (  5,u_f+s_f,1.0 );

	//  Unlock the vertex data of the object
	UnlockVertexData (  );

//endfunction

}

int Get_Spray_Mode_On(void)
{
	if (iDisplayCircleFrames > 0)
	{
		iDisplayCircleFrames--;
		return(true);
	}
	if (t.gridentity == 0) return false;
	return(t.gridedit.entityspraymode);
}

//#############
//#### RPG ####
//#############

#ifdef RPG_GAMES

//PE: Structures to be moved later.

//PE: Need limits to make sure we can save directly and are able to use IDs directly, no pointer to pointer to pointer coding nightmare.
//PE: We work with floats everywhere but only display integers. (always round up).
//PE: Each struct get saved into its own file, so its easy to expand each struct later. Saved with fpm level.

#define RPG_MAX_STATS 150
#define RPG_STATS_ACTION_NONE 0
#define RPG_STATS_ACTION_MONEY 1
#define RPG_STATS_ACTION_HEALTH 2
#define RPG_STATS_ACTION_ARMOR 3
#define RPG_STATS_ACTION_STRENGTH 4
#define RPG_STATS_ACTION_STAMINA 5
#define RPG_STATS_ACTION_MAGIC 6

struct RPGStats
{
	int StatID[RPG_MAX_STATS];
	int StatAction[RPG_MAX_STATS]; //Predefined action to change ingame settings , like play Health,Armor,Ammo...
	float StatMax[RPG_MAX_STATS]; //the max value for this stat.
	char StatName[RPG_MAX_STATS][256];
	float StatValue[RPG_MAX_STATS];
} RPG_Stats;

//PE: Used to group items into categories, like weapon,armor,ammo,consumable,resource,recipe,quest
//PE: Also used as filter names.
#define RPG_MAX_TYPES 50
struct RPGTypes
{
	int TypeID[RPG_MAX_TYPES];
	char TypeName[RPG_MAX_STATS][256];
} RPG_Types;

#define RPG_MAX_ITEMS 1000
struct RPGItems
{
	int ItemID[RPG_MAX_ITEMS]; //ID
	char ItemName[RPG_MAX_ITEMS][256]; //Name
	char ItemDesc[RPG_MAX_ITEMS][256]; //Description
	char ItemIconLarge[RPG_MAX_ITEMS][256]; //Large icon path.
	int ItemIconLargeID[RPG_MAX_ITEMS]; //Large icon ID
	char ItemIconSmall[RPG_MAX_ITEMS][256]; //Small icon path.
	int ItemIconSmallID[RPG_MAX_ITEMS]; //Small icon ID

	float ItemWeight[RPG_MAX_ITEMS]; // Weight.

	//Prices.
	float ItemBuyPrice[RPG_MAX_ITEMS]; //Fixed to stat money.
	float ItemSellPrice[RPG_MAX_ITEMS];
	float ItemTradePrice[RPG_MAX_ITEMS];

	//Relation to objects on map. To easy the setup, all objects on map will get this item added to them.
	int ItemMasterObjectID[RPG_MAX_ITEMS]; //entityprofile[] - All object of this type in the level will trigger this item.
	char ItemMasterObjectFPE[RPG_MAX_ITEMS][256]; //We need the master object fpe, if we change level we need to match ItemMasterObjectID to the FPE on that level.

	int ItemTypeID[RPG_MAX_ITEMS]; //Lookup in other struct (weapon,armor,ammo,consumable,resource,recipe,quest,"Stat"/"none") ("none" for item that dont go into inv. but count stat... or other actions ).
	float ItemTypeValue[RPG_MAX_ITEMS]; // Like Armor 23, Ammo 50 ...

	//Item can make stat changes. also minus.
	int ItemStatID[RPG_MAX_ITEMS][RPG_MAX_STATS]; //Stat ID to change.
	float ItemStatValue[RPG_MAX_ITEMS][RPG_MAX_STATS]; // Amount to change stat by. 0.0=random change.
	ImVec2 ItemStatRandomLowHigh[RPG_MAX_ITEMS][RPG_MAX_STATS];

	//If not selling but "USE" this item , trigger these stat changes.
	int ItemUseAction[RPG_MAX_ITEMS]; //Trigger action when using this item, Start Quest, PlayerItemInGameCarryMaxWeight (bag size), Fire a weapon in ALL directions,...
	int ItemUseStatID[RPG_MAX_ITEMS][RPG_MAX_STATS]; //Stat ID to change.
	float ItemUseStatValue[RPG_MAX_ITEMS][RPG_MAX_STATS]; // Amount to change stat by.

	//Pickup item.
	int ItemAvailableOnlyAfterDead[RPG_MAX_ITEMS]; //
	char ItemPickupText[RPG_MAX_ITEMS][256];
	int ItemPickupKey[RPG_MAX_ITEMS]; //Asc("E");
	int ItemPickupRange[RPG_MAX_ITEMS];
	int ItemAutoCollect[RPG_MAX_ITEMS]; //Just collect no prompt.
	int ItemAutoUse[RPG_MAX_ITEMS]; //Use this item instantly when pickup, add health, larger bag size ...

	//Effects.
	char ItemPickupDisplayText[RPG_MAX_ITEMS][256]; // value+text like "+5 Bag size increased" , fast scroll text up and out.
	char ItemPickupSound[RPG_MAX_ITEMS][256];
	char ItemPickupParticle[RPG_MAX_ITEMS][256];
	int ItemPickupDisplayValue[RPG_MAX_ITEMS];

} RPG_Items;

#define RPG_MAX_LEVELS 15
#define RPG_MAX_PLAYERS 200
//PE: Fixed level 0 playerid 0 always start marker.
//PE: Use storyboard unique nodeid as level number here ?
//PE: Somehow we need to remap PlayerID when changing level ?, or include a "level ID" here ?
//PE: Parse from Storyboard.Nodes[node].levelnumber and use this level.
struct RPGPlayer
{
	int RPGActive = -1;

	int PlayerID[RPG_MAX_PLAYERS];
	float PlayerItemCarryMaxWeight[RPG_MAX_PLAYERS]; //For Store set this high.
	float PlayerItemInGameCarryMaxWeight[RPG_MAX_PLAYERS]; //Copy from PlayerItemCarryMaxWeight on new game, and save/load this one.
	int PlayerAllowSelling[RPG_MAX_PLAYERS];
	int PlayerAllowTrading[RPG_MAX_PLAYERS];
	int PlayerAllowLoot[RPG_MAX_PLAYERS];

	//What items do this player carry.
	int PlayerItemID[RPG_MAX_PLAYERS][RPG_MAX_ITEMS];
	int PlayerItemStartTotal[RPG_MAX_PLAYERS][RPG_MAX_ITEMS];
	int PlayerItemInGameTotal[RPG_MAX_PLAYERS][RPG_MAX_ITEMS]; //Copy from PlayerItemStartAmounts on new game, and save/load this one.

	//What are the player stat, Health,money...
	int PlayerStatID[RPG_MAX_PLAYERS][RPG_MAX_STATS];
	float PlayerStatStartValue[RPG_MAX_PLAYERS][RPG_MAX_ITEMS];
	//PC,NPC's should all react on these values in game.
	float PlayerStatInGameValue[RPG_MAX_PLAYERS][RPG_MAX_ITEMS]; //Copy from PlayerStatStartValue on new game , and save/load this one.

} RPG_Player[RPG_MAX_LEVELS];

//void *RPG_System;

void init_rpg_system_stats( void )
{
	//Stats.
	for (int i = 0; i < RPG_MAX_STATS; i++)
	{
		RPG_Stats.StatID[i] = -1;
		RPG_Stats.StatAction[i] = -1;
		RPG_Stats.StatMax[i] = 10000;
		strcpy(RPG_Stats.StatName[i], "");
		RPG_Stats.StatValue[i] = 0.0;
	}
	int id = 0;
	//Stats predefined.
	RPG_Stats.StatID[id] = 0;
	RPG_Stats.StatAction[id] = RPG_STATS_ACTION_MONEY;
	RPG_Stats.StatMax[id] = 100000000;
	strcpy(RPG_Stats.StatName[id], "GOLD");
	RPG_Stats.StatValue[id] = 10;
	id++;
	RPG_Stats.StatID[id] = 0;
	RPG_Stats.StatAction[id] = RPG_STATS_ACTION_HEALTH;
	RPG_Stats.StatMax[id] = 1000;
	strcpy(RPG_Stats.StatName[id], "HEALTH");
	RPG_Stats.StatValue[id] = 500;
	id++;
	RPG_Stats.StatID[id] = 0;
	RPG_Stats.StatAction[id] = RPG_STATS_ACTION_ARMOR;
	RPG_Stats.StatMax[id] = 9999;
	strcpy(RPG_Stats.StatName[id], "ARMOR");
	RPG_Stats.StatValue[id] = 10;
	id++;
	RPG_Stats.StatID[id] = 0;
	RPG_Stats.StatAction[id] = RPG_STATS_ACTION_STRENGTH;
	RPG_Stats.StatMax[id] = 9999;
	strcpy(RPG_Stats.StatName[id], "STRENGTH");
	RPG_Stats.StatValue[id] = 10;
	id++;
	RPG_Stats.StatID[id] = 0;
	RPG_Stats.StatAction[id] = RPG_STATS_ACTION_STAMINA;
	RPG_Stats.StatMax[id] = 9999;
	strcpy(RPG_Stats.StatName[id], "STAMINA");
	RPG_Stats.StatValue[id] = 0;
	id++;
	RPG_Stats.StatID[id] = 0;
	RPG_Stats.StatAction[id] = RPG_STATS_ACTION_MAGIC;
	RPG_Stats.StatMax[id] = 9999;
	strcpy(RPG_Stats.StatName[id], "MAGIC");
	RPG_Stats.StatValue[id] = 0;
	id++;
}

void init_rpg_system_types(void)
{

	for (int i = 0; i < RPG_MAX_TYPES; i++)
	{
		RPG_Types.TypeID[i] = -1;
		strcpy(RPG_Types.TypeName[i], "");
	}
	int id = 0;
	RPG_Types.TypeID[id] = 0;
	strcpy(RPG_Types.TypeName[id], "OTHER");
	id++;
	RPG_Types.TypeID[id] = 0;
	strcpy(RPG_Types.TypeName[id], "WEAPON");
	id++;
	RPG_Types.TypeID[id] = 0;
	strcpy(RPG_Types.TypeName[id], "ARMOR");
	id++;
	RPG_Types.TypeID[id] = 0;
	strcpy(RPG_Types.TypeName[id], "AMMO");
	id++;
	RPG_Types.TypeID[id] = 0;
	strcpy(RPG_Types.TypeName[id], "CONSUMABLE");
	id++;
	RPG_Types.TypeID[id] = 0;
	strcpy(RPG_Types.TypeName[id], "RESOURCE");
	id++;
	RPG_Types.TypeID[id] = 0;
	strcpy(RPG_Types.TypeName[id], "RECIPE");
	id++;
	RPG_Types.TypeID[id] = 0;
	strcpy(RPG_Types.TypeName[id], "QUEST");
	id++;

}

void init_rpg_system_items(void)
{
	for (int i = 0; i < RPG_MAX_ITEMS; i++)
	{
		RPG_Items.ItemID[i] = -1;
		strcpy(RPG_Items.ItemName[i],"");
		strcpy(RPG_Items.ItemDesc[i], "");
		strcpy(RPG_Items.ItemIconLarge[i], "");
		RPG_Items.ItemIconLargeID[i] = -1;
		strcpy(RPG_Items.ItemIconSmall[i], "");
		RPG_Items.ItemIconSmallID[i] = -1;

		RPG_Items.ItemWeight[i] = 5; // Weight.

		//Prices.
		RPG_Items.ItemBuyPrice[i] = 2;
		RPG_Items.ItemSellPrice[i] = 1;
		RPG_Items.ItemTradePrice[i] = 1.5;

		//Relation to objects on map.
		RPG_Items.ItemMasterObjectID[i] = -1;
		strcpy(RPG_Items.ItemMasterObjectFPE[i], "");

		RPG_Items.ItemTypeID[i] = 0; //default to OTHER
		RPG_Items.ItemTypeValue[i] = 1; //How strong is this item, Like Armor 23, Ammo 50 ...

		//Item can make stat changes. also minus.
		for (int a = 0; a < RPG_MAX_STATS; a++)
		{
			RPG_Items.ItemStatID[i][a] = -1;
			RPG_Items.ItemStatValue[i][a] = 1; //0 = random.
			RPG_Items.ItemStatRandomLowHigh[i][a] = ImVec2(1, 4);
		}

		//If not selling but "USE" this item , trigger these stat changes.
		RPG_Items.ItemUseAction[i] = 0; //Trigger action when using this item, Start Quest, PlayerItemInGameCarryMaxWeight (bag size), Fire a weapon in ALL directions,...

		for (int a = 0; a < RPG_MAX_STATS; a++)
		{
			RPG_Items.ItemUseStatID[i][a] = -1;
			RPG_Items.ItemUseStatValue[i][a] = 0; // Amount to change stat by.
		}

		//Pickup item.
		RPG_Items.ItemAvailableOnlyAfterDead[i] = 0; //1=Item only available after object health <= 0.
		strcpy(RPG_Items.ItemPickupText[i], "");
		RPG_Items.ItemPickupKey[i] = Asc("E");
		RPG_Items.ItemPickupRange[i] = 100;
		RPG_Items.ItemAutoCollect[i] = 0; //1=Just collect no prompt.
		RPG_Items.ItemAutoUse[i] = 0; //1=Use this item instantly when pickup, add health, larger bag size , start quest ...

		//Pickup Effects.
		strcpy(RPG_Items.ItemPickupDisplayText[i], "");
		strcpy(RPG_Items.ItemPickupSound[i], "");
		strcpy(RPG_Items.ItemPickupParticle[i], "");
		RPG_Items.ItemPickupDisplayValue[i] = 0; //1=value+ItemPickupDisplayText like "+5 Bag size increased" , fast scroll text up and out.

	}

	//PE: default Inventory ?
}

void init_rpg_system_players(void)
{
	//PE: Fixed level 0 playerid 0 always start marker.
	//PE: Use storyboard unique nodeid as level number here ?
	//PE: Somehow we need to remap PlayerID when changing level ?, or include a "level ID" here ?
	//PE: Parse from Storyboard.Nodes[node].levelnumber and use this level.
	for (int level = 0; level < RPG_MAX_LEVELS; level++)
	{
		RPG_Player[level].RPGActive = -1;

		for (int i = 0; i < RPG_MAX_PLAYERS; i++)
		{
			RPG_Player[level].PlayerID[i] = -1;
			RPG_Player[level].PlayerItemCarryMaxWeight[i] = 1000;
			RPG_Player[level].PlayerItemInGameCarryMaxWeight[i] = 1000; //InGame.

			RPG_Player[level].PlayerAllowSelling[i] = 0;
			RPG_Player[level].PlayerAllowTrading[i] = 0;
			RPG_Player[level].PlayerAllowLoot[i] = 0; //Will turn enemy if looted. have loot time ? so he can perhaps attach us.

			//What items do this player carry.
			for (int a = 0; a < RPG_MAX_ITEMS; a++)
			{
				RPG_Player[level].PlayerItemID[i][a] = -1;
				RPG_Player[level].PlayerItemStartTotal[i][a] = 0;
				RPG_Player[level].PlayerItemInGameTotal[i][a] = 0; //Ingame Copy from RPG_Player[level].PlayerItemStartTotal on new game, and save/load this one.
			}

			//What are the player stat, Health,money...
			for (int a = 0; a < RPG_MAX_STATS; a++)
			{
				RPG_Player[level].PlayerStatID[i][a] = -1;
				RPG_Player[level].PlayerStatStartValue[i][a] = 0;
				RPG_Player[level].PlayerStatInGameValue[i][a] = 0; //Ingame: copy from RPG_Player[level].PlayerStatStartValue on new game, and save/load this one.
			}
		}

		//PE: Defaults ?
	}

}

void init_rpg_system(void)
{
	init_rpg_system_stats();
	init_rpg_system_types();
	init_rpg_system_items();
	init_rpg_system_players();
}

bool load_rpg_system(char *name)
{
	bool bValid = true;
	char project[MAX_PATH];

	//RPG_Stats
	strcpy(project, "projectbank\\");
	strcat(project, name);
	strcat(project, "\\RPG_Stats.dat");
	FILE* projectfile = GG_fopen(project, "rb");
	if (projectfile)
	{
		size_t size = fread(&RPG_Stats, 1, sizeof(RPG_Stats), projectfile);
	}
	else
	{
		bValid = false;
	}

	//RPG_Types
	strcpy(project, "projectbank\\");
	strcat(project, name);
	strcat(project, "\\RPG_Types.dat");
	projectfile = GG_fopen(project, "rb");
	if (projectfile)
	{
		size_t size = fread(&RPG_Types, 1, sizeof(RPG_Types), projectfile);
	}
	else
	{
		bValid = false;
	}


	//RPG_Items
	strcpy(project, "projectbank\\");
	strcat(project, name);
	strcat(project, "\\RPG_Items.dat");
	projectfile = GG_fopen(project, "rb");
	if (projectfile)
	{
		size_t size = fread(&RPG_Items, 1, sizeof(RPG_Items), projectfile);
	}
	else
	{
		bValid = false;
	}


	//RPG_Player
	for (int level = 0; level < RPG_MAX_LEVELS; level++)
	{
		char tmp[MAX_PATH];
		sprintf(tmp, "projectbank\\%s\\%dRPG_Player.dat", name, level);
		strcpy(project, tmp);
		FILE* projectfile = GG_fopen(project, "rb");
		if (projectfile)
		{
			size_t size = fread(&RPG_Player[level], 1, sizeof(RPG_Player[level]), projectfile);
			RPG_Player[level].RPGActive = 1; //PE: Mark as ready to be used. RPG need a storyboard.
		}
	}
	RPG_Player[0].RPGActive = 1; //0 always active.

	return bValid;
}

bool save_rpg_system(char *name)
{
	bool bValid = true;
	char project[MAX_PATH];

	//RPG_Stats
	strcpy(project, "projectbank\\");
	strcat(project, name);
	strcat(project, "\\RPG_Stats.dat");
	FILE* projectfile = GG_fopen(project, "wb+");
	if (projectfile) {
		fwrite(&RPG_Stats, 1, sizeof(RPG_Stats), projectfile);
		fclose(projectfile);
	}
	else
	{
		bValid = false; //Keep saving other structures even if one failed.
	}

	//RPG_Types
	strcpy(project, "projectbank\\");
	strcat(project, name);
	strcat(project, "\\RPG_Types.dat");
	projectfile = GG_fopen(project, "wb+");
	if (projectfile) {
		fwrite(&RPG_Types, 1, sizeof(RPG_Types), projectfile);
		fclose(projectfile);
	}
	else
	{
		bValid = false; //Keep saving other structures even if one failed.
	}

	//RPG_Items
	strcpy(project, "projectbank\\");
	strcat(project, name);
	strcat(project, "\\RPG_Items.dat");
	projectfile = GG_fopen(project, "wb+");
	if (projectfile) {
		fwrite(&RPG_Items, 1, sizeof(RPG_Items), projectfile);
		fclose(projectfile);
	}
	else
	{
		bValid = false; //Keep saving other structures even if one failed.
	}


	//RPG_Player
	for (int level = 0; level < RPG_MAX_LEVELS; level++)
	{
		if (RPG_Player[level].PlayerID[0] != -1 || RPG_Player[level].PlayerID[1] != -1) //Do we got anything ?
		{
			char tmp[MAX_PATH];
			sprintf(tmp, "projectbank\\%s\\%dRPG_Player.dat", name, level);
			strcpy(project, tmp);
			FILE* projectfile = GG_fopen(project, "wb+");
			if (projectfile) {
				fwrite(&RPG_Player[level], 1, sizeof(RPG_Player[level]), projectfile);
				fclose(projectfile);
			}
			else
			{
				bValid = false; //Keep saving other structures even if one failed.
			}
		}
	}
	return bValid;
}

#endif

bool IsRPGActive( void )
{
	#ifdef RPG_GAMES
	return true;
	#else
	return false;
	#endif
}



#ifdef RPG_GAMES
void ProcessRPGSetupWindow(void)
{
	if (!bRPGSetup_Window) return;

	if (refresh_gui_docking == 1)
	{
		ImGui::SetNextWindowSize(ImVec2(64 * ImGui::GetFontSize(), 38 * ImGui::GetFontSize()), ImGuiCond_Always);
		ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
	}
	else
	{
		ImGui::SetNextWindowSize(ImVec2(64 * ImGui::GetFontSize(), 38 * ImGui::GetFontSize()), ImGuiCond_Once);
		ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
	}

	ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings;
	ImGui::Begin("RPG setup##MustBeUnique", &bRPGSetup_Window, window_flags);

	//Tabs
	if (ImGui::BeginTabBar("rpgsetuptabbar"))
	{
		int flags = 0; // flags = ImGuiTabItemFlags_SetSelected;
		//RPG_Types
		if (ImGui::BeginTabItem(" Groups ", NULL, flags))
		{
			ImGui::Indent(10);

			ImGui::SetWindowFontScale(1.5);
			ImGui::TextCenter("Groups is used to order inventory into groups, and to filter lists.");
			ImGui::SetWindowFontScale(1.0);

			ImGui::Columns(2, "rpggroupscolumns2", false);  //false no border
			ImGui::SetColumnWidth(0, ImGui::GetWindowSize().x*0.25);

			ImGui::PushItemWidth(-10);
			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

			int padding_bottom_y = 10;
			static int current_group_selected = -1;

			if (ImGui::StyleButton("Add New Group", ImVec2(0, 0)))
			{
				for (int i = 0; i < RPG_MAX_TYPES; i++)
				{
					if (RPG_Types.TypeID[i] == -1)
					{
						RPG_Types.TypeID[i] = i;
						sprintf(RPG_Types.TypeName[i], "Empty%d", i);
						current_group_selected = i;
						break;
					}
				}
			}

			float ListBoxHeight = ImGui::GetContentRegionAvail().y - padding_bottom_y; //ImGui::GetFontSize()*16.0f;
			if (ImGui::ListBoxHeader("##rpggroupsBox", ImVec2(0, ListBoxHeight)) == true)
			{
				for (int i = 0; i < RPG_MAX_TYPES; i++)
				{
					if (RPG_Types.TypeID[i] != -1)
					{
						if (current_group_selected == -1) current_group_selected = i; //PE: Always have a selection.
						bool bIsSelected = false;
						if (current_group_selected == i) bIsSelected = true;
						if (ImGui::Selectable(RPG_Types.TypeName[i], bIsSelected))
						{
							current_group_selected = i;
						}
					}
				}
				ImGui::ListBoxFooter();
			}

			//#### Split ####
			ImGui::NextColumn();

			if (current_group_selected != -1)
			{
				ImGui::Text("");
				ImGui::Text("(%s ID=%d)", RPG_Types.TypeName[current_group_selected], current_group_selected);
				ImGui::Text("");
				ImGui::Text("Enter the name of this group.");
				ImGui::InputText("##RPGEnterGroupText", RPG_Types.TypeName[current_group_selected], 250);
				ImGui::Text("");
				if (ImGui::StyleButton("Delete This Group", ImVec2(0, 0)))
				{
					if (current_group_selected != 0) //We cant delete first group, always need atleast one group.
					{
						for (int i = 0; i < RPG_MAX_TYPES; i++)
						{
							if (RPG_Types.TypeID[i] == current_group_selected)
							{
								RPG_Types.TypeID[i] = -1;
								//Loop into all structs and delete references to this group.
								for (int a = 0; a < RPG_MAX_ITEMS; a++)
								{
									if (RPG_Items.ItemTypeID[a] == current_group_selected)
									{
										RPG_Items.ItemTypeID[i] = 0; //default to OTHER
									}
								}
								current_group_selected = 0;
								break;
							}
						}
					}
				}

			}

			ImGui::Columns(1);

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
			ImGui::PopItemWidth();
			ImGui::Indent(-10);

			if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
				ImGui::Text(""); //Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				ImGui::Text("");
			}

			ImGui::EndTabItem();
		}

		//RPG_Stats
		if (ImGui::BeginTabItem(" Stats ", NULL, flags))
		{
			ImGui::Indent(10);

			ImGui::SetWindowFontScale(1.5);
			ImGui::TextCenter("Stats is used to add custom variables to your games.");
			ImGui::TextCenter("Stats variables can be set to directly impact players in game, like Health,Armor,Money,Strength...");
			ImGui::SetWindowFontScale(1.0);

			ImGui::Columns(2, "rpgstatscolumns2", false);  //false no border
			ImGui::SetColumnWidth(0, ImGui::GetWindowSize().x*0.25);

			ImGui::PushItemWidth(-10);
			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

			int padding_bottom_y = 10;
			static int current_stat_selected = -1;

			if (ImGui::StyleButton("Add New Stat", ImVec2(0, 0)))
			{
				for (int i = 0; i < RPG_MAX_TYPES; i++)
				{
					if (RPG_Stats.StatID[i] == -1)
					{
						RPG_Stats.StatID[i] = i;
						RPG_Stats.StatAction[i] = 0;
						RPG_Stats.StatMax[i] = 9999;
						RPG_Stats.StatValue[i] = 1;
						sprintf(RPG_Stats.StatName[i], "Empty%d", i);
						current_stat_selected = i;
						break;
					}
				}
			}

			float ListBoxHeight = ImGui::GetContentRegionAvail().y - padding_bottom_y; //ImGui::GetFontSize()*16.0f;
			if (ImGui::ListBoxHeader("##rpgstatsBox", ImVec2(0, ListBoxHeight)) == true)
			{
				for (int i = 0; i < RPG_MAX_TYPES; i++)
				{
					if (RPG_Stats.StatID[i] != -1)
					{
						if (current_stat_selected == -1) current_stat_selected = i; //PE: Always have a selection.
						bool bIsSelected = false;
						if (current_stat_selected == i) bIsSelected = true;
						if (ImGui::Selectable(RPG_Stats.StatName[i], bIsSelected))
						{
							current_stat_selected = i;
						}
					}
				}
				ImGui::ListBoxFooter();
			}

			//#### Split ####
			ImGui::NextColumn();

			if (current_stat_selected != -1)
			{
				ImGui::Text("");
				ImGui::Text("(%s ID=%d)", RPG_Stats.StatName[current_stat_selected], current_stat_selected);
				ImGui::Text("");
				ImGui::Text("Enter the name of this stat.");
				ImGui::InputText("##RPGEnterstatText", RPG_Stats.StatName[current_stat_selected], 250);
				ImGui::Text("");

				ImGui::Text("Select in game action this stat will have, if its only a visible stat like XP,Level... set it to none.");
				const char* stat_action_items[] = { "None", "Add Money", "Add Health", "Add Armor", "Add Strength", "Add Stamina", "Add Magic" };
				if (ImGui::Combo("##GraphicsQualityTest", &RPG_Stats.StatAction[current_stat_selected], stat_action_items, IM_ARRAYSIZE(stat_action_items))) {
					//
				}

				ImGui::Text("");
				ImGui::Text("Enter the max value this stat can have. it will never go above this.");
				int iInt = RPG_Stats.StatMax[current_stat_selected]; //We use int but count using floats.
				if (ImGui::InputInt("##StatsMaxValue", &iInt, 0, 100000000))
				{
					RPG_Stats.StatMax[current_stat_selected] = iInt;
				}

				ImGui::Text("");
				ImGui::Text("Enter the start value this stat have. This can be overwritten when you later setup players and objects if needed.");
				iInt = RPG_Stats.StatValue[current_stat_selected]; //We use int but count using floats.
				if (ImGui::InputInt("##StatsStartValue", &iInt, 0, 100000000))
				{
					RPG_Stats.StatValue[current_stat_selected] = iInt;
				}

				ImGui::Text("");

				if (ImGui::StyleButton("Delete This Stat", ImVec2(0, 0)))
				{
					if (current_stat_selected > 5) //First 5 is needed , cant be deleted just changed.
					{
						for (int i = 0; i < RPG_MAX_TYPES; i++)
						{
							if (RPG_Stats.StatID[i] == current_stat_selected)
							{
								RPG_Stats.StatID[i] = -1;
								//Loop into all structs and delete references to this stat.
								for (int a = 0; a < RPG_MAX_ITEMS; a++)
								{
									for (int b = 0; b < RPG_MAX_STATS; b++)
									{
										if(RPG_Items.ItemStatID[a][b] == current_stat_selected)
											RPG_Items.ItemStatID[a][b] = -1;
										if (RPG_Items.ItemUseStatID[a][b] == current_stat_selected)
											RPG_Items.ItemUseStatID[a][b] = -1;
									}
								}
								break;
							}
						}

						for (int level = 0; level < RPG_MAX_LEVELS; level++)
						{
							for (int a = 0; a < RPG_MAX_PLAYERS; a++)
							{
								for (int b = 0; b < RPG_MAX_STATS; b++)
								{
									if(RPG_Player[level].PlayerStatID[a][b] == current_stat_selected)
										RPG_Player[level].PlayerStatID[a][b] = -1;
								}
							}
						}

						current_stat_selected = 0;
					}
				}

			}

			ImGui::Columns(1);

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
			ImGui::PopItemWidth();
			ImGui::Indent(-10);

			if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
				ImGui::Text(""); //Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				ImGui::Text("");
			}

			ImGui::EndTabItem();
		}

		//RPG_Items TODO
		if (ImGui::BeginTabItem(" Items ", NULL, flags))
		{
			ImGui::Indent(10);
			ImGui::PushItemWidth(-10);
			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

			ImGui::TextCenter("Items is used to add/setup available inventory for all players and objects.");

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
			ImGui::PopItemWidth();
			ImGui::Indent(-10);

			if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
				//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				ImGui::Text("");
				ImGui::Text("");
			}

			ImGui::EndTabItem();
		}

		//RPG_Player TODO
		if (ImGui::BeginTabItem(" Players ", NULL, flags))
		{
			ImGui::Indent(10);
			ImGui::PushItemWidth(-10);
			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

			ImGui::TextCenter("Players is used to add startup/default inventory/settings for all players and objects.");

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
			ImGui::PopItemWidth();
			ImGui::Indent(-10);

			if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
				//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				ImGui::Text("");
				ImGui::Text("");
			}

			ImGui::EndTabItem();
		}

		ImGui::EndTabBar();
	}

	if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
		//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
		ImGui::Text("");
		ImGui::Text("");
	}

	ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
	if (ImGui::IsMouseHoveringRect(bbwin.Min, bbwin.Max))
	{
		bImGuiGotFocus = true; //Must set bImGuiGotFocus so if you type "w" in a imgui widget , editor dont move forward.
	}
	if (ImGui::IsAnyItemFocused()) {
		bImGuiGotFocus = true;
	}

	ImGui::End();
}
#endif
